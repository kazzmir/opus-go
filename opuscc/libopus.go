// Code generated for linux/amd64 by 'ccgo --package-name opuscc --prefix-external Opus_ --prefix-typename OpusT_ -o opuscc/libopus.go -I .. -I ../include -I ../src -I ../celt -I ../silk -include config_ccgo.h -DOPUS_BUILD -DOPUS_DISABLE_INTRINSICS -DNONTHREADSAFE_PSEUDOSTACK -UVAR_ARRAYS -UUSE_ALLOCA -U__SSE__ -U__SSE2__ -U__SSE3__ -U__SSSE3__ -U__AVX__ -U__AVX2__ -std=c99 -O2 -fno-builtin -ignore-asm-errors -ignore-vector-functions ../src/opus.c ../src/opus_decoder.c ../src/opus_multistream.c ../src/opus_multistream_decoder.c ../src/mapping_matrix.c ../src/opus_projection_decoder.c ../src/extensions.c ../celt/celt.c ../celt/celt_lpc.c ../celt/kiss_fft.c ../celt/mathops.c ../celt/entdec.c ../celt/cwrs.c ../celt/celt_decoder.c ../celt/pitch.c ../celt/entenc.c ../celt/quant_bands.c ../celt/modes.c ../celt/vq.c ../celt/rate.c ../celt/entcode.c ../celt/bands.c ../celt/mdct.c ../celt/mini_kfft.c ../celt/laplace.c ../silk/CNG.c ../silk/code_signs.c ../silk/init_decoder.c ../silk/decode_core.c ../silk/decode_frame.c ../silk/decode_parameters.c ../silk/decode_indices.c ../silk/decode_pulses.c ../silk/decoder_set_fs.c ../silk/dec_API.c ../silk/gain_quant.c ../silk/interpolate.c ../silk/LP_variable_cutoff.c ../silk/NLSF_decode.c ../silk/PLC.c ../silk/shell_coder.c ../silk/tables_gain.c ../silk/tables_LTP.c ../silk/tables_NLSF_CB_NB_MB.c ../silk/tables_NLSF_CB_WB.c ../silk/tables_other.c ../silk/tables_pitch_lag.c ../silk/tables_pulses_per_block.c ../silk/VAD.c ../silk/NLSF_VQ.c ../silk/NLSF_unpack.c ../silk/NLSF_del_dec_quant.c ../silk/stereo_MS_to_LR.c ../silk/ana_filt_bank_1.c ../silk/biquad_alt.c ../silk/bwexpander_32.c ../silk/bwexpander.c ../silk/debug.c ../silk/decode_pitch.c ../silk/inner_prod_aligned.c ../silk/lin2log.c ../silk/log2lin.c ../silk/LPC_analysis_filter.c ../silk/LPC_inv_pred_gain.c ../silk/LPC_fit.c ../silk/table_LSF_cos.c ../silk/NLSF2A.c ../silk/NLSF_stabilize.c ../silk/NLSF_VQ_weights_laroia.c ../silk/pitch_est_tables.c ../silk/resampler.c ../silk/resampler_down2_3.c ../silk/resampler_down2.c ../silk/resampler_private_AR2.c ../silk/resampler_private_down_FIR.c ../silk/resampler_private_IIR_FIR.c ../silk/resampler_private_up2_HQ.c ../silk/resampler_rom.c ../silk/sigm_Q15.c ../silk/sort.c ../silk/sum_sqr_shift.c ../silk/stereo_decode_pred.c', DO NOT EDIT.

//go:build linux && amd64

package opuscc

import (
	"reflect"
	"unsafe"

	"modernc.org/libc"
)

var _ reflect.Type
var _ unsafe.Pointer

const ARG_MAX = 131072
const ATAN2_2_OVER_PI = 0.636619772367581
const ATAN2_COEFF_A05 = 0.19962704181671143
const ATAN2_COEFF_A09 = 0.09794234484434128
const ATAN2_COEFF_A13 = 0.023040136322379112
const BC_BASE_MAX = 99
const BC_DIM_MAX = 2048
const BC_SCALE_MAX = 99
const BC_STRING_MAX = 1000
const BITRES = 3
const CCGO_TLS_PSEUDOSTACK = 1
const CELTDecoder = "OpusCustomDecoder"
const CELTEncoder = "OpusCustomEncoder"
const CELTMode = "OpusCustomMode"
const CELT_GET_AND_CLEAR_ERROR_REQUEST = 10007
const CELT_GET_MODE_REQUEST = 10015
const CELT_SET_ANALYSIS_REQUEST = 10022
const CELT_SET_CHANNELS_REQUEST = 10008
const CELT_SET_END_BAND_REQUEST = 10012
const CELT_SET_INPUT_CLIPPING_REQUEST = 10004
const CELT_SET_PREDICTION_REQUEST = 10002
const CELT_SET_SIGNALLING_REQUEST = 10016
const CELT_SET_SILK_INFO_REQUEST = 10028
const CELT_SET_START_BAND_REQUEST = 10010
const CELT_SET_TONALITY_REQUEST = 10018
const CELT_SET_TONALITY_SLOPE_REQUEST = 10020
const CELT_SIG_SCALE = "32768.f"
const CHARCLASS_NAME_MAX = 14
const CHAR_BIT = 8
const CHAR_MAX = 255
const CHAR_MIN = 0
const COEF_ONE = "1.0f"
const COLL_WEIGHTS_MAX = 2
const COMBFILTER_MAXPERIOD = 1024
const COMBFILTER_MINPERIOD = 15
const COS_COEFF_A0 = 0.9999999403953552
const COS_COEFF_A4 = 0.2536507546901703
const COS_COEFF_A8 = 0.0008581906440667808
const CPU_INFO_BY_ASM = 1
const DELAYTIMER_MAX = 0x7fffffff
const DISABLE_DEBUG_FLOAT = 1
const EC_UINT_BITS = 8
const ENABLE_HARDENING = 1
const ENABLE_RES24 = 1
const EPSILON = "1e-15f"
const EXIT_FAILURE = 1
const EXIT_SUCCESS = 0
const EXP2_COEFF_A0 = 0.9999999403953552
const EXP2_COEFF_A1 = 0.6931530833244324
const EXP2_COEFF_A2 = 0.24015361070632935
const EXP2_COEFF_A3 = 0.05582631751894951
const EXP2_COEFF_A4 = 0.00898933969438076
const EXP2_COEFF_A5 = 0.0018775766948238015
const EXPR_NEST_MAX = 32
const FILESIZEBITS = 64
const FLOAT_APPROX = 1
const FP_ILOGB0 = "FP_ILOGBNAN"
const FP_INFINITE = 1
const FP_NAN = 0
const FP_NORMAL = 4
const FP_SUBNORMAL = 3
const FP_ZERO = 2
const GLOBAL_STACK_SIZE = 120000
const HAVE_DLFCN_H = 1
const HAVE_INTTYPES_H = 1
const HAVE_LRINT = 1
const HAVE_LRINTF = 1
const HAVE_STDINT_H = 1
const HAVE_STDIO_H = 1
const HAVE_STDLIB_H = 1
const HAVE_STRINGS_H = 1
const HAVE_STRING_H = 1
const HAVE_SYS_STAT_H = 1
const HAVE_SYS_TYPES_H = 1
const HAVE_UNISTD_H = 1
const HOST_NAME_MAX = 255
const HUGE = 3.40282346638528859812e+38
const HUGE_VALF = "INFINITY"
const INT16_MAX = 0x7fff
const INT32_MAX = 0x7fffffff
const INT64_MAX = 0x7fffffffffffffff
const INT8_MAX = 0x7f
const INTMAX_MAX = "INT64_MAX"
const INTMAX_MIN = "INT64_MIN"
const INTPTR_MAX = "INT64_MAX"
const INTPTR_MIN = "INT64_MIN"
const INT_FAST16_MAX = "INT32_MAX"
const INT_FAST16_MIN = "INT32_MIN"
const INT_FAST32_MAX = "INT32_MAX"
const INT_FAST32_MIN = "INT32_MIN"
const INT_FAST64_MAX = "INT64_MAX"
const INT_FAST64_MIN = "INT64_MIN"
const INT_FAST8_MAX = "INT8_MAX"
const INT_FAST8_MIN = "INT8_MIN"
const INT_LEAST16_MAX = "INT16_MAX"
const INT_LEAST16_MIN = "INT16_MIN"
const INT_LEAST32_MAX = "INT32_MAX"
const INT_LEAST32_MIN = "INT32_MIN"
const INT_LEAST64_MAX = "INT64_MAX"
const INT_LEAST64_MIN = "INT64_MIN"
const INT_LEAST8_MAX = "INT8_MAX"
const INT_LEAST8_MIN = "INT8_MIN"
const INT_MAX = 0x7fffffff
const IOV_MAX = 1024
const KF_SUFFIX = "_celt_single"
const KISS_FFT_MALLOC = "opus_alloc"
const LEAK_BANDS = 19
const LINE_MAX = 4096
const LLONG_MAX = 0x7fffffffffffffff
const LOG2_COEFF_A0 = 0.08746284246444702
const LOG2_COEFF_A1 = 1.3578295707702637
const LOG2_COEFF_A3 = 0.4019712507724762
const LOGIN_NAME_MAX = 256
const LONG_BIT = 64
const LONG_MAX = "__LONG_MAX"
const LT_OBJDIR = ".libs/"
const MATH_ERREXCEPT = 2
const MATH_ERRNO = 1
const MAXFACTORS = 8
const MAX_ENCODING_DEPTH = 24
const MB_LEN_MAX = 4
const MODE_CELT_ONLY = 1002
const MODE_HYBRID = 1001
const MODE_SILK_ONLY = 1000
const MQ_PRIO_MAX = 32768
const M_1_PI = 0.31830988618379067154
const M_2_PI = 0.63661977236758134308
const M_2_SQRTPI = 1.12837916709551257390
const M_E = 2.7182818284590452354
const M_LN10 = 2.30258509299404568402
const M_LN2 = 0.69314718055994530942
const M_LOG10E = 0.43429448190325182765
const M_LOG2E = 1.4426950408889634074
const M_PI = 3.14159265358979323846
const M_PI_2 = 1.57079632679489661923
const M_PI_4 = 0.78539816339744830962
const M_SQRT1_2 = 0.70710678118654752440
const M_SQRT2 = 1.41421356237309504880
const NAME_MAX = 255
const NGROUPS_MAX = 32
const NL_ARGMAX = 9
const NL_LANGMAX = 32
const NL_MSGMAX = 32767
const NL_NMAX = 16
const NL_SETMAX = 255
const NL_TEXTMAX = 2048
const NONTHREADSAFE_PSEUDOSTACK = 1
const NORM_SCALING = "1.f"
const NZERO = 20
const OPUS_APPLICATION_AUDIO = 2049
const OPUS_APPLICATION_RESTRICTED_CELT = 2053
const OPUS_APPLICATION_RESTRICTED_LOWDELAY = 2051
const OPUS_APPLICATION_RESTRICTED_SILK = 2052
const OPUS_APPLICATION_VOIP = 2048
const OPUS_ARCHMASK = 0
const OPUS_BANDWIDTH_FULLBAND = 1105
const OPUS_BANDWIDTH_MEDIUMBAND = 1102
const OPUS_BANDWIDTH_NARROWBAND = 1101
const OPUS_BANDWIDTH_SUPERWIDEBAND = 1104
const OPUS_BANDWIDTH_WIDEBAND = 1103
const OPUS_DISABLE_INTRINSICS = 1
const OPUS_FAST_INT64 = 1
const OPUS_FRAMESIZE_100_MS = 5008
const OPUS_FRAMESIZE_10_MS = 5003
const OPUS_FRAMESIZE_120_MS = 5009
const OPUS_FRAMESIZE_20_MS = 5004
const OPUS_FRAMESIZE_2_5_MS = 5001
const OPUS_FRAMESIZE_40_MS = 5005
const OPUS_FRAMESIZE_5_MS = 5002
const OPUS_FRAMESIZE_60_MS = 5006
const OPUS_FRAMESIZE_80_MS = 5007
const OPUS_FRAMESIZE_ARG = 5000
const OPUS_GET_APPLICATION_REQUEST = 4001
const OPUS_GET_BANDWIDTH_REQUEST = 4009
const OPUS_GET_BITRATE_REQUEST = 4003
const OPUS_GET_COMPLEXITY_REQUEST = 4011
const OPUS_GET_DRED_DURATION_REQUEST = 4051
const OPUS_GET_DTX_REQUEST = 4017
const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST = 4041
const OPUS_GET_FINAL_RANGE_REQUEST = 4031
const OPUS_GET_FORCE_CHANNELS_REQUEST = 4023
const OPUS_GET_GAIN_REQUEST = 4045
const OPUS_GET_IGNORE_EXTENSIONS_REQUEST = 4059
const OPUS_GET_INBAND_FEC_REQUEST = 4013
const OPUS_GET_IN_DTX_REQUEST = 4049
const OPUS_GET_LAST_PACKET_DURATION_REQUEST = 4039
const OPUS_GET_LOOKAHEAD_REQUEST = 4027
const OPUS_GET_LSB_DEPTH_REQUEST = 4037
const OPUS_GET_MAX_BANDWIDTH_REQUEST = 4005
const OPUS_GET_OSCE_BWE_REQUEST = 4055
const OPUS_GET_PACKET_LOSS_PERC_REQUEST = 4015
const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST = 4047
const OPUS_GET_PITCH_REQUEST = 4033
const OPUS_GET_PREDICTION_DISABLED_REQUEST = 4043
const OPUS_GET_QEXT_REQUEST = 4057
const OPUS_GET_SAMPLE_RATE_REQUEST = 4029
const OPUS_GET_SIGNAL_REQUEST = 4025
const OPUS_GET_VBR_CONSTRAINT_REQUEST = 4021
const OPUS_GET_VBR_REQUEST = 4007
const OPUS_GET_VOICE_RATIO_REQUEST = 11019
const OPUS_INLINE = "inline"
const OPUS_OK = 0
const OPUS_RESET_STATE = 4028
const OPUS_RESTRICT = "restrict"
const OPUS_SET_APPLICATION_REQUEST = 4000
const OPUS_SET_BANDWIDTH_REQUEST = 4008
const OPUS_SET_BITRATE_REQUEST = 4002
const OPUS_SET_COMPLEXITY_REQUEST = 4010
const OPUS_SET_DNN_BLOB_REQUEST = 4052
const OPUS_SET_DRED_DURATION_REQUEST = 4050
const OPUS_SET_DTX_REQUEST = 4016
const OPUS_SET_ENERGY_MASK_REQUEST = 10026
const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST = 4040
const OPUS_SET_FORCE_CHANNELS_REQUEST = 4022
const OPUS_SET_FORCE_MODE_REQUEST = 11002
const OPUS_SET_GAIN_REQUEST = 4034
const OPUS_SET_IGNORE_EXTENSIONS_REQUEST = 4058
const OPUS_SET_INBAND_FEC_REQUEST = 4012
const OPUS_SET_LFE_REQUEST = 10024
const OPUS_SET_LSB_DEPTH_REQUEST = 4036
const OPUS_SET_MAX_BANDWIDTH_REQUEST = 4004
const OPUS_SET_OSCE_BWE_REQUEST = 4054
const OPUS_SET_PACKET_LOSS_PERC_REQUEST = 4014
const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST = 4046
const OPUS_SET_PREDICTION_DISABLED_REQUEST = 4042
const OPUS_SET_QEXT_REQUEST = 4056
const OPUS_SET_SIGNAL_REQUEST = 4024
const OPUS_SET_VBR_CONSTRAINT_REQUEST = 4020
const OPUS_SET_VBR_REQUEST = 4006
const OPUS_SET_VOICE_RATIO_REQUEST = 11018
const OPUS_SIGNAL_MUSIC = 3002
const OPUS_SIGNAL_VOICE = 3001
const OPUS_X86_PRESUME_SSE = 1
const OPUS_X86_PRESUME_SSE2 = 1
const PACKAGE_BUGREPORT = "opus@xiph.org"
const PACKAGE_NAME = "opus"
const PACKAGE_STRING = "opus 1.6.1"
const PACKAGE_TARNAME = "opus"
const PACKAGE_URL = ""
const PACKAGE_VERSION = "1.6.1"
const PAGESIZE = 4096
const PAGE_SIZE = "PAGESIZE"
const PATH_MAX = 4096
const PI = 3.141592653589793
const PIPE_BUF = 4096
const PTHREAD_DESTRUCTOR_ITERATIONS = 4
const PTHREAD_KEYS_MAX = 128
const PTHREAD_STACK_MIN = 2048
const PTRDIFF_MAX = "INT64_MAX"
const PTRDIFF_MIN = "INT64_MIN"
const Q15ONE = "1.0f"
const Q31ONE = "1.0f"
const QEXT_EXTENSION_ID = 124
const RAND_MAX = 0x7fffffff
const RE_DUP_MAX = 255
const SCHAR_MAX = 127
const SEM_NSEMS_MAX = 256
const SEM_VALUE_MAX = 0x7fffffff
const SHRT_MAX = 0x7fff
const SIG_ATOMIC_MAX = "INT32_MAX"
const SIG_ATOMIC_MIN = "INT32_MIN"
const SIZE_MAX = "UINT64_MAX"
const SSIZE_MAX = "LONG_MAX"
const STDC_HEADERS = 1
const SYMLOOP_MAX = 40
const TTY_NAME_MAX = 32
const TZNAME_MAX = 6
const UCHAR_MAX = 255
const UINT16_MAX = 0xffff
const UINT32_MAX = "0xffffffffu"
const UINT64_MAX = "0xffffffffffffffffu"
const UINT8_MAX = 0xff
const UINTMAX_MAX = "UINT64_MAX"
const UINTPTR_MAX = "UINT64_MAX"
const UINT_FAST16_MAX = "UINT32_MAX"
const UINT_FAST32_MAX = "UINT32_MAX"
const UINT_FAST64_MAX = "UINT64_MAX"
const UINT_FAST8_MAX = "UINT8_MAX"
const UINT_LEAST16_MAX = "UINT16_MAX"
const UINT_LEAST32_MAX = "UINT32_MAX"
const UINT_LEAST64_MAX = "UINT64_MAX"
const UINT_LEAST8_MAX = "UINT8_MAX"
const UINT_MAX = 0xffffffff
const USHRT_MAX = 0xffff
const VERY_LARGE16 = "1e15f"
const VERY_SMALL = "1e-30f"
const WINT_MAX = "UINT32_MAX"
const WINT_MIN = 0
const WNOHANG = 1
const WORD_BIT = 32
const WUNTRACED = 2
const _FORTIFY_SOURCE = 3
const _GNU_SOURCE = 1
const _LP64 = 1
const _POSIX2_BC_BASE_MAX = 99
const _POSIX2_BC_DIM_MAX = 2048
const _POSIX2_BC_SCALE_MAX = 99
const _POSIX2_BC_STRING_MAX = 1000
const _POSIX2_CHARCLASS_NAME_MAX = 14
const _POSIX2_COLL_WEIGHTS_MAX = 2
const _POSIX2_EXPR_NEST_MAX = 32
const _POSIX2_LINE_MAX = 2048
const _POSIX2_RE_DUP_MAX = 255
const _POSIX_AIO_LISTIO_MAX = 2
const _POSIX_AIO_MAX = 1
const _POSIX_ARG_MAX = 4096
const _POSIX_CHILD_MAX = 25
const _POSIX_CLOCKRES_MIN = 20000000
const _POSIX_DELAYTIMER_MAX = 32
const _POSIX_HOST_NAME_MAX = 255
const _POSIX_LINK_MAX = 8
const _POSIX_LOGIN_NAME_MAX = 9
const _POSIX_MAX_CANON = 255
const _POSIX_MAX_INPUT = 255
const _POSIX_MQ_OPEN_MAX = 8
const _POSIX_MQ_PRIO_MAX = 32
const _POSIX_NAME_MAX = 14
const _POSIX_NGROUPS_MAX = 8
const _POSIX_OPEN_MAX = 20
const _POSIX_PATH_MAX = 256
const _POSIX_PIPE_BUF = 512
const _POSIX_RE_DUP_MAX = 255
const _POSIX_RTSIG_MAX = 8
const _POSIX_SEM_NSEMS_MAX = 256
const _POSIX_SEM_VALUE_MAX = 32767
const _POSIX_SIGQUEUE_MAX = 32
const _POSIX_SSIZE_MAX = 32767
const _POSIX_SS_REPL_MAX = 4
const _POSIX_STREAM_MAX = 8
const _POSIX_SYMLINK_MAX = 255
const _POSIX_SYMLOOP_MAX = 8
const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
const _POSIX_THREAD_KEYS_MAX = 128
const _POSIX_THREAD_THREADS_MAX = 64
const _POSIX_TIMER_MAX = 32
const _POSIX_TRACE_EVENT_NAME_MAX = 30
const _POSIX_TRACE_NAME_MAX = 8
const _POSIX_TRACE_SYS_MAX = 8
const _POSIX_TRACE_USER_EVENT_MAX = 32
const _POSIX_TTY_NAME_MAX = 9
const _POSIX_TZNAME_MAX = 6
const _STDC_PREDEF_H = 1
const _XOPEN_IOV_MAX = 16
const _XOPEN_NAME_MAX = 255
const _XOPEN_PATH_MAX = 1024
const __ATOMIC_ACQUIRE = 2
const __ATOMIC_ACQ_REL = 4
const __ATOMIC_CONSUME = 1
const __ATOMIC_HLE_ACQUIRE = 65536
const __ATOMIC_HLE_RELEASE = 131072
const __ATOMIC_RELAXED = 0
const __ATOMIC_RELEASE = 3
const __ATOMIC_SEQ_CST = 5
const __BFLT16_DECIMAL_DIG__ = 4
const __BFLT16_DENORM_MIN__ = "9.18354961579912115600575419704879436e-41B"
const __BFLT16_DIG__ = 2
const __BFLT16_EPSILON__ = "7.81250000000000000000000000000000000e-3B"
const __BFLT16_HAS_DENORM__ = 1
const __BFLT16_HAS_INFINITY__ = 1
const __BFLT16_HAS_QUIET_NAN__ = 1
const __BFLT16_IS_IEC_60559__ = 0
const __BFLT16_MANT_DIG__ = 8
const __BFLT16_MAX_10_EXP__ = 38
const __BFLT16_MAX_EXP__ = 128
const __BFLT16_MAX__ = "3.38953138925153547590470800371487867e+38B"
const __BFLT16_MIN__ = "1.17549435082228750796873653722224568e-38B"
const __BFLT16_NORM_MAX__ = "3.38953138925153547590470800371487867e+38B"
const __BIGGEST_ALIGNMENT__ = 16
const __BIG_ENDIAN = 4321
const __BYTE_ORDER = 1234
const __BYTE_ORDER__ = "__ORDER_LITTLE_ENDIAN__"
const __CCGO__ = 1
const __CET__ = 3
const __CHAR_BIT__ = 8
const __DBL_DECIMAL_DIG__ = 17
const __DBL_DIG__ = 15
const __DBL_HAS_DENORM__ = 1
const __DBL_HAS_INFINITY__ = 1
const __DBL_HAS_QUIET_NAN__ = 1
const __DBL_IS_IEC_60559__ = 1
const __DBL_MANT_DIG__ = 53
const __DBL_MAX_10_EXP__ = 308
const __DBL_MAX_EXP__ = 1024
const __DEC128_EPSILON__ = 1e-33
const __DEC128_MANT_DIG__ = 34
const __DEC128_MAX_EXP__ = 6145
const __DEC128_MAX__ = "9.999999999999999999999999999999999E6144"
const __DEC128_MIN__ = 1e-6143
const __DEC128_SUBNORMAL_MIN__ = 0.000000000000000000000000000000001e-6143
const __DEC32_EPSILON__ = 1e-6
const __DEC32_MANT_DIG__ = 7
const __DEC32_MAX_EXP__ = 97
const __DEC32_MAX__ = 9.999999e96
const __DEC32_MIN__ = 1e-95
const __DEC32_SUBNORMAL_MIN__ = 0.000001e-95
const __DEC64_EPSILON__ = 1e-15
const __DEC64_MANT_DIG__ = 16
const __DEC64_MAX_EXP__ = 385
const __DEC64_MAX__ = "9.999999999999999E384"
const __DEC64_MIN__ = 1e-383
const __DEC64_SUBNORMAL_MIN__ = 0.000000000000001e-383
const __DECIMAL_BID_FORMAT__ = 1
const __DECIMAL_DIG__ = 17
const __DEC_EVAL_METHOD__ = 2
const __ELF__ = 1
const __FINITE_MATH_ONLY__ = 0
const __FLOAT_WORD_ORDER__ = "__ORDER_LITTLE_ENDIAN__"
const __FLT128_DECIMAL_DIG__ = 36
const __FLT128_DENORM_MIN__ = 6.47517511943802511092443895822764655e-4966
const __FLT128_DIG__ = 33
const __FLT128_EPSILON__ = 1.92592994438723585305597794258492732e-34
const __FLT128_HAS_DENORM__ = 1
const __FLT128_HAS_INFINITY__ = 1
const __FLT128_HAS_QUIET_NAN__ = 1
const __FLT128_IS_IEC_60559__ = 1
const __FLT128_MANT_DIG__ = 113
const __FLT128_MAX_10_EXP__ = 4932
const __FLT128_MAX_EXP__ = 16384
const __FLT128_MAX__ = "1.18973149535723176508575932662800702e+4932"
const __FLT128_MIN__ = 3.36210314311209350626267781732175260e-4932
const __FLT128_NORM_MAX__ = "1.18973149535723176508575932662800702e+4932"
const __FLT16_DECIMAL_DIG__ = 5
const __FLT16_DENORM_MIN__ = 5.96046447753906250000000000000000000e-8
const __FLT16_DIG__ = 3
const __FLT16_EPSILON__ = 9.76562500000000000000000000000000000e-4
const __FLT16_HAS_DENORM__ = 1
const __FLT16_HAS_INFINITY__ = 1
const __FLT16_HAS_QUIET_NAN__ = 1
const __FLT16_IS_IEC_60559__ = 1
const __FLT16_MANT_DIG__ = 11
const __FLT16_MAX_10_EXP__ = 4
const __FLT16_MAX_EXP__ = 16
const __FLT16_MAX__ = 6.55040000000000000000000000000000000e+4
const __FLT16_MIN__ = 6.10351562500000000000000000000000000e-5
const __FLT16_NORM_MAX__ = 6.55040000000000000000000000000000000e+4
const __FLT32X_DECIMAL_DIG__ = 17
const __FLT32X_DENORM_MIN__ = 4.94065645841246544176568792868221372e-324
const __FLT32X_DIG__ = 15
const __FLT32X_EPSILON__ = 2.22044604925031308084726333618164062e-16
const __FLT32X_HAS_DENORM__ = 1
const __FLT32X_HAS_INFINITY__ = 1
const __FLT32X_HAS_QUIET_NAN__ = 1
const __FLT32X_IS_IEC_60559__ = 1
const __FLT32X_MANT_DIG__ = 53
const __FLT32X_MAX_10_EXP__ = 308
const __FLT32X_MAX_EXP__ = 1024
const __FLT32X_MAX__ = 1.79769313486231570814527423731704357e+308
const __FLT32X_MIN__ = 2.22507385850720138309023271733240406e-308
const __FLT32X_NORM_MAX__ = 1.79769313486231570814527423731704357e+308
const __FLT32_DECIMAL_DIG__ = 9
const __FLT32_DENORM_MIN__ = 1.40129846432481707092372958328991613e-45
const __FLT32_DIG__ = 6
const __FLT32_EPSILON__ = 1.19209289550781250000000000000000000e-7
const __FLT32_HAS_DENORM__ = 1
const __FLT32_HAS_INFINITY__ = 1
const __FLT32_HAS_QUIET_NAN__ = 1
const __FLT32_IS_IEC_60559__ = 1
const __FLT32_MANT_DIG__ = 24
const __FLT32_MAX_10_EXP__ = 38
const __FLT32_MAX_EXP__ = 128
const __FLT32_MAX__ = 3.40282346638528859811704183484516925e+38
const __FLT32_MIN__ = 1.17549435082228750796873653722224568e-38
const __FLT32_NORM_MAX__ = 3.40282346638528859811704183484516925e+38
const __FLT64X_DECIMAL_DIG__ = 36
const __FLT64X_DENORM_MIN__ = 6.47517511943802511092443895822764655e-4966
const __FLT64X_DIG__ = 33
const __FLT64X_EPSILON__ = 1.92592994438723585305597794258492732e-34
const __FLT64X_HAS_DENORM__ = 1
const __FLT64X_HAS_INFINITY__ = 1
const __FLT64X_HAS_QUIET_NAN__ = 1
const __FLT64X_IS_IEC_60559__ = 1
const __FLT64X_MANT_DIG__ = 113
const __FLT64X_MAX_10_EXP__ = 4932
const __FLT64X_MAX_EXP__ = 16384
const __FLT64X_MAX__ = "1.18973149535723176508575932662800702e+4932"
const __FLT64X_MIN__ = 3.36210314311209350626267781732175260e-4932
const __FLT64X_NORM_MAX__ = "1.18973149535723176508575932662800702e+4932"
const __FLT64_DECIMAL_DIG__ = 17
const __FLT64_DENORM_MIN__ = 4.94065645841246544176568792868221372e-324
const __FLT64_DIG__ = 15
const __FLT64_EPSILON__ = 2.22044604925031308084726333618164062e-16
const __FLT64_HAS_DENORM__ = 1
const __FLT64_HAS_INFINITY__ = 1
const __FLT64_HAS_QUIET_NAN__ = 1
const __FLT64_IS_IEC_60559__ = 1
const __FLT64_MANT_DIG__ = 53
const __FLT64_MAX_10_EXP__ = 308
const __FLT64_MAX_EXP__ = 1024
const __FLT64_MAX__ = 1.79769313486231570814527423731704357e+308
const __FLT64_MIN__ = 2.22507385850720138309023271733240406e-308
const __FLT64_NORM_MAX__ = 1.79769313486231570814527423731704357e+308
const __FLT_DECIMAL_DIG__ = 9
const __FLT_DENORM_MIN__ = 1.40129846432481707092372958328991613e-45
const __FLT_DIG__ = 6
const __FLT_EPSILON__ = 1.19209289550781250000000000000000000e-7
const __FLT_EVAL_METHOD_TS_18661_3__ = 0
const __FLT_EVAL_METHOD__ = 0
const __FLT_HAS_DENORM__ = 1
const __FLT_HAS_INFINITY__ = 1
const __FLT_HAS_QUIET_NAN__ = 1
const __FLT_IS_IEC_60559__ = 1
const __FLT_MANT_DIG__ = 24
const __FLT_MAX_10_EXP__ = 38
const __FLT_MAX_EXP__ = 128
const __FLT_MAX__ = 3.40282346638528859811704183484516925e+38
const __FLT_MIN__ = 1.17549435082228750796873653722224568e-38
const __FLT_NORM_MAX__ = 3.40282346638528859811704183484516925e+38
const __FLT_RADIX__ = 2
const __FUNCTION__ = "__func__"
const __FXSR__ = 1
const __GCC_ASM_FLAG_OUTPUTS__ = 1
const __GCC_ATOMIC_BOOL_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR_LOCK_FREE = 2
const __GCC_ATOMIC_INT_LOCK_FREE = 2
const __GCC_ATOMIC_LLONG_LOCK_FREE = 2
const __GCC_ATOMIC_LONG_LOCK_FREE = 2
const __GCC_ATOMIC_POINTER_LOCK_FREE = 2
const __GCC_ATOMIC_SHORT_LOCK_FREE = 2
const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1
const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2
const __GCC_CONSTRUCTIVE_SIZE = 64
const __GCC_DESTRUCTIVE_SIZE = 64
const __GCC_HAVE_DWARF2_CFI_ASM = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1
const __GCC_IEC_559 = 2
const __GCC_IEC_559_COMPLEX = 2
const __GNUC_EXECUTION_CHARSET_NAME = "UTF-8"
const __GNUC_MINOR__ = 3
const __GNUC_PATCHLEVEL__ = 0
const __GNUC_STDC_INLINE__ = 1
const __GNUC_WIDE_EXECUTION_CHARSET_NAME = "UTF-32LE"
const __GNUC__ = 13
const __GXX_ABI_VERSION = 1018
const __HAVE_SPECULATION_SAFE_VALUE = 1
const __INT16_MAX__ = 0x7fff
const __INT32_MAX__ = 0x7fffffff
const __INT32_TYPE__ = "int"
const __INT64_MAX__ = 0x7fffffffffffffff
const __INT8_MAX__ = 0x7f
const __INTMAX_MAX__ = 0x7fffffffffffffff
const __INTMAX_WIDTH__ = 64
const __INTPTR_MAX__ = 0x7fffffffffffffff
const __INTPTR_WIDTH__ = 64
const __INT_FAST16_MAX__ = 0x7fffffffffffffff
const __INT_FAST16_WIDTH__ = 64
const __INT_FAST32_MAX__ = 0x7fffffffffffffff
const __INT_FAST32_WIDTH__ = 64
const __INT_FAST64_MAX__ = 0x7fffffffffffffff
const __INT_FAST64_WIDTH__ = 64
const __INT_FAST8_MAX__ = 0x7f
const __INT_FAST8_WIDTH__ = 8
const __INT_LEAST16_MAX__ = 0x7fff
const __INT_LEAST16_WIDTH__ = 16
const __INT_LEAST32_MAX__ = 0x7fffffff
const __INT_LEAST32_TYPE__ = "int"
const __INT_LEAST32_WIDTH__ = 32
const __INT_LEAST64_MAX__ = 0x7fffffffffffffff
const __INT_LEAST64_WIDTH__ = 64
const __INT_LEAST8_MAX__ = 0x7f
const __INT_LEAST8_WIDTH__ = 8
const __INT_MAX__ = 0x7fffffff
const __INT_WIDTH__ = 32
const __LDBL_DECIMAL_DIG__ = 17
const __LDBL_DENORM_MIN__ = 4.94065645841246544176568792868221372e-324
const __LDBL_DIG__ = 15
const __LDBL_EPSILON__ = 2.22044604925031308084726333618164062e-16
const __LDBL_HAS_DENORM__ = 1
const __LDBL_HAS_INFINITY__ = 1
const __LDBL_HAS_QUIET_NAN__ = 1
const __LDBL_IS_IEC_60559__ = 1
const __LDBL_MANT_DIG__ = 53
const __LDBL_MAX_10_EXP__ = 308
const __LDBL_MAX_EXP__ = 1024
const __LDBL_MAX__ = 1.79769313486231570814527423731704357e+308
const __LDBL_MIN__ = 2.22507385850720138309023271733240406e-308
const __LDBL_NORM_MAX__ = 1.79769313486231570814527423731704357e+308
const __LITTLE_ENDIAN = 1234
const __LONG_DOUBLE_64__ = 1
const __LONG_LONG_MAX__ = 0x7fffffffffffffff
const __LONG_LONG_WIDTH__ = 64
const __LONG_MAX = 0x7fffffffffffffff
const __LONG_MAX__ = 0x7fffffffffffffff
const __LONG_WIDTH__ = 64
const __LP64__ = 1
const __MMX_WITH_SSE__ = 1
const __MMX__ = 1
const __OPTIMIZE__ = 1
const __ORDER_BIG_ENDIAN__ = 4321
const __ORDER_LITTLE_ENDIAN__ = 1234
const __ORDER_PDP_ENDIAN__ = 3412
const __PIC__ = 2
const __PIE__ = 2
const __PRAGMA_REDEFINE_EXTNAME = 1
const __PRETTY_FUNCTION__ = "__func__"
const __PTRDIFF_MAX__ = 0x7fffffffffffffff
const __PTRDIFF_WIDTH__ = 64
const __SCHAR_MAX__ = 0x7f
const __SCHAR_WIDTH__ = 8
const __SEG_FS = 1
const __SEG_GS = 1
const __SHRT_MAX__ = 0x7fff
const __SHRT_WIDTH__ = 16
const __SIG_ATOMIC_MAX__ = 0x7fffffff
const __SIG_ATOMIC_TYPE__ = "int"
const __SIG_ATOMIC_WIDTH__ = 32
const __SIZEOF_DOUBLE__ = 8
const __SIZEOF_FLOAT128__ = 16
const __SIZEOF_FLOAT80__ = 16
const __SIZEOF_FLOAT__ = 4
const __SIZEOF_INT128__ = 16
const __SIZEOF_INT__ = 4
const __SIZEOF_LONG_DOUBLE__ = 8
const __SIZEOF_LONG_LONG__ = 8
const __SIZEOF_LONG__ = 8
const __SIZEOF_POINTER__ = 8
const __SIZEOF_PTRDIFF_T__ = 8
const __SIZEOF_SHORT__ = 2
const __SIZEOF_SIZE_T__ = 8
const __SIZEOF_WCHAR_T__ = 4
const __SIZEOF_WINT_T__ = 4
const __SIZE_MAX__ = 0xffffffffffffffff
const __SIZE_WIDTH__ = 64
const __SSE2_MATH__ = 1
const __SSE_MATH__ = 1
const __SSP_STRONG__ = 3
const __STDC_HOSTED__ = 1
const __STDC_IEC_559_COMPLEX__ = 1
const __STDC_IEC_559__ = 1
const __STDC_IEC_60559_BFP__ = 201404
const __STDC_IEC_60559_COMPLEX__ = 201404
const __STDC_ISO_10646__ = 201706
const __STDC_VERSION__ = 199901
const __STDC__ = 1
const __STRICT_ANSI__ = 1
const __UINT16_MAX__ = 0xffff
const __UINT32_MAX__ = 0xffffffff
const __UINT64_MAX__ = 0xffffffffffffffff
const __UINT8_MAX__ = 0xff
const __UINTMAX_MAX__ = 0xffffffffffffffff
const __UINTPTR_MAX__ = 0xffffffffffffffff
const __UINT_FAST16_MAX__ = 0xffffffffffffffff
const __UINT_FAST32_MAX__ = 0xffffffffffffffff
const __UINT_FAST64_MAX__ = 0xffffffffffffffff
const __UINT_FAST8_MAX__ = 0xff
const __UINT_LEAST16_MAX__ = 0xffff
const __UINT_LEAST32_MAX__ = 0xffffffff
const __UINT_LEAST64_MAX__ = 0xffffffffffffffff
const __UINT_LEAST8_MAX__ = 0xff
const __USE_TIME_BITS64 = 1
const __VERSION__ = "13.3.0"
const __WCHAR_MAX__ = 0x7fffffff
const __WCHAR_TYPE__ = "int"
const __WCHAR_WIDTH__ = 32
const __WINT_MAX__ = 0xffffffff
const __WINT_MIN__ = 0
const __WINT_WIDTH__ = 32
const __amd64 = 1
const __amd64__ = 1
const __code_model_small__ = 1
const __gnu_linux__ = 1
const __inline = "inline"
const __k8 = 1
const __k8__ = 1
const __linux = 1
const __linux__ = 1
const __pic__ = 2
const __pie__ = 2
const __restrict = "restrict"
const __restrict_arr = "restrict"
const __unix = 1
const __unix__ = 1
const __x86_64 = 1
const __x86_64__ = 1
const _ecintrin_H = 1
const _entcode_H = 1
const _entdec_H = 1
const _entenc_H = 1
const alloca = "__builtin_alloca"
const celt_decoder_ctl = "opus_custom_decoder_ctl"
const celt_encoder_ctl = "opus_custom_encoder_ctl"
const celt_exp2_db = "celt_exp2"
const celt_log2_db = "celt_log2"
const celt_maxabs_res = "celt_maxabs16"
const kiss_fft_scalar = "float"
const kiss_twiddle_scalar = "float"
const math_errhandling = 2
const opus_int = "int"
const restrict = "__restrict"

type OpusT___builtin_va_list = uintptr

type OpusT___predefined_size_t = uint64

type OpusT___predefined_wchar_t = int32

type OpusT___predefined_ptrdiff_t = int64

type OpusT_uintptr_t = uint64

type OpusT_intptr_t = int64

type OpusT_int8_t = int8

type OpusT_int16_t = int16

type OpusT_int32_t = int32

type OpusT_int64_t = int64

type OpusT_intmax_t = int64

type OpusT_uint8_t = uint8

type OpusT_uint16_t = uint16

type OpusT_uint32_t = uint32

type OpusT_uint64_t = uint64

type OpusT_uintmax_t = uint64

type OpusT_int_fast8_t = int8

type OpusT_int_fast64_t = int64

type OpusT_int_least8_t = int8

type OpusT_int_least16_t = int16

type OpusT_int_least32_t = int32

type OpusT_int_least64_t = int64

type OpusT_uint_fast8_t = uint8

type OpusT_uint_fast64_t = uint64

type OpusT_uint_least8_t = uint8

type OpusT_uint_least16_t = uint16

type OpusT_uint_least32_t = uint32

type OpusT_uint_least64_t = uint64

type OpusT_int_fast16_t = int32

type OpusT_int_fast32_t = int32

type OpusT_uint_fast16_t = uint32

type OpusT_uint_fast32_t = uint32

type OpusT_opus_int8 = int8

type OpusT_opus_uint8 = uint8

type OpusT_opus_int16 = int16

type OpusT_opus_uint16 = uint16

type OpusT_opus_int32 = int32

type OpusT_opus_uint32 = uint32

type OpusT_opus_int64 = int64

type OpusT_opus_uint64 = uint64

type OpusT_OpusRepacketizer = struct {
	Ftoc               uint8
	Fnb_frames         int32
	Fframes            [48]uintptr
	Flen1              [48]OpusT_opus_int16
	Fframesize         int32
	Fpaddings          [48]uintptr
	Fpadding_len       [48]OpusT_opus_int32
	Fpadding_nb_frames [48]uint8
}

type OpusT_opus_val16 = float32

type OpusT_opus_val32 = float32

type OpusT_opus_val64 = float32

type OpusT_celt_sig = float32

type OpusT_celt_norm = float32

type OpusT_celt_ener = float32

type OpusT_celt_glog = float32

type OpusT_opus_res = float32

type OpusT_celt_coef = float32

type OpusT_wchar_t = int32

type OpusT_size_t = uint64

type OpusT_ptrdiff_t = int64

type OpusT_float_t = float32

type OpusT_double_t = float64

type OpusT_ec_window = uint32

type OpusT_ec_ctx = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type OpusT_ec_enc = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type ec_ctx = OpusT_ec_enc

type OpusT_ec_dec = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type OpusT_locale_t = uintptr

type OpusT_div_t = struct {
	Fquot int32
	Frem  int32
}

type OpusT_ldiv_t = struct {
	Fquot int64
	Frem  int64
}

type OpusT_lldiv_t = struct {
	Fquot int64
	Frem  int64
}

var log2_x_norm_coeff = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

type OpusT_kiss_fft_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_kiss_twiddle_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_arch_fft_state = struct {
	Fis_supported int32
	Fpriv         uintptr
}

type OpusT_kiss_fft_state = struct {
	Fnfft     int32
	Fscale    OpusT_celt_coef
	Fshift    int32
	Ffactors  [16]OpusT_opus_int16
	Fbitrev   uintptr
	Ftwiddles uintptr
	Farch_fft uintptr
}

type OpusT_AnalysisInfo = struct {
	Fvalid                int32
	Ftonality             float32
	Ftonality_slope       float32
	Fnoisiness            float32
	Factivity             float32
	Fmusic_prob           float32
	Fmusic_prob_min       float32
	Fmusic_prob_max       float32
	Fbandwidth            int32
	Factivity_probability float32
	Fmax_pitch_ratio      float32
	Fleak_boost           [19]uint8
}

type OpusT_SILKInfo = struct {
	FsignalType int32
	Foffset     int32
}

var trim_icdf = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_va_list = uintptr

type OpusRepacketizer = struct {
	Ftoc               uint8
	Fnb_frames         int32
	Fframes            [48]uintptr
	Flen1              [48]OpusT_opus_int16
	Fframesize         int32
	Fpaddings          [48]uintptr
	Fpadding_len       [48]OpusT_opus_int32
	Fpadding_nb_frames [48]uint8
}

type OpusT_OpusExtensionIterator = struct {
	Fdata               uintptr
	Fcurr_data          uintptr
	Frepeat_data        uintptr
	Flast_long          uintptr
	Fsrc_data           uintptr
	Flen1               OpusT_opus_int32
	Fcurr_len           OpusT_opus_int32
	Frepeat_len         OpusT_opus_int32
	Fsrc_len            OpusT_opus_int32
	Ftrailing_short_len OpusT_opus_int32
	Fnb_frames          int32
	Fframe_max          int32
	Fcurr_frame         int32
	Frepeat_frame       int32
	Frepeat_l           uint8
}

type OpusT_opus_extension_data = struct {
	Fid    int32
	Fframe int32
	Fdata  uintptr
	Flen1  OpusT_opus_int32
}

type OpusT_ChannelLayout = struct {
	Fnb_channels        int32
	Fnb_streams         int32
	Fnb_coupled_streams int32
	Fmapping            [256]uint8
}

type OpusT_MappingType = int32

const MAPPING_TYPE_NONE = 0
const MAPPING_TYPE_SURROUND = 1
const MAPPING_TYPE_AMBISONICS = 2

type OpusMSEncoder = struct {
	Flayout            OpusT_ChannelLayout
	Farch              int32
	Flfe_stream        int32
	Fapplication       int32
	FFs                OpusT_opus_int32
	Fvariable_duration int32
	Fmapping_type      OpusT_MappingType
	Fbitrate_bps       OpusT_opus_int32
}

type OpusMSDecoder = struct {
	Flayout OpusT_ChannelLayout
}

type OpusT_opus_copy_channel_in_func = uintptr

type OpusT_opus_copy_channel_out_func = uintptr

type OpusT_downmix_func = uintptr

func Opus_opus_pcm_soft_clip_impl(tls *libc.TLS, _x uintptr, N int32, C int32, declip_mem uintptr, arch int32) {
	var a, delta, maxval, offset, x0, v7, v8, v9 float32
	var all_within_neg1pos1, c, curr, end, i, peak_pos, special, start, v4 int32
	var x uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, all_within_neg1pos1, c, curr, delta, end, i, maxval, offset, peak_pos, special, start, x, x0, v4, v7, v8, v9
	if C < int32(1) || N < int32(1) || !(_x != 0) || !(declip_mem != 0) {
		return
	}
	/* Clamp everything within the range [-2, +2] which is the domain of the soft
	      clipping non-linearity. Outside the defined range the derivative will be zero,
	      therefore there is no discontinuity introduced here. The implementation
	      might provide a hint if all input samples are within the [-1, +1] range.
	   `opus_limit2_checkwithin1()`:
	      - Clamps all samples within the valid range [-2, +2].
	      - Generic C implementation:
	         * Does not attempt early detection whether samples are within hinted range.
	         * Always returns 0.
	      - Architecture specific implementation:
	         * Uses SIMD instructions to efficiently detect if all samples are
	           within the hinted range [-1, +1].
	         * Returns 1 if no samples exceed the hinted range, 0 otherwise.
	   `all_within_neg1pos1`:
	      - Optimization hint to skip per-sample out-of-bound checks.
	        If true, the check can be skipped. */
	_ = arch
	all_within_neg1pos1 = Opus_opus_limit2_checkwithin1_c(tls, _x, N*C)
	c = 0
	for {
		if !(c < C) {
			break
		}
		x = _x + uintptr(c)*4
		a = *(*float32)(unsafe.Pointer(declip_mem + uintptr(c)*4))
		/* Continue applying the non-linearity from the previous frame to avoid
		   any discontinuity. */
		i = 0
		for {
			if !(i < N) {
				break
			}
			if float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))*a) >= libc.Float32FromInt32(0) {
				break
			}
			*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) + float32(float32(a**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		curr = 0
		x0 = *(*float32)(unsafe.Pointer(x))
		for int32(1) != 0 {
			special = 0
			/* Detection for early exit can be skipped if hinted by `all_within_neg1pos1` */
			if all_within_neg1pos1 != 0 {
				i = N
			} else {
				i = curr
				for {
					if !(i < N) {
						break
					}
					if *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) > libc.Float32FromInt32(1) || *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) < float32(-libc.Int32FromInt32(1)) {
						break
					}
					goto _3
				_3:
					;
					i = i + 1
				}
			}
			if i == N {
				a = libc.Float32FromInt32(0)
				break
			}
			peak_pos = i
			v4 = i
			end = v4
			start = v4
			maxval = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))))
			/* Look for first zero crossing before clipping */
			for start > 0 && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x + uintptr((start-int32(1))*C)*4))) >= libc.Float32FromInt32(0) {
				start = start - 1
			}
			/* Look for first zero crossing after clipping */
			for end < N && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x + uintptr(end*C)*4))) >= libc.Float32FromInt32(0) {
				/* Look for other peaks until the next zero-crossing. */
				if float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(end*C)*4))))) > maxval {
					maxval = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(end*C)*4)))))
					peak_pos = end
				}
				end = end + 1
			}
			/* Detect the special case where we clip before the first zero crossing */
			special = libc.BoolInt32(start == 0 && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x))) >= libc.Float32FromInt32(0))
			/* Compute a such that maxval + a*maxval^2 = 1 */
			a = (maxval - libc.Float32FromInt32(1)) / float32(maxval*maxval)
			/* Slightly boost "a" by 2^-22. This is just enough to ensure -ffast-math
			   does not cause output values larger than +/-1, but small enough not
			   to matter even for 24-bit output.  */
			a = a + float32(a*libc.Float32FromFloat32(2.4e-07))
			if *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) > libc.Float32FromInt32(0) {
				a = -a
			}
			/* Apply soft clipping */
			i = start
			for {
				if !(i < end) {
					break
				}
				*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) + float32(float32(a**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))
				goto _5
			_5:
				;
				i = i + 1
			}
			if special != 0 && peak_pos >= int32(2) {
				offset = x0 - *(*float32)(unsafe.Pointer(x))
				delta = offset / float32(peak_pos)
				i = curr
				for {
					if !(i < peak_pos) {
						break
					}
					offset = offset - delta
					*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) += offset
					if libc.Float32FromFloat32(1) < *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) {
						v8 = libc.Float32FromFloat32(1)
					} else {
						v8 = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))
					}
					if -libc.Float32FromFloat32(1) > v8 {
						v7 = -libc.Float32FromFloat32(1)
					} else {
						if libc.Float32FromFloat32(1) < *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) {
							v9 = libc.Float32FromFloat32(1)
						} else {
							v9 = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))
						}
						v7 = v9
					}
					*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = v7
					goto _6
				_6:
					;
					i = i + 1
				}
			}
			curr = end
			if curr == N {
				break
			}
		}
		*(*float32)(unsafe.Pointer(declip_mem + uintptr(c)*4)) = a
		goto _1
	_1:
		;
		c = c + 1
	}
}

func Opus_opus_pcm_soft_clip(tls *libc.TLS, _x uintptr, N int32, C int32, declip_mem uintptr) {
	Opus_opus_pcm_soft_clip_impl(tls, _x, N, C, declip_mem, 0)
}

func Opus_encode_size(tls *libc.TLS, size int32, data uintptr) (r int32) {
	if size < int32(252) {
		*(*uint8)(unsafe.Pointer(data)) = libc.Uint8FromInt32(size)
		return int32(1)
	} else {
		*(*uint8)(unsafe.Pointer(data)) = libc.Uint8FromInt32(int32(252) + size&int32(0x3))
		*(*uint8)(unsafe.Pointer(data + 1)) = libc.Uint8FromInt32((size - libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))) >> int32(2))
		return int32(2)
	}
	return r
}

func parse_size(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, size uintptr) (r int32) {
	if len1 < int32(1) {
		*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(-int32(1))
		return -int32(1)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) < int32(252) {
			*(*OpusT_opus_int16)(unsafe.Pointer(size)) = libc.Int16FromUint8(*(*uint8)(unsafe.Pointer(data)))
			return int32(1)
		} else {
			if len1 < int32(2) {
				*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(-int32(1))
				return -int32(1)
			} else {
				*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(int32(4)*libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data + 1))) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))))
				return int32(2)
			}
		}
	}
	return r
}

func Opus_opus_packet_get_samples_per_frame(tls *libc.TLS, data uintptr, Fs OpusT_opus_int32) (r int32) {
	var audiosize, v1 int32
	_, _ = audiosize, v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		audiosize = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) >> int32(3) & int32(0x3)
		audiosize = Fs << audiosize / int32(400)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x08) != 0 {
				v1 = Fs / int32(50)
			} else {
				v1 = Fs / int32(100)
			}
			audiosize = v1
		} else {
			audiosize = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) >> int32(3) & int32(0x3)
			if audiosize == int32(3) {
				audiosize = Fs * int32(60) / int32(1000)
			} else {
				audiosize = Fs << audiosize / int32(100)
			}
		}
	}
	return audiosize
}

func Opus_opus_packet_parse_impl(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, self_delimited int32, out_toc uintptr, frames uintptr, size uintptr, payload_offset uintptr, packet_offset uintptr, padding uintptr, padding_len uintptr) (r int32) {
	var bytes, cbr, count, framesize, i, p, tmp, v4 int32
	var ch, toc uint8
	var data0, v1 uintptr
	var last_size, pad OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = bytes, cbr, ch, count, data0, framesize, i, last_size, p, pad, tmp, toc, v1, v4
	pad = 0
	data0 = data
	/* Make sure we return NULL/0 on error. */
	if padding != libc.UintptrFromInt32(0) {
		*(*uintptr)(unsafe.Pointer(padding)) = libc.UintptrFromInt32(0)
		*(*OpusT_opus_int32)(unsafe.Pointer(padding_len)) = 0
	}
	if size == libc.UintptrFromInt32(0) || len1 < 0 {
		return -int32(1)
	}
	if len1 == 0 {
		return -int32(4)
	}
	framesize = Opus_opus_packet_get_samples_per_frame(tls, data, int32(48000))
	cbr = 0
	v1 = data
	data = data + 1
	toc = *(*uint8)(unsafe.Pointer(v1))
	len1 = len1 - 1
	last_size = len1
	switch libc.Int32FromUint8(toc) & libc.Int32FromInt32(0x3) {
	/* One frame */
	case 0:
		count = int32(1)
		break
		/* Two CBR frames */
		fallthrough
	case int32(1):
		count = int32(2)
		cbr = int32(1)
		if !(self_delimited != 0) {
			if len1&int32(0x1) != 0 {
				return -int32(4)
			}
			last_size = len1 / int32(2)
			/* If last_size doesn't fit in size[0], we'll catch it later */
			*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(last_size)
		}
		break
		/* Two VBR frames */
		fallthrough
	case int32(2):
		count = int32(2)
		bytes = parse_size(tls, data, len1, size)
		len1 = len1 - bytes
		if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size))) > len1 {
			return -int32(4)
		}
		data = data + uintptr(bytes)
		last_size = len1 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(size)))
		break
		/* Multiple CBR/VBR frames (from 0 to 120 ms) */
		fallthrough
	default: /*case 3:*/
		if len1 < int32(1) {
			return -int32(4)
		}
		/* Number of frames encoded in bits 0 to 5 */
		v1 = data
		data = data + 1
		ch = *(*uint8)(unsafe.Pointer(v1))
		count = libc.Int32FromUint8(ch) & int32(0x3F)
		if count <= 0 || framesize*count > int32(5760) {
			return -int32(4)
		}
		len1 = len1 - 1
		/* Padding flag is bit 6 */
		if libc.Int32FromUint8(ch)&int32(0x40) != 0 {
			for cond := true; cond; cond = p == int32(255) {
				if len1 <= 0 {
					return -int32(4)
				}
				v1 = data
				data = data + 1
				p = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
				len1 = len1 - 1
				if p == int32(255) {
					v4 = int32(254)
				} else {
					v4 = p
				}
				tmp = v4
				len1 = len1 - tmp
				pad = pad + tmp
			}
		}
		if len1 < 0 {
			return -int32(4)
		}
		/* VBR flag is bit 7 */
		cbr = libc.BoolInt32(!(libc.Int32FromUint8(ch)&libc.Int32FromInt32(0x80) != 0))
		if !(cbr != 0) {
			/* VBR case */
			last_size = len1
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				bytes = parse_size(tls, data, len1, size+uintptr(i)*2)
				len1 = len1 - bytes
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))) > len1 {
					return -int32(4)
				}
				data = data + uintptr(bytes)
				last_size = last_size - (bytes + int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))))
				goto _5
			_5:
				;
				i = i + 1
			}
			if last_size < 0 {
				return -int32(4)
			}
		} else {
			if !(self_delimited != 0) {
				/* CBR case */
				last_size = len1 / count
				if last_size*count != len1 {
					return -int32(4)
				}
				i = 0
				for {
					if !(i < count-int32(1)) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)) = int16(last_size)
					goto _6
				_6:
					;
					i = i + 1
				}
			}
		}
		break
	}
	/* Self-delimited framing has an extra size for the last frame. */
	if self_delimited != 0 {
		bytes = parse_size(tls, data, len1, size+uintptr(count)*2-uintptr(1)*2)
		len1 = len1 - bytes
		if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) > len1 {
			return -int32(4)
		}
		data = data + uintptr(bytes)
		/* For CBR packets, apply the size to all the frames. */
		if cbr != 0 {
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2)))*count > len1 {
				return -int32(4)
			}
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))
				goto _7
			_7:
				;
				i = i + 1
			}
		} else {
			if bytes+int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) > last_size {
				return -int32(4)
			}
		}
	} else {
		/* Because it's not encoded explicitly, it's possible the size of the
		   last packet (or all the packets, for the CBR case) is larger than
		   1275. Reject them here.*/
		if last_size > int32(1275) {
			return -int32(4)
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2)) = int16(last_size)
	}
	if payload_offset != 0 {
		*(*int32)(unsafe.Pointer(payload_offset)) = int32(int64(data) - int64(data0))
	}
	i = 0
	for {
		if !(i < count) {
			break
		}
		if frames != 0 {
			*(*uintptr)(unsafe.Pointer(frames + uintptr(i)*8)) = data
		}
		data = data + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)))
		goto _8
	_8:
		;
		i = i + 1
	}
	if padding != libc.UintptrFromInt32(0) {
		*(*uintptr)(unsafe.Pointer(padding)) = data
		*(*OpusT_opus_int32)(unsafe.Pointer(padding_len)) = pad
	}
	if packet_offset != 0 {
		*(*OpusT_opus_int32)(unsafe.Pointer(packet_offset)) = pad + int32(int64(data)-int64(data0))
	}
	if out_toc != 0 {
		*(*uint8)(unsafe.Pointer(out_toc)) = toc
	}
	return count
}

func Opus_opus_packet_parse(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, out_toc uintptr, frames uintptr, size uintptr, payload_offset uintptr) (r int32) {
	return Opus_opus_packet_parse_impl(tls, data, len1, 0, out_toc, frames, size, payload_offset, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
}

const ALLOC_NONE = 0
const BWE_AFTER_LOSS_Q16 = 63570
const CELT_SIG_SCALE1 = 32768
const CLOCKS_PER_SEC = 1000000
const CLOCK_BOOTTIME = 7
const CLOCK_BOOTTIME_ALARM = 9
const CLOCK_MONOTONIC = 1
const CLOCK_MONOTONIC_COARSE = 6
const CLOCK_MONOTONIC_RAW = 4
const CLOCK_PROCESS_CPUTIME_ID = 2
const CLOCK_REALTIME = 0
const CLOCK_REALTIME_ALARM = 8
const CLOCK_REALTIME_COARSE = 5
const CLOCK_SGI_CYCLE = 10
const CLOCK_TAI = 11
const CLOCK_THREAD_CPUTIME_ID = 3
const CLONE_CHILD_CLEARTID = 0x00200000
const CLONE_CHILD_SETTID = 0x01000000
const CLONE_DETACHED = 0x00400000
const CLONE_FILES = 0x00000400
const CLONE_FS = 0x00000200
const CLONE_IO = 0x80000000
const CLONE_NEWCGROUP = 0x02000000
const CLONE_NEWIPC = 0x08000000
const CLONE_NEWNET = 0x40000000
const CLONE_NEWNS = 0x00020000
const CLONE_NEWPID = 0x20000000
const CLONE_NEWTIME = 0x00000080
const CLONE_NEWUSER = 0x10000000
const CLONE_NEWUTS = 0x04000000
const CLONE_PARENT = 0x00008000
const CLONE_PARENT_SETTID = 0x00100000
const CLONE_PIDFD = 0x00001000
const CLONE_PTRACE = 0x00002000
const CLONE_SETTLS = 0x00080000
const CLONE_SIGHAND = 0x00000800
const CLONE_SYSVSEM = 0x00040000
const CLONE_THREAD = 0x00010000
const CLONE_UNTRACED = 0x00800000
const CLONE_VFORK = 0x00004000
const CLONE_VM = 0x00000100
const CNG_BUF_MASK_MAX = 255
const CNG_GAIN_SMTH_Q16 = 4634
const CNG_GAIN_SMTH_THRESHOLD_Q16 = 46396
const CNG_NLSF_SMTH_Q16 = 16348
const CODE_CONDITIONALLY = 2
const CODE_INDEPENDENTLY = 0
const CODE_INDEPENDENTLY_NO_LTP_SCALING = 1
const COEF_ONE1 = 1
const CPU_SETSIZE = 1024
const CSIGNAL = 0x000000ff
const DBL_DECIMAL_DIG = 17
const DBL_DIG = 15
const DBL_EPSILON = 2.22044604925031308085e-16
const DBL_HAS_SUBNORM = 1
const DBL_MANT_DIG = 53
const DBL_MAX = 1.79769313486231570815e+308
const DBL_MAX_10_EXP = 308
const DBL_MAX_EXP = 1024
const DBL_MIN = 2.22507385850720138309e-308
const DBL_TRUE_MIN = 4.94065645841246544177e-324
const DECIMAL_DIG = 17
const DECISION_DELAY = 40
const DECODER_NUM_CHANNELS = 2
const DEC_PITCH_BUF_SIZE = 2048
const DTX_ACTIVITY_THRESHOLD = "0.1f"
const ENCODER_NUM_CHANNELS = 2
const FLAG_DECODE_LBRR = 2
const FLAG_DECODE_NORMAL = 0
const FLAG_PACKET_LOST = 1
const FLT_DECIMAL_DIG = 9
const FLT_DIG = 6
const FLT_EPSILON = 1.1920928955078125e-07
const FLT_EVAL_METHOD = 0
const FLT_HAS_SUBNORM = 1
const FLT_MANT_DIG = 24
const FLT_MAX = 3.40282346638528859812e+38
const FLT_MAX_10_EXP = 38
const FLT_MAX_EXP = 128
const FLT_MIN = 1.17549435082228750797e-38
const FLT_RADIX = 2
const FLT_TRUE_MIN = 1.40129846432481707092e-45
const HARM_SHAPE_FIR_TAPS = 3
const LA_PITCH_MS = 2
const LA_SHAPE_MS = 5
const LBRR_MB_MIN_RATE_BPS = 14000
const LBRR_NB_MIN_RATE_BPS = 12000
const LBRR_WB_MIN_RATE_BPS = 16000
const LDBL_DECIMAL_DIG = "DECIMAL_DIG"
const LDBL_DIG = 15
const LDBL_EPSILON = 2.22044604925031308085e-16
const LDBL_HAS_SUBNORM = 1
const LDBL_MANT_DIG = 53
const LDBL_MAX = 1.79769313486231570815e+308
const LDBL_MAX_10_EXP = 308
const LDBL_MAX_EXP = 1024
const LDBL_MIN = 2.22507385850720138309e-308
const LDBL_TRUE_MIN = 4.94065645841246544177e-324
const LOG2_SHELL_CODEC_FRAME_LENGTH = 4
const LSF_COS_TAB_SZ_FIX = 128
const LTP_BUF_LENGTH = 512
const LTP_MEM_LENGTH_MS = 20
const LTP_ORDER = 5
const MAX_API_FS_KHZ = 48
const MAX_CONSECUTIVE_DTX = 20
const MAX_DELTA_GAIN_QUANT = 36
const MAX_DEL_DEC_STATES = 4
const MAX_FIND_PITCH_LPC_ORDER = 16
const MAX_FRAMES_PER_PACKET = 3
const MAX_FS_KHZ = 16
const MAX_LPC_ORDER = 16
const MAX_LPC_STABILIZE_ITERATIONS = 16
const MAX_MATRIX_SIZE = "MAX_LPC_ORDER"
const MAX_NB_SUBFR = 4
const MAX_PERIOD = 1024
const MAX_PREDICTION_POWER_GAIN = "1e4f"
const MAX_PREDICTION_POWER_GAIN_AFTER_RESET = "1e2f"
const MAX_QGAIN_DB = 88
const MAX_SHAPE_LPC_ORDER = 24
const MAX_TARGET_RATE_BPS = 80000
const MIN_LPC_ORDER = 10
const MIN_QGAIN_DB = 2
const MIN_TARGET_RATE_BPS = 5000
const NB_LTP_CBKS = 3
const NB_SPEECH_FRAMES_BEFORE_DTX = 10
const NLSF_QUANT_DEL_DEC_STATES_LOG2 = 2
const NLSF_QUANT_LEVEL_ADJ = 0.1
const NLSF_QUANT_MAX_AMPLITUDE = 4
const NLSF_QUANT_MAX_AMPLITUDE_EXT = 10
const NLSF_VQ_MAX_VECTORS = 32
const NLSF_W_Q = 2
const NSQ_LPC_BUF_LENGTH = "MAX_LPC_ORDER"
const N_LEVELS_QGAIN = 64
const N_RATE_LEVELS = 10
const OFFSET_UVH_Q10 = 240
const OFFSET_UVL_Q10 = 100
const OFFSET_VH_Q10 = 100
const OFFSET_VL_Q10 = 32
const OPTIONAL_CLIP = 1
const OPUS_CCGO_PSEUDOSTACK_KEY = 1869641075
const OPUS_DECODER_RESET_START = "stream_channels"
const OPUS_FPRINTF = "void"
const PITCH_EST_MAX_LAG_MS = 18
const PITCH_EST_MIN_LAG_MS = 2
const PTHREAD_CANCEL_ASYNCHRONOUS = 1
const PTHREAD_CANCEL_DEFERRED = 0
const PTHREAD_CANCEL_DISABLE = 1
const PTHREAD_CANCEL_ENABLE = 0
const PTHREAD_CANCEL_MASKED = 2
const PTHREAD_CREATE_DETACHED = 1
const PTHREAD_CREATE_JOINABLE = 0
const PTHREAD_EXPLICIT_SCHED = 1
const PTHREAD_INHERIT_SCHED = 0
const PTHREAD_MUTEX_DEFAULT = 0
const PTHREAD_MUTEX_ERRORCHECK = 2
const PTHREAD_MUTEX_NORMAL = 0
const PTHREAD_MUTEX_RECURSIVE = 1
const PTHREAD_MUTEX_ROBUST = 1
const PTHREAD_MUTEX_STALLED = 0
const PTHREAD_ONCE_INIT = 0
const PTHREAD_PRIO_INHERIT = 1
const PTHREAD_PRIO_NONE = 0
const PTHREAD_PRIO_PROTECT = 2
const PTHREAD_PROCESS_PRIVATE = 0
const PTHREAD_PROCESS_SHARED = 1
const PTHREAD_SCOPE_PROCESS = 1
const PTHREAD_SCOPE_SYSTEM = 0
const QUANT_LEVEL_ADJUST_Q10 = 80
const RAND_INCREMENT = 907633515
const RAND_MULTIPLIER = 196314165
const SCHED_BATCH = 3
const SCHED_DEADLINE = 6
const SCHED_FIFO = 1
const SCHED_IDLE = 5
const SCHED_OTHER = 0
const SCHED_RESET_ON_FORK = 0x40000000
const SCHED_RR = 2
const SHELL_CODEC_FRAME_LENGTH = 16
const SILK_DECODER_STATE_RESET_START = "prev_gain_Q16"
const SILK_MAX_FRAMES_PER_PACKET = 3
const SILK_MAX_ORDER_LPC = 24
const SILK_MAX_PULSES = 16
const SILK_NO_ERROR = 0
const SILK_RESAMPLER_MAX_FIR_ORDER = 36
const SILK_RESAMPLER_MAX_IIR_ORDER = 6
const STEREO_INTERP_LEN_MS = 8
const STEREO_QUANT_SUB_STEPS = 5
const STEREO_QUANT_TAB_SIZE = 16
const STEREO_RATIO_SMOOTH_COEF = 0.01
const SUB_FRAME_LENGTH_MS = 5
const TIMER_ABSTIME = 1
const TIME_UTC = 1
const TRANSITION_INT_NUM = 5
const TRANSITION_NA = 2
const TRANSITION_NB = 3
const TRANSITION_TIME_MS = 5120
const TYPE_NO_VOICE_ACTIVITY = 0
const TYPE_UNVOICED = 1
const TYPE_VOICED = 2
const USE_HARM_SHAPING = 1
const VAD_ACTIVITY = 1
const VAD_INTERNAL_SUBFRAMES_LOG2 = 2
const VAD_NEGATIVE_OFFSET_Q5 = 128
const VAD_NOISE_LEVELS_BIAS = 50
const VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 = 1024
const VAD_NO_ACTIVITY = 0
const VAD_N_BANDS = 4
const VAD_SNR_FACTOR_Q16 = 45000
const VAD_SNR_SMOOTH_COEF_Q18 = 4096
const _ISOC99_SOURCE = 1
const _ISOC9X_SOURCE = 1
const __USE_ISOC99 = 1
const __USE_ISOC9X = 1
const __tm_gmtoff = "tm_gmtoff"
const __tm_zone = "tm_zone"
const silk_FALSE = 0
const silk_LIMIT_16 = "silk_LIMIT"
const silk_LIMIT_32 = "silk_LIMIT"
const silk_LIMIT_int = "silk_LIMIT"
const silk_TRUE = 1
const silk_float = "float"
const silk_float_MAX = "FLT_MAX"
const silk_int16_MAX = 0x7FFF
const silk_int32_MAX = 2147483647
const silk_int8_MAX = 0x7F
const silk_uint8_MAX = 0xFF

type OpusT_OpusCustomMode = struct {
	FFs             OpusT_opus_int32
	Foverlap        int32
	FnbEBands       int32
	FeffEBands      int32
	Fpreemph        [4]OpusT_opus_val16
	FeBands         uintptr
	FmaxLM          int32
	FnbShortMdcts   int32
	FshortMdctSize  int32
	FnbAllocVectors int32
	FallocVectors   uintptr
	FlogN           uintptr
	Fwindow         uintptr
	Fmdct           OpusT_mdct_lookup
	Fcache          OpusT_PulseCache
}

var trim_icdf1 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf1 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf1 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusDecoder = struct {
	Fcelt_dec_offset      int32
	Fsilk_dec_offset      int32
	Fchannels             int32
	FFs                   OpusT_opus_int32
	FDecControl           OpusT_silk_DecControlStruct
	Fdecode_gain          int32
	Fcomplexity           int32
	Fignore_extensions    int32
	Farch                 int32
	Fstream_channels      int32
	Fbandwidth            int32
	Fmode                 int32
	Fprev_mode            int32
	Fframe_size           int32
	Fprev_redundancy      int32
	Flast_packet_duration int32
	Fsoftclip_mem         [2]OpusT_opus_val16
	FrangeFinal           OpusT_opus_uint32
}

type OpusT_OpusDREDDecoder = struct {
	Floaded int32
	Farch   int32
	Fmagic  OpusT_opus_uint32
}

type OpusT_mdct_lookup = struct {
	Fn        int32
	Fmaxshift int32
	Fkfft     [4]uintptr
	Ftrig     uintptr
}

type OpusT_PulseCache = struct {
	Fsize  int32
	Findex uintptr
	Fbits  uintptr
	Fcaps  uintptr
}

type OpusCustomMode = struct {
	FFs             OpusT_opus_int32
	Foverlap        int32
	FnbEBands       int32
	FeffEBands      int32
	Fpreemph        [4]OpusT_opus_val16
	FeBands         uintptr
	FmaxLM          int32
	FnbShortMdcts   int32
	FshortMdctSize  int32
	FnbAllocVectors int32
	FallocVectors   uintptr
	FlogN           uintptr
	Fwindow         uintptr
	Fmdct           OpusT_mdct_lookup
	Fcache          OpusT_PulseCache
}

type OpusT_silk_EncControlStruct = struct {
	FnChannelsAPI              OpusT_opus_int32
	FnChannelsInternal         OpusT_opus_int32
	FAPI_sampleRate            OpusT_opus_int32
	FmaxInternalSampleRate     OpusT_opus_int32
	FminInternalSampleRate     OpusT_opus_int32
	FdesiredInternalSampleRate OpusT_opus_int32
	FpayloadSize_ms            int32
	FbitRate                   OpusT_opus_int32
	FpacketLossPercentage      int32
	Fcomplexity                int32
	FuseInBandFEC              int32
	FuseDRED                   int32
	FLBRR_coded                int32
	FuseDTX                    int32
	FuseCBR                    int32
	FmaxBits                   int32
	FtoMono                    int32
	FopusCanSwitch             int32
	FreducedDependency         int32
	FinternalSampleRate        OpusT_opus_int32
	FallowBandwidthSwitch      int32
	FinWBmodeWithoutVariableLP int32
	FstereoWidth_Q14           int32
	FswitchReady               int32
	FsignalType                int32
	Foffset                    int32
}

type OpusT_silk_DecControlStruct = struct {
	FnChannelsAPI       OpusT_opus_int32
	FnChannelsInternal  OpusT_opus_int32
	FAPI_sampleRate     OpusT_opus_int32
	FinternalSampleRate OpusT_opus_int32
	FpayloadSize_ms     int32
	FprevPitchLag       int32
	Fenable_deep_plc    int32
}

type OpusT_silk_TOC_struct = struct {
	FVADFlag       int32
	FVADFlags      [3]int32
	FinbandFECFlag int32
}

type OpusT_time_t = int64

type OpusT_clockid_t = int32

type timespec = struct {
	Ftv_sec  OpusT_time_t
	Ftv_nsec int64
}

type OpusT_pthread_t = uintptr

type OpusT_pthread_once_t = int32

type OpusT_pthread_key_t = uint32

type OpusT_pthread_spinlock_t = int32

type OpusT_pthread_mutexattr_t = struct {
	F__attr uint32
}

type OpusT_pthread_condattr_t = struct {
	F__attr uint32
}

type OpusT_pthread_barrierattr_t = struct {
	F__attr uint32
}

type OpusT_pthread_rwlockattr_t = struct {
	F__attr [2]uint32
}

type OpusT_sigset_t = struct {
	F__bits [16]uint64
}

type __sigset_t = OpusT_sigset_t

type OpusT_pthread_attr_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__s  [0][7]uint64
		F__i  [14]int32
	}
}

type OpusT_pthread_mutex_t = struct {
	F__u struct {
		F__vi [0][10]int32
		F__p  [0][5]uintptr
		F__i  [10]int32
	}
}

type OpusT_pthread_cond_t = struct {
	F__u struct {
		F__vi [0][12]int32
		F__p  [0][6]uintptr
		F__i  [12]int32
	}
}

type OpusT_pthread_rwlock_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__p  [0][7]uintptr
		F__i  [14]int32
	}
}

type OpusT_pthread_barrier_t = struct {
	F__u struct {
		F__vi [0][8]int32
		F__p  [0][4]uintptr
		F__i  [8]int32
	}
}

type OpusT_pid_t = int32

type sched_param = struct {
	Fsched_priority int32
	F__reserved1    int32
	F__reserved2    [2]struct {
		F__reserved1 OpusT_time_t
		F__reserved2 int64
	}
	F__reserved3 int32
}

type OpusT_cpu_set_t = struct {
	F__bits [16]uint64
}

type OpusT_timer_t = uintptr

type OpusT_clock_t = int64

type tm = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
}

type itimerspec = struct {
	Fit_interval timespec
	Fit_value    timespec
}

type __ptcb = struct {
	F__f    uintptr
	F__x    uintptr
	F__next uintptr
}

type cpu_set_t = struct {
	F__bits [16]uint64
}

type OpusT_opus_ccgo_pseudostack_state = struct {
	Fscratch_ptr  uintptr
	Fglobal_stack uintptr
}

type OpusT_silk_resampler_state_struct = struct {
	FsIIR [6]OpusT_opus_int32
	FsFIR struct {
		Fi16 [0][36]OpusT_opus_int16
		Fi32 [36]OpusT_opus_int32
	}
	FdelayBuf           [96]OpusT_opus_int16
	Fresampler_function int32
	FbatchSize          int32
	FinvRatio_Q16       OpusT_opus_int32
	FFIR_Order          int32
	FFIR_Fracs          int32
	FFs_in_kHz          int32
	FFs_out_kHz         int32
	FinputDelay         int32
	FCoefs              uintptr
}

type _silk_resampler_state_struct = OpusT_silk_resampler_state_struct

type OpusT_silk_nsq_state = struct {
	Fxq               [640]OpusT_opus_int16
	FsLTP_shp_Q14     [640]OpusT_opus_int32
	FsLPC_Q14         [96]OpusT_opus_int32
	FsAR2_Q14         [24]OpusT_opus_int32
	FsLF_AR_shp_Q14   OpusT_opus_int32
	FsDiff_shp_Q14    OpusT_opus_int32
	FlagPrev          int32
	FsLTP_buf_idx     int32
	FsLTP_shp_buf_idx int32
	Frand_seed        OpusT_opus_int32
	Fprev_gain_Q16    OpusT_opus_int32
	Frewhite_flag     int32
}

type OpusT_silk_VAD_state = struct {
	FAnaState        [2]OpusT_opus_int32
	FAnaState1       [2]OpusT_opus_int32
	FAnaState2       [2]OpusT_opus_int32
	FXnrgSubfr       [4]OpusT_opus_int32
	FNrgRatioSmth_Q8 [4]OpusT_opus_int32
	FHPstate         OpusT_opus_int16
	FNL              [4]OpusT_opus_int32
	Finv_NL          [4]OpusT_opus_int32
	FNoiseLevelBias  [4]OpusT_opus_int32
	Fcounter         OpusT_opus_int32
}

type OpusT_silk_LP_state = struct {
	FIn_LP_State         [2]OpusT_opus_int32
	Ftransition_frame_no OpusT_opus_int32
	Fmode                int32
	Fsaved_fs_kHz        OpusT_opus_int32
}

type OpusT_silk_NLSF_CB_struct = struct {
	FnVectors            OpusT_opus_int16
	Forder               OpusT_opus_int16
	FquantStepSize_Q16   OpusT_opus_int16
	FinvQuantStepSize_Q6 OpusT_opus_int16
	FCB1_NLSF_Q8         uintptr
	FCB1_Wght_Q9         uintptr
	FCB1_iCDF            uintptr
	Fpred_Q8             uintptr
	Fec_sel              uintptr
	Fec_iCDF             uintptr
	Fec_Rates_Q5         uintptr
	FdeltaMin_Q15        uintptr
}

type OpusT_stereo_enc_state = struct {
	Fpred_prev_Q13   [2]OpusT_opus_int16
	FsMid            [2]OpusT_opus_int16
	FsSide           [2]OpusT_opus_int16
	Fmid_side_amp_Q0 [4]OpusT_opus_int32
	Fsmth_width_Q14  OpusT_opus_int16
	Fwidth_prev_Q14  OpusT_opus_int16
	Fsilent_side_len OpusT_opus_int16
	FpredIx          [3][2][3]OpusT_opus_int8
	Fmid_only_flags  [3]OpusT_opus_int8
}

type OpusT_stereo_dec_state = struct {
	Fpred_prev_Q13 [2]OpusT_opus_int16
	FsMid          [2]OpusT_opus_int16
	FsSide         [2]OpusT_opus_int16
}

type OpusT_SideInfoIndices = struct {
	FGainsIndices      [4]OpusT_opus_int8
	FLTPIndex          [4]OpusT_opus_int8
	FNLSFIndices       [17]OpusT_opus_int8
	FlagIndex          OpusT_opus_int16
	FcontourIndex      OpusT_opus_int8
	FsignalType        OpusT_opus_int8
	FquantOffsetType   OpusT_opus_int8
	FNLSFInterpCoef_Q2 OpusT_opus_int8
	FPERIndex          OpusT_opus_int8
	FLTP_scaleIndex    OpusT_opus_int8
	FSeed              OpusT_opus_int8
}

type OpusT_silk_encoder_state = struct {
	FIn_HP_State                   [2]OpusT_opus_int32
	Fvariable_HP_smth1_Q15         OpusT_opus_int32
	Fvariable_HP_smth2_Q15         OpusT_opus_int32
	FsLP                           OpusT_silk_LP_state
	FsVAD                          OpusT_silk_VAD_state
	FsNSQ                          OpusT_silk_nsq_state
	Fprev_NLSFq_Q15                [16]OpusT_opus_int16
	Fspeech_activity_Q8            int32
	Fallow_bandwidth_switch        int32
	FLBRRprevLastGainIndex         OpusT_opus_int8
	FprevSignalType                OpusT_opus_int8
	FprevLag                       int32
	Fpitch_LPC_win_length          int32
	Fmax_pitch_lag                 int32
	FAPI_fs_Hz                     OpusT_opus_int32
	Fprev_API_fs_Hz                OpusT_opus_int32
	FmaxInternal_fs_Hz             int32
	FminInternal_fs_Hz             int32
	FdesiredInternal_fs_Hz         int32
	Ffs_kHz                        int32
	Fnb_subfr                      int32
	Fframe_length                  int32
	Fsubfr_length                  int32
	Fltp_mem_length                int32
	Fla_pitch                      int32
	Fla_shape                      int32
	FshapeWinLength                int32
	FTargetRate_bps                OpusT_opus_int32
	FPacketSize_ms                 int32
	FPacketLoss_perc               int32
	FframeCounter                  OpusT_opus_int32
	FComplexity                    int32
	FnStatesDelayedDecision        int32
	FuseInterpolatedNLSFs          int32
	FshapingLPCOrder               int32
	FpredictLPCOrder               int32
	FpitchEstimationComplexity     int32
	FpitchEstimationLPCOrder       int32
	FpitchEstimationThreshold_Q16  OpusT_opus_int32
	Fsum_log_gain_Q7               OpusT_opus_int32
	FNLSF_MSVQ_Survivors           int32
	Ffirst_frame_after_reset       int32
	Fcontrolled_since_last_payload int32
	Fwarping_Q16                   int32
	FuseCBR                        int32
	FprefillFlag                   int32
	Fpitch_lag_low_bits_iCDF       uintptr
	Fpitch_contour_iCDF            uintptr
	FpsNLSF_CB                     uintptr
	Finput_quality_bands_Q15       [4]int32
	Finput_tilt_Q15                int32
	FSNR_dB_Q7                     int32
	FVAD_flags                     [3]OpusT_opus_int8
	FLBRR_flag                     OpusT_opus_int8
	FLBRR_flags                    [3]int32
	Findices                       OpusT_SideInfoIndices
	Fpulses                        [320]OpusT_opus_int8
	Farch                          int32
	FinputBuf                      [322]OpusT_opus_int16
	FinputBufIx                    int32
	FnFramesPerPacket              int32
	FnFramesEncoded                int32
	FnChannelsAPI                  int32
	FnChannelsInternal             int32
	FchannelNb                     int32
	Fframes_since_onset            int32
	Fec_prevSignalType             int32
	Fec_prevLagIndex               OpusT_opus_int16
	Fresampler_state               OpusT_silk_resampler_state_struct
	FuseDTX                        int32
	FinDTX                         int32
	FnoSpeechCounter               int32
	FuseInBandFEC                  int32
	FLBRR_enabled                  int32
	FLBRR_GainIncreases            int32
	Findices_LBRR                  [3]OpusT_SideInfoIndices
	Fpulses_LBRR                   [3][320]OpusT_opus_int8
}

type OpusT_silk_PLC_struct = struct {
	FpitchL_Q8         OpusT_opus_int32
	FLTPCoef_Q14       [5]OpusT_opus_int16
	FprevLPC_Q12       [16]OpusT_opus_int16
	Flast_frame_lost   int32
	Frand_seed         OpusT_opus_int32
	FrandScale_Q14     OpusT_opus_int16
	Fconc_energy       OpusT_opus_int32
	Fconc_energy_shift int32
	FprevLTP_scale_Q14 OpusT_opus_int16
	FprevGain_Q16      [2]OpusT_opus_int32
	Ffs_kHz            int32
	Fnb_subfr          int32
	Fsubfr_length      int32
	Fenable_deep_plc   int32
}

type OpusT_silk_CNG_struct = struct {
	FCNG_exc_buf_Q14   [320]OpusT_opus_int32
	FCNG_smth_NLSF_Q15 [16]OpusT_opus_int16
	FCNG_synth_state   [16]OpusT_opus_int32
	FCNG_smth_Gain_Q16 OpusT_opus_int32
	Frand_seed         OpusT_opus_int32
	Ffs_kHz            int32
}

type OpusT_silk_decoder_state = struct {
	Fprev_gain_Q16           OpusT_opus_int32
	Fexc_Q14                 [320]OpusT_opus_int32
	FsLPC_Q14_buf            [16]OpusT_opus_int32
	FoutBuf                  [480]OpusT_opus_int16
	FlagPrev                 int32
	FLastGainIndex           OpusT_opus_int8
	Ffs_kHz                  int32
	Ffs_API_hz               OpusT_opus_int32
	Fnb_subfr                int32
	Fframe_length            int32
	Fsubfr_length            int32
	Fltp_mem_length          int32
	FLPC_order               int32
	FprevNLSF_Q15            [16]OpusT_opus_int16
	Ffirst_frame_after_reset int32
	Fpitch_lag_low_bits_iCDF uintptr
	Fpitch_contour_iCDF      uintptr
	FnFramesDecoded          int32
	FnFramesPerPacket        int32
	Fec_prevSignalType       int32
	Fec_prevLagIndex         OpusT_opus_int16
	FVAD_flags               [3]int32
	FLBRR_flag               int32
	FLBRR_flags              [3]int32
	Fresampler_state         OpusT_silk_resampler_state_struct
	FpsNLSF_CB               uintptr
	Findices                 OpusT_SideInfoIndices
	FsCNG                    OpusT_silk_CNG_struct
	FlossCnt                 int32
	FprevSignalType          int32
	Farch                    int32
	FsPLC                    OpusT_silk_PLC_struct
}

type OpusT_silk_decoder_control = struct {
	FpitchL        [4]int32
	FGains_Q16     [4]OpusT_opus_int32
	FPredCoef_Q12  [2][16]OpusT_opus_int16
	FLTPCoef_Q14   [20]OpusT_opus_int16
	FLTP_scale_Q14 int32
}

var log2_x_norm_coeff1 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff1 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2010 Xiph.Org Foundation
 * Copyright (c) 2013 Parrot */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

type OpusDecoder = struct {
	Fcelt_dec_offset      int32
	Fsilk_dec_offset      int32
	Fchannels             int32
	FFs                   OpusT_opus_int32
	FDecControl           OpusT_silk_DecControlStruct
	Fdecode_gain          int32
	Fcomplexity           int32
	Fignore_extensions    int32
	Farch                 int32
	Fstream_channels      int32
	Fbandwidth            int32
	Fmode                 int32
	Fprev_mode            int32
	Fframe_size           int32
	Fprev_redundancy      int32
	Flast_packet_duration int32
	Fsoftclip_mem         [2]OpusT_opus_val16
	FrangeFinal           OpusT_opus_uint32
}

func validate_opus_decoder(tls *libc.TLS, st uintptr) {
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(99))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(48000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(24000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(16000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(12000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(8000)) {
		Opus_celt_fatal(tls, __ccgo_ts+79, __ccgo_ts+57, int32(103))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FAPI_sampleRate == (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs) {
		Opus_celt_fatal(tls, __ccgo_ts+188, __ccgo_ts+57, int32(105))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(16000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(12000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(8000)) {
		Opus_celt_fatal(tls, __ccgo_ts+246, __ccgo_ts+57, int32(106))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsAPI == (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels) {
		Opus_celt_fatal(tls, __ccgo_ts+440, __ccgo_ts+57, int32(107))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+502, __ccgo_ts+57, int32(108))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(10) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(20) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(40) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(60)) {
		Opus_celt_fatal(tls, __ccgo_ts+640, __ccgo_ts+57, int32(109))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+849, __ccgo_ts+57, int32(111))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch <= libc.Int32FromInt32(OPUS_ARCHMASK)) {
		Opus_celt_fatal(tls, __ccgo_ts+881, __ccgo_ts+57, int32(112))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+925, __ccgo_ts+57, int32(114))
	}
}

func Opus_opus_decoder_get_size(tls *libc.TLS, channels int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var alignment uint32
	var celtDecSizeBytes, ret, v1 int32
	var _ /* silkDecSizeBytes at bp+0 */ int32
	_, _, _, _ = alignment, celtDecSizeBytes, ret, v1
	if channels < int32(1) || channels > int32(2) {
		return 0
	}
	ret = Opus_silk_Get_Decoder_Size(tls, bp)
	if ret != 0 {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	*(*int32)(unsafe.Pointer(bp)) = v1
	celtDecSizeBytes = Opus_celt_decoder_get_size(tls, channels)
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(100)) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	return v1 + *(*int32)(unsafe.Pointer(bp)) + celtDecSizeBytes
}

func Opus_opus_decoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var celt_dec, silk_dec uintptr
	var ret, v1 int32
	var _ /* silkDecSizeBytes at bp+0 */ int32
	_, _, _, _, _ = alignment, celt_dec, ret, silk_dec, v1
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) {
		return -int32(1)
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(Opus_opus_decoder_get_size(tls, channels))*uint64(1))
	/* Initialize SILK decoder */
	ret = Opus_silk_Get_Decoder_Size(tls, bp)
	if ret != 0 {
		return -int32(3)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	*(*int32)(unsafe.Pointer(bp)) = v1
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(100)) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset + *(*int32)(unsafe.Pointer(bp))
	silk_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset)
	celt_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset)
	v1 = channels
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity = 0
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs = Fs
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FAPI_sampleRate = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsAPI = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels
	/* Reset decoder */
	ret = Opus_silk_InitDecoder(tls, silk_dec)
	if ret != 0 {
		return -int32(3)
	}
	/* Initialize CELT decoder */
	ret = Opus_celt_decoder_init(tls, celt_dec, Fs, channels)
	if ret != OPUS_OK {
		return -int32(3)
	}
	_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
	Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_SIGNALLING_REQUEST), libc.VaList(bp+16, libc.Int32FromInt32(0)))
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fprev_mode = 0
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = Fs / int32(400)
	v1 = 0
	goto _7
_7:
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch = v1
	return OPUS_OK
}

func Opus_opus_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, error1 uintptr) (r uintptr) {
	var ret int32
	var st, v1 uintptr
	_, _, _ = ret, st, v1
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_decoder_get_size(tls, channels)))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_decoder_init(tls, st, Fs, channels)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	return st
}

func smooth_fade(tls *libc.TLS, in1 uintptr, in2 uintptr, out uintptr, overlap int32, channels int32, window uintptr, Fs OpusT_opus_int32) {
	var c, i, inc int32
	var w OpusT_celt_coef
	_, _, _, _ = c, i, inc, w
	inc = int32(48000) / Fs
	c = 0
	for {
		if !(c < channels) {
			break
		}
		i = 0
		for {
			if !(i < overlap) {
				break
			}
			w = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4)) * *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4)))
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+c)*4)) = OpusT_celt_coef(w**(*OpusT_opus_res)(unsafe.Pointer(in2 + uintptr(i*channels+c)*4))) + float32((libc.Float32FromFloat32(1)-w)**(*OpusT_opus_res)(unsafe.Pointer(in1 + uintptr(i*channels+c)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		c = c + 1
	}
}

func opus_packet_get_mode(tls *libc.TLS, data uintptr) (r int32) {
	var mode int32
	_ = mode
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		mode = int32(MODE_CELT_ONLY)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			mode = int32(MODE_HYBRID)
		} else {
			mode = int32(MODE_SILK_ONLY)
		}
	}
	return mode
}

func opus_decode_frame(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var F10, F20, F2_5, F5, audiosize, bandwidth, c, celt_accum, celt_frame_size, celt_ret, celt_to_silk, decoded_samples, endband, first_frame, i, lost_flag, mode, pcm_silk_size, pcm_too_small, pcm_transition_celt_size, pcm_transition_silk_size, redundancy, redundancy_bytes, redundant_audio_size, ret, silk_ret, start_band, transition, v31, v32 int32
	var _saved_stack, celt_dec, pcm_ptr, pcm_silk, pcm_transition, pcm_transition_celt, pcm_transition_silk, redundant_audio, silk_dec, st, window, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var frac, v175, v176 float32
	var gain, x1 OpusT_opus_val32
	var integer OpusT_opus_int32
	var v111 bool
	var _ /* celt_mode at bp+80 */ uintptr
	var _ /* dec at bp+8 */ OpusT_ec_dec
	var _ /* redundant_rng at bp+68 */ OpusT_opus_uint32
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* silence at bp+72 */ [2]uint8
	var _ /* silk_frame_size at bp+64 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = F10, F20, F2_5, F5, _saved_stack, audiosize, bandwidth, c, celt_accum, celt_dec, celt_frame_size, celt_ret, celt_to_silk, decoded_samples, endband, first_frame, frac, gain, i, integer, lost_flag, mode, pcm_ptr, pcm_silk, pcm_silk_size, pcm_too_small, pcm_transition, pcm_transition_celt, pcm_transition_celt_size, pcm_transition_silk, pcm_transition_silk_size, redundancy, redundancy_bytes, redundant_audio, redundant_audio_size, ret, silk_dec, silk_ret, st, start_band, transition, window, x1, v1, v10, v11, v111, v13, v15, v17, v175, v176, v19, v21, v3, v31, v32, v5, v6, v8
	silk_ret = 0
	celt_ret = 0
	pcm_transition = libc.UintptrFromInt32(0)
	transition = 0
	redundancy = 0
	redundancy_bytes = 0
	celt_to_silk = 0
	*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 68)) = uint32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	silk_dec = st1 + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fsilk_dec_offset)
	celt_dec = st1 + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fcelt_dec_offset)
	F20 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs / int32(50)
	F10 = F20 >> int32(1)
	F5 = F10 >> int32(1)
	F2_5 = F5 >> int32(1)
	if frame_size < F2_5 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(2)
	}
	/* Limit frame_size to avoid excessive stack allocations. */
	if frame_size < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs/int32(25)*int32(3) {
		v31 = frame_size
	} else {
		v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs / int32(25) * int32(3)
	}
	frame_size = v31
	/* Payloads of 1 (2 including ToC) or 0 trigger the PLC/DTX */
	if len1 <= int32(1) {
		data = libc.UintptrFromInt32(0)
		/* In that case, don't conceal more than what the ToC says */
		if frame_size < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size {
			v31 = frame_size
		} else {
			v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size
		}
		frame_size = v31
	}
	if data != libc.UintptrFromInt32(0) {
		audiosize = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size
		mode = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fmode
		bandwidth = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fbandwidth
		Opus_ec_dec_init(tls, bp+8, data, libc.Uint32FromInt32(len1))
	} else {
		audiosize = frame_size
		/* Run PLC using last used mode (CELT if we ended with CELT redundancy) */
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0 {
			v31 = int32(MODE_CELT_ONLY)
		} else {
			v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode
		}
		mode = v31
		bandwidth = 0
		if mode == 0 {
			/* If we haven't got any packet yet, all we can do is return zeros */
			i = 0
			for {
				if !(i < audiosize*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = libc.Float32FromInt32(0)
				goto _34
			_34:
				;
				i = i + 1
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _36
			_36:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _38
		_38:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return audiosize
		}
		/* Avoids trying to run the PLC on sizes other than 2.5 (CELT), 5 (CELT),
		   10, or 20 (e.g. 12.5 or 30 ms). */
		if audiosize > F20 {
			for cond := true; cond; cond = audiosize > 0 {
				if audiosize < F20 {
					v31 = audiosize
				} else {
					v31 = F20
				}
				ret = opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm, v31, 0)
				if ret < 0 {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _41
					_41:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _43
				_43:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return ret
				}
				pcm = pcm + uintptr(ret*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*4
				audiosize = audiosize - ret
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _45
			_45:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _47
		_47:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return frame_size
		} else {
			if audiosize < F20 {
				if audiosize > F10 {
					audiosize = F10
				} else {
					if mode != int32(MODE_SILK_ONLY) && audiosize > F5 && audiosize < F10 {
						audiosize = F5
					}
				}
			}
		}
	}
	/* In fixed-point, we can tell CELT to do the accumulation on top of the
	   SILK PCM buffer. This saves some stack space. */
	celt_accum = libc.BoolInt32(mode != int32(MODE_CELT_ONLY))
	pcm_transition_silk_size = ALLOC_NONE
	pcm_transition_celt_size = ALLOC_NONE
	if data != libc.UintptrFromInt32(0) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && (mode == int32(MODE_CELT_ONLY) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_CELT_ONLY) && !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) || mode != int32(MODE_CELT_ONLY) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY)) {
		transition = int32(1)
		/* Decide where to allocate the stack memory for pcm_transition */
		if mode == int32(MODE_CELT_ONLY) {
			pcm_transition_celt_size = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		} else {
			pcm_transition_silk_size = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _51
_51:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _55
_55:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _59
_59:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _61
	_61:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _63
_63:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_transition_celt_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(386))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _67
_67:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_transition_celt_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _71
_71:
	pcm_transition_celt = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_transition_celt_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if transition != 0 && mode == int32(MODE_CELT_ONLY) {
		pcm_transition = pcm_transition_celt
		if F5 < audiosize {
			v31 = F5
		} else {
			v31 = audiosize
		}
		opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm_transition, v31, 0)
	}
	if audiosize > frame_size {
		/*fprintf(stderr, "PCM buffer too small: %d vs %d (mode = %d)\n", audiosize, frame_size, mode);*/
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _74
		_74:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _76
	_76:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	} else {
		frame_size = audiosize
	}
	/* SILK processing */
	if mode != int32(MODE_CELT_ONLY) {
		pcm_silk_size = ALLOC_NONE
		pcm_too_small = libc.BoolInt32(frame_size < F10)
		if pcm_too_small != 0 {
			pcm_silk_size = F10 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _78
		_78:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _80
	_80:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _82
		_82:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v6 = st
		goto _84
	_84:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v8 = libc.Xmalloc(tls, uint64(16))
			goto _86
		_86:
			st = v8
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _88
	_88:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _90
		_90:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _92
	_92:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(412))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _94
		_94:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _96
	_96:
		*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_silk_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _98
		_98:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _100
	_100:
		pcm_silk = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		if pcm_too_small != 0 {
			pcm_ptr = pcm_silk
		} else {
			pcm_ptr = pcm
		}
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) {
			Opus_silk_ResetDecoder(tls, silk_dec)
		}
		/* The SILK PLC cannot produce frames of less than 10 ms */
		if int32(10) > int32(1000)*audiosize/(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs {
			v31 = int32(10)
		} else {
			v31 = int32(1000) * audiosize / (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FpayloadSize_ms = v31
		if data != libc.UintptrFromInt32(0) {
			(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FnChannelsInternal = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels
			if mode == int32(MODE_SILK_ONLY) {
				if bandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
					(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(8000)
				} else {
					if bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
						(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(12000)
					} else {
						if bandwidth == int32(OPUS_BANDWIDTH_WIDEBAND) {
							(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
						} else {
							(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
							if !(libc.Int32FromInt32(0) != 0) {
								Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+57, int32(436))
							}
						}
					}
				}
			} else {
				/* Hybrid mode */
				(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
			}
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.Fenable_deep_plc = libc.BoolInt32((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fcomplexity >= int32(5))
		if data == libc.UintptrFromInt32(0) {
			v31 = int32(1)
		} else {
			v31 = int32(2) * libc.BoolInt32(!!(decode_fec != 0))
		}
		lost_flag = v31
		decoded_samples = 0
		for cond := true; cond; cond = decoded_samples < frame_size {
			/* Call SILK decoder */
			first_frame = libc.BoolInt32(decoded_samples == 0)
			silk_ret = Opus_silk_Decode(tls, silk_dec, st1+16, lost_flag, first_frame, bp+8, pcm_ptr, bp+64, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Farch)
			if silk_ret != 0 {
				if lost_flag != 0 {
					/* PLC failure should not be fatal */
					*(*OpusT_opus_int32)(unsafe.Pointer(bp + 64)) = frame_size
					i = 0
					for {
						if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
							break
						}
						*(*OpusT_opus_res)(unsafe.Pointer(pcm_ptr + uintptr(i)*4)) = libc.Float32FromInt32(0)
						goto _103
					_103:
						;
						i = i + 1
					}
				} else {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _105
					_105:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _107
				_107:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return -int32(3)
				}
			}
			pcm_ptr = pcm_ptr + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 64))*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*4
			decoded_samples = decoded_samples + *(*OpusT_opus_int32)(unsafe.Pointer(bp + 64))
		}
		if pcm_too_small != 0 {
			libc.Xmemcpy(tls, pcm, pcm_silk, libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4)+libc.Uint64FromInt64(0*((int64(pcm)-int64(pcm_silk))/4)))
		}
	}
	start_band = 0
	if v111 = !(decode_fec != 0) && mode != int32(MODE_CELT_ONLY) && data != libc.UintptrFromInt32(0); v111 {
		v1 = bp + 8
		v31 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _110
	_110:
	}
	if v111 && v31+int32(17)+int32(20)*libc.BoolInt32(mode == int32(MODE_HYBRID)) <= int32(8)*len1 {
		/* Check if we have a redundant 0-8 kHz band */
		if mode == int32(MODE_HYBRID) {
			redundancy = Opus_ec_dec_bit_logp(tls, bp+8, uint32(12))
		} else {
			redundancy = int32(1)
		}
		if redundancy != 0 {
			celt_to_silk = Opus_ec_dec_bit_logp(tls, bp+8, uint32(1))
			/* redundancy_bytes will be at least two, in the non-hybrid
			   case due to the ec_tell() check above */
			if mode == int32(MODE_HYBRID) {
				v31 = libc.Int32FromUint32(Opus_ec_dec_uint(tls, bp+8, uint32(256))) + int32(2)
			} else {
				v1 = bp + 8
				v32 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _115
			_115:
				v31 = len1 - (v32+int32(7))>>int32(3)
			}
			redundancy_bytes = v31
			len1 = len1 - redundancy_bytes
			/* This is a sanity check. It should never happen for a valid
			   packet, so the exact behaviour is not normative. */
			v1 = bp + 8
			v31 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _118
		_118:
			if len1*int32(8) < v31 {
				len1 = 0
				redundancy_bytes = 0
				redundancy = 0
			}
			/* Shrink decoder because of raw bits */
			(*(*OpusT_ec_dec)(unsafe.Pointer(bp + 8))).Fstorage -= libc.Uint32FromInt32(redundancy_bytes)
		}
	}
	if mode != int32(MODE_CELT_ONLY) {
		start_band = int32(17)
	}
	if redundancy != 0 {
		transition = 0
		pcm_transition_silk_size = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _120
	_120:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _122
_122:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _126
_126:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _128
	_128:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _130
_130:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _132
	_132:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _134
_134:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_transition_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(538))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _136
	_136:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _138
_138:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_transition_silk_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _140
	_140:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _142
_142:
	pcm_transition_silk = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_transition_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if transition != 0 && mode != int32(MODE_CELT_ONLY) {
		pcm_transition = pcm_transition_silk
		if F5 < audiosize {
			v31 = F5
		} else {
			v31 = audiosize
		}
		opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm_transition, v31, 0)
	}
	if bandwidth != 0 {
		endband = int32(21)
		switch bandwidth {
		case int32(OPUS_BANDWIDTH_NARROWBAND):
			endband = int32(13)
		case int32(OPUS_BANDWIDTH_MEDIUMBAND):
			fallthrough
		case int32(OPUS_BANDWIDTH_WIDEBAND):
			endband = int32(17)
		case int32(OPUS_BANDWIDTH_SUPERWIDEBAND):
			endband = int32(19)
		case int32(OPUS_BANDWIDTH_FULLBAND):
			endband = int32(21)
		default:
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+57, int32(567))
			}
			break
		}
		_ = endband == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_END_BAND_REQUEST), libc.VaList(bp+96, endband)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1037, __ccgo_ts+57, int32(570))
		}
	}
	_ = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels == libc.Int32FromInt32(0)
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_CHANNELS_REQUEST), libc.VaList(bp+96, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1172, __ccgo_ts+57, int32(572))
	}
	/* Only allocation memory for redundancy if/when needed */
	if redundancy != 0 {
		v31 = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
	} else {
		v31 = ALLOC_NONE
	}
	redundant_audio_size = v31
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _146
	_146:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _148
_148:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _150
	_150:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _152
_152:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _154
	_154:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _156
_156:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _158
	_158:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _160
_160:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(redundant_audio_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(576))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _162
	_162:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _164
_164:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(redundant_audio_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _166
	_166:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _168
_168:
	redundant_audio = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(redundant_audio_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* 5 ms redundant frame for CELT->SILK*/
	if redundancy != 0 && celt_to_silk != 0 {
		/* If the previous frame did not use CELT (the first redundancy frame in
		   a transition from SILK may have been lost) then the CELT decoder is
		   stale at this point and the redundancy audio is not useful, however
		   the final range is still needed (for testing), so the redundancy is
		   always decoded but the decoded audio may not be used */
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(586))
		}
		Opus_celt_decode_with_ec(tls, celt_dec, data+uintptr(len1), redundancy_bytes, redundant_audio, F5, libc.UintptrFromInt32(0), 0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, bp+68+uintptr((OpusT___predefined_ptrdiff_t(bp+68)-int64(bp+68))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1454, __ccgo_ts+57, int32(589))
		}
	}
	/* MUST be after PLC */
	_ = start_band == libc.Int32FromInt32(0)
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, start_band)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1599, __ccgo_ts+57, int32(593))
	}
	if mode != int32(MODE_SILK_ONLY) {
		if F20 < frame_size {
			v31 = F20
		} else {
			v31 = frame_size
		}
		celt_frame_size = v31
		/* Make sure to discard any previous CELT state */
		if mode != (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
			if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0) == libc.Int32FromInt32(OPUS_OK)) {
				Opus_celt_fatal(tls, __ccgo_ts+1740, __ccgo_ts+57, int32(604))
			}
		}
		/* Decode CELT */
		if decode_fec != 0 {
			v1 = libc.UintptrFromInt32(0)
		} else {
			v1 = data
		}
		celt_ret = Opus_celt_decode_with_ec_dred(tls, celt_dec, v1, len1, pcm, celt_frame_size, bp+8, celt_accum)
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, st1+96+uintptr((OpusT___predefined_ptrdiff_t(st1+96)-int64(st1+96))/4)*4))
	} else {
		*(*[2]uint8)(unsafe.Pointer(bp + 72)) = [2]uint8{
			0: uint8(0xFF),
			1: uint8(0xFF),
		}
		if !(celt_accum != 0) {
			i = 0
			for {
				if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = libc.Float32FromInt32(0)
				goto _171
			_171:
				;
				i = i + 1
			}
		}
		/* For hybrid -> SILK transitions, we let the CELT MDCT
		   do a fade-out by decoding a silence frame */
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_HYBRID) && !(redundancy != 0 && celt_to_silk != 0 && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
			_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
			if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
				Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(624))
			}
			Opus_celt_decode_with_ec(tls, celt_dec, bp+72, int32(2), pcm, F2_5, libc.UintptrFromInt32(0), celt_accum)
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FrangeFinal = (*(*OpusT_ec_dec)(unsafe.Pointer(bp + 8))).Frng
	}
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+96, bp+80+uintptr((OpusT___predefined_ptrdiff_t(bp+80)-int64(bp+80))/8)*8)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1811, __ccgo_ts+57, int32(632))
	}
	window = (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Fwindow
	/* 5 ms redundant frame for SILK->CELT */
	if redundancy != 0 && !(celt_to_silk != 0) {
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1740, __ccgo_ts+57, int32(639))
		}
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(640))
		}
		Opus_celt_decode_with_ec(tls, celt_dec, data+uintptr(len1), redundancy_bytes, redundant_audio, F5, libc.UintptrFromInt32(0), 0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, bp+68+uintptr((OpusT___predefined_ptrdiff_t(bp+68)-int64(bp+68))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1454, __ccgo_ts+57, int32(643))
		}
		smooth_fade(tls, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*(frame_size-F2_5))*4, redundant_audio+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*(frame_size-F2_5))*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
	}
	/* 5ms redundant frame for CELT->SILK; ignore if the previous frame did not
	   use CELT (the first redundancy frame in a transition from SILK may have
	   been lost) */
	if redundancy != 0 && celt_to_silk != 0 && ((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_SILK_ONLY) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
		c = 0
		for {
			if !(c < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
				break
			}
			i = 0
			for {
				if !(i < F2_5) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*i+c)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(redundant_audio + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*i+c)*4))
				goto _173
			_173:
				;
				i = i + 1
			}
			goto _172
		_172:
			;
			c = c + 1
		}
		smooth_fade(tls, redundant_audio+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
	}
	if transition != 0 {
		if audiosize >= F5 {
			i = 0
			for {
				if !(i < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(pcm_transition + uintptr(i)*4))
				goto _174
			_174:
				;
				i = i + 1
			}
			smooth_fade(tls, pcm_transition+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
		} else {
			/* Not enough time to do a clean transition, but we do it anyway
			   This will not preserve amplitude perfectly and may introduce
			   a bit of temporal aliasing, but it shouldn't be too bad and
			   that's pretty much the best we can do. In any case, generating this
			   transition it pretty silly in the first place */
			smooth_fade(tls, pcm_transition, pcm, pcm, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
		}
	}
	if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fdecode_gain != 0 {
		v175 = float32(libc.Float32FromFloat32(0.000648814081) * float32((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fdecode_gain))
		integer = int32(libc.Xfloor(tls, float64(v175)))
		if integer < -libc.Int32FromInt32(50) {
			v176 = libc.Float32FromInt32(0)
			goto _177
		}
		frac = v175 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v176 = *(*float32)(unsafe.Pointer(bp))
		goto _177
	_177:
		gain = v176
		i = 0
		for {
			if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
				break
			}
			x1 = OpusT_opus_res(*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) * gain)
			*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = x1
			goto _178
		_178:
			;
			i = i + 1
		}
	}
	if len1 <= int32(1) {
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(st1 + 96)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp + 68))
	}
	(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode = mode
	(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy = libc.BoolInt32(redundancy != 0 && !(celt_to_silk != 0))
	if celt_ret >= 0 {
		v31 = 0
		goto _180
	_180:
		if v31 != 0 {
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _182
	_182:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _184
_184:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	if celt_ret < 0 {
		v31 = celt_ret
	} else {
		v31 = audiosize
	}
	return v31
}

func Opus_opus_decode_native(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32, self_delimited int32, packet_offset uintptr, soft_clip int32, dred uintptr, dred_offset OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var count, duration_copy, i, nb_samples, packet_bandwidth, packet_frame_size, packet_mode, packet_stream_channels, pcm_count, ret, ret1, ret2, v1 int32
	var v8 OpusT_opus_val16
	var _ /* iter at bp+120 */ OpusT_OpusExtensionIterator
	var _ /* offset at bp+0 */ int32
	var _ /* padding at bp+104 */ uintptr
	var _ /* padding_len at bp+112 */ OpusT_opus_int32
	var _ /* size at bp+6 */ [48]OpusT_opus_int16
	var _ /* toc at bp+4 */ uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = count, duration_copy, i, nb_samples, packet_bandwidth, packet_frame_size, packet_mode, packet_stream_channels, pcm_count, ret, ret1, ret2, v1, v8
	validate_opus_decoder(tls, st)
	if decode_fec < 0 || decode_fec > int32(1) {
		return -int32(1)
	}
	/* For FEC/PLC, frame_size has to be to have a multiple of 2.5 ms */
	if (decode_fec != 0 || len1 == 0 || data == libc.UintptrFromInt32(0)) && frame_size%((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs/int32(400)) != 0 {
		return -int32(1)
	}
	_ = dred
	_ = dred_offset
	if len1 == 0 || data == libc.UintptrFromInt32(0) {
		pcm_count = 0
		for cond := true; cond; cond = pcm_count < frame_size {
			ret = opus_decode_frame(tls, st, libc.UintptrFromInt32(0), 0, pcm+uintptr(pcm_count*(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels)*4, frame_size-pcm_count, 0)
			if ret < 0 {
				return ret
			}
			pcm_count = pcm_count + ret
		}
		if !(pcm_count == frame_size) {
			Opus_celt_fatal(tls, __ccgo_ts+1955, __ccgo_ts+57, int32(773))
		}
		v1 = 0
		goto _2
	_2:
		if v1 != 0 {
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = pcm_count
		return pcm_count
	} else {
		if len1 < 0 {
			return -int32(1)
		}
	}
	packet_mode = opus_packet_get_mode(tls, data)
	packet_bandwidth = Opus_opus_packet_get_bandwidth(tls, data)
	packet_frame_size = Opus_opus_packet_get_samples_per_frame(tls, data, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs)
	packet_stream_channels = Opus_opus_packet_get_nb_channels(tls, data)
	count = Opus_opus_packet_parse_impl(tls, data, len1, self_delimited, bp+4, libc.UintptrFromInt32(0), bp+6, bp, packet_offset, bp+104, bp+112)
	if (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions != 0 {
		*(*uintptr)(unsafe.Pointer(bp + 104)) = libc.UintptrFromInt32(0)
		*(*OpusT_opus_int32)(unsafe.Pointer(bp + 112)) = 0
	}
	if count < 0 {
		return count
	}
	Opus_opus_extension_iterator_init(tls, bp+120, *(*uintptr)(unsafe.Pointer(bp + 104)), *(*OpusT_opus_int32)(unsafe.Pointer(bp + 112)), count)
	data = data + uintptr(*(*int32)(unsafe.Pointer(bp)))
	if decode_fec != 0 {
		/* If no FEC can be present, run the PLC (recursive call) */
		if frame_size < packet_frame_size || packet_mode == int32(MODE_CELT_ONLY) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode == int32(MODE_CELT_ONLY) {
			return Opus_opus_decode_native(tls, st, libc.UintptrFromInt32(0), 0, pcm, frame_size, 0, 0, libc.UintptrFromInt32(0), soft_clip, libc.UintptrFromInt32(0), 0)
		}
		/* Otherwise, run the PLC on everything except the size for which we might have FEC */
		duration_copy = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration
		if frame_size-packet_frame_size != 0 {
			ret1 = Opus_opus_decode_native(tls, st, libc.UintptrFromInt32(0), 0, pcm, frame_size-packet_frame_size, 0, 0, libc.UintptrFromInt32(0), soft_clip, libc.UintptrFromInt32(0), 0)
			if ret1 < 0 {
				(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = duration_copy
				return ret1
			}
			if !(ret1 == frame_size-packet_frame_size) {
				Opus_celt_fatal(tls, __ccgo_ts+1997, __ccgo_ts+57, int32(815))
			}
		}
		/* Complete with FEC */
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode = packet_mode
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth = packet_bandwidth
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = packet_frame_size
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = packet_stream_channels
		ret1 = opus_decode_frame(tls, st, data, int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[0]), pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels*(frame_size-packet_frame_size))*4, packet_frame_size, int32(1))
		if ret1 < 0 {
			return ret1
		} else {
			v1 = 0
			goto _4
		_4:
			if v1 != 0 {
			}
			(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = frame_size
			return frame_size
		}
	}
	if count*packet_frame_size > frame_size {
		return -int32(2)
	}
	/* Update the state as the last step to avoid updating it on an invalid packet */
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode = packet_mode
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth = packet_bandwidth
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = packet_frame_size
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = packet_stream_channels
	nb_samples = 0
	i = 0
	for {
		if !(i < count) {
			break
		}
		ret2 = opus_decode_frame(tls, st, data, int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[i]), pcm+uintptr(nb_samples*(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels)*4, frame_size-nb_samples, 0)
		if ret2 < 0 {
			return ret2
		}
		if !(ret2 == packet_frame_size) {
			Opus_celt_fatal(tls, __ccgo_ts+2049, __ccgo_ts+57, int32(865))
		}
		data = data + uintptr((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[i])
		nb_samples = nb_samples + ret2
		goto _5
	_5:
		;
		i = i + 1
	}
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = nb_samples
	v1 = 0
	goto _7
_7:
	if v1 != 0 {
	}
	if soft_clip != 0 {
		Opus_opus_pcm_soft_clip_impl(tls, pcm, nb_samples, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels, st+88, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch)
	} else {
		v8 = libc.Float32FromInt32(0)
		*(*OpusT_opus_val16)(unsafe.Pointer(st + 88 + 1*4)) = v8
		*(*OpusT_opus_val16)(unsafe.Pointer(st + 88)) = v8
	}
	return nb_samples
}

func Opus_opus_decode(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	var _saved_stack, out, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var nb_samples, ret, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, nb_samples, out, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if data != libc.UintptrFromInt32(0) && len1 > 0 && !(decode_fec != 0) {
		nb_samples = Opus_opus_decoder_get_nb_samples(tls, st1, data, len1)
		if nb_samples > 0 {
			if frame_size < nb_samples {
				v31 = frame_size
			} else {
				v31 = nb_samples
			}
			frame_size = v31
		} else {
			return -int32(4)
		}
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(917))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(918))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	out = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	ret = Opus_opus_decode_native(tls, st1, data, len1, out, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), int32(OPTIONAL_CLIP), libc.UintptrFromInt32(0), 0)
	if ret > 0 {
		_ = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Farch
		Opus_celt_float2int16_c(tls, out, pcm, ret*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _59
_59:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_decode24(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	var _saved_stack, out, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var i, nb_samples, ret, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, i, nb_samples, out, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if data != libc.UintptrFromInt32(0) && len1 > 0 && !(decode_fec != 0) {
		nb_samples = Opus_opus_decoder_get_nb_samples(tls, st1, data, len1)
		if nb_samples > 0 {
			if frame_size < nb_samples {
				v31 = frame_size
			} else {
				v31 = nb_samples
			}
			frame_size = v31
		} else {
			return -int32(4)
		}
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(966))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(967))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	out = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	ret = Opus_opus_decode_native(tls, st1, data, len1, out, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), 0, libc.UintptrFromInt32(0), 0)
	if ret > 0 {
		nb_samples = ret * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		i = 0
		for {
			if !(i < nb_samples) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(pcm + uintptr(i)*4)) = int32(libc.Xlrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i)*4)))))
			goto _56
		_56:
			;
			i = i + 1
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _60
_60:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	if frame_size <= 0 {
		return -int32(1)
	}
	return Opus_opus_decode_native(tls, st, data, len1, pcm, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), 0, libc.UintptrFromInt32(0), 0)
}

func Opus_opus_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap OpusT_va_list
	var celt_dec, silk_dec, value, value10, value12, value2, value3, value4, value5, value6, value8 uintptr
	var ret int32
	var value1, value11, value7, value9 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, celt_dec, ret, silk_dec, value, value1, value10, value11, value12, value2, value3, value4, value5, value6, value7, value8, value9
	ret = OPUS_OK
	silk_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset)
	celt_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset)
	ap = va
	switch request {
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		value = libc.VaUintptr(&ap)
		if !(value != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value1 = libc.VaInt32(&ap)
		if value1 < 0 || value1 > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity = value1
		_ = value1 == libc.Int32FromInt32(0)
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_SET_COMPLEXITY_REQUEST), libc.VaList(bp+8, value1))
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		value2 = libc.VaUintptr(&ap)
		if !(value2 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value2)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value3 = libc.VaUintptr(&ap)
		if !(value3 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value3)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FrangeFinal
	case int32(OPUS_RESET_STATE):
		libc.Xmemset(tls, st+60, 0, (uint64(100)-libc.Uint64FromInt64(int64(st+60)-int64(st)))*uint64(1))
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0)
		Opus_silk_ResetDecoder(tls, silk_dec)
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs / int32(400)
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		value4 = libc.VaUintptr(&ap)
		if !(value4 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value4)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs
	case int32(OPUS_GET_PITCH_REQUEST):
		value5 = libc.VaUintptr(&ap)
		if !(value5 != 0) {
			goto bad_arg
		}
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fprev_mode == int32(MODE_CELT_ONLY) {
			ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_PITCH_REQUEST), libc.VaList(bp+8, value5+uintptr((int64(value5)-int64(value5))/4)*4))
		} else {
			*(*OpusT_opus_int32)(unsafe.Pointer(value5)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FprevPitchLag
		}
	case int32(OPUS_GET_GAIN_REQUEST):
		value6 = libc.VaUintptr(&ap)
		if !(value6 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value6)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fdecode_gain
	case int32(OPUS_SET_GAIN_REQUEST):
		value7 = libc.VaInt32(&ap)
		if value7 < -int32(32768) || value7 > int32(32767) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fdecode_gain = value7
	case int32(OPUS_GET_LAST_PACKET_DURATION_REQUEST):
		value8 = libc.VaUintptr(&ap)
		if !(value8 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value8)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value9 = libc.VaInt32(&ap)
		if value9 < 0 || value9 > int32(1) {
			goto bad_arg
		}
		_ = value9 == libc.Int32FromInt32(0)
		ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+8, value9))
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value10 = libc.VaUintptr(&ap)
		if !(value10 != 0) {
			goto bad_arg
		}
		ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+8, value10+uintptr((int64(value10)-int64(value10))/4)*4))
	case int32(OPUS_SET_IGNORE_EXTENSIONS_REQUEST):
		value11 = libc.VaInt32(&ap)
		if value11 < 0 || value11 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions = value11
	case int32(OPUS_GET_IGNORE_EXTENSIONS_REQUEST):
		value12 = libc.VaUintptr(&ap)
		if !(value12 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value12)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions
	default:
		/*fprintf(stderr, "unknown opus_decoder_ctl() request: %d", request);*/
		ret = -int32(5)
		break
	}
	_ = ap
	return ret
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
}

func Opus_opus_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

func Opus_opus_packet_get_bandwidth(tls *libc.TLS, data uintptr) (r int32) {
	var bandwidth, v1 int32
	_, _ = bandwidth, v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		bandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))>>int32(5)&int32(0x3)
		if bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
			bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
		}
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x10) != 0 {
				v1 = int32(OPUS_BANDWIDTH_FULLBAND)
			} else {
				v1 = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
			}
			bandwidth = v1
		} else {
			bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))>>int32(5)&int32(0x3)
		}
	}
	return bandwidth
}

func Opus_opus_packet_get_nb_channels(tls *libc.TLS, data uintptr) (r int32) {
	var v1 int32
	_ = v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x4) != 0 {
		v1 = int32(2)
	} else {
		v1 = int32(1)
	}
	return v1
}

func Opus_opus_packet_get_nb_frames(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	var count int32
	_ = count
	if len1 < int32(1) {
		return -int32(1)
	}
	count = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(packet))) & int32(0x3)
	if count == 0 {
		return int32(1)
	} else {
		if count != int32(3) {
			return int32(2)
		} else {
			if len1 < int32(2) {
				return -int32(4)
			} else {
				return libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(packet + 1))) & int32(0x3F)
			}
		}
	}
	return r
}

func Opus_opus_packet_get_nb_samples(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32, Fs OpusT_opus_int32) (r int32) {
	var count, samples int32
	_, _ = count, samples
	count = Opus_opus_packet_get_nb_frames(tls, packet, len1)
	if count < 0 {
		return count
	}
	samples = count * Opus_opus_packet_get_samples_per_frame(tls, packet, Fs)
	/* Can't have more than 120 ms */
	if samples*int32(25) > Fs*int32(3) {
		return -int32(4)
	} else {
		return samples
	}
	return r
}

func Opus_opus_packet_has_lbrr(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(480)
	defer tls.Free(480)
	var lbrr, nb_frames, packet_frame_size, packet_mode, packet_stream_channels, ret int32
	var _ /* frames at bp+0 */ [48]uintptr
	var _ /* size at bp+384 */ [48]OpusT_opus_int16
	_, _, _, _, _, _ = lbrr, nb_frames, packet_frame_size, packet_mode, packet_stream_channels, ret
	nb_frames = int32(1)
	packet_mode = opus_packet_get_mode(tls, packet)
	if packet_mode == int32(MODE_CELT_ONLY) {
		return 0
	}
	packet_frame_size = Opus_opus_packet_get_samples_per_frame(tls, packet, int32(48000))
	if packet_frame_size > int32(960) {
		nb_frames = packet_frame_size / int32(960)
	}
	packet_stream_channels = Opus_opus_packet_get_nb_channels(tls, packet)
	ret = Opus_opus_packet_parse(tls, packet, len1, libc.UintptrFromInt32(0), bp, bp+384, libc.UintptrFromInt32(0))
	if ret <= 0 {
		return ret
	}
	if int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 384)))[0]) == 0 {
		return 0
	}
	lbrr = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*(*[48]uintptr)(unsafe.Pointer(bp)))[0]))) >> (int32(7) - nb_frames) & int32(0x1)
	if packet_stream_channels == int32(2) {
		lbrr = libc.BoolInt32(lbrr != 0 || libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*(*[48]uintptr)(unsafe.Pointer(bp)))[0])))>>(int32(6)-int32(2)*nb_frames)&int32(0x1) != 0)
	}
	return lbrr
}

func Opus_opus_decoder_get_nb_samples(tls *libc.TLS, dec uintptr, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	return Opus_opus_packet_get_nb_samples(tls, packet, len1, (*OpusT_OpusDecoder)(unsafe.Pointer(dec)).FFs)
}

type OpusDREDDecoder = struct {
	Floaded int32
	Farch   int32
	Fmagic  OpusT_opus_uint32
}

func Opus_opus_dred_decoder_get_size(tls *libc.TLS) (r int32) {
	return int32(12)
}

func Opus_opus_dred_decoder_init(tls *libc.TLS, dec uintptr) (r int32) {
	var ret, v1 int32
	_, _ = ret, v1
	ret = 0
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Floaded = 0
	v1 = 0
	goto _2
_2:
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Farch = v1
	/* To make sure nobody forgets to init, use a magic number. */
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Fmagic = uint32(0xD8EDDEC0)
	if ret == 0 {
		v1 = OPUS_OK
	} else {
		v1 = -int32(5)
	}
	return v1
}

func Opus_opus_dred_decoder_create(tls *libc.TLS, error1 uintptr) (r uintptr) {
	var dec, v1 uintptr
	var ret int32
	_, _, _ = dec, ret, v1
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_dred_decoder_get_size(tls)))
	goto _2
_2:
	dec = v1
	if dec == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_dred_decoder_init(tls, dec)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, dec)
		dec = libc.UintptrFromInt32(0)
	}
	return dec
}

func Opus_opus_dred_decoder_destroy(tls *libc.TLS, dec uintptr) {
	if dec != 0 {
		(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Fmagic = uint32(0xDE57801D)
	}
	libc.Xfree(tls, dec)
}

func Opus_opus_dred_decoder_ctl(tls *libc.TLS, dred_dec uintptr, request int32, va uintptr) (r int32) {
	_ = dred_dec
	_ = request
	return -int32(5)
}

func Opus_opus_dred_get_size(tls *libc.TLS) (r int32) {
	return 0
}

func Opus_opus_dred_alloc(tls *libc.TLS, error1 uintptr) (r uintptr) {
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = -int32(5)
	}
	return libc.UintptrFromInt32(0)
}

func Opus_opus_dred_free(tls *libc.TLS, dec uintptr) {
	_ = dec
}

func Opus_opus_dred_parse(tls *libc.TLS, dred_dec uintptr, dred uintptr, data uintptr, len1 OpusT_opus_int32, max_dred_samples OpusT_opus_int32, sampling_rate OpusT_opus_int32, dred_end uintptr, defer_processing int32) (r int32) {
	_ = dred_dec
	_ = dred
	_ = data
	_ = len1
	_ = max_dred_samples
	_ = sampling_rate
	_ = defer_processing
	_ = dred_end
	return -int32(5)
}

func Opus_opus_dred_process(tls *libc.TLS, dred_dec uintptr, src uintptr, dst uintptr) (r int32) {
	_ = dred_dec
	_ = src
	_ = dst
	return -int32(5)
}

func Opus_opus_decoder_dred_decode(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

func Opus_opus_decoder_dred_decode24(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

func Opus_opus_decoder_dred_decode_float(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

const COEF_ONE2 = "1.0f"
const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST = 5122
const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST = 5120

type OpusT_OpusMSEncoder = struct {
	Flayout            OpusT_ChannelLayout
	Farch              int32
	Flfe_stream        int32
	Fapplication       int32
	FFs                OpusT_opus_int32
	Fvariable_duration int32
	Fmapping_type      OpusT_MappingType
	Fbitrate_bps       OpusT_opus_int32
}

type OpusT_OpusMSDecoder = struct {
	Flayout OpusT_ChannelLayout
}

var trim_icdf2 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf2 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf2 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

func Opus_validate_layout(tls *libc.TLS, layout uintptr) (r int32) {
	var i, max_channel int32
	_, _ = i, max_channel
	max_channel = (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_streams + (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_coupled_streams
	if max_channel > int32(255) {
		return 0
	}
	i = 0
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) >= max_channel && libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) != int32(255) {
			return 0
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	return int32(1)
}

func Opus_get_left_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id*int32(2) {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

func Opus_get_right_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id*int32(2)+int32(1) {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

func Opus_get_mono_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id+(*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_coupled_streams {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

var trim_icdf3 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf3 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf3 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

/* DECODER */

func validate_ms_decoder(tls *libc.TLS, st uintptr) {
	Opus_validate_layout(tls, st)
}

func Opus_opus_multistream_decoder_get_size(tls *libc.TLS, nb_streams int32, nb_coupled_streams int32) (r OpusT_opus_int32) {
	var alignment uint32
	var coupled_size, mono_size, v1, v3, v5 int32
	_, _, _, _, _, _ = alignment, coupled_size, mono_size, v1, v3, v5
	if nb_streams < int32(1) || nb_coupled_streams > nb_streams || nb_coupled_streams < 0 {
		return 0
	}
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v5 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
	goto _6
_6:
	return v1 + nb_coupled_streams*v3 + (nb_streams-nb_coupled_streams)*v5
}

func Opus_opus_multistream_decoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr) (r int32) {
	var alignment uint32
	var coupled_size, i1, mono_size, ret, v2 int32
	var ptr uintptr
	_, _, _, _, _, _, _ = alignment, coupled_size, i1, mono_size, ptr, ret, v2
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams {
		return -int32(1)
	}
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_channels = channels
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams = streams
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams = coupled_streams
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_channels) {
			break
		}
		*(*uint8)(unsafe.Pointer(st + 12 + uintptr(i1))) = *(*uint8)(unsafe.Pointer(mapping + uintptr(i1)))
		goto _1
	_1:
		;
		i1 = i1 + 1
	}
	if !(Opus_validate_layout(tls, st) != 0) {
		return -int32(1)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v2 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _3
_3:
	ptr = st + uintptr(v2)
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams) {
			break
		}
		ret = Opus_opus_decoder_init(tls, ptr, Fs, int32(2))
		if ret != OPUS_OK {
			return ret
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v2 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
		goto _6
	_6:
		ptr = ptr + uintptr(v2)
		goto _4
	_4:
		;
		i1 = i1 + 1
	}
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		ret = Opus_opus_decoder_init(tls, ptr, Fs, int32(1))
		if ret != OPUS_OK {
			return ret
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v2 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
		goto _9
	_9:
		ptr = ptr + uintptr(v2)
		goto _7
	_7:
		;
		i1 = i1 + 1
	}
	return OPUS_OK
}

func Opus_opus_multistream_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr, error1 uintptr) (r uintptr) {
	var ret int32
	var st, v1 uintptr
	_, _, _ = ret, st, v1
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_multistream_decoder_get_size(tls, streams, coupled_streams)))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_multistream_decoder_init(tls, st, Fs, channels, streams, coupled_streams, mapping)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	return st
}

func opus_multistream_packet_validate(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_streams int32, Fs OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count, s, samples, tmp_samples int32
	var _ /* packet_offset at bp+100 */ OpusT_opus_int32
	var _ /* size at bp+2 */ [48]OpusT_opus_int16
	var _ /* toc at bp+0 */ uint8
	_, _, _, _ = count, s, samples, tmp_samples
	samples = 0
	s = 0
	for {
		if !(s < nb_streams) {
			break
		}
		if len1 <= 0 {
			return -int32(4)
		}
		count = Opus_opus_packet_parse_impl(tls, data, len1, libc.BoolInt32(s != nb_streams-int32(1)), bp, libc.UintptrFromInt32(0), bp+2, libc.UintptrFromInt32(0), bp+100, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
		if count < 0 {
			return count
		}
		tmp_samples = Opus_opus_packet_get_nb_samples(tls, data, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)), Fs)
		if s != 0 && samples != tmp_samples {
			return -int32(4)
		}
		samples = tmp_samples
		data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)))
		len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100))
		goto _1
	_1:
		;
		s = s + 1
	}
	return samples
}

type OpusT___ccgo_fp__Xopus_multistream_decode_native_4 = func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr)

func Opus_opus_multistream_decode_native(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, __ccgo_fp_copy_channel_out OpusT_opus_copy_channel_out_func, frame_size int32, decode_fec int32, soft_clip int32, user_data uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _saved_stack, buf, dec, ptr, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var alignment uint32
	var c, chan1, chan11, coupled_size, do_plc, mono_size, prev, prev1, ret, ret1, s, v31, v56, v75 int32
	var _ /* Fs at bp+0 */ OpusT_opus_int32
	var _ /* packet_offset at bp+4 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, alignment, buf, c, chan1, chan11, coupled_size, dec, do_plc, mono_size, prev, prev1, ptr, ret, ret1, s, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v56, v6, v75, v8
	do_plc = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	validate_ms_decoder(tls, st1)
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Limit frame_size to avoid excessive stack allocations. */
	if !(Opus_opus_multistream_decoder_ctl(tls, st1, int32(OPUS_GET_SAMPLE_RATE_REQUEST), libc.VaList(bp+16, bp+uintptr((OpusT___predefined_ptrdiff_t(bp)-int64(bp))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+2090, __ccgo_ts+2200, int32(206))
	}
	if frame_size < *(*OpusT_opus_int32)(unsafe.Pointer(bp))/int32(25)*int32(3) {
		v31 = frame_size
	} else {
		v31 = *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / int32(25) * int32(3)
	}
	frame_size = v31
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2200, int32(208))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v31 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _57
_57:
	ptr = st1 + uintptr(v31)
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	if len1 == 0 {
		do_plc = int32(1)
	}
	if len1 < 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _59
		_59:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _61
	_61:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if !(do_plc != 0) && len1 < int32(2)*(*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _63
		_63:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _65
	_65:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(4)
	}
	if !(do_plc != 0) {
		ret = opus_multistream_packet_validate(tls, data, len1, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams, *(*OpusT_opus_int32)(unsafe.Pointer(bp)))
		if ret < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _67
			_67:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _69
		_69:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return ret
		} else {
			if ret > frame_size {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _71
				_71:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _73
			_73:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(2)
			}
		}
	}
	s = 0
	for {
		if !(s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams) {
			break
		}
		dec = ptr
		if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v56 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _77
		_77:
			v31 = v56
		} else {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v75 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _79
		_79:
			v31 = v75
		}
		ptr = ptr + uintptr(v31)
		if !(do_plc != 0) && len1 <= 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _81
			_81:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _83
		_83:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = 0
		ret1 = Opus_opus_decode_native(tls, dec, data, len1, buf, frame_size, decode_fec, libc.BoolInt32(s != (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1)), bp+4, soft_clip, libc.UintptrFromInt32(0), 0)
		if !(do_plc != 0) {
			data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
			len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))
		}
		if ret1 <= 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _85
			_85:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _87
		_87:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return ret1
		}
		frame_size = ret1
		if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			prev = -int32(1)
			/* Copy "left" audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_left_channel(tls, st1, s, prev)
				chan1 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan1, buf, int32(2), frame_size, user_data)
				prev = chan1
			}
			prev = -int32(1)
			/* Copy "right" audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_right_channel(tls, st1, s, prev)
				chan1 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan1, buf+uintptr(1)*4, int32(2), frame_size, user_data)
				prev = chan1
			}
		} else {
			prev1 = -int32(1)
			/* Copy audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_mono_channel(tls, st1, s, prev1)
				chan11 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan11, buf, int32(1), frame_size, user_data)
				prev1 = chan11
			}
		}
		goto _74
	_74:
		;
		s = s + 1
	}
	/* Handle muted channels */
	c = 0
	for {
		if !(c < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(st1 + 12 + uintptr(c)))) == int32(255) {
			(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, c, libc.UintptrFromInt32(0), 0, frame_size, user_data)
		}
		goto _91
	_91:
		;
		c = c + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _93
	_93:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _95
_95:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return frame_size
}

func opus_copy_channel_out_float(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var float_dst uintptr
	var i OpusT_opus_int32
	_, _ = float_dst, i
	_ = user_data
	float_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*float32)(unsafe.Pointer(float_dst + uintptr(i*dst_stride+dst_channel)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4))
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*float32)(unsafe.Pointer(float_dst + uintptr(i*dst_stride+dst_channel)*4)) = libc.Float32FromInt32(0)
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func opus_copy_channel_out_short(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_dst uintptr
	var v2, v3, v4 float32
	var v5 OpusT_opus_int16
	_, _, _, _, _, _ = i, short_dst, v2, v3, v4, v5
	_ = user_data
	short_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			v2 = *(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4))
			v2 = float32(v2 * libc.Float32FromFloat32(32768))
			if v2 > float32(-libc.Int32FromInt32(32768)) {
				v3 = v2
			} else {
				v3 = float32(-libc.Int32FromInt32(32768))
			}
			v2 = v3
			if v2 < float32(libc.Int32FromInt32(32767)) {
				v4 = v2
			} else {
				v4 = float32(libc.Int32FromInt32(32767))
			}
			v2 = v4
			v5 = int16(libc.Xlrintf(tls, v2))
			goto _6
		_6:
			*(*OpusT_opus_int16)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*2)) = v5
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*2)) = 0
			goto _7
		_7:
			;
			i = i + 1
		}
	}
}

func opus_copy_channel_out_int24(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_dst uintptr
	_, _ = i, short_dst
	_ = user_data
	short_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*4)) = int32(libc.Xlrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4)))))
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*4)) = 0
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func Opus_opus_multistream_decode(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_short), frame_size, decode_fec, int32(OPTIONAL_CLIP), libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decode24(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_int24), frame_size, decode_fec, 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_float), frame_size, decode_fec, 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decoder_ctl_va_list(tls *libc.TLS, st uintptr, request int32, ap OpusT_va_list) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var coupled_size, mono_size, ret, s, s1, s2, s3, v1 int32
	var dec, dec1, dec2, dec3, ptr, value, value1, value2 uintptr
	var stream_id, value3 OpusT_opus_int32
	var _ /* tmp at bp+0 */ OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alignment, coupled_size, dec, dec1, dec2, dec3, mono_size, ptr, ret, s, s1, s2, s3, stream_id, value, value1, value2, value3, v1
	ret = OPUS_OK
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	switch request {
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		fallthrough
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		fallthrough
	case int32(OPUS_GET_GAIN_REQUEST):
		fallthrough
	case int32(OPUS_GET_LAST_PACKET_DURATION_REQUEST):
		fallthrough
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		/* For int32* GET params, just query the first stream */
		value = libc.VaUintptr(&ap)
		dec = ptr
		ret = Opus_opus_decoder_ctl(tls, dec, request, libc.VaList(bp+16, value))
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value1)) = uint32(0)
		s = 0
		for {
			if !(s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec1 = ptr
			if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _5
			_5:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _7
			_7:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec1, request, libc.VaList(bp+16, bp))
			if ret != OPUS_OK {
				break
			}
			*(*OpusT_opus_uint32)(unsafe.Pointer(value1)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp))
			goto _3
		_3:
			;
			s = s + 1
		}
	case int32(OPUS_RESET_STATE):
		s1 = 0
		for {
			if !(s1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec2 = ptr
			if s1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _10
			_10:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _12
			_12:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec2, int32(OPUS_RESET_STATE), 0)
			if ret != OPUS_OK {
				break
			}
			goto _8
		_8:
			;
			s1 = s1 + 1
		}
	case int32(OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST):
		stream_id = libc.VaInt32(&ap)
		if stream_id < 0 || stream_id >= (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams {
			goto bad_arg
		}
		value2 = libc.VaUintptr(&ap)
		if !(value2 != 0) {
			goto bad_arg
		}
		s2 = 0
		for {
			if !(s2 < stream_id) {
				break
			}
			if s2 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _15
			_15:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _17
			_17:
				ptr = ptr + uintptr(v1)
			}
			goto _13
		_13:
			;
			s2 = s2 + 1
		}
		*(*uintptr)(unsafe.Pointer(value2)) = ptr
	case int32(OPUS_SET_GAIN_REQUEST):
		fallthrough
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		fallthrough
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		/* This works for int32 params */
		value3 = libc.VaInt32(&ap)
		s3 = 0
		for {
			if !(s3 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec3 = ptr
			if s3 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _20
			_20:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _22
			_22:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec3, request, libc.VaList(bp+16, value3))
			if ret != OPUS_OK {
				break
			}
			goto _18
		_18:
			;
			s3 = s3 + 1
		}
	default:
		ret = -int32(5)
		break
	}
	return ret
	goto bad_arg
bad_arg:
	;
	return -int32(1)
	return r
}

func Opus_opus_multistream_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Opus_opus_multistream_decoder_ctl_va_list(tls, st, request, ap)
	_ = ap
	return ret
}

func Opus_opus_multistream_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

const OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST = 6001
const OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST = 6005
const OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST = 6003

var trim_icdf4 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf4 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf4 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_MappingMatrix = struct {
	Frows int32
	Fcols int32
	Fgain int32
}

func Opus_mapping_matrix_get_size(tls *libc.TLS, rows int32, cols int32) (r OpusT_opus_int32) {
	var alignment uint32
	var size OpusT_opus_int32
	var v1, v3 int32
	_, _, _, _ = alignment, size, v1, v3
	/* Mapping Matrix must only support up to 255 channels in or out.
	 * Additionally, the total cell count must be <= 65004 octets in order
	 * for the matrix to be stored in an OGG header.
	 */
	if rows > int32(255) || cols > int32(255) {
		return 0
	}
	size = libc.Int32FromUint64(libc.Uint64FromInt32(rows*cols) * uint64(2))
	if size > int32(65004) {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(12)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(size) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	return v1 + v3
}

func Opus_mapping_matrix_get_data(tls *libc.TLS, matrix uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(12)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return matrix + uintptr(v1)
}

func Opus_mapping_matrix_init(tls *libc.TLS, matrix uintptr, rows int32, cols int32, gain int32, data uintptr, data_size OpusT_opus_int32) {
	var alignment uint32
	var i1, v1, v3 int32
	var ptr uintptr
	_, _, _, _, _ = alignment, i1, ptr, v1, v3
	_ = data_size
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(data_size) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(libc.Uint64FromInt32(rows*cols)*uint64(2))) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	if !(v1 == v3) {
		Opus_celt_fatal(tls, __ccgo_ts+2234, __ccgo_ts+2312, int32(72))
	}
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows = rows
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols = cols
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fgain = gain
	ptr = Opus_mapping_matrix_get_data(tls, matrix)
	i1 = 0
	for {
		if !(i1 < rows*cols) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(ptr + uintptr(i1)*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(data + uintptr(i1)*2))
		goto _5
	_5:
		;
		i1 = i1 + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_float(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp float32
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(98))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))**(*float32)(unsafe.Pointer(input + uintptr(input_rows*i+col)*4)))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_out_float(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample, tmp float32
	var matrix_data uintptr
	_, _, _, _, _ = i, input_sample, matrix_data, row, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(130))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		input_sample = *(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4))
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = float32(float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2)))) * input_sample)
			*(*float32)(unsafe.Pointer(output + uintptr(output_rows*i+row)*4)) += tmp
			goto _2
		_2:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_short(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp OpusT_opus_val32
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(161))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + OpusT_opus_val32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(input + uintptr(input_rows*i+col)*2))))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = OpusT_opus_res(libc.Float32FromInt32(1) / float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(32768)) * tmp)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_out_short(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample, tmp OpusT_opus_int32
	var matrix_data, v8 uintptr
	var v2, v3, v4 float32
	var v5 OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _ = i, input_sample, matrix_data, row, tmp, v2, v3, v4, v5, v8
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(206))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		v2 = *(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4))
		v2 = float32(v2 * libc.Float32FromFloat32(32768))
		if v2 > float32(-libc.Int32FromInt32(32768)) {
			v3 = v2
		} else {
			v3 = float32(-libc.Int32FromInt32(32768))
		}
		v2 = v3
		if v2 < float32(libc.Int32FromInt32(32767)) {
			v4 = v2
		} else {
			v4 = float32(libc.Int32FromInt32(32767))
		}
		v2 = v4
		v5 = int16(libc.Xlrintf(tls, v2))
		goto _6
	_6:
		input_sample = int32(v5)
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = int32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2))) * input_sample
			v8 = output + uintptr(output_rows*i+row)*2
			*(*OpusT_opus_int16)(unsafe.Pointer(v8)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v8))) + (tmp+libc.Int32FromInt32(16384))>>libc.Int32FromInt32(15))
			goto _7
		_7:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_int24(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp OpusT_opus_val64
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(236))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + OpusT_opus_val64(float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))*float32(*(*OpusT_opus_int32)(unsafe.Pointer(input + uintptr(input_rows*i+col)*4))))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = float32(libc.Float32FromFloat32(1) / libc.Float32FromFloat32(32768) / libc.Float32FromFloat32(256) * float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*tmp))
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_out_int24(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample OpusT_opus_int32
	var matrix_data, v3 uintptr
	var tmp OpusT_opus_int64
	_, _, _, _, _, _ = i, input_sample, matrix_data, row, tmp, v3
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+2336, __ccgo_ts+2312, int32(271))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		input_sample = int32(libc.Xlrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4)))))
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = int64(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2))) * int64(input_sample)
			v3 = output + uintptr(output_rows*i+row)*4
			*(*OpusT_opus_int32)(unsafe.Pointer(v3)) = OpusT_opus_int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(v3))) + (tmp+libc.Int64FromInt32(16384))>>libc.Int32FromInt32(15))
			goto _2
		_2:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

const CELT_SIG_SCALE2 = "32768.f"

var log2_x_norm_coeff2 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff2 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf5 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf5 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf5 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusProjectionDecoder = struct {
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

type OpusProjectionDecoder = struct {
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

func opus_projection_copy_channel_out_float(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var float_dst, matrix uintptr
	_, _ = float_dst, matrix
	float_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, float_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(4))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_float(tls, matrix, src, dst_channel, src_stride, float_dst, dst_stride, frame_size)
	}
}

func opus_projection_copy_channel_out_short(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var matrix, short_dst uintptr
	_, _ = matrix, short_dst
	short_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, short_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(2))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_short(tls, matrix, src, dst_channel, src_stride, short_dst, dst_stride, frame_size)
	}
}

func opus_projection_copy_channel_out_int24(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var matrix, short_dst uintptr
	_, _ = matrix, short_dst
	short_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, short_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(4))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_int24(tls, matrix, src, dst_channel, src_stride, short_dst, dst_stride, frame_size)
	}
}

func get_dec_demixing_matrix(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(4)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_multistream_decoder(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(uint64(4)+libc.Uint64FromInt32((*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st)).Fdemixing_matrix_size_in_bytes))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func Opus_opus_projection_decoder_get_size(tls *libc.TLS, channels int32, streams int32, coupled_streams int32) (r OpusT_opus_int32) {
	var alignment uint32
	var decoder_size, matrix_size OpusT_opus_int32
	var v1 int32
	_, _, _, _ = alignment, decoder_size, matrix_size, v1
	matrix_size = Opus_mapping_matrix_get_size(tls, streams+coupled_streams, channels)
	if !(matrix_size != 0) {
		return 0
	}
	decoder_size = Opus_opus_multistream_decoder_get_size(tls, streams, coupled_streams)
	if !(decoder_size != 0) {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(4)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return v1 + matrix_size + decoder_size
}

func Opus_opus_projection_decoder_init(tls *libc.TLS, st1 uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, demixing_matrix uintptr, demixing_matrix_size OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var _saved_stack, buf, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var expected_matrix_size OpusT_opus_int32
	var i, nb_input_streams, ret, s int32
	var _ /* mapping at bp+0 */ [255]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, buf, expected_matrix_size, i, nb_input_streams, ret, s, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Verify supplied matrix size. */
	nb_input_streams = streams + coupled_streams
	expected_matrix_size = libc.Int32FromUint64(libc.Uint64FromInt32(nb_input_streams*channels) * uint64(2))
	if expected_matrix_size != demixing_matrix_size {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Convert demixing matrix input into internal format. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nb_input_streams*channels)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2412, int32(167))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nb_input_streams*channels) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _54
_54:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nb_input_streams*channels)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < nb_input_streams*channels) {
			break
		}
		s = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(demixing_matrix + uintptr(int32(2)*i+int32(1)))))<<int32(8) | libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(demixing_matrix + uintptr(int32(2)*i))))
		s = s&int32(0xFFFF) ^ int32(0x8000) - int32(0x8000)
		*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(i)*2)) = int16(s)
		goto _55
	_55:
		;
		i = i + 1
	}
	/* Assign demixing matrix. */
	(*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st1)).Fdemixing_matrix_size_in_bytes = Opus_mapping_matrix_get_size(tls, channels, nb_input_streams)
	if !((*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st1)).Fdemixing_matrix_size_in_bytes != 0) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _57
		_57:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _59
	_59:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	Opus_mapping_matrix_init(tls, get_dec_demixing_matrix(tls, st1), channels, nb_input_streams, 0, buf, demixing_matrix_size)
	/* Set trivial mapping so each input channel pairs with a matrix column. */
	i = 0
	for {
		if !(i < channels) {
			break
		}
		(*(*[255]uint8)(unsafe.Pointer(bp)))[i] = libc.Uint8FromInt32(i)
		goto _60
	_60:
		;
		i = i + 1
	}
	ret = Opus_opus_multistream_decoder_init(tls, get_multistream_decoder(tls, st1), Fs, channels, streams, coupled_streams, bp)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _64
_64:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_projection_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, demixing_matrix uintptr, demixing_matrix_size OpusT_opus_int32, error1 uintptr) (r uintptr) {
	var ret, size1 int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	/* Allocate space for the projection decoder. */
	size1 = Opus_opus_projection_decoder_get_size(tls, channels, streams, coupled_streams)
	if !(size1 != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if !(st != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	/* Initialize projection decoder with provided settings. */
	ret = Opus_opus_projection_decoder_init(tls, st, Fs, channels, streams, coupled_streams, demixing_matrix, demixing_matrix_size)
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	return st
}

func Opus_opus_projection_decode(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_short), frame_size, decode_fec, int32(OPTIONAL_CLIP), get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decode24(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_int24), frame_size, decode_fec, 0, get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_float), frame_size, decode_fec, 0, get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var ret int32
	_, _ = ap, ret
	ret = OPUS_OK
	ap = va
	ret = Opus_opus_multistream_decoder_ctl_va_list(tls, get_multistream_decoder(tls, st), request, ap)
	_ = ap
	return ret
}

func Opus_opus_projection_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

var trim_icdf6 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf6 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf6 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

// C documentation
//
//	/* Given an extension payload (i.e., excluding the initial ID byte), advance
//	    data to the next extension and return the length of the remaining
//	    extensions.
//	   N.B., a "Repeat These Extensions" extension (ID==2) does not advance past
//	    the repeated extension payloads.
//	   That requires higher-level logic. */
func skip_extension_payload(tls *libc.TLS, pdata uintptr, len1 OpusT_opus_int32, pheader_size uintptr, id_byte int32, trailing_short_len OpusT_opus_int32) (r OpusT_opus_int32) {
	var L, id int32
	var bytes, header_size, lacing OpusT_opus_int32
	var data, v1 uintptr
	_, _, _, _, _, _, _ = L, bytes, data, header_size, id, lacing, v1
	data = *(*uintptr)(unsafe.Pointer(pdata))
	header_size = 0
	id = id_byte >> int32(1)
	L = id_byte & int32(1)
	if id == 0 && L == int32(1) || id == int32(2) {
		/* Nothing to do. */
	} else {
		if id > 0 && id < int32(32) {
			if len1 < L {
				return -int32(1)
			}
			data = data + uintptr(L)
			len1 = len1 - L
		} else {
			if L == 0 {
				if len1 < trailing_short_len {
					return -int32(1)
				}
				data = data + uintptr(len1-trailing_short_len)
				len1 = trailing_short_len
			} else {
				bytes = 0
				for cond := true; cond; cond = lacing == int32(255) {
					if len1 < int32(1) {
						return -int32(1)
					}
					v1 = data
					data = data + 1
					lacing = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
					bytes = bytes + lacing
					header_size = header_size + 1
					len1 = len1 - (lacing + int32(1))
				}
				if len1 < 0 {
					return -int32(1)
				}
				data = data + uintptr(bytes)
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(pdata)) = data
	*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = header_size
	return len1
}

// C documentation
//
//	/* Given an extension, advance data to the next extension and return the
//	   length of the remaining extensions.
//	   N.B., a "Repeat These Extensions" extension (ID==2) only advances past the
//	    extension ID byte.
//	   Higher-level logic is required to skip the extension payloads that come
//	    after it.*/
func skip_extension(tls *libc.TLS, pdata uintptr, len1 OpusT_opus_int32, pheader_size uintptr) (r OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var id_byte int32
	var v1 uintptr
	var _ /* data at bp+0 */ uintptr
	_, _ = id_byte, v1
	if len1 == 0 {
		*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = 0
		return 0
	}
	if len1 < int32(1) {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(pdata))
	v1 = *(*uintptr)(unsafe.Pointer(bp))
	*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(bp)) + 1
	id_byte = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
	len1 = len1 - 1
	len1 = skip_extension_payload(tls, bp, len1, pheader_size, id_byte, 0)
	if len1 >= 0 {
		*(*uintptr)(unsafe.Pointer(pdata)) = *(*uintptr)(unsafe.Pointer(bp))
		*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = *(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) + 1
	}
	return len1
}

func Opus_opus_extension_iterator_init(tls *libc.TLS, iter uintptr, data uintptr, len1 OpusT_opus_int32, nb_frames OpusT_opus_int32) {
	var v1, v2 uintptr
	var v4 OpusT_opus_int32
	var v6 int32
	_, _, _, _ = v1, v2, v4, v6
	if !(len1 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2445, __ccgo_ts+2472, int32(122))
	}
	if !(data != libc.UintptrFromInt32(0) || len1 == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2492, __ccgo_ts+2472, int32(123))
	}
	if !(nb_frames >= 0 && nb_frames <= int32(48)) {
		Opus_celt_fatal(tls, __ccgo_ts+2535, __ccgo_ts+2472, int32(124))
	}
	v2 = data
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata = v2
	v1 = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = v1
	v1 = libc.UintptrFromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = v1
	v4 = len1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1 = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = v4
	v4 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
	v6 = nb_frames
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max = v6
	v6 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l = uint8(0)
}

// C documentation
//
//	/* Reset the iterator so it can start iterating again from the first
//	    extension. */
func Opus_opus_extension_iterator_reset(tls *libc.TLS, iter uintptr) {
	var v1 uintptr
	var v2 int32
	_, _ = v1, v2
	v1 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1
	v2 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
}

// C documentation
//
//	/* Tell the iterator not to return any extensions for frames of index
//	    frame_max or larger.
//	   This can allow it to stop iterating early if these extensions are not
//	    needed. */
func Opus_opus_extension_iterator_set_frame_max(tls *libc.TLS, iter uintptr, frame_max int32) {
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max = frame_max
}

// C documentation
//
//	/* Return the next repeated extension.
//	   The return value is non-zero if one is found, negative on error, or 0 if we
//	    have finished repeating extensions. */
func opus_extension_iterator_next_repeat(tls *libc.TLS, iter uintptr, ext uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var curr_data0 uintptr
	var repeat_id_byte int32
	var _ /* header_size at bp+0 */ OpusT_opus_int32
	_, _ = curr_data0, repeat_id_byte
	if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2587, __ccgo_ts+2472, int32(160))
	}
	for {
		if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame < (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames) {
			break
		}
		for (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len > 0 {
			repeat_id_byte = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data)))
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = skip_extension(tls, iter+32, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len, bp)
			/* We skipped this extension earlier, so it should not fail now. */
			if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len >= libc.Int32FromInt32(0)) {
				Opus_celt_fatal(tls, __ccgo_ts+2628, __ccgo_ts+2472, int32(169))
			}
			/* Don't repeat padding or frame separators with a 0 increment. */
			if repeat_id_byte <= int32(3) {
				continue
			}
			/* If the "Repeat These Extensions" extension had L == 0 and this
			   is the last repeated long extension, then force decoding the
			   payload with L = 0. */
			if libc.Int32FromUint8((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l) == 0 && (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame+int32(1) >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames && (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data == (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long {
				repeat_id_byte = repeat_id_byte & ^libc.Int32FromInt32(1)
			}
			curr_data0 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = skip_extension_payload(tls, iter+8, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len, bp, repeat_id_byte, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len)
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
				return -int32(4)
			}
			if !(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data)-int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata) == int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1-(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len)) {
				Opus_celt_fatal(tls, __ccgo_ts+2665, __ccgo_ts+2472, int32(187))
			}
			/* If we were asked to stop at frame_max, skip extensions for later
			   frames. */
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
				continue
			}
			if ext != libc.UintptrFromInt32(0) {
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid = repeat_id_byte >> int32(1)
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fframe = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata = curr_data0 + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp)))
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 = int32(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data) - int64(curr_data0) - int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp))))
			}
			return int32(1)
		}
		/* We finished repeating the extensions for this frame. */
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len
		goto _1
	_1:
		;
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame + 1
	}
	/* We finished repeating extensions. */
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
	/* If L == 0, advance the frame number to handle the case where we did
	   not consume all of the data with an L == 0 long extension. */
	if libc.Int32FromUint8((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l) == 0 {
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + 1
		/* Ignore additional padding if this was already the last frame. */
		if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames {
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = 0
		}
	}
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = 0
	return 0
}

// C documentation
//
//	/* Return the next extension (excluding real padding, separators, and repeat
//	    indicators, but including the repeated extensions) in bitstream order.
//	   Due to the extension repetition mechanism, extensions are not necessarily
//	    returned in frame order. */
func Opus_opus_extension_iterator_next(tls *libc.TLS, iter uintptr, ext uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var L, id, ret, ret1 int32
	var curr_data0 uintptr
	var _ /* header_size at bp+0 */ OpusT_opus_int32
	_, _, _, _, _ = L, curr_data0, id, ret, ret1
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
		return -int32(4)
	}
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame > 0 {
		/* We are in the process of repeating some extensions. */
		ret = opus_extension_iterator_next_repeat(tls, iter, ext)
		if ret != 0 {
			return ret
		}
	}
	/* Checking this here allows opus_extension_iterator_set_frame_max() to be
	   called at any point. */
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
		return 0
	}
	for (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len > 0 {
		curr_data0 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
		id = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0))) >> int32(1)
		L = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0))) & int32(1)
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = skip_extension(tls, iter+8, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len, bp)
		if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
			return -int32(4)
		}
		if !(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data)-int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata) == int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1-(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len)) {
			Opus_celt_fatal(tls, __ccgo_ts+2665, __ccgo_ts+2472, int32(255))
		}
		if id == int32(1) {
			if L == 0 {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + 1
			} else {
				/* A frame increment of 0 is a no-op. */
				if !(*(*uint8)(unsafe.Pointer(curr_data0 + 1)) != 0) {
					continue
				}
				*(*int32)(unsafe.Pointer(iter + 68)) += libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0 + 1)))
			}
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = -int32(1)
				return -int32(4)
			}
			/* If we were asked to stop at frame_max, skip extensions for later
			   frames. */
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = 0
			}
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
		} else {
			if id == int32(2) {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l = libc.Uint8FromInt32(L)
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + int32(1)
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len = int32(int64(curr_data0) - int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data))
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len
				ret1 = opus_extension_iterator_next_repeat(tls, iter, ext)
				if ret1 != 0 {
					return ret1
				}
			} else {
				if id > int32(2) {
					/* Update the location of the last long extension.
					   This lets us know when we need to modify the last L flag if we
					    repeat these extensions with L=0. */
					if id >= int32(32) {
						(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
						(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
					} else {
						*(*OpusT_opus_int32)(unsafe.Pointer(iter + 56)) += L
					}
					if ext != libc.UintptrFromInt32(0) {
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid = id
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fframe = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata = curr_data0 + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp)))
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 = int32(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data) - int64(curr_data0) - int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp))))
					}
					return int32(1)
				}
			}
		}
	}
	return 0
}

func Opus_opus_extension_iterator_find(tls *libc.TLS, iter uintptr, ext uintptr, id int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ret int32
	var _ /* curr_ext at bp+0 */ OpusT_opus_extension_data
	_ = ret
	for {
		ret = Opus_opus_extension_iterator_next(tls, iter, bp)
		if ret <= 0 {
			return ret
		}
		if (*(*OpusT_opus_extension_data)(unsafe.Pointer(bp))).Fid == id {
			*(*OpusT_opus_extension_data)(unsafe.Pointer(ext)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp))
			return ret
		}
		goto _1
	_1:
	}
	return r
}

// C documentation
//
//	/* Count the number of extensions, excluding real padding, separators, and
//	    repeat indicators, but including the repeated extensions. */
func Opus_opus_packet_extensions_count(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var count int32
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_ = count
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		if !(Opus_opus_extension_iterator_next(tls, bp, libc.UintptrFromInt32(0)) > 0) {
			break
		}
		goto _1
	_1:
		;
		count = count + 1
	}
	return count
}

// C documentation
//
//	/* Count the number of extensions for each frame, excluding real padding and
//	    separators and repeat indicators, but including the repeated extensions. */
func Opus_opus_packet_extensions_count_ext(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_frame_exts uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count int32
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_ = count
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	libc.Xmemset(tls, nb_frame_exts, 0, libc.Uint64FromInt32(nb_frames)*uint64(4))
	count = 0
	for {
		if !(Opus_opus_extension_iterator_next(tls, bp, bp+80) > 0) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4)) + 1
		goto _1
	_1:
		;
		count = count + 1
	}
	return count
}

// C documentation
//
//	/* Extract extensions from Opus padding (excluding real padding, separators,
//	    and repeat indicators, but including the repeated extensions) in bitstream
//	    order.
//	   Due to the extension repetition mechanism, extensions are not necessarily
//	    returned in frame order. */
func Opus_opus_packet_extensions_parse(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count, ret int32
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_, _ = count, ret
	if !(nb_extensions != libc.UintptrFromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2742, __ccgo_ts+2472, int32(365))
	}
	if !(extensions != libc.UintptrFromInt32(0) || *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2782, __ccgo_ts+2472, int32(366))
	}
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		ret = Opus_opus_extension_iterator_next(tls, bp, bp+80)
		if ret <= 0 {
			break
		}
		if count == *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) {
			return -int32(2)
		}
		*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(count)*24)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))
		goto _1
	_1:
		;
		count = count + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) = count
	return ret
}

// C documentation
//
//	/* Extract extensions from Opus padding (excluding real padding, separators,
//	    and repeat indicators, but including the repeated extensions) in frame
//	    order.
//	   nb_frame_exts must be filled with the output of
//	    opus_packet_extensions_count_ext(). */
func Opus_opus_packet_extensions_parse_ext(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions uintptr, nb_frame_exts uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var count, prev_total, ret, total int32
	var idx, v3 OpusT_opus_int32
	var v4 uintptr
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	var _ /* nb_frames_cum at bp+104 */ [49]OpusT_opus_int32
	_, _, _, _, _, _, _ = count, idx, prev_total, ret, total, v3, v4
	if !(nb_extensions != libc.UintptrFromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2742, __ccgo_ts+2472, int32(395))
	}
	if !(extensions != libc.UintptrFromInt32(0) || *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2782, __ccgo_ts+2472, int32(396))
	}
	if !(nb_frames <= libc.Int32FromInt32(48)) {
		Opus_celt_fatal(tls, __ccgo_ts+2842, __ccgo_ts+2472, int32(397))
	}
	/* Convert the frame extension count array to a cumulative sum. */
	prev_total = 0
	count = 0
	for {
		if !(count < nb_frames) {
			break
		}
		total = *(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr(count)*4)) + prev_total
		(*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[count] = prev_total
		prev_total = total
		goto _1
	_1:
		;
		count = count + 1
	}
	(*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[count] = prev_total
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		ret = Opus_opus_extension_iterator_next(tls, bp, bp+80)
		if ret <= 0 {
			break
		}
		v4 = bp + 104 + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4
		v3 = *(*OpusT_opus_int32)(unsafe.Pointer(v4))
		*(*OpusT_opus_int32)(unsafe.Pointer(v4)) = *(*OpusT_opus_int32)(unsafe.Pointer(v4)) + 1
		idx = v3
		if idx >= *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) {
			return -int32(2)
		}
		if !(idx < (*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[(*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe+int32(1)]) {
			Opus_celt_fatal(tls, __ccgo_ts+2876, __ccgo_ts+2472, int32(416))
		}
		*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(idx)*24)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))
		goto _2
	_2:
		;
		count = count + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) = count
	return ret
}

func write_extension_payload(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, pos OpusT_opus_int32, ext uintptr, last int32) (r int32) {
	var j, length_bytes OpusT_opus_int32
	_, _ = j, length_bytes
	if !((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid >= int32(3) && (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid <= int32(127)) {
		Opus_celt_fatal(tls, __ccgo_ts+2929, __ccgo_ts+2472, int32(425))
	}
	if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid < int32(32) {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 < 0 || (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 > int32(1) {
			return -int32(1)
		}
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 > 0 {
			if len1-pos < (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 {
				return -int32(2)
			}
			if data != 0 {
				*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = *(*uint8)(unsafe.Pointer((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata))
			}
			pos = pos + 1
		}
	} else {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 < 0 {
			return -int32(1)
		}
		length_bytes = int32(1) + (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1/int32(255)
		if last != 0 {
			length_bytes = 0
		}
		if len1-pos < length_bytes+(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 {
			return -int32(2)
		}
		if !(last != 0) {
			j = 0
			for {
				if !(j < (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1/int32(255)) {
					break
				}
				if data != 0 {
					*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(255)
				}
				pos = pos + 1
				goto _1
			_1:
				;
				j = j + 1
			}
			if data != 0 {
				*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 % int32(255))
			}
			pos = pos + 1
		}
		if data != 0 {
			libc.Xmemcpy(tls, data+uintptr(pos), (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata, libc.Uint64FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1)*uint64(1)+libc.Uint64FromInt64(0*(OpusT___predefined_ptrdiff_t(data+uintptr(pos))-int64((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata))))
		}
		pos = pos + (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1
	}
	return pos
}

func write_extension(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, pos OpusT_opus_int32, ext uintptr, last int32) (r int32) {
	var v1 int32
	_ = v1
	if len1-pos < int32(1) {
		return -int32(2)
	}
	if !((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid >= int32(3) && (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid <= int32(127)) {
		Opus_celt_fatal(tls, __ccgo_ts+2929, __ccgo_ts+2472, int32(465))
	}
	if data != 0 {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid < int32(32) {
			v1 = (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1
		} else {
			v1 = libc.BoolInt32(!(last != 0))
		}
		*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid<<int32(1) + v1)
	}
	pos = pos + 1
	return write_extension_payload(tls, data, len1, pos, ext, last)
}

func Opus_opus_packet_extensions_generate(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions OpusT_opus_int32, nb_frames int32, pad int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	var curr_frame, diff, f, g, g1, j, j1, last, nb_repeated, repeat_count, v3 int32
	var frame_min_idx, frame_repeat_idx [48]OpusT_opus_int32
	var i, last_long_idx, padding, pos, written OpusT_opus_int32
	var _ /* frame_max_idx at bp+0 */ [48]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = curr_frame, diff, f, frame_min_idx, frame_repeat_idx, g, g1, i, j, j1, last, last_long_idx, nb_repeated, padding, pos, repeat_count, written, v3
	curr_frame = 0
	pos = 0
	written = 0
	if !(len1 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2445, __ccgo_ts+2472, int32(484))
	}
	if nb_frames > int32(48) {
		return -int32(1)
	}
	/* Do a little work up-front to make this O(nb_extensions) instead of
	   O(nb_extensions*nb_frames) so long as the extensions are in frame
	   order (without requiring that they be in frame order). */
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		frame_min_idx[f] = nb_extensions
		goto _1
	_1:
		;
		f = f + 1
	}
	libc.Xmemset(tls, bp, 0, libc.Uint64FromInt32(nb_frames)*uint64(4))
	i = 0
	for {
		if !(i < nb_extensions) {
			break
		}
		f = (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe
		if f < 0 || f >= nb_frames {
			return -int32(1)
		}
		if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid < int32(3) || (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid > int32(127) {
			return -int32(1)
		}
		if frame_min_idx[f] < i {
			v3 = frame_min_idx[f]
		} else {
			v3 = i
		}
		frame_min_idx[f] = v3
		if (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f] > i+int32(1) {
			v3 = (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]
		} else {
			v3 = i + int32(1)
		}
		(*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f] = v3
		goto _2
	_2:
		;
		i = i + 1
	}
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		frame_repeat_idx[f] = frame_min_idx[f]
		goto _5
	_5:
		;
		f = f + 1
	}
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		repeat_count = 0
		last_long_idx = -int32(1)
		if f+int32(1) < nb_frames {
			i = frame_min_idx[f]
			for {
				if !(i < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]) {
					break
				}
				if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe == f {
					/* Test if we can repeat this extension in future frames. */
					g = f + int32(1)
					for {
						if !(g < nb_frames) {
							break
						}
						if frame_repeat_idx[g] >= (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[g] {
							break
						}
						if !((*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fframe == g) {
							Opus_celt_fatal(tls, __ccgo_ts+2978, __ccgo_ts+2472, int32(518))
						}
						if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fid != (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid {
							break
						}
						if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fid < int32(32) && (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Flen1 != (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Flen1 {
							break
						}
						goto _8
					_8:
						;
						g = g + 1
					}
					if g < nb_frames {
						break
					}
					/* We can! */
					/* If this is a long extension, save the index of the last
					   instance, so we can modify its L flag. */
					if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid >= int32(32) {
						last_long_idx = frame_repeat_idx[nb_frames-int32(1)]
					}
					/* Using the repeat mechanism almost always makes the
					    encoding smaller (or at least no larger).
					   However, there's one case where that might not be true: if
					    the last repeated long extension in the last frame was
					    previously the last extension, but using the repeat
					    mechanism makes that no longer true (because there are other
					    non-repeated extensions in earlier frames that must now be
					    coded after it), and coding its length requires more bytes
					    than the repeat mechanism saves.
					   This can only be true if its length is at least 255 bytes
					    (although sometimes it requires even more).
					   Currently we do not check for that, and just always use the
					    repeat mechanism if we can.
					   See git history for code that does the check. */
					/* Advance the repeat pointers. */
					g = f + int32(1)
					for {
						if !(g < nb_frames) {
							break
						}
						j = frame_repeat_idx[g] + int32(1)
						for {
							if !(j < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[g] && (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(j)*24))).Fframe != g) {
								break
							}
							goto _10
						_10:
							;
							j = j + 1
						}
						frame_repeat_idx[g] = j
						goto _9
					_9:
						;
						g = g + 1
					}
					repeat_count = repeat_count + 1
					/* Point the repeat pointer for this frame to the current
					   extension, so we know when to trigger the repeats. */
					frame_repeat_idx[f] = i
				}
				goto _7
			_7:
				;
				i = i + 1
			}
		}
		i = frame_min_idx[f]
		for {
			if !(i < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]) {
				break
			}
			if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe == f {
				/* Insert separator when needed. */
				if f != curr_frame {
					diff = f - curr_frame
					if len1-pos < int32(2) {
						return -int32(2)
					}
					if diff == int32(1) {
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(0x02)
						}
						pos = pos + 1
					} else {
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(0x03)
						}
						pos = pos + 1
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32(diff)
						}
						pos = pos + 1
					}
					curr_frame = f
				}
				pos = write_extension(tls, data, len1, pos, extensions+uintptr(i)*24, libc.BoolInt32(written == nb_extensions-int32(1)))
				if pos < 0 {
					return pos
				}
				written = written + 1
				if repeat_count > 0 && frame_repeat_idx[f] == i {
					/* Add the repeat indicator. */
					nb_repeated = repeat_count * (nb_frames - (f + int32(1)))
					last = libc.BoolInt32(written+nb_repeated == nb_extensions || last_long_idx < 0 && i+int32(1) >= (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f])
					if len1-pos < int32(1) {
						return -int32(2)
					}
					if data != 0 {
						*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32(int32(0x04) + libc.BoolInt32(!(last != 0)))
					}
					pos = pos + 1
					g1 = f + int32(1)
					for {
						if !(g1 < nb_frames) {
							break
						}
						j1 = frame_min_idx[g1]
						for {
							if !(j1 < frame_repeat_idx[g1]) {
								break
							}
							if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(j1)*24))).Fframe == g1 {
								pos = write_extension_payload(tls, data, len1, pos, extensions+uintptr(j1)*24, libc.BoolInt32(last != 0 && j1 == last_long_idx))
								if pos < 0 {
									return pos
								}
								written = written + 1
							}
							goto _13
						_13:
							;
							j1 = j1 + 1
						}
						frame_min_idx[g1] = j1
						goto _12
					_12:
						;
						g1 = g1 + 1
					}
					if last != 0 {
						curr_frame = curr_frame + 1
					}
				}
			}
			goto _11
		_11:
			;
			i = i + 1
		}
		goto _6
	_6:
		;
		f = f + 1
	}
	if !(written == nb_extensions) {
		Opus_celt_fatal(tls, __ccgo_ts+3039, __ccgo_ts+2472, int32(624))
	}
	/* If we need to pad, just prepend 0x01 bytes. Even better would be to fill the
	   end with zeros, but that requires checking that turning the last extension into
	   an L=1 case still fits. */
	if pad != 0 && pos < len1 {
		padding = len1 - pos
		if data != 0 {
			libc.Xmemmove(tls, data+uintptr(padding), data, libc.Uint64FromInt32(pos)*uint64(1)+libc.Uint64FromInt64(0*(int64(data+uintptr(padding))-int64(data))))
			i = 0
			for {
				if !(i < padding) {
					break
				}
				*(*uint8)(unsafe.Pointer(data + uintptr(i))) = uint8(0x01)
				goto _14
			_14:
				;
				i = i + 1
			}
		}
		pos = pos + padding
	}
	return pos
}

const BUFSIZ = 1024
const CELT_LPC_ORDER = 24
const CELT_MAX_PULSES = 128
const CELT_SIG_SCALE3 = 32768
const COEF_ONE3 = 1
const FILENAME_MAX = 4096
const FINE_OFFSET = 21
const FOPEN_MAX = 1000
const LOG_MAX_PSEUDO = 6
const L_ctermid = 20
const L_cuserid = 20
const L_tmpnam = 20
const MAX_FINE_BITS = 8
const MAX_PSEUDO = 40
const P_tmpdir = "/tmp"
const QTHETA_OFFSET = 4
const QTHETA_OFFSET_TWOPHASE = 16
const SPREAD_AGGRESSIVE = 3
const SPREAD_LIGHT = 1
const SPREAD_NONE = 0
const SPREAD_NORMAL = 2
const TMP_MAX = 10000
const _IOFBF = 0
const _IOLBF = 1
const _IONBF = 2
const celt_inner_prod_norm = "celt_inner_prod"
const celt_inner_prod_norm_shift = "celt_inner_prod"
const celt_pitch_xcorr = "celt_pitch_xcorr_c"

type OpusT_ssize_t = int64

type OpusT_off_t = int64

type _IO_FILE = struct {
	F__x int8
}

type OpusT_FILE = struct {
	F__x int8
}

type OpusT___isoc_va_list = uintptr

type OpusT_fpos_t = struct {
	F__lldata [0]int64
	F__align  [0]float64
	F__opaque [16]int8
}

type _G_fpos64_t = OpusT_fpos_t

type OpusT_cookie_io_functions_t = struct {
	Fread   uintptr
	Fwrite  uintptr
	Fseek   uintptr
	Fclose1 uintptr
}

type _IO_cookie_io_functions_t = OpusT_cookie_io_functions_t

func Opus_celt_fatal(tls *libc.TLS, str uintptr, file uintptr, line int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	libc.Xfprintf(tls, libc.Xstderr, __ccgo_ts+3082, libc.VaList(bp+8, file, line, str))
	libc.Xabort(tls)
}

var trim_icdf7 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf7 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf7 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff3 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff3 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

func Opus_resampling_factor(tls *libc.TLS, rate OpusT_opus_int32) (r int32) {
	var ret int32
	_ = ret
	switch rate {
	case int32(48000):
		ret = int32(1)
	case int32(24000):
		ret = int32(2)
	case int32(16000):
		ret = int32(3)
	case int32(12000):
		ret = int32(4)
	case int32(8000):
		ret = int32(6)
	default:
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+3125, int32(87))
		}
		ret = 0
		break
	}
	return ret
}

// C documentation
//
//	/* This version should be faster on ARM */
func comb_filter_const_c(tls *libc.TLS, y uintptr, x uintptr, T int32, N int32, g10 OpusT_celt_coef, g11 OpusT_celt_coef, g12 OpusT_celt_coef) {
	var i int32
	var x0, x1, x2, x3, x4 OpusT_opus_val32
	_, _, _, _, _, _ = i, x0, x1, x2, x3, x4
	x4 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T-int32(2))*4))
	x3 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T-int32(1))*4))
	x2 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T)*4))
	x1 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T+int32(1))*4))
	i = 0
	for {
		if !(i < N) {
			break
		}
		x0 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T+int32(2))*4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i)*4)) + OpusT_celt_coef(g10*x2) + OpusT_celt_coef(g11*(x1+x3)) + OpusT_celt_coef(g12*(x0+x4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4))
		x4 = x3
		x3 = x2
		x2 = x1
		x1 = x0
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_comb_filter(tls *libc.TLS, y uintptr, x uintptr, T0 int32, T1 int32, N int32, g0 OpusT_opus_val16, g1 OpusT_opus_val16, tapset0 int32, tapset1 int32, window uintptr, overlap int32, arch int32) {
	var f, g00, g01, g02, g10, g11, g12 OpusT_celt_coef
	var i, v1 int32
	var x0, x1, x2, x3, x4 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, g00, g01, g02, g10, g11, g12, i, x0, x1, x2, x3, x4, v1
	if g0 == libc.Float32FromInt32(0) && g1 == libc.Float32FromInt32(0) {
		/* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
		if x != y {
			libc.Xmemmove(tls, y, x, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(y)-int64(x))/4)))
		}
		return
	}
	/* When the gain is zero, T0 and/or T1 is set to zero. We need
	   to have then be at least 2 to avoid processing garbage data. */
	if T0 > int32(COMBFILTER_MINPERIOD) {
		v1 = T0
	} else {
		v1 = int32(COMBFILTER_MINPERIOD)
	}
	T0 = v1
	if T1 > int32(COMBFILTER_MINPERIOD) {
		v1 = T1
	} else {
		v1 = int32(COMBFILTER_MINPERIOD)
	}
	T1 = v1
	g00 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12)))
	g01 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12 + 1*4)))
	g02 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12 + 2*4)))
	g10 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12)))
	g11 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12 + 1*4)))
	g12 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12 + 2*4)))
	x1 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1+int32(1))*4))
	x2 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1)*4))
	x3 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1-int32(1))*4))
	x4 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1-int32(2))*4))
	/* If the filter didn't change, we don't need the overlap */
	if g0 == g1 && T0 == T1 && tapset0 == tapset1 {
		overlap = 0
	}
	i = 0
	for {
		if !(i < overlap) {
			break
		}
		x0 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T1+int32(2))*4))
		f = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4)) * *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4)))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i)*4)) + float32(float32((libc.Float32FromFloat32(1)-f)*g00)**(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0)*4))) + float32(float32((libc.Float32FromFloat32(1)-f)*g01)*(*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0+int32(1))*4))+*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0-int32(1))*4)))) + float32(float32((libc.Float32FromFloat32(1)-f)*g02)*(*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0+int32(2))*4))+*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0-int32(2))*4)))) + OpusT_celt_coef(OpusT_celt_coef(f*g10)*x2) + OpusT_celt_coef(OpusT_celt_coef(f*g11)*(x1+x3)) + OpusT_celt_coef(OpusT_celt_coef(f*g12)*(x0+x4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4))
		x4 = x3
		x3 = x2
		x2 = x1
		x1 = x0
		goto _3
	_3:
		;
		i = i + 1
	}
	if g1 == libc.Float32FromInt32(0) {
		/* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
		if x != y {
			libc.Xmemmove(tls, y+uintptr(overlap)*4, x+uintptr(overlap)*4, libc.Uint64FromInt32(N-overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(y+uintptr(overlap)*4)-int64(x+uintptr(overlap)*4))/4)))
		}
		return
	}
	/* Compute the part with the constant filter. */
	_ = arch
	comb_filter_const_c(tls, y+uintptr(i)*4, x+uintptr(i)*4, T1, N-i, g10, g11, g12)
}

var gains = [3][3]OpusT_opus_val16{
	0: {
		0: libc.Float32FromFloat32(0.306640625),
		1: libc.Float32FromFloat32(0.2170410156),
		2: libc.Float32FromFloat32(0.1296386719),
	},
	1: {
		0: libc.Float32FromFloat32(0.4638671875),
		1: libc.Float32FromFloat32(0.2680664062),
	},
	2: {
		0: libc.Float32FromFloat32(0.7998046875),
		1: libc.Float32FromFloat32(0.1000976562),
	},
}

func Opus_init_caps(tls *libc.TLS, m uintptr, cap1 uintptr, LM int32, C int32) {
	var N, i int32
	_, _ = N, i
	i = 0
	for {
		if !(i < (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) {
			break
		}
		N = (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))) << LM
		*(*int32)(unsafe.Pointer(cap1 + uintptr(i)*4)) = (libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).Fcache.Fcaps + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands*(int32(2)*LM+C-int32(1))+i)))) + int32(64)) * C * N >> int32(2)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_opus_strerror(tls *libc.TLS, error1 int32) (r uintptr) {
	if error1 > 0 || error1 < -int32(7) {
		return __ccgo_ts + 3277
	} else {
		return error_strings[-error1]
	}
	return r
}

var error_strings = [8]uintptr{
	0: __ccgo_ts + 3140,
	1: __ccgo_ts + 3148,
	2: __ccgo_ts + 3165,
	3: __ccgo_ts + 3182,
	4: __ccgo_ts + 3197,
	5: __ccgo_ts + 3214,
	6: __ccgo_ts + 3238,
	7: __ccgo_ts + 3252,
}

func Opus_opus_get_version_string(tls *libc.TLS) (r uintptr) {
	return __ccgo_ts + 3291
}

const CELT_SIG_SCALE4 = "32768.f"
const COEF_ONE4 = "1.0f"

var log2_x_norm_coeff4 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff4 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf8 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf8 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf8 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

func Opus__celt_lpc(tls *libc.TLS, _lpc uintptr, ac uintptr, p int32) {
	var error1, r, rr, tmp1, tmp2 OpusT_opus_val32
	var i, j int32
	var lpc uintptr
	_, _, _, _, _, _, _, _ = error1, i, j, lpc, r, rr, tmp1, tmp2
	error1 = *(*OpusT_opus_val32)(unsafe.Pointer(ac))
	lpc = _lpc
	libc.Xmemset(tls, lpc, 0, libc.Uint64FromInt32(p)*uint64(4))
	if *(*OpusT_opus_val32)(unsafe.Pointer(ac)) > libc.Float32FromFloat32(1e-10) {
		i = 0
		for {
			if !(i < p) {
				break
			}
			/* Sum up this iteration's reflection coefficient */
			rr = libc.Float32FromInt32(0)
			j = 0
			for {
				if !(j < i) {
					break
				}
				rr = rr + float32(*(*float32)(unsafe.Pointer(lpc + uintptr(j)*4))**(*OpusT_opus_val32)(unsafe.Pointer(ac + uintptr(i-j)*4)))
				goto _2
			_2:
				;
				j = j + 1
			}
			rr = rr + *(*OpusT_opus_val32)(unsafe.Pointer(ac + uintptr(i+int32(1))*4))
			r = -(rr / error1)
			/*  Update LPC coefficients and total error */
			*(*float32)(unsafe.Pointer(lpc + uintptr(i)*4)) = r
			j = 0
			for {
				if !(j < (i+int32(1))>>int32(1)) {
					break
				}
				tmp1 = *(*float32)(unsafe.Pointer(lpc + uintptr(j)*4))
				tmp2 = *(*float32)(unsafe.Pointer(lpc + uintptr(i-int32(1)-j)*4))
				*(*float32)(unsafe.Pointer(lpc + uintptr(j)*4)) = tmp1 + OpusT_opus_val32(r*tmp2)
				*(*float32)(unsafe.Pointer(lpc + uintptr(i-int32(1)-j)*4)) = tmp2 + OpusT_opus_val32(r*tmp1)
				goto _3
			_3:
				;
				j = j + 1
			}
			error1 = error1 - OpusT_opus_val32(OpusT_opus_val32(r*r)*error1)
			/* Bail out once we get 30 dB gain */
			if error1 <= OpusT_opus_val32(libc.Float32FromFloat32(0.001)**(*OpusT_opus_val32)(unsafe.Pointer(ac))) {
				break
			}
			goto _1
		_1:
			;
			i = i + 1
		}
	}
}

func Opus_celt_fir_c(tls *libc.TLS, x1 uintptr, num uintptr, y1 uintptr, N int32, ord int32, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, rnum, st, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v31, v32, v33, v35, v36, v37, v5, v7, v9 uintptr
	var i, j, j1, v34, v47, v50 int32
	var sum2 OpusT_opus_val32
	var tmp, tmp1, tmp2, tmp3, y_0, y_1, y_2, y_3 OpusT_opus_val16
	var _ /* sum at bp+0 */ [4]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, i, j, j1, rnum, st, sum2, tmp, tmp1, tmp2, tmp3, y_0, y_1, y_2, y_3, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v31, v32, v33, v34, v35, v36, v37, v47, v5, v50, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(x1 != y1) {
		Opus_celt_fatal(tls, __ccgo_ts+3305, __ccgo_ts+3330, int32(157))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3330, int32(158))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(ord) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	rnum = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < ord) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(rnum + uintptr(i)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(num + uintptr(ord-i-int32(1))*4))
		goto _29
	_29:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < N-int32(3)) {
			break
		}
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i)*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)] = *(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i+int32(1))*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] = *(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i+int32(2))*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] = *(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i+int32(3))*4))
		_ = arch
		v1 = rnum
		v3 = x1 + uintptr(i)*4 - uintptr(ord)*4
		v5 = bp
		v34 = ord
		if !(v34 >= libc.Int32FromInt32(3)) {
			Opus_celt_fatal(tls, __ccgo_ts+3349, __ccgo_ts+3374, int32(69))
		}
		y_3 = libc.Float32FromInt32(0)
		v7 = v3
		v3 += 4
		y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v7))
		v9 = v3
		v3 += 4
		y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v9))
		v11 = v3
		v3 += 4
		y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v11))
		j = libc.Int32FromInt32(0)
		for {
			if !(j < v34-libc.Int32FromInt32(3)) {
				break
			}
			v13 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v13))
			v15 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v15))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_3)
			v17 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v17))
			v19 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v19))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_0)
			v21 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v21))
			v23 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v23))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_1)
			v25 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v25))
			v27 = v3
			v3 += 4
			y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v27))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_2)
			goto _38
		_38:
			;
			j = j + int32(4)
		}
		v47 = j
		j = j + 1
		if v47 < v34 {
			v31 = v1
			v1 += 4
			tmp1 = *(*OpusT_opus_val16)(unsafe.Pointer(v31))
			v32 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v32))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp1*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp1*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp1*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp1*y_3)
		}
		v50 = j
		j = j + 1
		if v50 < v34 {
			v33 = v1
			v1 += 4
			tmp2 = *(*OpusT_opus_val16)(unsafe.Pointer(v33))
			v35 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v35))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp2*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp2*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp2*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp2*y_0)
		}
		if j < v34 {
			v36 = v1
			v1 += 4
			tmp3 = *(*OpusT_opus_val16)(unsafe.Pointer(v36))
			v37 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v37))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp3*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp3*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp3*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp3*y_1)
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i)*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+int32(1))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)]
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+int32(2))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)]
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+int32(3))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)]
		goto _30
	_30:
		;
		i = i + int32(4)
	}
	for {
		if !(i < N) {
			break
		}
		sum2 = *(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i)*4))
		j1 = 0
		for {
			if !(j1 < ord) {
				break
			}
			sum2 = sum2 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(rnum + uintptr(j1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x1 + uintptr(i+j1-ord)*4)))
			goto _56
		_56:
			;
			j1 = j1 + 1
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i)*4)) = sum2
		goto _55
	_55:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _60
_60:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_celt_iir(tls *libc.TLS, _x uintptr, den uintptr, _y uintptr, N int32, ord int32, mem uintptr, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, rden, st, y1, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v29, v3, v31, v33, v35, v37, v39, v5, v7, v9 uintptr
	var i, j, j1, v60, v73, v76 int32
	var sum2 OpusT_opus_val32
	var tmp, tmp1, tmp2, tmp3, y_0, y_1, y_2, y_3 OpusT_opus_val16
	var _ /* sum at bp+0 */ [4]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, i, j, j1, rden, st, sum2, tmp, tmp1, tmp2, tmp3, y1, y_0, y_1, y_2, y_3, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v29, v3, v31, v33, v35, v37, v39, v5, v60, v7, v73, v76, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(ord&libc.Int32FromInt32(3) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3390, __ccgo_ts+3330, int32(225))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3330, int32(226))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(ord) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	rden = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N+ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3330, int32(227))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N+ord) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	y1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N+ord)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < ord) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(rden + uintptr(i)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(den + uintptr(ord-i-int32(1))*4))
		goto _53
	_53:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < ord) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i)*4)) = -*(*OpusT_opus_val16)(unsafe.Pointer(mem + uintptr(ord-i-int32(1))*4))
		goto _54
	_54:
		;
		i = i + 1
	}
	for {
		if !(i < N+ord) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i)*4)) = libc.Float32FromInt32(0)
		goto _55
	_55:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < N-int32(3)) {
			break
		}
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_val32)(unsafe.Pointer(_x + uintptr(i)*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)] = *(*OpusT_opus_val32)(unsafe.Pointer(_x + uintptr(i+int32(1))*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] = *(*OpusT_opus_val32)(unsafe.Pointer(_x + uintptr(i+int32(2))*4))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] = *(*OpusT_opus_val32)(unsafe.Pointer(_x + uintptr(i+int32(3))*4))
		_ = arch
		v1 = rden
		v3 = y1 + uintptr(i)*4
		v5 = bp
		v60 = ord
		if !(v60 >= libc.Int32FromInt32(3)) {
			Opus_celt_fatal(tls, __ccgo_ts+3349, __ccgo_ts+3374, int32(69))
		}
		y_3 = libc.Float32FromInt32(0)
		v7 = v3
		v3 += 4
		y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v7))
		v9 = v3
		v3 += 4
		y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v9))
		v11 = v3
		v3 += 4
		y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v11))
		j = libc.Int32FromInt32(0)
		for {
			if !(j < v60-libc.Int32FromInt32(3)) {
				break
			}
			v13 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v13))
			v15 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v15))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_3)
			v17 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v17))
			v19 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v19))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_0)
			v21 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v21))
			v23 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v23))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_1)
			v25 = v1
			v1 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v25))
			v27 = v3
			v3 += 4
			y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v27))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp*y_2)
			goto _64
		_64:
			;
			j = j + int32(4)
		}
		v73 = j
		j = j + 1
		if v73 < v60 {
			v29 = v1
			v1 += 4
			tmp1 = *(*OpusT_opus_val16)(unsafe.Pointer(v29))
			v31 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v31))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp1*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp1*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp1*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp1*y_3)
		}
		v76 = j
		j = j + 1
		if v76 < v60 {
			v33 = v1
			v1 += 4
			tmp2 = *(*OpusT_opus_val16)(unsafe.Pointer(v33))
			v35 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v35))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp2*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp2*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp2*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp2*y_0)
		}
		if j < v60 {
			v37 = v1
			v1 += 4
			tmp3 = *(*OpusT_opus_val16)(unsafe.Pointer(v37))
			v39 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v39))
			*(*OpusT_opus_val32)(unsafe.Pointer(v5)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5)) + OpusT_opus_val32(tmp3*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 1*4)) + OpusT_opus_val32(tmp3*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 2*4)) + OpusT_opus_val32(tmp3*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v5 + 3*4)) + OpusT_opus_val32(tmp3*y_1)
		}
		/* Patch up the result to compensate for the fact that this is an IIR */
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord)*4)) = -(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]
		*(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(i)*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord)*4))**(*OpusT_opus_val16)(unsafe.Pointer(den)))
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(1))*4)) = -(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)]
		*(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(i+int32(1))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)]
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(1))*4))**(*OpusT_opus_val16)(unsafe.Pointer(den)))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord)*4))**(*OpusT_opus_val16)(unsafe.Pointer(den + 1*4)))
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(2))*4)) = -(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)]
		*(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(i+int32(2))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)]
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(2))*4))**(*OpusT_opus_val16)(unsafe.Pointer(den)))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(1))*4))**(*OpusT_opus_val16)(unsafe.Pointer(den + 1*4)))
		(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)] + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord)*4))**(*OpusT_opus_val16)(unsafe.Pointer(den + 2*4)))
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord+int32(3))*4)) = -(*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)]
		*(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(i+int32(3))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)]
		goto _56
	_56:
		;
		i = i + int32(4)
	}
	for {
		if !(i < N) {
			break
		}
		sum2 = *(*OpusT_opus_val32)(unsafe.Pointer(_x + uintptr(i)*4))
		j1 = 0
		for {
			if !(j1 < ord) {
				break
			}
			sum2 = sum2 - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(rden + uintptr(j1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+j1)*4)))
			goto _82
		_82:
			;
			j1 = j1 + 1
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i+ord)*4)) = sum2
		*(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(i)*4)) = sum2
		goto _81
	_81:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < ord) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(mem + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(_y + uintptr(N-i-int32(1))*4))
		goto _83
	_83:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _85
	_85:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _87
_87:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus__celt_autocorr(tls *libc.TLS, x uintptr, ac uintptr, window uintptr, overlap int32, lag int32, n int32, arch int32) (r int32) {
	var _saved_stack, st, xptr, xx, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var d OpusT_opus_val32
	var fastN, i, k, shift int32
	var w OpusT_opus_val16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, d, fastN, i, k, shift, st, w, xptr, xx, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	fastN = n - lag
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(n)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3330, int32(301))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(n) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	xx = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(n)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if !(n > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3419, __ccgo_ts+3330, int32(302))
	}
	if !(overlap >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3441, __ccgo_ts+3330, int32(303))
	}
	if overlap == 0 {
		xptr = x
	} else {
		i = 0
		for {
			if !(i < n) {
				break
			}
			*(*OpusT_opus_val16)(unsafe.Pointer(xx + uintptr(i)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))
			goto _29
		_29:
			;
			i = i + 1
		}
		i = 0
		for {
			if !(i < overlap) {
				break
			}
			w = *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4))
			*(*OpusT_opus_val16)(unsafe.Pointer(xx + uintptr(i)*4)) = OpusT_opus_val16(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4)) * w)
			*(*OpusT_opus_val16)(unsafe.Pointer(xx + uintptr(n-i-int32(1))*4)) = OpusT_opus_val16(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(n-i-int32(1))*4)) * w)
			goto _30
		_30:
			;
			i = i + 1
		}
		xptr = xx
	}
	shift = 0
	Opus_celt_pitch_xcorr_c(tls, xptr, xptr, ac, fastN, lag+int32(1), arch)
	k = 0
	for {
		if !(k <= lag) {
			break
		}
		i = k + fastN
		d = libc.Float32FromInt32(0)
		for {
			if !(i < n) {
				break
			}
			d = d + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(xptr + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(xptr + uintptr(i-k)*4)))
			goto _32
		_32:
			;
			i = i + 1
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(ac + uintptr(k)*4)) += d
		goto _31
	_31:
		;
		k = k + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return shift
}

var log2_x_norm_coeff5 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff5 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The guts header contains all the multiplication and addition macros that are defined for
   complex numbers.  It also declares the kf_ internal functions.
*/

func kf_bfly2(tls *libc.TLS, Fout uintptr, m int32, N int32) {
	var Fout2 uintptr
	var i int32
	var t OpusT_kiss_fft_cpx
	var tw OpusT_celt_coef
	_, _, _, _ = Fout2, i, t, tw
	_ = m
	tw = libc.Float32FromFloat32(0.7071067812)
	/* We know that m==4 here because the radix-2 is just after a radix-4 */
	if !(m == libc.Int32FromInt32(4)) {
		Opus_celt_fatal(tls, __ccgo_ts+3470, __ccgo_ts+3493, int32(80))
	}
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout2 = Fout + uintptr(4)*8
		t = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fi += t.Fi
		t.Fr = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi) * tw)
		t.Fi = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr) * tw)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi += t.Fi
		t.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fi
		t.Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi += t.Fi
		t.Fr = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr) * tw)
		t.Fi = float32(-((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr) * tw)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi += t.Fi
		Fout = Fout + uintptr(8)*8
		goto _1
	_1:
		;
		i = i + 1
	}
}

func kf_bfly4(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout_beg, tw1, tw2, tw3, v3, v4 uintptr
	var i, j, m2, m3 int32
	var scratch [6]OpusT_kiss_fft_cpx
	var scratch0, scratch1 OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _, _, _ = Fout_beg, i, j, m2, m3, scratch, scratch0, scratch1, tw1, tw2, tw3, v3, v4
	if m == int32(1) {
		/* Degenerate case where all the twiddles are 1. */
		i = 0
		for {
			if !(i < N) {
				break
			}
			scratch0.Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr
			scratch0.Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi
			scratch1.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr
			scratch1.Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch1.Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch1.Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch1.Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch1.Fi
			scratch1.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr
			scratch1.Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr = scratch0.Fr + scratch1.Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi = scratch0.Fi - scratch1.Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr = scratch0.Fr - scratch1.Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi = scratch0.Fi + scratch1.Fr
			Fout = Fout + uintptr(4)*8
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		m2 = int32(2) * m
		m3 = int32(3) * m
		Fout_beg = Fout
		i = 0
		for {
			if !(i < N) {
				break
			}
			Fout = Fout_beg + uintptr(i*mm)*8
			v4 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
			tw1 = v4
			v3 = v4
			tw2 = v3
			tw3 = v3
			/* m is guaranteed to be a multiple of 4. */
			j = 0
			for {
				if !(j < m) {
					break
				}
				scratch[0].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi)
				scratch[0].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr)
				scratch[int32(1)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi)
				scratch[int32(1)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr)
				scratch[int32(2)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fi)
				scratch[int32(2)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fr)
				scratch[int32(5)].Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(1)].Fr
				scratch[int32(5)].Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(1)].Fi
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(1)].Fr
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(1)].Fi
				scratch[int32(3)].Fr = scratch[0].Fr + scratch[int32(2)].Fr
				scratch[int32(3)].Fi = scratch[0].Fi + scratch[int32(2)].Fi
				scratch[int32(4)].Fr = scratch[0].Fr - scratch[int32(2)].Fr
				scratch[int32(4)].Fi = scratch[0].Fi - scratch[int32(2)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(3)].Fr
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(3)].Fi
				tw1 = tw1 + uintptr(fstride)*8
				tw2 = tw2 + uintptr(fstride*uint64(2))*8
				tw3 = tw3 + uintptr(fstride*uint64(3))*8
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
				Fout += 8
				goto _5
			_5:
				;
				j = j + 1
			}
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func kf_bfly3(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout_beg, tw1, tw2, v2 uintptr
	var epi3 OpusT_kiss_twiddle_cpx
	var i int32
	var k, m2, v3 OpusT_size_t
	var scratch [5]OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _ = Fout_beg, epi3, i, k, m2, scratch, tw1, tw2, v2, v3
	m2 = libc.Uint64FromInt32(int32(2) * m)
	Fout_beg = Fout
	epi3 = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout = Fout_beg + uintptr(i*mm)*8
		v2 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
		tw2 = v2
		tw1 = v2
		/* For non-custom modes, m is guaranteed to be a multiple of 4. */
		k = libc.Uint64FromInt32(m)
		for {
			scratch[int32(1)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi)
			scratch[int32(1)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr)
			scratch[int32(2)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi)
			scratch[int32(2)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr)
			scratch[int32(3)].Fr = scratch[int32(1)].Fr + scratch[int32(2)].Fr
			scratch[int32(3)].Fi = scratch[int32(1)].Fi + scratch[int32(2)].Fi
			scratch[0].Fr = scratch[int32(1)].Fr - scratch[int32(2)].Fr
			scratch[0].Fi = scratch[int32(1)].Fi - scratch[int32(2)].Fi
			tw1 = tw1 + uintptr(fstride)*8
			tw2 = tw2 + uintptr(fstride*uint64(2))*8
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - float32(scratch[int32(3)].Fr*libc.Float32FromFloat32(0.5))
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - float32(scratch[int32(3)].Fi*libc.Float32FromFloat32(0.5))
			scratch[0].Fr *= epi3.Fi
			scratch[0].Fi *= epi3.Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr + scratch[0].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi - scratch[0].Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr - scratch[0].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi + scratch[0].Fr
			Fout += 8
			goto _4
		_4:
			;
			k = k - 1
			v3 = k
			if !(v3 != 0) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func kf_bfly5(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout0, Fout1, Fout2, Fout3, Fout4, Fout_beg, tw uintptr
	var i, u int32
	var scratch [13]OpusT_kiss_fft_cpx
	var ya, yb OpusT_kiss_twiddle_cpx
	_, _, _, _, _, _, _, _, _, _, _, _ = Fout0, Fout1, Fout2, Fout3, Fout4, Fout_beg, i, scratch, tw, u, ya, yb
	Fout_beg = Fout
	ya = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	yb = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*uint64(2)*libc.Uint64FromInt32(m))*8))
	tw = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout = Fout_beg + uintptr(i*mm)*8
		Fout0 = Fout
		Fout1 = Fout0 + uintptr(m)*8
		Fout2 = Fout0 + uintptr(int32(2)*m)*8
		Fout3 = Fout0 + uintptr(int32(3)*m)*8
		Fout4 = Fout0 + uintptr(int32(4)*m)*8
		/* For non-custom modes, m is guaranteed to be a multiple of 4. */
		u = 0
		for {
			if !(u < m) {
				break
			}
			scratch[0] = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0))
			scratch[int32(1)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi)
			scratch[int32(1)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr)
			scratch[int32(2)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi)
			scratch[int32(2)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr)
			scratch[int32(3)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi)
			scratch[int32(3)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr)
			scratch[int32(4)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi)
			scratch[int32(4)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr)
			scratch[int32(7)].Fr = scratch[int32(1)].Fr + scratch[int32(4)].Fr
			scratch[int32(7)].Fi = scratch[int32(1)].Fi + scratch[int32(4)].Fi
			scratch[int32(10)].Fr = scratch[int32(1)].Fr - scratch[int32(4)].Fr
			scratch[int32(10)].Fi = scratch[int32(1)].Fi - scratch[int32(4)].Fi
			scratch[int32(8)].Fr = scratch[int32(2)].Fr + scratch[int32(3)].Fr
			scratch[int32(8)].Fi = scratch[int32(2)].Fi + scratch[int32(3)].Fi
			scratch[int32(9)].Fr = scratch[int32(2)].Fr - scratch[int32(3)].Fr
			scratch[int32(9)].Fi = scratch[int32(2)].Fi - scratch[int32(3)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fr + (scratch[int32(7)].Fr + scratch[int32(8)].Fr)
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fi + (scratch[int32(7)].Fi + scratch[int32(8)].Fi)
			scratch[int32(5)].Fr = scratch[0].Fr + (float32(scratch[int32(7)].Fr*ya.Fr) + float32(scratch[int32(8)].Fr*yb.Fr))
			scratch[int32(5)].Fi = scratch[0].Fi + (float32(scratch[int32(7)].Fi*ya.Fr) + float32(scratch[int32(8)].Fi*yb.Fr))
			scratch[int32(6)].Fr = float32(scratch[int32(10)].Fi*ya.Fi) + float32(scratch[int32(9)].Fi*yb.Fi)
			scratch[int32(6)].Fi = -(float32(scratch[int32(10)].Fr*ya.Fi) + float32(scratch[int32(9)].Fr*yb.Fi))
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr = scratch[int32(5)].Fr - scratch[int32(6)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi = scratch[int32(5)].Fi - scratch[int32(6)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr = scratch[int32(5)].Fr + scratch[int32(6)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi = scratch[int32(5)].Fi + scratch[int32(6)].Fi
			scratch[int32(11)].Fr = scratch[0].Fr + (float32(scratch[int32(7)].Fr*yb.Fr) + float32(scratch[int32(8)].Fr*ya.Fr))
			scratch[int32(11)].Fi = scratch[0].Fi + (float32(scratch[int32(7)].Fi*yb.Fr) + float32(scratch[int32(8)].Fi*ya.Fr))
			scratch[int32(12)].Fr = float32(scratch[int32(9)].Fi*ya.Fi) - float32(scratch[int32(10)].Fi*yb.Fi)
			scratch[int32(12)].Fi = float32(scratch[int32(10)].Fr*yb.Fi) - float32(scratch[int32(9)].Fr*ya.Fi)
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = scratch[int32(11)].Fr + scratch[int32(12)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = scratch[int32(11)].Fi + scratch[int32(12)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr = scratch[int32(11)].Fr - scratch[int32(12)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi = scratch[int32(11)].Fi - scratch[int32(12)].Fi
			Fout0 += 8
			Fout1 += 8
			Fout2 += 8
			Fout3 += 8
			Fout4 += 8
			goto _2
		_2:
			;
			u = u + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_opus_fft_impl(tls *libc.TLS, st uintptr, fout uintptr) {
	var L, i, m, m2, p, shift, v1 int32
	var fstride [8]int32
	_, _, _, _, _, _, _, _ = L, fstride, i, m, m2, p, shift, v1
	/* st->shift can be -1 */
	if (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fshift > 0 {
		v1 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fshift
	} else {
		v1 = 0
	}
	shift = v1
	fstride[0] = int32(1)
	L = 0
	for cond := true; cond; cond = m != int32(1) {
		p = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L)*2)))
		m = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L+int32(1))*2)))
		fstride[L+int32(1)] = fstride[L] * p
		L = L + 1
	}
	m = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L-int32(1))*2)))
	i = L - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		if i != 0 {
			m2 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*i-int32(1))*2)))
		} else {
			m2 = int32(1)
		}
		switch int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*i)*2))) {
		case int32(2):
			kf_bfly2(tls, fout, m, fstride[i])
		case int32(4):
			kf_bfly4(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
		case int32(3):
			kf_bfly3(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
		case int32(5):
			kf_bfly5(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
			break
		}
		m = m2
		goto _2
	_2:
		;
		i = i - 1
	}
}

func Opus_opus_fft_c(tls *libc.TLS, st uintptr, fin uintptr, fout uintptr) {
	var i int32
	var scale OpusT_celt_coef
	var x OpusT_kiss_fft_cpx
	_, _, _ = i, scale, x
	scale = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fscale
	if !(fin != fout) {
		Opus_celt_fatal(tls, __ccgo_ts+3512, __ccgo_ts+3493, int32(626))
	}
	/* Bit-reverse the input */
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		x = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fin + uintptr(i)*8))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8))).Fr = float32(x.Fr * scale)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8))).Fi = float32(x.Fi * scale)
		goto _1
	_1:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, st, fout)
}

func Opus_opus_ifft_c(tls *libc.TLS, st uintptr, fin uintptr, fout uintptr) {
	var i int32
	_ = i
	if !(fin != fout) {
		Opus_celt_fatal(tls, __ccgo_ts+3512, __ccgo_ts+3493, int32(641))
	}
	/* Bit-reverse the input */
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8)) = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fin + uintptr(i)*8))
		goto _1
	_1:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi
		goto _2
	_2:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, st, fout)
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi
		goto _3
	_3:
		;
		i = i + 1
	}
}

const CELT_SIG_SCALE5 = 32768

var log2_x_norm_coeff6 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff6 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

// C documentation
//
//	/*Compute floor(sqrt(_val)) with exact arithmetic.
//	  _val must be greater than 0.
//	  This has been tested on all possible 32-bit inputs greater than 0.*/
func Opus_isqrt32(tls *libc.TLS, _val OpusT_opus_uint32) (r uint32) {
	var b, g uint32
	var bshift int32
	var t OpusT_opus_uint32
	_, _, _, _ = b, bshift, g, t
	/*Uses the second method from
	   http://www.azillionmonkeys.com/qed/sqroot.html
	  The main idea is to search for the largest binary digit b such that
	   (g+b)*(g+b) <= _val, and add it to the solution g.*/
	g = uint32(0)
	bshift = (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, _val) - int32(1)) >> int32(1)
	b = uint32(1) << bshift
	for cond := true; cond; cond = bshift >= 0 {
		t = (g<<libc.Int32FromInt32(1) + b) << bshift
		if t <= _val {
			g = g + b
			_val = _val - t
		}
		b = b >> uint32(1)
		bshift = bshift - 1
	}
	return g
}

func Opus_celt_float2int16_c(tls *libc.TLS, in uintptr, out uintptr, cnt int32) {
	var i int32
	var v2, v3, v4 float32
	var v5 OpusT_opus_int16
	_, _, _, _, _ = i, v2, v3, v4, v5
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		v2 = *(*float32)(unsafe.Pointer(in + uintptr(i)*4))
		v2 = float32(v2 * libc.Float32FromFloat32(32768))
		if v2 > float32(-libc.Int32FromInt32(32768)) {
			v3 = v2
		} else {
			v3 = float32(-libc.Int32FromInt32(32768))
		}
		v2 = v3
		if v2 < float32(libc.Int32FromInt32(32767)) {
			v4 = v2
		} else {
			v4 = float32(libc.Int32FromInt32(32767))
		}
		v2 = v4
		v5 = int16(libc.Xlrintf(tls, v2))
		goto _6
	_6:
		*(*int16)(unsafe.Pointer(out + uintptr(i)*2)) = v5
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_opus_limit2_checkwithin1_c(tls *libc.TLS, samples uintptr, cnt int32) (r int32) {
	var clippedVal, v2 float32
	var i int32
	_, _, _ = clippedVal, i, v2
	if cnt <= 0 {
		return int32(1)
	}
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		clippedVal = *(*float32)(unsafe.Pointer(samples + uintptr(i)*4))
		if -libc.Float32FromFloat32(2) > clippedVal {
			v2 = -libc.Float32FromFloat32(2)
		} else {
			v2 = clippedVal
		}
		clippedVal = v2
		if libc.Float32FromFloat32(2) < clippedVal {
			v2 = libc.Float32FromFloat32(2)
		} else {
			v2 = clippedVal
		}
		clippedVal = v2
		*(*float32)(unsafe.Pointer(samples + uintptr(i)*4)) = clippedVal
		goto _1
	_1:
		;
		i = i + 1
	}
	/* C implementation can't provide quick hint. Assume it might exceed -1/+1. */
	return 0
}

const CELT_SIG_SCALE6 = "32768.f"
const EC_CODE_BITS = 32
const EC_SYM_BITS = 8
const _mfrngcode_H = 1

/* Copyright (c) 2001-2008 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2001-2011 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* (C) COPYRIGHT 1994-2002 Xiph.Org Foundation */
/* Modified by Jean-Marc Valin */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* opus_types.h based on ogg_types.h from libogg */

/**
  @file opus_types.h
  @brief Opus reference implementation types
*/
/* Copyright (c) 2010-2011 Xiph.Org Foundation, Skype Limited
   Written by Jean-Marc Valin and Koen Vos */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @file opus_defines.h
 * @brief Opus reference implementation constants
 */

/*Constants used by the entropy encoder/decoder.*/

/*The number of bits to output at a time.*/
/*The total number of bits in each of the state registers.*/
/*The maximum symbol value.*/
/*Bits to shift by to move a symbol into the high-order position.*/
/*Carry bit of the high-order range symbol.*/
/*Low-order bit of the high-order range symbol.*/
/*The number of bits available for the last, partial symbol in the code field.*/

/*A range decoder.
  This is an entropy decoder based upon \cite{Mar79}, which is itself a
   rediscovery of the FIFO arithmetic code introduced by \cite{Pas76}.
  It is very similar to arithmetic encoding, except that encoding is done with
   digits in any base, instead of with bits, and so it is faster when using
   larger bases (i.e.: a byte).
  The author claims an average waste of $\frac{1}{2}\log_b(2b)$ bits, where $b$
   is the base, longer than the theoretical optimum, but to my knowledge there
   is no published justification for this claim.
  This only seems true when using near-infinite precision arithmetic so that
   the process is carried out with no rounding errors.

  An excellent description of implementation details is available at
   http://www.arturocampos.com/ac_range.html
  A recent work \cite{MNW98} which proposes several changes to arithmetic
   encoding for efficiency actually re-discovers many of the principles
   behind range encoding, and presents a good theoretical analysis of them.

  End of stream is handled by writing out the smallest number of bits that
   ensures that the stream will be correctly decoded regardless of the value of
   any subsequent bits.
  ec_tell() can be used to determine how many bits were needed to decode
   all the symbols thus far; other data can be packed in the remaining bits of
   the input buffer.
  @PHDTHESIS{Pas76,
    author="Richard Clark Pasco",
    title="Source coding algorithms for fast data compression",
    school="Dept. of Electrical Engineering, Stanford University",
    address="Stanford, CA",
    month=May,
    year=1976
  }
  @INPROCEEDINGS{Mar79,
   author="Martin, G.N.N.",
   title="Range encoding: an algorithm for removing redundancy from a digitised
    message",
   booktitle="Video & Data Recording Conference",
   year=1979,
   address="Southampton",
   month=Jul
  }
  @ARTICLE{MNW98,
   author="Alistair Moffat and Radford Neal and Ian H. Witten",
   title="Arithmetic Coding Revisited",
   journal="{ACM} Transactions on Information Systems",
   year=1998,
   volume=16,
   number=3,
   pages="256--294",
   month=Jul,
   URL="http://www.stanford.edu/class/ee398a/handouts/papers/Moffat98ArithmCoding.pdf"
  }*/

func ec_read_byte(tls *libc.TLS, _this uintptr) (r int32) {
	var v1 int32
	var v2 OpusT_opus_uint32
	var v3 uintptr
	_, _, _ = v1, v2, v3
	if (*OpusT_ec_dec)(unsafe.Pointer(_this)).Foffs < (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage {
		v3 = _this + 28
		v2 = *(*OpusT_opus_uint32)(unsafe.Pointer(v3))
		*(*OpusT_opus_uint32)(unsafe.Pointer(v3)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v3)) + 1
		v1 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf + uintptr(v2))))
	} else {
		v1 = 0
	}
	return v1
}

func ec_read_byte_from_end(tls *libc.TLS, _this uintptr) (r int32) {
	var v1 int32
	var v2 OpusT_opus_uint32
	var v3 uintptr
	_, _, _ = v1, v2, v3
	if (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_offs < (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage {
		v3 = _this + 12
		*(*OpusT_opus_uint32)(unsafe.Pointer(v3)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v3)) + 1
		v2 = *(*OpusT_opus_uint32)(unsafe.Pointer(v3))
		v1 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage-v2))))
	} else {
		v1 = 0
	}
	return v1
}

// C documentation
//
//	/*Normalizes the contents of val and rng so that rng lies entirely in the
//	   high-order symbol.*/
func ec_dec_normalize(tls *libc.TLS, _this uintptr) {
	var sym int32
	_ = sym
	/*If the range is too small, rescale it and input some bits.*/
	for (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>libc.Int32FromInt32(EC_SYM_BITS) {
		*(*int32)(unsafe.Pointer(_this + 24)) += int32(EC_SYM_BITS)
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) <<= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		/*Use up the remaining bits from our last symbol.*/
		sym = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem
		/*Read the next value from the input.*/
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem = ec_read_byte(tls, _this)
		/*Take the rest of the bits we need from this new symbol.*/
		sym = (sym<<int32(EC_SYM_BITS) | (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem) >> (libc.Int32FromInt32(EC_SYM_BITS) - ((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS) + libc.Int32FromInt32(1)))
		/*And subtract them from val, capped to be less than EC_CODE_TOP.*/
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = ((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval<<libc.Int32FromInt32(EC_SYM_BITS) + (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1))&libc.Uint32FromInt32(^sym)) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
	}
}

func Opus_ec_dec_init(tls *libc.TLS, _this uintptr, _buf uintptr, _storage OpusT_opus_uint32) {
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf = _buf
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage = _storage
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_offs = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits = 0
	/*This is the offset from which ec_tell() will subtract partial bits.
	  The final value after the ec_dec_normalize() call will be the same as in
	   the encoder, but we have to compensate for the bits that are added there.*/
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnbits_total = libc.Int32FromInt32(EC_CODE_BITS) + libc.Int32FromInt32(1) - (libc.Int32FromInt32(EC_CODE_BITS)-((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS)+libc.Int32FromInt32(1)))/libc.Int32FromInt32(EC_SYM_BITS)*libc.Int32FromInt32(EC_SYM_BITS)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Foffs = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = libc.Uint32FromUint32(1) << ((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS) + libc.Int32FromInt32(1))
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem = ec_read_byte(tls, _this)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng - uint32(1) - libc.Uint32FromInt32((*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem>>(libc.Int32FromInt32(EC_SYM_BITS)-((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS)+libc.Int32FromInt32(1))))
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Ferror1 = 0
	/*Normalize the interval.*/
	ec_dec_normalize(tls, _this)
}

func Opus_ec_decode(tls *libc.TLS, _this uintptr, _ft uint32) (r uint32) {
	var s uint32
	var v1, v2 OpusT_opus_uint32
	_, _, _ = s, v1, v2
	v1 = _ft
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng / v1
	goto _3
_3:
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext = v2
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval / (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext
	return _ft - (s + uint32(1) + (_ft-(s+uint32(1)))&libc.Uint32FromInt32(-libc.BoolInt32(_ft < s+libc.Uint32FromInt32(1))))
}

func Opus_ec_decode_bin(tls *libc.TLS, _this uintptr, _bits uint32) (r uint32) {
	var s uint32
	_ = s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng >> _bits
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval / (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext
	return uint32(1)<<_bits - (s + uint32(1) + (uint32(1)<<_bits-(s+uint32(1)))&libc.Uint32FromInt32(-libc.BoolInt32(libc.Uint32FromUint32(1)<<_bits < s+libc.Uint32FromUint32(1))))
}

func Opus_ec_dec_update(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _ft uint32) {
	var s OpusT_opus_uint32
	var v1 uint32
	_, _ = s, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext * (_ft - _fh)
	*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) -= s
	if _fl > uint32(0) {
		v1 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext * (_fh - _fl)
	} else {
		v1 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng - s
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = v1
	ec_dec_normalize(tls, _this)
}

// C documentation
//
//	/*The probability of having a "one" is 1/(1<<_logp).*/
func Opus_ec_dec_bit_logp(tls *libc.TLS, _this uintptr, _logp uint32) (r1 int32) {
	var d, r, s OpusT_opus_uint32
	var ret int32
	var v1 uint32
	_, _, _, _, _ = d, r, ret, s, v1
	r = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	s = r >> _logp
	ret = libc.BoolInt32(d < s)
	if !(ret != 0) {
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	}
	if ret != 0 {
		v1 = s
	} else {
		v1 = r - s
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = v1
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_icdf(tls *libc.TLS, _this uintptr, _icdf uintptr, _ftb uint32) (r1 int32) {
	var d, r, s, t OpusT_opus_uint32
	var ret, v1 int32
	_, _, _, _, _, _ = d, r, ret, s, t, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	r = s >> _ftb
	ret = -int32(1)
	for cond := true; cond; cond = d < s {
		t = s
		ret = ret + 1
		v1 = ret
		s = r * uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(v1))))
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = t - s
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_icdf16(tls *libc.TLS, _this uintptr, _icdf uintptr, _ftb uint32) (r1 int32) {
	var d, r, s, t OpusT_opus_uint32
	var ret, v1 int32
	_, _, _, _, _, _ = d, r, ret, s, t, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	r = s >> _ftb
	ret = -int32(1)
	for cond := true; cond; cond = d < s {
		t = s
		ret = ret + 1
		v1 = ret
		s = r * uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(v1)*2)))
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = t - s
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_uint(tls *libc.TLS, _this uintptr, _ft OpusT_opus_uint32) (r OpusT_opus_uint32) {
	var ft, s uint32
	var ftb int32
	var t OpusT_opus_uint32
	_, _, _, _ = ft, ftb, s, t
	/*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
	if !(_ft > libc.Uint32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+3569, __ccgo_ts+3593, int32(224))
	}
	_ft = _ft - 1
	ftb = libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, _ft)
	if ftb > int32(EC_UINT_BITS) {
		ftb = ftb - int32(EC_UINT_BITS)
		ft = _ft>>ftb + uint32(1)
		s = Opus_ec_decode(tls, _this, ft)
		Opus_ec_dec_update(tls, _this, s, s+uint32(1), ft)
		t = s<<ftb | Opus_ec_dec_bits(tls, _this, libc.Uint32FromInt32(ftb))
		if t <= _ft {
			return t
		}
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Ferror1 = int32(1)
		return _ft
	} else {
		_ft = _ft + 1
		s = Opus_ec_decode(tls, _this, _ft)
		Opus_ec_dec_update(tls, _this, s, s+uint32(1), _ft)
		return s
	}
	return r
}

func Opus_ec_dec_bits(tls *libc.TLS, _this uintptr, _bits uint32) (r OpusT_opus_uint32) {
	var available int32
	var ret OpusT_opus_uint32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _, _ = available, ret, window, v1
	window = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window
	available = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits
	if libc.Uint32FromInt32(available) < _bits {
		for cond := true; cond; cond = available <= libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT)-libc.Int32FromInt32(EC_SYM_BITS) {
			window = window | libc.Uint32FromInt32(ec_read_byte_from_end(tls, _this))<<available
			available = available + int32(EC_SYM_BITS)
		}
	}
	ret = window & (libc.Uint32FromInt32(1)<<_bits - uint32(1))
	window = window >> _bits
	available = libc.Int32FromUint32(uint32(available) - _bits)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window = window
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits = available
	v1 = _this + 24
	*(*int32)(unsafe.Pointer(v1)) = int32(uint32(*(*int32)(unsafe.Pointer(v1))) + _bits)
	return ret
}

var log2_x_norm_coeff7 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff7 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2003-2008 Jean-Marc Valin
   Copyright (c) 2007-2008 CSIRO
   Copyright (c) 2007-2009 Xiph.Org Foundation
   Written by Jean-Marc Valin */
/**
  @file arch.h
  @brief Various architecture definitions for CELT
*/
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*Although derived separately, the pulse vector coding scheme is equivalent to
   a Pyramid Vector Quantizer \cite{Fis86}.
  Some additional notes about an early version appear at
   https://people.xiph.org/~tterribe/notes/cwrs.html, but the codebook ordering
   and the definitions of some terms have evolved since that was written.

  The conversion from a pulse vector to an integer index (encoding) and back
   (decoding) is governed by two related functions, V(N,K) and U(N,K).

  V(N,K) = the number of combinations, with replacement, of N items, taken K
   at a time, when a sign bit is added to each item taken at least once (i.e.,
   the number of N-dimensional unit pulse vectors with K pulses).
  One way to compute this is via
    V(N,K) = K>0 ? sum(k=1...K,2**k*choose(N,k)*choose(K-1,k-1)) : 1,
   where choose() is the binomial function.
  A table of values for N<10 and K<10 looks like:
  V[10][10] = {
    {1,  0,   0,    0,    0,     0,     0,      0,      0,       0},
    {1,  2,   2,    2,    2,     2,     2,      2,      2,       2},
    {1,  4,   8,   12,   16,    20,    24,     28,     32,      36},
    {1,  6,  18,   38,   66,   102,   146,    198,    258,     326},
    {1,  8,  32,   88,  192,   360,   608,    952,   1408,    1992},
    {1, 10,  50,  170,  450,  1002,  1970,   3530,   5890,    9290},
    {1, 12,  72,  292,  912,  2364,  5336,  10836,  20256,   35436},
    {1, 14,  98,  462, 1666,  4942, 12642,  28814,  59906,  115598},
    {1, 16, 128,  688, 2816,  9424, 27008,  68464, 157184,  332688},
    {1, 18, 162,  978, 4482, 16722, 53154, 148626, 374274,  864146}
  };

  U(N,K) = the number of such combinations wherein N-1 objects are taken at
   most K-1 at a time.
  This is given by
    U(N,K) = sum(k=0...K-1,V(N-1,k))
           = K>0 ? (V(N-1,K-1) + V(N,K-1))/2 : 0.
  The latter expression also makes clear that U(N,K) is half the number of such
   combinations wherein the first object is taken at least once.
  Although it may not be clear from either of these definitions, U(N,K) is the
   natural function to work with when enumerating the pulse vector codebooks,
   not V(N,K).
  U(N,K) is not well-defined for N=0, but with the extension
    U(0,K) = K>0 ? 0 : 1,
   the function becomes symmetric: U(N,K) = U(K,N), with a similar table:
  U[10][10] = {
    {1, 0,  0,   0,    0,    0,     0,     0,      0,      0},
    {0, 1,  1,   1,    1,    1,     1,     1,      1,      1},
    {0, 1,  3,   5,    7,    9,    11,    13,     15,     17},
    {0, 1,  5,  13,   25,   41,    61,    85,    113,    145},
    {0, 1,  7,  25,   63,  129,   231,   377,    575,    833},
    {0, 1,  9,  41,  129,  321,   681,  1289,   2241,   3649},
    {0, 1, 11,  61,  231,  681,  1683,  3653,   7183,  13073},
    {0, 1, 13,  85,  377, 1289,  3653,  8989,  19825,  40081},
    {0, 1, 15, 113,  575, 2241,  7183, 19825,  48639, 108545},
    {0, 1, 17, 145,  833, 3649, 13073, 40081, 108545, 265729}
  };

  With this extension, V(N,K) may be written in terms of U(N,K):
    V(N,K) = U(N,K) + U(N,K+1)
   for all N>=0, K>=0.
  Thus U(N,K+1) represents the number of combinations where the first element
   is positive or zero, and U(N,K) represents the number of combinations where
   it is negative.
  With a large enough table of U(N,K) values, we could write O(N) encoding
   and O(min(N*log(K),N+K)) decoding routines, but such a table would be
   prohibitively large for small embedded devices (K may be as large as 32767
   for small N, and N may be as large as 200).

  Both functions obey the same recurrence relation:
    V(N,K) = V(N-1,K) + V(N,K-1) + V(N-1,K-1),
    U(N,K) = U(N-1,K) + U(N,K-1) + U(N-1,K-1),
   for all N>0, K>0, with different initial conditions at N=0 or K=0.
  This allows us to construct a row of one of the tables above given the
   previous row or the next row.
  Thus we can derive O(NK) encoding and decoding routines with O(K) memory
   using only addition and subtraction.

  When encoding, we build up from the U(2,K) row and work our way forwards.
  When decoding, we need to start at the U(N,K) row and work our way backwards,
   which requires a means of computing U(N,K).
  U(N,K) may be computed from two previous values with the same N:
    U(N,K) = ((2*N-1)*U(N,K-1) - U(N,K-2))/(K-1) + U(N,K-2)
   for all N>1, and since U(N,K) is symmetric, a similar relation holds for two
   previous values with the same K:
    U(N,K>1) = ((2*K-1)*U(N-1,K) - U(N-2,K))/(N-1) + U(N-2,K)
   for all K>1.
  This allows us to construct an arbitrary row of the U(N,K) table by starting
   with the first two values, which are constants.
  This saves roughly 2/3 the work in our O(NK) decoding routine, but costs O(K)
   multiplications.
  Similar relations can be derived for V(N,K), but are not used here.

  For N>0 and K>0, U(N,K) and V(N,K) take on the form of an (N-1)-degree
   polynomial for fixed N.
  The first few are
    U(1,K) = 1,
    U(2,K) = 2*K-1,
    U(3,K) = (2*K-2)*K+1,
    U(4,K) = (((4*K-6)*K+8)*K-3)/3,
    U(5,K) = ((((2*K-4)*K+10)*K-8)*K+3)/3,
   and
    V(1,K) = 2,
    V(2,K) = 4*K,
    V(3,K) = 4*K*K+2,
    V(4,K) = 8*(K*K+2)*K/3,
    V(5,K) = ((4*K*K+20)*K*K+6)/3,
   for all K>0.
  This allows us to derive O(N) encoding and O(N*log(K)) decoding routines for
   small N (and indeed decoding is also O(N) for N<3).

  @ARTICLE{Fis86,
    author="Thomas R. Fischer",
    title="A Pyramid Vector Quantizer",
    journal="IEEE Transactions on Information Theory",
    volume="IT-32",
    number=4,
    pages="568--583",
    month=Jul,
    year=1986
  }*/

/*U(N,K) = U(K,N) := N>0?K>0?U(N-1,K)+U(N,K-1)+U(N-1,K-1):0:K>0?1:0*/
/*V(N,K) := U(N,K)+U(N,K+1) = the number of PVQ codewords for a band of size N
  with K pulses allocated to it.*/

// C documentation
//
//	/*For each V(N,K) supported, we will access element U(min(N,K+1),max(N,K+1)).
//	  Thus, the number of entries in row I is the larger of the maximum number of
//	   pulses we will ever allocate for a given N=I (K=128, or however many fit in
//	   32 bits, whichever is smaller), plus one, and the maximum N for which
//	   K=I-1 pulses fit in 32 bits.
//	  The largest band size in an Opus Custom mode is 208.
//	  Otherwise, we can limit things to the set of N which can be achieved by
//	   splitting a band from a standard Opus mode: 176, 144, 96, 88, 72, 64, 48,
//	   44, 36, 32, 24, 22, 18, 16, 8, 4, 2).*/
var CELT_PVQ_U_DATA = [1272]OpusT_opus_uint32{
	0:    uint32(1),
	177:  uint32(1),
	178:  uint32(1),
	179:  uint32(1),
	180:  uint32(1),
	181:  uint32(1),
	182:  uint32(1),
	183:  uint32(1),
	184:  uint32(1),
	185:  uint32(1),
	186:  uint32(1),
	187:  uint32(1),
	188:  uint32(1),
	189:  uint32(1),
	190:  uint32(1),
	191:  uint32(1),
	192:  uint32(1),
	193:  uint32(1),
	194:  uint32(1),
	195:  uint32(1),
	196:  uint32(1),
	197:  uint32(1),
	198:  uint32(1),
	199:  uint32(1),
	200:  uint32(1),
	201:  uint32(1),
	202:  uint32(1),
	203:  uint32(1),
	204:  uint32(1),
	205:  uint32(1),
	206:  uint32(1),
	207:  uint32(1),
	208:  uint32(1),
	209:  uint32(1),
	210:  uint32(1),
	211:  uint32(1),
	212:  uint32(1),
	213:  uint32(1),
	214:  uint32(1),
	215:  uint32(1),
	216:  uint32(1),
	217:  uint32(1),
	218:  uint32(1),
	219:  uint32(1),
	220:  uint32(1),
	221:  uint32(1),
	222:  uint32(1),
	223:  uint32(1),
	224:  uint32(1),
	225:  uint32(1),
	226:  uint32(1),
	227:  uint32(1),
	228:  uint32(1),
	229:  uint32(1),
	230:  uint32(1),
	231:  uint32(1),
	232:  uint32(1),
	233:  uint32(1),
	234:  uint32(1),
	235:  uint32(1),
	236:  uint32(1),
	237:  uint32(1),
	238:  uint32(1),
	239:  uint32(1),
	240:  uint32(1),
	241:  uint32(1),
	242:  uint32(1),
	243:  uint32(1),
	244:  uint32(1),
	245:  uint32(1),
	246:  uint32(1),
	247:  uint32(1),
	248:  uint32(1),
	249:  uint32(1),
	250:  uint32(1),
	251:  uint32(1),
	252:  uint32(1),
	253:  uint32(1),
	254:  uint32(1),
	255:  uint32(1),
	256:  uint32(1),
	257:  uint32(1),
	258:  uint32(1),
	259:  uint32(1),
	260:  uint32(1),
	261:  uint32(1),
	262:  uint32(1),
	263:  uint32(1),
	264:  uint32(1),
	265:  uint32(1),
	266:  uint32(1),
	267:  uint32(1),
	268:  uint32(1),
	269:  uint32(1),
	270:  uint32(1),
	271:  uint32(1),
	272:  uint32(1),
	273:  uint32(1),
	274:  uint32(1),
	275:  uint32(1),
	276:  uint32(1),
	277:  uint32(1),
	278:  uint32(1),
	279:  uint32(1),
	280:  uint32(1),
	281:  uint32(1),
	282:  uint32(1),
	283:  uint32(1),
	284:  uint32(1),
	285:  uint32(1),
	286:  uint32(1),
	287:  uint32(1),
	288:  uint32(1),
	289:  uint32(1),
	290:  uint32(1),
	291:  uint32(1),
	292:  uint32(1),
	293:  uint32(1),
	294:  uint32(1),
	295:  uint32(1),
	296:  uint32(1),
	297:  uint32(1),
	298:  uint32(1),
	299:  uint32(1),
	300:  uint32(1),
	301:  uint32(1),
	302:  uint32(1),
	303:  uint32(1),
	304:  uint32(1),
	305:  uint32(1),
	306:  uint32(1),
	307:  uint32(1),
	308:  uint32(1),
	309:  uint32(1),
	310:  uint32(1),
	311:  uint32(1),
	312:  uint32(1),
	313:  uint32(1),
	314:  uint32(1),
	315:  uint32(1),
	316:  uint32(1),
	317:  uint32(1),
	318:  uint32(1),
	319:  uint32(1),
	320:  uint32(1),
	321:  uint32(1),
	322:  uint32(1),
	323:  uint32(1),
	324:  uint32(1),
	325:  uint32(1),
	326:  uint32(1),
	327:  uint32(1),
	328:  uint32(1),
	329:  uint32(1),
	330:  uint32(1),
	331:  uint32(1),
	332:  uint32(1),
	333:  uint32(1),
	334:  uint32(1),
	335:  uint32(1),
	336:  uint32(1),
	337:  uint32(1),
	338:  uint32(1),
	339:  uint32(1),
	340:  uint32(1),
	341:  uint32(1),
	342:  uint32(1),
	343:  uint32(1),
	344:  uint32(1),
	345:  uint32(1),
	346:  uint32(1),
	347:  uint32(1),
	348:  uint32(1),
	349:  uint32(1),
	350:  uint32(1),
	351:  uint32(1),
	352:  uint32(1),
	353:  uint32(3),
	354:  uint32(5),
	355:  uint32(7),
	356:  uint32(9),
	357:  uint32(11),
	358:  uint32(13),
	359:  uint32(15),
	360:  uint32(17),
	361:  uint32(19),
	362:  uint32(21),
	363:  uint32(23),
	364:  uint32(25),
	365:  uint32(27),
	366:  uint32(29),
	367:  uint32(31),
	368:  uint32(33),
	369:  uint32(35),
	370:  uint32(37),
	371:  uint32(39),
	372:  uint32(41),
	373:  uint32(43),
	374:  uint32(45),
	375:  uint32(47),
	376:  uint32(49),
	377:  uint32(51),
	378:  uint32(53),
	379:  uint32(55),
	380:  uint32(57),
	381:  uint32(59),
	382:  uint32(61),
	383:  uint32(63),
	384:  uint32(65),
	385:  uint32(67),
	386:  uint32(69),
	387:  uint32(71),
	388:  uint32(73),
	389:  uint32(75),
	390:  uint32(77),
	391:  uint32(79),
	392:  uint32(81),
	393:  uint32(83),
	394:  uint32(85),
	395:  uint32(87),
	396:  uint32(89),
	397:  uint32(91),
	398:  uint32(93),
	399:  uint32(95),
	400:  uint32(97),
	401:  uint32(99),
	402:  uint32(101),
	403:  uint32(103),
	404:  uint32(105),
	405:  uint32(107),
	406:  uint32(109),
	407:  uint32(111),
	408:  uint32(113),
	409:  uint32(115),
	410:  uint32(117),
	411:  uint32(119),
	412:  uint32(121),
	413:  uint32(123),
	414:  uint32(125),
	415:  uint32(127),
	416:  uint32(129),
	417:  uint32(131),
	418:  uint32(133),
	419:  uint32(135),
	420:  uint32(137),
	421:  uint32(139),
	422:  uint32(141),
	423:  uint32(143),
	424:  uint32(145),
	425:  uint32(147),
	426:  uint32(149),
	427:  uint32(151),
	428:  uint32(153),
	429:  uint32(155),
	430:  uint32(157),
	431:  uint32(159),
	432:  uint32(161),
	433:  uint32(163),
	434:  uint32(165),
	435:  uint32(167),
	436:  uint32(169),
	437:  uint32(171),
	438:  uint32(173),
	439:  uint32(175),
	440:  uint32(177),
	441:  uint32(179),
	442:  uint32(181),
	443:  uint32(183),
	444:  uint32(185),
	445:  uint32(187),
	446:  uint32(189),
	447:  uint32(191),
	448:  uint32(193),
	449:  uint32(195),
	450:  uint32(197),
	451:  uint32(199),
	452:  uint32(201),
	453:  uint32(203),
	454:  uint32(205),
	455:  uint32(207),
	456:  uint32(209),
	457:  uint32(211),
	458:  uint32(213),
	459:  uint32(215),
	460:  uint32(217),
	461:  uint32(219),
	462:  uint32(221),
	463:  uint32(223),
	464:  uint32(225),
	465:  uint32(227),
	466:  uint32(229),
	467:  uint32(231),
	468:  uint32(233),
	469:  uint32(235),
	470:  uint32(237),
	471:  uint32(239),
	472:  uint32(241),
	473:  uint32(243),
	474:  uint32(245),
	475:  uint32(247),
	476:  uint32(249),
	477:  uint32(251),
	478:  uint32(253),
	479:  uint32(255),
	480:  uint32(257),
	481:  uint32(259),
	482:  uint32(261),
	483:  uint32(263),
	484:  uint32(265),
	485:  uint32(267),
	486:  uint32(269),
	487:  uint32(271),
	488:  uint32(273),
	489:  uint32(275),
	490:  uint32(277),
	491:  uint32(279),
	492:  uint32(281),
	493:  uint32(283),
	494:  uint32(285),
	495:  uint32(287),
	496:  uint32(289),
	497:  uint32(291),
	498:  uint32(293),
	499:  uint32(295),
	500:  uint32(297),
	501:  uint32(299),
	502:  uint32(301),
	503:  uint32(303),
	504:  uint32(305),
	505:  uint32(307),
	506:  uint32(309),
	507:  uint32(311),
	508:  uint32(313),
	509:  uint32(315),
	510:  uint32(317),
	511:  uint32(319),
	512:  uint32(321),
	513:  uint32(323),
	514:  uint32(325),
	515:  uint32(327),
	516:  uint32(329),
	517:  uint32(331),
	518:  uint32(333),
	519:  uint32(335),
	520:  uint32(337),
	521:  uint32(339),
	522:  uint32(341),
	523:  uint32(343),
	524:  uint32(345),
	525:  uint32(347),
	526:  uint32(349),
	527:  uint32(351),
	528:  uint32(13),
	529:  uint32(25),
	530:  uint32(41),
	531:  uint32(61),
	532:  uint32(85),
	533:  uint32(113),
	534:  uint32(145),
	535:  uint32(181),
	536:  uint32(221),
	537:  uint32(265),
	538:  uint32(313),
	539:  uint32(365),
	540:  uint32(421),
	541:  uint32(481),
	542:  uint32(545),
	543:  uint32(613),
	544:  uint32(685),
	545:  uint32(761),
	546:  uint32(841),
	547:  uint32(925),
	548:  uint32(1013),
	549:  uint32(1105),
	550:  uint32(1201),
	551:  uint32(1301),
	552:  uint32(1405),
	553:  uint32(1513),
	554:  uint32(1625),
	555:  uint32(1741),
	556:  uint32(1861),
	557:  uint32(1985),
	558:  uint32(2113),
	559:  uint32(2245),
	560:  uint32(2381),
	561:  uint32(2521),
	562:  uint32(2665),
	563:  uint32(2813),
	564:  uint32(2965),
	565:  uint32(3121),
	566:  uint32(3281),
	567:  uint32(3445),
	568:  uint32(3613),
	569:  uint32(3785),
	570:  uint32(3961),
	571:  uint32(4141),
	572:  uint32(4325),
	573:  uint32(4513),
	574:  uint32(4705),
	575:  uint32(4901),
	576:  uint32(5101),
	577:  uint32(5305),
	578:  uint32(5513),
	579:  uint32(5725),
	580:  uint32(5941),
	581:  uint32(6161),
	582:  uint32(6385),
	583:  uint32(6613),
	584:  uint32(6845),
	585:  uint32(7081),
	586:  uint32(7321),
	587:  uint32(7565),
	588:  uint32(7813),
	589:  uint32(8065),
	590:  uint32(8321),
	591:  uint32(8581),
	592:  uint32(8845),
	593:  uint32(9113),
	594:  uint32(9385),
	595:  uint32(9661),
	596:  uint32(9941),
	597:  uint32(10225),
	598:  uint32(10513),
	599:  uint32(10805),
	600:  uint32(11101),
	601:  uint32(11401),
	602:  uint32(11705),
	603:  uint32(12013),
	604:  uint32(12325),
	605:  uint32(12641),
	606:  uint32(12961),
	607:  uint32(13285),
	608:  uint32(13613),
	609:  uint32(13945),
	610:  uint32(14281),
	611:  uint32(14621),
	612:  uint32(14965),
	613:  uint32(15313),
	614:  uint32(15665),
	615:  uint32(16021),
	616:  uint32(16381),
	617:  uint32(16745),
	618:  uint32(17113),
	619:  uint32(17485),
	620:  uint32(17861),
	621:  uint32(18241),
	622:  uint32(18625),
	623:  uint32(19013),
	624:  uint32(19405),
	625:  uint32(19801),
	626:  uint32(20201),
	627:  uint32(20605),
	628:  uint32(21013),
	629:  uint32(21425),
	630:  uint32(21841),
	631:  uint32(22261),
	632:  uint32(22685),
	633:  uint32(23113),
	634:  uint32(23545),
	635:  uint32(23981),
	636:  uint32(24421),
	637:  uint32(24865),
	638:  uint32(25313),
	639:  uint32(25765),
	640:  uint32(26221),
	641:  uint32(26681),
	642:  uint32(27145),
	643:  uint32(27613),
	644:  uint32(28085),
	645:  uint32(28561),
	646:  uint32(29041),
	647:  uint32(29525),
	648:  uint32(30013),
	649:  uint32(30505),
	650:  uint32(31001),
	651:  uint32(31501),
	652:  uint32(32005),
	653:  uint32(32513),
	654:  uint32(33025),
	655:  uint32(33541),
	656:  uint32(34061),
	657:  uint32(34585),
	658:  uint32(35113),
	659:  uint32(35645),
	660:  uint32(36181),
	661:  uint32(36721),
	662:  uint32(37265),
	663:  uint32(37813),
	664:  uint32(38365),
	665:  uint32(38921),
	666:  uint32(39481),
	667:  uint32(40045),
	668:  uint32(40613),
	669:  uint32(41185),
	670:  uint32(41761),
	671:  uint32(42341),
	672:  uint32(42925),
	673:  uint32(43513),
	674:  uint32(44105),
	675:  uint32(44701),
	676:  uint32(45301),
	677:  uint32(45905),
	678:  uint32(46513),
	679:  uint32(47125),
	680:  uint32(47741),
	681:  uint32(48361),
	682:  uint32(48985),
	683:  uint32(49613),
	684:  uint32(50245),
	685:  uint32(50881),
	686:  uint32(51521),
	687:  uint32(52165),
	688:  uint32(52813),
	689:  uint32(53465),
	690:  uint32(54121),
	691:  uint32(54781),
	692:  uint32(55445),
	693:  uint32(56113),
	694:  uint32(56785),
	695:  uint32(57461),
	696:  uint32(58141),
	697:  uint32(58825),
	698:  uint32(59513),
	699:  uint32(60205),
	700:  uint32(60901),
	701:  uint32(61601),
	702:  uint32(63),
	703:  uint32(129),
	704:  uint32(231),
	705:  uint32(377),
	706:  uint32(575),
	707:  uint32(833),
	708:  uint32(1159),
	709:  uint32(1561),
	710:  uint32(2047),
	711:  uint32(2625),
	712:  uint32(3303),
	713:  uint32(4089),
	714:  uint32(4991),
	715:  uint32(6017),
	716:  uint32(7175),
	717:  uint32(8473),
	718:  uint32(9919),
	719:  uint32(11521),
	720:  uint32(13287),
	721:  uint32(15225),
	722:  uint32(17343),
	723:  uint32(19649),
	724:  uint32(22151),
	725:  uint32(24857),
	726:  uint32(27775),
	727:  uint32(30913),
	728:  uint32(34279),
	729:  uint32(37881),
	730:  uint32(41727),
	731:  uint32(45825),
	732:  uint32(50183),
	733:  uint32(54809),
	734:  uint32(59711),
	735:  uint32(64897),
	736:  uint32(70375),
	737:  uint32(76153),
	738:  uint32(82239),
	739:  uint32(88641),
	740:  uint32(95367),
	741:  uint32(102425),
	742:  uint32(109823),
	743:  uint32(117569),
	744:  uint32(125671),
	745:  uint32(134137),
	746:  uint32(142975),
	747:  uint32(152193),
	748:  uint32(161799),
	749:  uint32(171801),
	750:  uint32(182207),
	751:  uint32(193025),
	752:  uint32(204263),
	753:  uint32(215929),
	754:  uint32(228031),
	755:  uint32(240577),
	756:  uint32(253575),
	757:  uint32(267033),
	758:  uint32(280959),
	759:  uint32(295361),
	760:  uint32(310247),
	761:  uint32(325625),
	762:  uint32(341503),
	763:  uint32(357889),
	764:  uint32(374791),
	765:  uint32(392217),
	766:  uint32(410175),
	767:  uint32(428673),
	768:  uint32(447719),
	769:  uint32(467321),
	770:  uint32(487487),
	771:  uint32(508225),
	772:  uint32(529543),
	773:  uint32(551449),
	774:  uint32(573951),
	775:  uint32(597057),
	776:  uint32(620775),
	777:  uint32(645113),
	778:  uint32(670079),
	779:  uint32(695681),
	780:  uint32(721927),
	781:  uint32(748825),
	782:  uint32(776383),
	783:  uint32(804609),
	784:  uint32(833511),
	785:  uint32(863097),
	786:  uint32(893375),
	787:  uint32(924353),
	788:  uint32(956039),
	789:  uint32(988441),
	790:  uint32(1021567),
	791:  uint32(1055425),
	792:  uint32(1090023),
	793:  uint32(1125369),
	794:  uint32(1161471),
	795:  uint32(1198337),
	796:  uint32(1235975),
	797:  uint32(1274393),
	798:  uint32(1313599),
	799:  uint32(1353601),
	800:  uint32(1394407),
	801:  uint32(1436025),
	802:  uint32(1478463),
	803:  uint32(1521729),
	804:  uint32(1565831),
	805:  uint32(1610777),
	806:  uint32(1656575),
	807:  uint32(1703233),
	808:  uint32(1750759),
	809:  uint32(1799161),
	810:  uint32(1848447),
	811:  uint32(1898625),
	812:  uint32(1949703),
	813:  uint32(2001689),
	814:  uint32(2054591),
	815:  uint32(2108417),
	816:  uint32(2163175),
	817:  uint32(2218873),
	818:  uint32(2275519),
	819:  uint32(2333121),
	820:  uint32(2391687),
	821:  uint32(2451225),
	822:  uint32(2511743),
	823:  uint32(2573249),
	824:  uint32(2635751),
	825:  uint32(2699257),
	826:  uint32(2763775),
	827:  uint32(2829313),
	828:  uint32(2895879),
	829:  uint32(2963481),
	830:  uint32(3032127),
	831:  uint32(3101825),
	832:  uint32(3172583),
	833:  uint32(3244409),
	834:  uint32(3317311),
	835:  uint32(3391297),
	836:  uint32(3466375),
	837:  uint32(3542553),
	838:  uint32(3619839),
	839:  uint32(3698241),
	840:  uint32(3777767),
	841:  uint32(3858425),
	842:  uint32(3940223),
	843:  uint32(4023169),
	844:  uint32(4107271),
	845:  uint32(4192537),
	846:  uint32(4278975),
	847:  uint32(4366593),
	848:  uint32(4455399),
	849:  uint32(4545401),
	850:  uint32(4636607),
	851:  uint32(4729025),
	852:  uint32(4822663),
	853:  uint32(4917529),
	854:  uint32(5013631),
	855:  uint32(5110977),
	856:  uint32(5209575),
	857:  uint32(5309433),
	858:  uint32(5410559),
	859:  uint32(5512961),
	860:  uint32(5616647),
	861:  uint32(5721625),
	862:  uint32(5827903),
	863:  uint32(5935489),
	864:  uint32(6044391),
	865:  uint32(6154617),
	866:  uint32(6266175),
	867:  uint32(6379073),
	868:  uint32(6493319),
	869:  uint32(6608921),
	870:  uint32(6725887),
	871:  uint32(6844225),
	872:  uint32(6963943),
	873:  uint32(7085049),
	874:  uint32(7207551),
	875:  uint32(321),
	876:  uint32(681),
	877:  uint32(1289),
	878:  uint32(2241),
	879:  uint32(3649),
	880:  uint32(5641),
	881:  uint32(8361),
	882:  uint32(11969),
	883:  uint32(16641),
	884:  uint32(22569),
	885:  uint32(29961),
	886:  uint32(39041),
	887:  uint32(50049),
	888:  uint32(63241),
	889:  uint32(78889),
	890:  uint32(97281),
	891:  uint32(118721),
	892:  uint32(143529),
	893:  uint32(172041),
	894:  uint32(204609),
	895:  uint32(241601),
	896:  uint32(283401),
	897:  uint32(330409),
	898:  uint32(383041),
	899:  uint32(441729),
	900:  uint32(506921),
	901:  uint32(579081),
	902:  uint32(658689),
	903:  uint32(746241),
	904:  uint32(842249),
	905:  uint32(947241),
	906:  uint32(1061761),
	907:  uint32(1186369),
	908:  uint32(1321641),
	909:  uint32(1468169),
	910:  uint32(1626561),
	911:  uint32(1797441),
	912:  uint32(1981449),
	913:  uint32(2179241),
	914:  uint32(2391489),
	915:  uint32(2618881),
	916:  uint32(2862121),
	917:  uint32(3121929),
	918:  uint32(3399041),
	919:  uint32(3694209),
	920:  uint32(4008201),
	921:  uint32(4341801),
	922:  uint32(4695809),
	923:  uint32(5071041),
	924:  uint32(5468329),
	925:  uint32(5888521),
	926:  uint32(6332481),
	927:  uint32(6801089),
	928:  uint32(7295241),
	929:  uint32(7815849),
	930:  uint32(8363841),
	931:  uint32(8940161),
	932:  uint32(9545769),
	933:  uint32(10181641),
	934:  uint32(10848769),
	935:  uint32(11548161),
	936:  uint32(12280841),
	937:  uint32(13047849),
	938:  uint32(13850241),
	939:  uint32(14689089),
	940:  uint32(15565481),
	941:  uint32(16480521),
	942:  uint32(17435329),
	943:  uint32(18431041),
	944:  uint32(19468809),
	945:  uint32(20549801),
	946:  uint32(21675201),
	947:  uint32(22846209),
	948:  uint32(24064041),
	949:  uint32(25329929),
	950:  uint32(26645121),
	951:  uint32(28010881),
	952:  uint32(29428489),
	953:  uint32(30899241),
	954:  uint32(32424449),
	955:  uint32(34005441),
	956:  uint32(35643561),
	957:  uint32(37340169),
	958:  uint32(39096641),
	959:  uint32(40914369),
	960:  uint32(42794761),
	961:  uint32(44739241),
	962:  uint32(46749249),
	963:  uint32(48826241),
	964:  uint32(50971689),
	965:  uint32(53187081),
	966:  uint32(55473921),
	967:  uint32(57833729),
	968:  uint32(60268041),
	969:  uint32(62778409),
	970:  uint32(65366401),
	971:  uint32(68033601),
	972:  uint32(70781609),
	973:  uint32(73612041),
	974:  uint32(76526529),
	975:  uint32(79526721),
	976:  uint32(82614281),
	977:  uint32(85790889),
	978:  uint32(89058241),
	979:  uint32(92418049),
	980:  uint32(95872041),
	981:  uint32(99421961),
	982:  uint32(103069569),
	983:  uint32(106816641),
	984:  uint32(110664969),
	985:  uint32(114616361),
	986:  uint32(118672641),
	987:  uint32(122835649),
	988:  uint32(127107241),
	989:  uint32(131489289),
	990:  uint32(135983681),
	991:  uint32(140592321),
	992:  uint32(145317129),
	993:  uint32(150160041),
	994:  uint32(155123009),
	995:  uint32(160208001),
	996:  uint32(165417001),
	997:  uint32(170752009),
	998:  uint32(176215041),
	999:  uint32(181808129),
	1000: uint32(187533321),
	1001: uint32(193392681),
	1002: uint32(199388289),
	1003: uint32(205522241),
	1004: uint32(211796649),
	1005: uint32(218213641),
	1006: uint32(224775361),
	1007: uint32(231483969),
	1008: uint32(238341641),
	1009: uint32(245350569),
	1010: uint32(252512961),
	1011: uint32(259831041),
	1012: uint32(267307049),
	1013: uint32(274943241),
	1014: uint32(282741889),
	1015: uint32(290705281),
	1016: uint32(298835721),
	1017: uint32(307135529),
	1018: uint32(315607041),
	1019: uint32(324252609),
	1020: uint32(333074601),
	1021: uint32(342075401),
	1022: uint32(351257409),
	1023: uint32(360623041),
	1024: uint32(370174729),
	1025: uint32(379914921),
	1026: uint32(389846081),
	1027: uint32(399970689),
	1028: uint32(410291241),
	1029: uint32(420810249),
	1030: uint32(431530241),
	1031: uint32(442453761),
	1032: uint32(453583369),
	1033: uint32(464921641),
	1034: uint32(476471169),
	1035: uint32(488234561),
	1036: uint32(500214441),
	1037: uint32(512413449),
	1038: uint32(524834241),
	1039: uint32(537479489),
	1040: uint32(550351881),
	1041: uint32(563454121),
	1042: uint32(576788929),
	1043: uint32(590359041),
	1044: uint32(604167209),
	1045: uint32(618216201),
	1046: uint32(632508801),
	1047: uint32(1683),
	1048: uint32(3653),
	1049: uint32(7183),
	1050: uint32(13073),
	1051: uint32(22363),
	1052: uint32(36365),
	1053: uint32(56695),
	1054: uint32(85305),
	1055: uint32(124515),
	1056: uint32(177045),
	1057: uint32(246047),
	1058: uint32(335137),
	1059: uint32(448427),
	1060: uint32(590557),
	1061: uint32(766727),
	1062: uint32(982729),
	1063: uint32(1244979),
	1064: uint32(1560549),
	1065: uint32(1937199),
	1066: uint32(2383409),
	1067: uint32(2908411),
	1068: uint32(3522221),
	1069: uint32(4235671),
	1070: uint32(5060441),
	1071: uint32(6009091),
	1072: uint32(7095093),
	1073: uint32(8332863),
	1074: uint32(9737793),
	1075: uint32(11326283),
	1076: uint32(13115773),
	1077: uint32(15124775),
	1078: uint32(17372905),
	1079: uint32(19880915),
	1080: uint32(22670725),
	1081: uint32(25765455),
	1082: uint32(29189457),
	1083: uint32(32968347),
	1084: uint32(37129037),
	1085: uint32(41699767),
	1086: uint32(46710137),
	1087: uint32(52191139),
	1088: uint32(58175189),
	1089: uint32(64696159),
	1090: uint32(71789409),
	1091: uint32(79491819),
	1092: uint32(87841821),
	1093: uint32(96879431),
	1094: uint32(106646281),
	1095: uint32(117185651),
	1096: uint32(128542501),
	1097: uint32(140763503),
	1098: uint32(153897073),
	1099: uint32(167993403),
	1100: uint32(183104493),
	1101: uint32(199284183),
	1102: uint32(216588185),
	1103: uint32(235074115),
	1104: uint32(254801525),
	1105: uint32(275831935),
	1106: uint32(298228865),
	1107: uint32(322057867),
	1108: uint32(347386557),
	1109: uint32(374284647),
	1110: uint32(402823977),
	1111: uint32(433078547),
	1112: uint32(465124549),
	1113: uint32(499040399),
	1114: uint32(534906769),
	1115: uint32(572806619),
	1116: uint32(612825229),
	1117: uint32(655050231),
	1118: uint32(699571641),
	1119: uint32(746481891),
	1120: uint32(795875861),
	1121: uint32(847850911),
	1122: uint32(902506913),
	1123: uint32(959946283),
	1124: uint32(1020274013),
	1125: uint32(1083597703),
	1126: uint32(1150027593),
	1127: uint32(1219676595),
	1128: uint32(1292660325),
	1129: uint32(1369097135),
	1130: uint32(1449108145),
	1131: uint32(1532817275),
	1132: uint32(1620351277),
	1133: uint32(1711839767),
	1134: uint32(1807415257),
	1135: uint32(1907213187),
	1136: uint32(2011371957),
	1137: uint32(2120032959),
	1138: uint32(8989),
	1139: uint32(19825),
	1140: uint32(40081),
	1141: uint32(75517),
	1142: uint32(134245),
	1143: uint32(227305),
	1144: uint32(369305),
	1145: uint32(579125),
	1146: uint32(880685),
	1147: uint32(1303777),
	1148: uint32(1884961),
	1149: uint32(2668525),
	1150: uint32(3707509),
	1151: uint32(5064793),
	1152: uint32(6814249),
	1153: uint32(9041957),
	1154: uint32(11847485),
	1155: uint32(15345233),
	1156: uint32(19665841),
	1157: uint32(24957661),
	1158: uint32(31388293),
	1159: uint32(39146185),
	1160: uint32(48442297),
	1161: uint32(59511829),
	1162: uint32(72616013),
	1163: uint32(88043969),
	1164: uint32(106114625),
	1165: uint32(127178701),
	1166: uint32(151620757),
	1167: uint32(179861305),
	1168: uint32(212358985),
	1169: uint32(249612805),
	1170: uint32(292164445),
	1171: uint32(340600625),
	1172: uint32(395555537),
	1173: uint32(457713341),
	1174: uint32(527810725),
	1175: uint32(606639529),
	1176: uint32(695049433),
	1177: uint32(793950709),
	1178: uint32(904317037),
	1179: uint32(1027188385),
	1180: uint32(1163673953),
	1181: uint32(1314955181),
	1182: uint32(1482288821),
	1183: uint32(1667010073),
	1184: uint32(1870535785),
	1185: uint32(2094367717),
	1186: uint32(48639),
	1187: uint32(108545),
	1188: uint32(224143),
	1189: uint32(433905),
	1190: uint32(795455),
	1191: uint32(1392065),
	1192: uint32(2340495),
	1193: uint32(3800305),
	1194: uint32(5984767),
	1195: uint32(9173505),
	1196: uint32(13726991),
	1197: uint32(20103025),
	1198: uint32(28875327),
	1199: uint32(40754369),
	1200: uint32(56610575),
	1201: uint32(77500017),
	1202: uint32(104692735),
	1203: uint32(139703809),
	1204: uint32(184327311),
	1205: uint32(240673265),
	1206: uint32(311207743),
	1207: uint32(398796225),
	1208: uint32(506750351),
	1209: uint32(638878193),
	1210: uint32(799538175),
	1211: uint32(993696769),
	1212: uint32(1226990095),
	1213: uint32(1505789553),
	1214: uint32(1837271615),
	1215: uint32(2229491905),
	1216: uint32(265729),
	1217: uint32(598417),
	1218: uint32(1256465),
	1219: uint32(2485825),
	1220: uint32(4673345),
	1221: uint32(8405905),
	1222: uint32(14546705),
	1223: uint32(24331777),
	1224: uint32(39490049),
	1225: uint32(62390545),
	1226: uint32(96220561),
	1227: uint32(145198913),
	1228: uint32(214828609),
	1229: uint32(312193553),
	1230: uint32(446304145),
	1231: uint32(628496897),
	1232: uint32(872893441),
	1233: uint32(1196924561),
	1234: uint32(1621925137),
	1235: uint32(2173806145),
	1236: uint32(1462563),
	1237: uint32(3317445),
	1238: uint32(7059735),
	1239: uint32(14218905),
	1240: uint32(27298155),
	1241: uint32(50250765),
	1242: uint32(89129247),
	1243: uint32(152951073),
	1244: uint32(254831667),
	1245: uint32(413442773),
	1246: uint32(654862247),
	1247: uint32(1014889769),
	1248: uint32(1541911931),
	1249: uint32(2300409629),
	1250: uint32(3375210671),
	1251: uint32(8097453),
	1252: uint32(18474633),
	1253: uint32(39753273),
	1254: uint32(81270333),
	1255: uint32(158819253),
	1256: uint32(298199265),
	1257: uint32(540279585),
	1258: uint32(948062325),
	1259: uint32(1616336765),
	1260: uint32(45046719),
	1261: uint32(103274625),
	1262: uint32(224298231),
	1263: uint32(464387817),
	1264: uint32(921406335),
	1265: uint32(1759885185),
	1266: uint32(3248227095),
	1267: uint32(251595969),
	1268: uint32(579168825),
	1269: uint32(1267854873),
	1270: uint32(2653649025),
	1271: uint32(1409933619),
}

var CELT_PVQ_U_ROW = [15]uintptr{
	0:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(0)*4,
	1:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(176)*4,
	2:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(351)*4,
	3:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(525)*4,
	4:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(698)*4,
	5:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(870)*4,
	6:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1041)*4,
	7:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1131)*4,
	8:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1178)*4,
	9:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1207)*4,
	10: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1226)*4,
	11: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1240)*4,
	12: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1248)*4,
	13: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1254)*4,
	14: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1257)*4,
}

func icwrs(tls *libc.TLS, _n int32, _y uintptr) (r OpusT_opus_uint32) {
	var i OpusT_opus_uint32
	var j, k, v1, v2 int32
	_, _, _, _, _ = i, j, k, v1, v2
	if !(_n >= libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+3610, __ccgo_ts+3634, int32(448))
	}
	j = _n - int32(1)
	i = libc.BoolUint32(*(*int32)(unsafe.Pointer(_y + uintptr(j)*4)) < 0)
	k = libc.Xabs(tls, *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)))
	for cond := true; cond; cond = j > 0 {
		j = j - 1
		if _n-j < k {
			v1 = _n - j
		} else {
			v1 = k
		}
		if _n-j > k {
			v2 = _n - j
		} else {
			v2 = k
		}
		i = i + *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))
		k = k + libc.Xabs(tls, *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)))
		if *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)) < 0 {
			if _n-j < k+int32(1) {
				v1 = _n - j
			} else {
				v1 = k + int32(1)
			}
			if _n-j > k+int32(1) {
				v2 = _n - j
			} else {
				v2 = k + int32(1)
			}
			i = i + *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))
		}
	}
	return i
}

func Opus_encode_pulses(tls *libc.TLS, _y uintptr, _n int32, _k int32, _enc uintptr) {
	var v1, v2, v3, v4 int32
	_, _, _, _ = v1, v2, v3, v4
	if !(_k > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3649, __ccgo_ts+3634, int32(463))
	}
	if _n < _k {
		v1 = _n
	} else {
		v1 = _k
	}
	if _n > _k {
		v2 = _n
	} else {
		v2 = _k
	}
	if _n < _k+int32(1) {
		v3 = _n
	} else {
		v3 = _k + int32(1)
	}
	if _n > _k+int32(1) {
		v4 = _n
	} else {
		v4 = _k + int32(1)
	}
	Opus_ec_enc_uint(tls, _enc, icwrs(tls, _n, _y), *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))+*(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v3] + uintptr(v4)*4)))
}

func cwrsi(tls *libc.TLS, _n int32, _k int32, _i OpusT_opus_uint32, _y uintptr) (r OpusT_opus_val32) {
	var k0, s, v1 int32
	var p, q OpusT_opus_uint32
	var row, v3 uintptr
	var val OpusT_opus_int16
	var yy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _ = k0, p, q, row, s, val, yy, v1, v3
	yy = libc.Float32FromInt32(0)
	if !(_k > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3649, __ccgo_ts+3634, int32(473))
	}
	if !(_n > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+3672, __ccgo_ts+3634, int32(474))
	}
	for _n > int32(2) {
		/*Lots of pulses case:*/
		if _k >= _n {
			row = CELT_PVQ_U_ROW[_n]
			/*Are the pulses in this dimension negative?*/
			p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k+int32(1))*4))
			s = -libc.BoolInt32(_i >= p)
			_i = _i - p&libc.Uint32FromInt32(s)
			/*Count how many pulses were placed in this dimension.*/
			k0 = _k
			q = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_n)*4))
			if q > _i {
				_ = p > q
				_k = _n
				for cond := true; cond; cond = p > _i {
					_k = _k - 1
					v1 = _k
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(_n)*4))
				}
			} else {
				p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k)*4))
				for {
					if !(p > _i) {
						break
					}
					_k = _k - 1
					goto _2
				_2:
					;
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k)*4))
				}
			}
			_i = _i - p
			val = int16(k0 - _k + s ^ s)
			v3 = _y
			_y += 4
			*(*int32)(unsafe.Pointer(v3)) = int32(val)
			yy = yy + OpusT_opus_val32(float32(val)*float32(val))
		} else {
			/*Are there any pulses in this dimension at all?*/
			p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[_k] + uintptr(_n)*4))
			q = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[_k+int32(1)] + uintptr(_n)*4))
			if p <= _i && _i < q {
				_i = _i - p
				v3 = _y
				_y += 4
				*(*int32)(unsafe.Pointer(v3)) = 0
			} else {
				/*Are the pulses in this dimension negative?*/
				s = -libc.BoolInt32(_i >= q)
				_i = _i - q&libc.Uint32FromInt32(s)
				/*Count how many pulses were placed in this dimension.*/
				k0 = _k
				for cond := true; cond; cond = p > _i {
					_k = _k - 1
					v1 = _k
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(_n)*4))
				}
				_i = _i - p
				val = int16(k0 - _k + s ^ s)
				v3 = _y
				_y += 4
				*(*int32)(unsafe.Pointer(v3)) = int32(val)
				yy = yy + OpusT_opus_val32(float32(val)*float32(val))
			}
		}
		_n = _n - 1
	}
	/*_n==2*/
	p = libc.Uint32FromInt32(int32(2)*_k + int32(1))
	s = -libc.BoolInt32(_i >= p)
	_i = _i - p&libc.Uint32FromInt32(s)
	k0 = _k
	_k = libc.Int32FromUint32((_i + uint32(1)) >> int32(1))
	if _k != 0 {
		_i = _i - libc.Uint32FromInt32(int32(2)*_k-int32(1))
	}
	val = int16(k0 - _k + s ^ s)
	v3 = _y
	_y += 4
	*(*int32)(unsafe.Pointer(v3)) = int32(val)
	yy = yy + OpusT_opus_val32(float32(val)*float32(val))
	/*_n==1*/
	s = -libc.Int32FromUint32(_i)
	val = int16(_k + s ^ s)
	*(*int32)(unsafe.Pointer(_y)) = int32(val)
	yy = yy + OpusT_opus_val32(float32(val)*float32(val))
	return yy
}

func Opus_decode_pulses(tls *libc.TLS, _y uintptr, _n int32, _k int32, _dec uintptr) (r OpusT_opus_val32) {
	var v1, v2, v3, v4 int32
	_, _, _, _ = v1, v2, v3, v4
	if _n < _k {
		v1 = _n
	} else {
		v1 = _k
	}
	if _n > _k {
		v2 = _n
	} else {
		v2 = _k
	}
	if _n < _k+int32(1) {
		v3 = _n
	} else {
		v3 = _k + int32(1)
	}
	if _n > _k+int32(1) {
		v4 = _n
	} else {
		v4 = _k + int32(1)
	}
	return cwrsi(tls, _n, _k, Opus_ec_dec_uint(tls, _dec, *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))+*(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v3] + uintptr(v4)*4))), _y)
}

const CELT_SIG_SCALE7 = 32768
const DECODER_RESET_START = "rng"
const DECODE_BUFFER_SIZE = "DEC_PITCH_BUF_SIZE"
const FRAME_DRED = 5
const FRAME_NONE = 0
const FRAME_NORMAL = 1
const FRAME_PLC_NEURAL = 4
const FRAME_PLC_NOISE = 2
const FRAME_PLC_PERIODIC = 3
const PLC_PITCH_LAG_MAX = 720
const PLC_PITCH_LAG_MIN = 100
const PLC_UPDATE_FRAMES = 4
const Q15ONE1 = 1
const Q31ONE1 = 1
const VERY_SMALL1 = 1e-30
const qext_bytes = 0

type OpusT_OpusCustomDecoder = struct {
	Fmode                  uintptr
	Foverlap               int32
	Fchannels              int32
	Fstream_channels       int32
	Fdownsample            int32
	Fstart                 int32
	Fend                   int32
	Fsignalling            int32
	Fdisable_inv           int32
	Fcomplexity            int32
	Farch                  int32
	Frng                   OpusT_opus_uint32
	Ferror1                int32
	Flast_pitch_index      int32
	Floss_duration         int32
	Fplc_duration          int32
	Flast_frame_type       int32
	Fskip_plc              int32
	Fpostfilter_period     int32
	Fpostfilter_period_old int32
	Fpostfilter_gain       OpusT_opus_val16
	Fpostfilter_gain_old   OpusT_opus_val16
	Fpostfilter_tapset     int32
	Fpostfilter_tapset_old int32
	Fprefilter_and_fold    int32
	Fpreemph_memD          [2]OpusT_celt_sig
	F_decode_mem           [1]OpusT_celt_sig
}

var trim_icdf9 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf9 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf9 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff8 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff8 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The maximum pitch lag to allow in the pitch-based PLC. It's possible to save
   CPU time in the PLC pitch search by making this smaller than MAX_PERIOD. The
   current value corresponds to a pitch of 66.67 Hz. */
/* The minimum pitch lag to allow in the pitch-based PLC. This corresponds to a
   pitch of 480 Hz. */

/**********************************************************************/
/*                                                                    */
/*                             DECODER                                */
/*                                                                    */
/**********************************************************************/

/*
  - Decoder state
    @brief Decoder state
*/
type OpusCustomDecoder = struct {
	Fmode                  uintptr
	Foverlap               int32
	Fchannels              int32
	Fstream_channels       int32
	Fdownsample            int32
	Fstart                 int32
	Fend                   int32
	Fsignalling            int32
	Fdisable_inv           int32
	Fcomplexity            int32
	Farch                  int32
	Frng                   OpusT_opus_uint32
	Ferror1                int32
	Flast_pitch_index      int32
	Floss_duration         int32
	Fplc_duration          int32
	Flast_frame_type       int32
	Fskip_plc              int32
	Fpostfilter_period     int32
	Fpostfilter_period_old int32
	Fpostfilter_gain       OpusT_opus_val16
	Fpostfilter_gain_old   OpusT_opus_val16
	Fpostfilter_tapset     int32
	Fpostfilter_tapset_old int32
	Fprefilter_and_fold    int32
	Fpreemph_memD          [2]OpusT_celt_sig
	F_decode_mem           [1]OpusT_celt_sig
}

// C documentation
//
//	/* Make basic checks on the CELT state to ensure we don't end
//	   up writing all over memory. */
func Opus_validate_celt_decoder(tls *libc.TLS, st uintptr) {
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode == Opus_opus_custom_mode_create(tls, int32(48000), int32(960), libc.UintptrFromInt32(0))) {
		Opus_celt_fatal(tls, __ccgo_ts+3695, __ccgo_ts+3767, int32(147))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap == libc.Int32FromInt32(120)) {
		Opus_celt_fatal(tls, __ccgo_ts+3790, __ccgo_ts+3767, int32(148))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend <= libc.Int32FromInt32(21)) {
		Opus_celt_fatal(tls, __ccgo_ts+3827, __ccgo_ts+3767, int32(149))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels == int32(1) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+3767, int32(157))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(1) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+925, __ccgo_ts+3767, int32(158))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3859, __ccgo_ts+3767, int32(159))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart == 0 || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart == int32(17)) {
		Opus_celt_fatal(tls, __ccgo_ts+3896, __ccgo_ts+3767, int32(160))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart < (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend) {
		Opus_celt_fatal(tls, __ccgo_ts+3948, __ccgo_ts+3767, int32(161))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Farch >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+849, __ccgo_ts+3767, int32(163))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Farch <= libc.Int32FromInt32(OPUS_ARCHMASK)) {
		Opus_celt_fatal(tls, __ccgo_ts+881, __ccgo_ts+3767, int32(164))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Flast_pitch_index <= libc.Int32FromInt32(PLC_PITCH_LAG_MAX)) {
		Opus_celt_fatal(tls, __ccgo_ts+3986, __ccgo_ts+3767, int32(167))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Flast_pitch_index >= int32(PLC_PITCH_LAG_MIN) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Flast_pitch_index == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+4046, __ccgo_ts+3767, int32(168))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period < libc.Int32FromInt32(MAX_PERIOD)) {
		Opus_celt_fatal(tls, __ccgo_ts+4135, __ccgo_ts+3767, int32(170))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period >= int32(COMBFILTER_MINPERIOD) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+4188, __ccgo_ts+3767, int32(171))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period_old < libc.Int32FromInt32(MAX_PERIOD)) {
		Opus_celt_fatal(tls, __ccgo_ts+4282, __ccgo_ts+3767, int32(172))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period_old >= int32(COMBFILTER_MINPERIOD) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period_old == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+4339, __ccgo_ts+3767, int32(173))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_tapset <= libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+4441, __ccgo_ts+3767, int32(174))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_tapset >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4486, __ccgo_ts+3767, int32(175))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_tapset_old <= libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+4531, __ccgo_ts+3767, int32(176))
	}
	if !((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_tapset_old >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4580, __ccgo_ts+3767, int32(177))
	}
}

func Opus_celt_decoder_get_size(tls *libc.TLS, channels int32) (r int32) {
	var mode uintptr
	_ = mode
	mode = Opus_opus_custom_mode_create(tls, int32(48000), int32(960), libc.UintptrFromInt32(0))
	return opus_custom_decoder_get_size(tls, mode, channels)
}

func opus_custom_decoder_get_size(tls *libc.TLS, mode uintptr, channels int32) (r int32) {
	var size int32
	_ = size
	size = libc.Int32FromUint64(uint64(120) + libc.Uint64FromInt32(channels*(libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)+(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap)-libc.Int32FromInt32(1))*uint64(4) + libc.Uint64FromInt32(libc.Int32FromInt32(4)*libc.Int32FromInt32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands)*uint64(4) + libc.Uint64FromInt32(channels*int32(CELT_LPC_ORDER))*uint64(4))
	return size
}

func Opus_celt_decoder_init(tls *libc.TLS, st uintptr, sampling_rate OpusT_opus_int32, channels int32) (r int32) {
	var ret int32
	_ = ret
	ret = opus_custom_decoder_init(tls, st, Opus_opus_custom_mode_create(tls, int32(48000), int32(960), libc.UintptrFromInt32(0)), channels)
	if ret != OPUS_OK {
		return ret
	}
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample = Opus_resampling_factor(tls, sampling_rate)
	if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample == 0 {
		return -int32(1)
	} else {
		return OPUS_OK
	}
	return r
}

func opus_custom_decoder_init(tls *libc.TLS, st uintptr, mode uintptr, channels int32) (r int32) {
	var v1 int32
	_ = v1
	if channels < 0 || channels > int32(2) {
		return -int32(1)
	}
	if st == libc.UintptrFromInt32(0) {
		return -int32(7)
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(opus_custom_decoder_get_size(tls, mode, channels))*uint64(1))
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode = mode
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	v1 = channels
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample = int32(1)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart = 0
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend = (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FeffEBands
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fsignalling = int32(1)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv = libc.BoolInt32(channels == int32(1))
	v1 = 0
	goto _3
_3:
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Farch = v1
	Opus_opus_custom_decoder_ctl(tls, st, int32(OPUS_RESET_STATE), 0)
	return OPUS_OK
}

// C documentation
//
//	/* Special case for stereo with no downsampling and no accumulation. This is
//	   quite common and we can make it faster by processing both channels in the
//	   same loop, reducing overhead due to the dependency loop in the IIR filter. */
func deemphasis_stereo_simple(tls *libc.TLS, in uintptr, pcm uintptr, N int32, coef0 OpusT_opus_val16, mem uintptr) {
	var j int32
	var m0, m1, tmp0, tmp1 OpusT_celt_sig
	var x0, x1 uintptr
	_, _, _, _, _, _, _ = j, m0, m1, tmp0, tmp1, x0, x1
	x0 = *(*uintptr)(unsafe.Pointer(in))
	x1 = *(*uintptr)(unsafe.Pointer(in + 1*8))
	m0 = *(*OpusT_celt_sig)(unsafe.Pointer(mem))
	m1 = *(*OpusT_celt_sig)(unsafe.Pointer(mem + 1*4))
	j = 0
	for {
		if !(j < N) {
			break
		}
		/* Add VERY_SMALL to x[] first to reduce dependency chain. */
		tmp0 = *(*OpusT_celt_sig)(unsafe.Pointer(x0 + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m0
		tmp1 = *(*OpusT_celt_sig)(unsafe.Pointer(x1 + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m1
		m0 = OpusT_opus_val16(coef0 * tmp0)
		m1 = OpusT_opus_val16(coef0 * tmp1)
		*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*j)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp0)
		*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*j+int32(1))*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp1)
		goto _1
	_1:
		;
		j = j + 1
	}
	*(*OpusT_celt_sig)(unsafe.Pointer(mem)) = m0
	*(*OpusT_celt_sig)(unsafe.Pointer(mem + 1*4)) = m1
}

func deemphasis(tls *libc.TLS, in uintptr, pcm uintptr, N int32, C int32, downsample int32, coef uintptr, mem uintptr, accum int32) {
	var Nd, apply_downsampling, c, j, v29 int32
	var _saved_stack, scratch, st, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var coef0 OpusT_opus_val16
	var m, tmp, tmp1, tmp2 OpusT_celt_sig
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Nd, _saved_stack, apply_downsampling, c, coef0, j, m, scratch, st, tmp, tmp1, tmp2, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	apply_downsampling = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Short version for common case. */
	if downsample == int32(1) && C == int32(2) && !(accum != 0) {
		deemphasis_stereo_simple(tls, in, pcm, N, *(*OpusT_opus_val16)(unsafe.Pointer(coef)), mem)
		return
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(335))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	scratch = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	coef0 = *(*OpusT_opus_val16)(unsafe.Pointer(coef))
	Nd = N / downsample
	c = 0
	for {
		m = *(*OpusT_celt_sig)(unsafe.Pointer(mem + uintptr(c)*4))
		x = *(*uintptr)(unsafe.Pointer(in + uintptr(c)*8))
		y = pcm + uintptr(c)*4
		if downsample > int32(1) {
			/* Shortcut for the standard (non-custom modes) case */
			j = 0
			for {
				if !(j < N) {
					break
				}
				tmp = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m
				m = OpusT_opus_val16(coef0 * tmp)
				*(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j)*4)) = tmp
				goto _31
			_31:
				;
				j = j + 1
			}
			apply_downsampling = int32(1)
		} else {
			/* Shortcut for the standard (non-custom modes) case */
			if accum != 0 {
				j = 0
				for {
					if !(j < N) {
						break
					}
					tmp1 = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + m + libc.Float32FromFloat32(1e-30)
					m = OpusT_opus_val16(coef0 * tmp1)
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) + float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*tmp1)
					goto _32
				_32:
					;
					j = j + 1
				}
			} else {
				j = 0
				for {
					if !(j < N) {
						break
					}
					tmp2 = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m
					m = OpusT_opus_val16(coef0 * tmp2)
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp2)
					goto _33
				_33:
					;
					j = j + 1
				}
			}
		}
		*(*OpusT_celt_sig)(unsafe.Pointer(mem + uintptr(c)*4)) = m
		if apply_downsampling != 0 {
			/* Perform down-sampling */
			if accum != 0 {
				j = 0
				for {
					if !(j < Nd) {
						break
					}
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) + float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)**(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j*downsample)*4)))
					goto _34
				_34:
					;
					j = j + 1
				}
			} else {
				j = 0
				for {
					if !(j < Nd) {
						break
					}
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * *(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j*downsample)*4)))
					goto _35
				_35:
					;
					j = j + 1
				}
			}
		}
		goto _30
	_30:
		;
		c = c + 1
		v29 = c
		if !(v29 < C) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _39
_39:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func celt_synthesis(tls *libc.TLS, mode uintptr, X uintptr, out_syn uintptr, oldBandE uintptr, start int32, effEnd int32, C int32, CC int32, isTransient int32, LM int32, downsample int32, silence int32, arch int32) {
	var B, M, N, NB, b, c, i, nbEBands, overlap, shift, v33 int32
	var _saved_stack, freq, freq2, freq21, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B, M, N, NB, _saved_stack, b, c, freq, freq2, freq21, i, nbEBands, overlap, shift, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v33, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	overlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	nbEBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands
	N = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize << LM
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(432))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	freq = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1))) /**< Interleaved signal MDCTs */
	M = int32(1) << LM
	if isTransient != 0 {
		B = M
		NB = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize
		shift = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM
	} else {
		B = int32(1)
		NB = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize << LM
		shift = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM - LM
	}
	if CC == int32(2) && C == int32(1) {
		Opus_denormalise_bands(tls, mode, X, freq, oldBandE, start, effEnd, M, downsample, silence)
		/* Store a temporary copy in the output buffer because the IMDCT destroys its input. */
		freq2 = *(*uintptr)(unsafe.Pointer(out_syn + 1*8)) + uintptr(overlap/int32(2))*4
		libc.Xmemcpy(tls, freq2, freq, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(freq2)-int64(freq))/4)))
		b = 0
		for {
			if !(b < B) {
				break
			}
			Opus_clt_mdct_backward_c(tls, mode+80, freq2+uintptr(b)*4, *(*uintptr)(unsafe.Pointer(out_syn))+uintptr(NB*b)*4, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, shift, B, arch)
			goto _29
		_29:
			;
			b = b + 1
		}
		b = 0
		for {
			if !(b < B) {
				break
			}
			Opus_clt_mdct_backward_c(tls, mode+80, freq+uintptr(b)*4, *(*uintptr)(unsafe.Pointer(out_syn + 1*8))+uintptr(NB*b)*4, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, shift, B, arch)
			goto _30
		_30:
			;
			b = b + 1
		}
	} else {
		if CC == int32(1) && C == int32(2) {
			freq21 = *(*uintptr)(unsafe.Pointer(out_syn)) + uintptr(overlap/int32(2))*4
			Opus_denormalise_bands(tls, mode, X, freq, oldBandE, start, effEnd, M, downsample, silence)
			/* Use the output buffer as temp array before downmixing. */
			Opus_denormalise_bands(tls, mode, X+uintptr(N)*4, freq21, oldBandE+uintptr(nbEBands)*4, start, effEnd, M, downsample, silence)
			i = 0
			for {
				if !(i < N) {
					break
				}
				*(*OpusT_celt_sig)(unsafe.Pointer(freq + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(freq + uintptr(i)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(freq21 + uintptr(i)*4)))
				goto _31
			_31:
				;
				i = i + 1
			}
			b = 0
			for {
				if !(b < B) {
					break
				}
				Opus_clt_mdct_backward_c(tls, mode+80, freq+uintptr(b)*4, *(*uintptr)(unsafe.Pointer(out_syn))+uintptr(NB*b)*4, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, shift, B, arch)
				goto _32
			_32:
				;
				b = b + 1
			}
		} else {
			/* Normal case (mono or stereo) */
			c = 0
			for {
				Opus_denormalise_bands(tls, mode, X+uintptr(c*N)*4, freq, oldBandE+uintptr(c*nbEBands)*4, start, effEnd, M, downsample, silence)
				b = 0
				for {
					if !(b < B) {
						break
					}
					Opus_clt_mdct_backward_c(tls, mode+80, freq+uintptr(b)*4, *(*uintptr)(unsafe.Pointer(out_syn + uintptr(c)*8))+uintptr(NB*b)*4, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, shift, B, arch)
					goto _35
				_35:
					;
					b = b + 1
				}
				goto _34
			_34:
				;
				c = c + 1
				v33 = c
				if !(v33 < CC) {
					break
				}
			}
		}
	}
	/* Saturate IMDCT output so that we can't overflow in the pitch postfilter
	   or in the */
	c = 0
	for {
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out_syn + uintptr(c)*8)) + uintptr(i)*4)) = *(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out_syn + uintptr(c)*8)) + uintptr(i)*4))
			goto _38
		_38:
			;
			i = i + 1
		}
		goto _37
	_37:
		;
		c = c + 1
		v33 = c
		if !(v33 < CC) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _42
_42:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func tf_decode(tls *libc.TLS, start int32, end int32, isTransient int32, tf_res uintptr, LM int32, dec uintptr) {
	var budget, tell OpusT_opus_uint32
	var curr, i, logp, tf_changed, tf_select, tf_select_rsv, v2 int32
	var v1 uintptr
	_, _, _, _, _, _, _, _, _, _ = budget, curr, i, logp, tell, tf_changed, tf_select, tf_select_rsv, v1, v2
	budget = (*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage * uint32(8)
	v1 = dec
	v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _3
_3:
	tell = libc.Uint32FromInt32(v2)
	if isTransient != 0 {
		v2 = int32(2)
	} else {
		v2 = int32(4)
	}
	logp = v2
	tf_select_rsv = libc.BoolInt32(LM > 0 && tell+libc.Uint32FromInt32(logp)+uint32(1) <= budget)
	budget = budget - libc.Uint32FromInt32(tf_select_rsv)
	v2 = libc.Int32FromInt32(0)
	curr = v2
	tf_changed = v2
	i = start
	for {
		if !(i < end) {
			break
		}
		if tell+libc.Uint32FromInt32(logp) <= budget {
			curr = curr ^ Opus_ec_dec_bit_logp(tls, dec, libc.Uint32FromInt32(logp))
			v1 = dec
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _9
		_9:
			tell = libc.Uint32FromInt32(v2)
			tf_changed = tf_changed | curr
		}
		*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = curr
		if isTransient != 0 {
			v2 = int32(4)
		} else {
			v2 = int32(5)
		}
		logp = v2
		goto _6
	_6:
		;
		i = i + 1
	}
	tf_select = 0
	if tf_select_rsv != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+0+tf_changed)))) != int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)+tf_changed)))) {
		tf_select = Opus_ec_dec_bit_logp(tls, dec, uint32(1))
	}
	i = start
	for {
		if !(i < end) {
			break
		}
		*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4))))))
		goto _11
	_11:
		;
		i = i + 1
	}
}

func celt_plc_pitch_search(tls *libc.TLS, st1 uintptr, decode_mem uintptr, C int32, arch int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, lp_pitch_buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var _ /* pitch_index at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, lp_pitch_buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = st1
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(565))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)>>libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	lp_pitch_buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_pitch_downsample(tls, decode_mem, lp_pitch_buf, libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)>>libc.Int32FromInt32(1), C, int32(2), arch)
	Opus_pitch_search(tls, lp_pitch_buf+uintptr(libc.Int32FromInt32(PLC_PITCH_LAG_MAX)>>libc.Int32FromInt32(1))*4, lp_pitch_buf, libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)-libc.Int32FromInt32(PLC_PITCH_LAG_MAX), libc.Int32FromInt32(PLC_PITCH_LAG_MAX)-libc.Int32FromInt32(PLC_PITCH_LAG_MIN), bp, arch)
	*(*int32)(unsafe.Pointer(bp)) = int32(PLC_PITCH_LAG_MAX) - *(*int32)(unsafe.Pointer(bp))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return *(*int32)(unsafe.Pointer(bp))
}

func prefilter_and_fold(tls *libc.TLS, st1 uintptr, N int32) {
	var CC, c, decode_buffer_size, i, overlap, v29 int32
	var _saved_stack, etmp, mode, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var decode_mem [2]uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = CC, _saved_stack, c, decode_buffer_size, decode_mem, etmp, i, mode, overlap, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
	mode = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fmode
	overlap = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Foverlap
	CC = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fchannels
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(597))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(overlap) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	etmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	c = 0
	for {
		decode_mem[c] = st1 + 112 + uintptr(c*(decode_buffer_size+overlap))*4
		goto _30
	_30:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	c = 0
	for {
		/* Apply the pre-filter to the MDCT overlap for the next frame because
		   the post-filter will be re-applied in the decoder after the MDCT
		   overlap. */
		Opus_comb_filter(tls, etmp, decode_mem[c]+uintptr(decode_buffer_size)*4-uintptr(N)*4, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, overlap, -(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old, -(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, libc.UintptrFromInt32(0), 0, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
		/* Simulate TDAC on the concealed audio so that it blends with the
		   MDCT of the next frame. */
		i = 0
		for {
			if !(i < overlap/int32(2)) {
				break
			}
			*(*OpusT_celt_sig)(unsafe.Pointer(decode_mem[c] + uintptr(decode_buffer_size-N+i)*4)) = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow + uintptr(i)*4))**(*OpusT_opus_val32)(unsafe.Pointer(etmp + uintptr(overlap-int32(1)-i)*4))) + OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow + uintptr(overlap-i-int32(1))*4))**(*OpusT_opus_val32)(unsafe.Pointer(etmp + uintptr(i)*4)))
			goto _33
		_33:
			;
			i = i + 1
		}
		goto _32
	_32:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _37
_37:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func celt_decode_lost(tls *libc.TLS, st1 uintptr, N int32, LM int32) {
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var C, blen, boffs, c, curr_frame_type, curr_neural, decay_length, decode_buffer_size, effEnd, end, exc_length, extrapolation_len, extrapolation_offset, i, j, j1, last_neural, loss_duration, max_period, nbEBands, overlap, pitch_index, start, v5, v7, v8 int32
	var E1, E2, S1, S2, v103 OpusT_opus_val32
	var X, _exc, _saved_stack, backgroundLogE, buf, eBands, exc, fir_tmp, lpc, mode, oldBandE, oldLogE, oldLogE2, st, window, v1, v10, v12, v14, v16, v18, v20, v22, v24, v26, v28, v3 uintptr
	var attenuation, decay1, e, fade, ratio, tmp, tmp1, tmp_g OpusT_opus_val16
	var decay, v40 OpusT_celt_glog
	var seed OpusT_opus_uint32
	var v36 float32
	var _ /* ac at bp+32 */ [25]OpusT_opus_val32
	var _ /* decode_mem at bp+0 */ [2]uintptr
	var _ /* lpc_mem at bp+132 */ [24]OpusT_opus_val16
	var _ /* out_syn at bp+16 */ [2]uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = C, E1, E2, S1, S2, X, _exc, _saved_stack, attenuation, backgroundLogE, blen, boffs, buf, c, curr_frame_type, curr_neural, decay, decay1, decay_length, decode_buffer_size, e, eBands, effEnd, end, exc, exc_length, extrapolation_len, extrapolation_offset, fade, fir_tmp, i, j, j1, last_neural, loss_duration, lpc, max_period, mode, nbEBands, oldBandE, oldLogE, oldLogE2, overlap, pitch_index, ratio, seed, st, start, tmp, tmp1, tmp_g, window, v1, v10, v103, v12, v14, v16, v18, v20, v22, v24, v26, v28, v3, v36, v40, v5, v7, v8
	C = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fchannels
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
	max_period = int32(MAX_PERIOD)
	mode = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fmode
	nbEBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands
	overlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeBands
	c = 0
	for {
		(*(*[2]uintptr)(unsafe.Pointer(bp)))[c] = st1 + 112 + uintptr(c*(decode_buffer_size+overlap))*4
		(*(*[2]uintptr)(unsafe.Pointer(bp + 16)))[c] = (*(*[2]uintptr)(unsafe.Pointer(bp)))[c] + uintptr(decode_buffer_size)*4 - uintptr(N)*4
		goto _6
	_6:
		;
		c = c + 1
		v5 = c
		if !(v5 < C) {
			break
		}
	}
	oldBandE = st1 + 112 + uintptr((decode_buffer_size+overlap)*C)*4
	oldLogE = oldBandE + uintptr(int32(2)*nbEBands)*4
	oldLogE2 = oldLogE + uintptr(int32(2)*nbEBands)*4
	backgroundLogE = oldLogE2 + uintptr(int32(2)*nbEBands)*4
	lpc = backgroundLogE + uintptr(libc.Int32FromInt32(2)*nbEBands)*4
	loss_duration = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration
	start = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fstart
	curr_frame_type = int32(FRAME_PLC_PERIODIC)
	if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fplc_duration >= int32(40) || start != 0 || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fskip_plc != 0 {
		curr_frame_type = int32(FRAME_PLC_NOISE)
	}
	if curr_frame_type == int32(FRAME_PLC_NOISE) {
		end = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fend
		if end < (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands {
			v7 = end
		} else {
			v7 = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands
		}
		if start > v7 {
			v5 = start
		} else {
			if end < (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands {
				v8 = end
			} else {
				v8 = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands
			}
			v5 = v8
		}
		effEnd = v5
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _11
		_11:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _13
	_13:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v10 = libc.Xmalloc(tls, uint64(16))
			goto _15
		_15:
			st = v10
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v12 = st
		goto _17
	_17:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v14 = libc.Xmalloc(tls, uint64(16))
			goto _19
		_19:
			st = v14
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v16 = st
		goto _21
	_21:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v18 = libc.Xmalloc(tls, uint64(16))
			goto _23
		_23:
			st = v18
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v20 = st
		goto _25
	_25:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v20)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(749))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v22 = libc.Xmalloc(tls, uint64(16))
			goto _27
		_27:
			st = v22
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v24 = st
		goto _29
	_29:
		*(*uintptr)(unsafe.Pointer(v24 + 8)) += uintptr(libc.Uint64FromInt32(C*N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v26 = libc.Xmalloc(tls, uint64(16))
			goto _31
		_31:
			st = v26
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v28 = st
		goto _33
	_33:
		X = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v28)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1))) /**< Interleaved normalised MDCTs */
		c = 0
		for {
			libc.Xmemmove(tls, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c], (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(N)*4, libc.Uint64FromInt32(decode_buffer_size-N+overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c])-int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(N)*4))/4)))
			goto _35
		_35:
			;
			c = c + 1
			v5 = c
			if !(v5 < C) {
				break
			}
		}
		if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fprefilter_and_fold != 0 {
			prefilter_and_fold(tls, st1, N)
		}
		/* Energy decay */
		if loss_duration == 0 {
			v36 = libc.Float32FromFloat32(1.5)
		} else {
			v36 = libc.Float32FromFloat32(0.5)
		}
		decay = v36
		c = 0
		for {
			i = start
			for {
				if !(i < end) {
					break
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(backgroundLogE + uintptr(c*nbEBands+i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4))-decay {
					v40 = *(*OpusT_celt_glog)(unsafe.Pointer(backgroundLogE + uintptr(c*nbEBands+i)*4))
				} else {
					v40 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) - decay
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) = v40
				goto _39
			_39:
				;
				i = i + 1
			}
			goto _38
		_38:
			;
			c = c + 1
			v5 = c
			if !(v5 < C) {
				break
			}
		}
		seed = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Frng
		c = 0
		for {
			if !(c < C) {
				break
			}
			i = start
			for {
				if !(i < effEnd) {
					break
				}
				boffs = N*c + int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))<<LM
				blen = (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))) << LM
				j = 0
				for {
					if !(j < blen) {
						break
					}
					seed = Opus_celt_lcg_rand(tls, seed)
					*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(boffs+j)*4)) = float32(libc.Int32FromUint32(seed) >> libc.Int32FromInt32(20))
					goto _43
				_43:
					;
					j = j + 1
				}
				Opus_renormalise_vector(tls, X+uintptr(boffs)*4, blen, libc.Float32FromFloat32(1), (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
				goto _42
			_42:
				;
				i = i + 1
			}
			goto _41
		_41:
			;
			c = c + 1
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Frng = seed
		celt_synthesis(tls, mode, X, bp+16, oldBandE, start, effEnd, C, C, 0, LM, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample, 0, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
		/* Run the postfilter with the last parameters. */
		c = 0
		for {
			if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period > int32(COMBFILTER_MINPERIOD) {
				v7 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period
			} else {
				v7 = int32(COMBFILTER_MINPERIOD)
			}
			(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period = v7
			if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old > int32(COMBFILTER_MINPERIOD) {
				v5 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old
			} else {
				v5 = int32(COMBFILTER_MINPERIOD)
			}
			(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old = v5
			Opus_comb_filter(tls, (*(*[2]uintptr)(unsafe.Pointer(bp + 16)))[c], (*(*[2]uintptr)(unsafe.Pointer(bp + 16)))[c], (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
			if LM != 0 {
				Opus_comb_filter(tls, (*(*[2]uintptr)(unsafe.Pointer(bp + 16)))[c]+uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize)*4, (*(*[2]uintptr)(unsafe.Pointer(bp + 16)))[c]+uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize)*4, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, N-(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
			}
			goto _45
		_45:
			;
			c = c + 1
			v5 = c
			if !(v5 < C) {
				break
			}
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fprefilter_and_fold = 0
		/* Skip regular PLC until we get two consecutive packets. */
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fskip_plc = int32(1)
	} else {
		fade = libc.Float32FromFloat32(1)
		curr_neural = libc.BoolInt32(curr_frame_type == int32(FRAME_PLC_NEURAL) || curr_frame_type == int32(FRAME_DRED))
		last_neural = libc.BoolInt32((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type == int32(FRAME_PLC_NEURAL) || (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type == int32(FRAME_DRED))
		if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type != int32(FRAME_PLC_PERIODIC) && !(last_neural != 0 && curr_neural != 0) {
			v5 = celt_plc_pitch_search(tls, st1, bp, C, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
			pitch_index = v5
			(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_pitch_index = v5
		} else {
			pitch_index = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_pitch_index
			fade = libc.Float32FromFloat32(0.8)
		}
		/* We want the excitation for 2 pitch periods in order to look for a
		   decaying signal, but we can't get more than MAX_PERIOD. */
		if int32(2)*pitch_index < max_period {
			v5 = int32(2) * pitch_index
		} else {
			v5 = max_period
		}
		exc_length = v5
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _51
		_51:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _53
	_53:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v10 = libc.Xmalloc(tls, uint64(16))
			goto _55
		_55:
			st = v10
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v12 = st
		goto _57
	_57:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v14 = libc.Xmalloc(tls, uint64(16))
			goto _59
		_59:
			st = v14
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v16 = st
		goto _61
	_61:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v18 = libc.Xmalloc(tls, uint64(16))
			goto _63
		_63:
			st = v18
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v20 = st
		goto _65
	_65:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(max_period+libc.Int32FromInt32(CELT_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v20)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(837))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v22 = libc.Xmalloc(tls, uint64(16))
			goto _67
		_67:
			st = v22
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v24 = st
		goto _69
	_69:
		*(*uintptr)(unsafe.Pointer(v24 + 8)) += uintptr(libc.Uint64FromInt32(max_period+libc.Int32FromInt32(CELT_LPC_ORDER)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v26 = libc.Xmalloc(tls, uint64(16))
			goto _71
		_71:
			st = v26
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v28 = st
		goto _73
	_73:
		_exc = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v28)).Fglobal_stack - uintptr(libc.Uint64FromInt32(max_period+libc.Int32FromInt32(CELT_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _75
		_75:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _77
	_77:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v10 = libc.Xmalloc(tls, uint64(16))
			goto _79
		_79:
			st = v10
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v12 = st
		goto _81
	_81:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v14 = libc.Xmalloc(tls, uint64(16))
			goto _83
		_83:
			st = v14
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v16 = st
		goto _85
	_85:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v18 = libc.Xmalloc(tls, uint64(16))
			goto _87
		_87:
			st = v18
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v20 = st
		goto _89
	_89:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(exc_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v20)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(838))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v22 = libc.Xmalloc(tls, uint64(16))
			goto _91
		_91:
			st = v22
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v24 = st
		goto _93
	_93:
		*(*uintptr)(unsafe.Pointer(v24 + 8)) += uintptr(libc.Uint64FromInt32(exc_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v26 = libc.Xmalloc(tls, uint64(16))
			goto _95
		_95:
			st = v26
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v28 = st
		goto _97
	_97:
		fir_tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v28)).Fglobal_stack - uintptr(libc.Uint64FromInt32(exc_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		exc = _exc + uintptr(CELT_LPC_ORDER)*4
		window = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow
		c = 0
		for {
			S1 = libc.Float32FromInt32(0)
			buf = (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]
			i = 0
			for {
				if !(i < max_period+int32(CELT_LPC_ORDER)) {
					break
				}
				*(*OpusT_opus_val16)(unsafe.Pointer(exc + uintptr(i-int32(CELT_LPC_ORDER))*4)) = *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-max_period-int32(CELT_LPC_ORDER)+i)*4))
				goto _100
			_100:
				;
				i = i + 1
			}
			if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type != int32(FRAME_PLC_PERIODIC) && !(last_neural != 0 && curr_neural != 0) {
				/* Compute LPC coefficients for the last MAX_PERIOD samples before
				   the first loss so we can work in the excitation-filter domain. */
				Opus__celt_autocorr(tls, exc, bp+32, window, overlap, int32(CELT_LPC_ORDER), max_period, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
				/* Add a noise floor of -40 dB. */
				*(*OpusT_opus_val32)(unsafe.Pointer(bp + 32)) *= libc.Float32FromFloat32(1.0001)
				/* Use lag windowing to stabilize the Levinson-Durbin recursion. */
				i = int32(1)
				for {
					if !(i <= int32(CELT_LPC_ORDER)) {
						break
					}
					/*ac[i] *= exp(-.5*(2*M_PI*.002*i)*(2*M_PI*.002*i));*/
					*(*OpusT_opus_val32)(unsafe.Pointer(bp + 32 + uintptr(i)*4)) -= OpusT_opus_val32(OpusT_opus_val32(OpusT_opus_val32((*(*[25]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[i]*float32(libc.Float32FromFloat32(0.008)*libc.Float32FromFloat32(0.008)))*float32(i)) * float32(i))
					goto _101
				_101:
					;
					i = i + 1
				}
				Opus__celt_lpc(tls, lpc+uintptr(c*int32(CELT_LPC_ORDER))*4, bp+32, int32(CELT_LPC_ORDER))
			}
			/* Initialize the LPC history with the samples just before the start
			   of the region for which we're computing the excitation. */
			/* Compute the excitation for exc_length samples before the loss. We need the copy
			   because celt_fir() cannot filter in-place. */
			Opus_celt_fir_c(tls, exc+uintptr(max_period)*4-uintptr(exc_length)*4, lpc+uintptr(c*int32(CELT_LPC_ORDER))*4, fir_tmp, exc_length, int32(CELT_LPC_ORDER), (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
			libc.Xmemcpy(tls, exc+uintptr(max_period)*4-uintptr(exc_length)*4, fir_tmp, libc.Uint64FromInt32(exc_length)*uint64(4)+libc.Uint64FromInt64(0*((int64(exc+uintptr(max_period)*4-uintptr(exc_length)*4)-int64(fir_tmp))/4)))
			/* Check if the waveform is decaying, and if so how fast.
			   We do this to avoid adding energy when concealing in a segment
			   with decaying energy. */
			E1 = libc.Float32FromInt32(1)
			E2 = libc.Float32FromInt32(1)
			decay_length = exc_length >> int32(1)
			i = 0
			for {
				if !(i < decay_length) {
					break
				}
				e = *(*OpusT_opus_val16)(unsafe.Pointer(exc + uintptr(max_period-decay_length+i)*4))
				E1 = E1 + OpusT_opus_val32(e*e)
				e = *(*OpusT_opus_val16)(unsafe.Pointer(exc + uintptr(max_period-int32(2)*decay_length+i)*4))
				E2 = E2 + OpusT_opus_val32(e*e)
				goto _102
			_102:
				;
				i = i + 1
			}
			if E1 < E2 {
				v103 = E1
			} else {
				v103 = E2
			}
			E1 = v103
			decay1 = float32(libc.Xsqrt(tls, float64(E1/E2)))
			/* Move the decoder memory one frame to the left to give us room to
			   add the data for the new frame. We ignore the overlap that extends
			   past the end of the buffer, because we aren't going to use it. */
			libc.Xmemmove(tls, buf, buf+uintptr(N)*4, libc.Uint64FromInt32(decode_buffer_size-N)*uint64(4)+libc.Uint64FromInt64(0*((int64(buf)-int64(buf+uintptr(N)*4))/4)))
			/* Extrapolate from the end of the excitation with a period of
			   "pitch_index", scaling down each period by an additional factor of
			   "decay". */
			extrapolation_offset = max_period - pitch_index
			/* We need to extrapolate enough samples to cover a complete MDCT
			   window (including overlap/2 samples on both sides). */
			extrapolation_len = N + overlap
			/* We also apply fading if this is not the first loss. */
			attenuation = OpusT_opus_val16(fade * decay1)
			v5 = libc.Int32FromInt32(0)
			j1 = v5
			i = v5
			for {
				if !(i < extrapolation_len) {
					break
				}
				if j1 >= pitch_index {
					j1 = j1 - pitch_index
					attenuation = OpusT_opus_val16(attenuation * decay1)
				}
				*(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)) = OpusT_opus_val16(attenuation * *(*OpusT_opus_val16)(unsafe.Pointer(exc + uintptr(extrapolation_offset+j1)*4)))
				/* Compute the energy of the previously decoded signal whose
				   excitation we're copying. */
				tmp = *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-max_period-N+extrapolation_offset+j1)*4))
				S1 = S1 + OpusT_opus_val32(tmp*tmp)
				goto _104
			_104:
				;
				i = i + 1
				j1 = j1 + 1
			}
			/* Copy the last decoded samples (prior to the overlap region) to
			   synthesis filter memory so we can have a continuous signal. */
			i = 0
			for {
				if !(i < int32(CELT_LPC_ORDER)) {
					break
				}
				(*(*[24]OpusT_opus_val16)(unsafe.Pointer(bp + 132)))[i] = *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N-int32(1)-i)*4))
				goto _106
			_106:
				;
				i = i + 1
			}
			/* Apply the synthesis filter to convert the excitation back into
			   the signal domain. */
			Opus_celt_iir(tls, buf+uintptr(decode_buffer_size)*4-uintptr(N)*4, lpc+uintptr(c*int32(CELT_LPC_ORDER))*4, buf+uintptr(decode_buffer_size)*4-uintptr(N)*4, extrapolation_len, int32(CELT_LPC_ORDER), bp+132, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
			/* Check if the synthesis energy is higher than expected, which can
			   happen with the signal changes during our window. If so,
			   attenuate. */
			S2 = libc.Float32FromInt32(0)
			i = 0
			for {
				if !(i < extrapolation_len) {
					break
				}
				tmp1 = *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4))
				S2 = S2 + OpusT_opus_val32(tmp1*tmp1)
				goto _107
			_107:
				;
				i = i + 1
			}
			/* This checks for an "explosion" in the synthesis. */
			/* The float test is written this way to catch NaNs in the output
			   of the IIR filter at the same time. */
			if !(S1 > OpusT_opus_val32(libc.Float32FromFloat32(0.2)*S2)) {
				i = 0
				for {
					if !(i < extrapolation_len) {
						break
					}
					*(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)) = libc.Float32FromInt32(0)
					goto _108
				_108:
					;
					i = i + 1
				}
			} else {
				if S1 < S2 {
					ratio = float32(libc.Xsqrt(tls, float64((S1+libc.Float32FromInt32(1))/(S2+libc.Float32FromInt32(1)))))
					i = 0
					for {
						if !(i < overlap) {
							break
						}
						tmp_g = libc.Float32FromFloat32(1) - OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4))*(libc.Float32FromFloat32(1)-ratio))
						*(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)) = OpusT_opus_val16(tmp_g * *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)))
						goto _109
					_109:
						;
						i = i + 1
					}
					i = overlap
					for {
						if !(i < extrapolation_len) {
							break
						}
						*(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)) = OpusT_opus_val16(ratio * *(*OpusT_celt_sig)(unsafe.Pointer(buf + uintptr(decode_buffer_size-N+i)*4)))
						goto _110
					_110:
						;
						i = i + 1
					}
				}
			}
			goto _99
		_99:
			;
			c = c + 1
			v5 = c
			if !(v5 < C) {
				break
			}
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fprefilter_and_fold = int32(1)
	}
	/* Saturate to something large to avoid wrap-around. */
	if int32(10000) < loss_duration+int32(1)<<LM {
		v5 = int32(10000)
	} else {
		v5 = loss_duration + int32(1)<<LM
	}
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration = v5
	if int32(10000) < (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fplc_duration+int32(1)<<LM {
		v5 = int32(10000)
	} else {
		v5 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fplc_duration + int32(1)<<LM
	}
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fplc_duration = v5
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type = curr_frame_type
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _114
	_114:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _116
_116:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_celt_decode_with_ec_dred(tls *libc.TLS, st1 uintptr, data uintptr, len1 int32, pcm uintptr, frame_size int32, dec uintptr, accum int32) (r int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var C, CC, LM, M, N, alloc_trim, anti_collapse_on, anti_collapse_rsv, boost, c, codedBands, decode_buffer_size, dynalloc_logp, dynalloc_loop_logp, effEnd, end, flag, i, intra_ener, isTransient, missing, nbEBands, octave, overlap, postfilter_pitch, postfilter_tapset, qg, quanta, shortBlocks, silence, spread_decision, start, width, v28, v37, v40 int32
	var E0, E1, E2, slope, v57 OpusT_opus_val32
	var X, _saved_stack, backgroundLogE, cap1, collapse_masks, eBands, fine_priority, fine_quant, mode, offsets, oldBandE, oldLogE, oldLogE2, pulses, st, tf_res, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var bits, tell, total_bits OpusT_opus_int32
	var decode_mem [2]uintptr
	var max_background_increase, safety, v35, v56, v61 OpusT_celt_glog
	var postfilter_gain OpusT_opus_val16
	var v60 float32
	var _ /* _dec at bp+0 */ OpusT_ec_dec
	var _ /* balance at bp+80 */ OpusT_opus_int32
	var _ /* dual_stereo at bp+76 */ int32
	var _ /* intensity at bp+72 */ int32
	var _ /* out_syn at bp+56 */ [2]uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = C, CC, E0, E1, E2, LM, M, N, X, _saved_stack, alloc_trim, anti_collapse_on, anti_collapse_rsv, backgroundLogE, bits, boost, c, cap1, codedBands, collapse_masks, decode_buffer_size, decode_mem, dynalloc_logp, dynalloc_loop_logp, eBands, effEnd, end, fine_priority, fine_quant, flag, i, intra_ener, isTransient, max_background_increase, missing, mode, nbEBands, octave, offsets, oldBandE, oldLogE, oldLogE2, overlap, postfilter_gain, postfilter_pitch, postfilter_tapset, pulses, qg, quanta, safety, shortBlocks, silence, slope, spread_decision, st, start, tell, tf_res, total_bits, width, v1, v10, v11, v13, v15, v17, v19, v21, v28, v3, v35, v37, v40, v5, v56, v57, v6, v60, v61, v8
	CC = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fchannels
	*(*int32)(unsafe.Pointer(bp + 72)) = 0
	*(*int32)(unsafe.Pointer(bp + 76)) = 0
	anti_collapse_on = 0
	C = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fstream_channels
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
	Opus_validate_celt_decoder(tls, st1)
	mode = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fmode
	nbEBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands
	overlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeBands
	start = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fstart
	end = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fend
	frame_size = frame_size * (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample
	oldBandE = st1 + 112 + uintptr((decode_buffer_size+overlap)*CC)*4
	oldLogE = oldBandE + uintptr(int32(2)*nbEBands)*4
	oldLogE2 = oldLogE + uintptr(int32(2)*nbEBands)*4
	backgroundLogE = oldLogE2 + uintptr(int32(2)*nbEBands)*4
	LM = 0
	for {
		if !(LM <= (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM) {
			break
		}
		if (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize<<LM == frame_size {
			break
		}
		goto _27
	_27:
		;
		LM = LM + 1
	}
	if LM > (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM {
		return -int32(1)
	}
	M = int32(1) << LM
	if len1 < 0 || len1 > int32(1275) || pcm == libc.UintptrFromInt32(0) {
		return -int32(1)
	}
	N = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize
	c = 0
	for {
		decode_mem[c] = st1 + 112 + uintptr(c*(decode_buffer_size+overlap))*4
		(*(*[2]uintptr)(unsafe.Pointer(bp + 56)))[c] = decode_mem[c] + uintptr(decode_buffer_size)*4 - uintptr(N)*4
		goto _29
	_29:
		;
		c = c + 1
		v28 = c
		if !(v28 < CC) {
			break
		}
	}
	effEnd = end
	if effEnd > (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands {
		effEnd = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeffEBands
	}
	if data == libc.UintptrFromInt32(0) || len1 <= int32(1) {
		celt_decode_lost(tls, st1, N, LM)
		deemphasis(tls, bp+56, pcm, N, CC, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample, mode+16, st1+104, accum)
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _31
		_31:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _33
	_33:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return frame_size / (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample
	}
	/* Check if there are at least two packets received consecutively before
	 * turning on the pitch-based PLC */
	if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration == 0 {
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fskip_plc = 0
	}
	if dec == libc.UintptrFromInt32(0) {
		Opus_ec_dec_init(tls, bp, data, libc.Uint32FromInt32(len1))
		dec = bp
	}
	if C == int32(1) {
		i = 0
		for {
			if !(i < nbEBands) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(nbEBands+i)*4)) {
				v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4))
			} else {
				v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(nbEBands+i)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4)) = v35
			goto _34
		_34:
			;
			i = i + 1
		}
	}
	total_bits = len1 * int32(8)
	v1 = dec
	v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _38
_38:
	tell = v28
	if tell >= total_bits {
		silence = int32(1)
	} else {
		if tell == int32(1) {
			silence = Opus_ec_dec_bit_logp(tls, dec, uint32(15))
		} else {
			silence = 0
		}
	}
	if silence != 0 {
		/* Pretend we've read all the remaining bits */
		tell = len1 * int32(8)
		v1 = dec
		v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _41
	_41:
		*(*int32)(unsafe.Pointer(dec + 24)) += tell - v28
	}
	postfilter_gain = libc.Float32FromInt32(0)
	postfilter_pitch = 0
	postfilter_tapset = 0
	if start == 0 && tell+int32(16) <= total_bits {
		if Opus_ec_dec_bit_logp(tls, dec, uint32(1)) != 0 {
			octave = libc.Int32FromUint32(Opus_ec_dec_uint(tls, dec, uint32(6)))
			postfilter_pitch = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(16)<<octave) + Opus_ec_dec_bits(tls, dec, libc.Uint32FromInt32(int32(4)+octave)) - uint32(1))
			qg = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, uint32(3)))
			v1 = dec
			v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _44
		_44:
			if v28+int32(2) <= total_bits {
				postfilter_tapset = Opus_ec_dec_icdf(tls, dec, uintptr(unsafe.Pointer(&tapset_icdf9)), uint32(2))
			}
			postfilter_gain = OpusT_opus_val16(libc.Float32FromFloat32(0.09375) * float32(qg+libc.Int32FromInt32(1)))
		}
		v1 = dec
		v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _47
	_47:
		tell = v28
	}
	if LM > 0 && tell+int32(3) <= total_bits {
		isTransient = Opus_ec_dec_bit_logp(tls, dec, uint32(3))
		v1 = dec
		v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _50
	_50:
		tell = v28
	} else {
		isTransient = 0
	}
	if isTransient != 0 {
		shortBlocks = M
	} else {
		shortBlocks = 0
	}
	/* Decode the global flags (first symbols in the stream) */
	if tell+int32(3) <= total_bits {
		v28 = Opus_ec_dec_bit_logp(tls, dec, uint32(3))
	} else {
		v28 = 0
	}
	intra_ener = v28
	/* If recovering from packet loss, make sure we make the energy prediction safe to reduce the
	   risk of getting loud artifacts. */
	if !(intra_ener != 0) && (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration != 0 {
		c = 0
		for {
			safety = libc.Float32FromInt32(0)
			if int32(10) < (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration>>LM {
				v37 = int32(10)
			} else {
				v37 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration >> LM
			}
			missing = v37
			if LM == 0 {
				safety = libc.Float32FromFloat32(1.5)
			} else {
				if LM == int32(1) {
					safety = libc.Float32FromFloat32(0.5)
				}
			}
			i = start
			for {
				if !(i < end) {
					break
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4)) {
					v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4))
				} else {
					v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4))
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) < v35 {
					E0 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4))
					E1 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4))
					E2 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4))
					if E1-E0 > float32(libc.Float32FromFloat32(0.5)*(E2-E0)) {
						v57 = E1 - E0
					} else {
						v57 = float32(libc.Float32FromFloat32(0.5) * (E2 - E0))
					}
					slope = v57
					if slope < libc.Float32FromFloat32(2) {
						v57 = slope
					} else {
						v57 = libc.Float32FromFloat32(2)
					}
					slope = v57
					if float32(libc.Int32FromInt32(0)) > OpusT_opus_val32(float32(libc.Int32FromInt32(1)+missing)*slope) {
						v57 = float32(libc.Int32FromInt32(0))
					} else {
						v57 = OpusT_opus_val32(float32(libc.Int32FromInt32(1)+missing) * slope)
					}
					E0 = E0 - v57
					if -libc.Float32FromFloat32(20) > E0 {
						v60 = -libc.Float32FromFloat32(20)
					} else {
						v60 = E0
					}
					*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) = v60
				} else {
					/* Otherwise take the min of the last frames. */
					if *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) < *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4)) {
						v56 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4))
					} else {
						v56 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4))
					}
					if v56 < *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4)) {
						if *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) < *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4)) {
							v61 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4))
						} else {
							v61 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4))
						}
						v35 = v61
					} else {
						v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4))
					}
					*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) = v35
				}
				/* Shorter frames have more natural fluctuations -- play it safe. */
				*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) -= safety
				goto _55
			_55:
				;
				i = i + 1
			}
			goto _53
		_53:
			;
			c = c + 1
			v28 = c
			if !(v28 < int32(2)) {
				break
			}
		}
	}
	/* Get band energies */
	Opus_unquant_coarse_energy(tls, mode, start, end, oldBandE, intra_ener, dec, C, LM)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _67
_67:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _71
_71:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _73
	_73:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _75
_75:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _77
	_77:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _79
_79:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1395))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _81
	_81:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _83
_83:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _85
	_85:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _87
_87:
	tf_res = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	tf_decode(tls, start, end, isTransient, tf_res, LM, dec)
	v1 = dec
	v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _90
_90:
	tell = v28
	spread_decision = int32(SPREAD_NORMAL)
	if tell+int32(4) <= total_bits {
		spread_decision = Opus_ec_dec_icdf(tls, dec, uintptr(unsafe.Pointer(&spread_icdf9)), uint32(5))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _92
	_92:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _94
_94:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _96
	_96:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _98
_98:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _100
	_100:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _102
_102:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _104
	_104:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _106
_106:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1403))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _108
	_108:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _110
_110:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _112
	_112:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _114
_114:
	cap1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_init_caps(tls, mode, cap1, LM, C)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _116
	_116:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _118
_118:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _120
	_120:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _122
_122:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _126
_126:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _128
	_128:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _130
_130:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1407))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _132
	_132:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _134
_134:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _136
	_136:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _138
_138:
	offsets = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	dynalloc_logp = int32(6)
	total_bits = total_bits << int32(BITRES)
	tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, dec))
	i = start
	for {
		if !(i < end) {
			break
		}
		width = C * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))) << LM
		/* quanta is 6 bits, but no more than 1 bit/sample
		   and no less than 1/8 bit/sample */
		if libc.Int32FromInt32(6)<<libc.Int32FromInt32(BITRES) > width {
			v37 = libc.Int32FromInt32(6) << libc.Int32FromInt32(BITRES)
		} else {
			v37 = width
		}
		if width<<int32(BITRES) < v37 {
			v28 = width << int32(BITRES)
		} else {
			if libc.Int32FromInt32(6)<<libc.Int32FromInt32(BITRES) > width {
				v40 = libc.Int32FromInt32(6) << libc.Int32FromInt32(BITRES)
			} else {
				v40 = width
			}
			v28 = v40
		}
		quanta = v28
		dynalloc_loop_logp = dynalloc_logp
		boost = 0
		for tell+dynalloc_loop_logp<<int32(BITRES) < total_bits && boost < *(*int32)(unsafe.Pointer(cap1 + uintptr(i)*4)) {
			flag = Opus_ec_dec_bit_logp(tls, dec, libc.Uint32FromInt32(dynalloc_loop_logp))
			tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, dec))
			if !(flag != 0) {
				break
			}
			boost = boost + quanta
			total_bits = total_bits - quanta
			dynalloc_loop_logp = int32(1)
		}
		*(*int32)(unsafe.Pointer(offsets + uintptr(i)*4)) = boost
		/* Making dynalloc more likely */
		if boost > 0 {
			if int32(2) > dynalloc_logp-int32(1) {
				v28 = int32(2)
			} else {
				v28 = dynalloc_logp - int32(1)
			}
			dynalloc_logp = v28
		}
		goto _139
	_139:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _145
	_145:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _147
_147:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _149
	_149:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _151
_151:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _153
	_153:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _155
_155:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _157
	_157:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _159
_159:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1440))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _161
	_161:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _163
_163:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _165
	_165:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _167
_167:
	fine_quant = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if tell+libc.Int32FromInt32(6)<<libc.Int32FromInt32(BITRES) <= total_bits {
		v28 = Opus_ec_dec_icdf(tls, dec, uintptr(unsafe.Pointer(&trim_icdf9)), uint32(7))
	} else {
		v28 = int32(5)
	}
	alloc_trim = v28
	bits = len1*int32(8)<<int32(BITRES) - libc.Int32FromUint32(Opus_ec_tell_frac(tls, dec)) - int32(1)
	if isTransient != 0 && LM >= int32(2) && bits >= (LM+int32(2))<<int32(BITRES) {
		v28 = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
	} else {
		v28 = 0
	}
	anti_collapse_rsv = v28
	bits = bits - anti_collapse_rsv
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _171
	_171:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _173
_173:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _175
	_175:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _177
_177:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _179
	_179:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _181
_181:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _183
	_183:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _185
_185:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1448))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _187
	_187:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _189
_189:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _191
	_191:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _193
_193:
	pulses = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _195
	_195:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _197
_197:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _199
	_199:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _201
_201:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _203
	_203:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _205
_205:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _207
	_207:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _209
_209:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1449))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _211
	_211:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _213
_213:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _215
	_215:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _217
_217:
	fine_priority = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	codedBands = Opus_clt_compute_allocation(tls, mode, start, end, offsets, cap1, alloc_trim, bp+72, bp+76, bits, bp+80, pulses, fine_quant, fine_priority, C, LM, dec, 0, 0, 0)
	Opus_unquant_fine_energy(tls, mode, start, end, oldBandE, libc.UintptrFromInt32(0), fine_quant, dec, C)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _219
	_219:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _221
_221:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _223
	_223:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _225
_225:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _227
	_227:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _229
_229:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _231
	_231:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _233
_233:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1457))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _235
	_235:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _237
_237:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(C*N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _239
	_239:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _241
_241:
	X = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1))) /**< Interleaved normalised MDCTs */
	c = 0
	for {
		libc.Xmemmove(tls, decode_mem[c], decode_mem[c]+uintptr(N)*4, libc.Uint64FromInt32(decode_buffer_size-N+overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(decode_mem[c])-int64(decode_mem[c]+uintptr(N)*4))/4)))
		goto _243
	_243:
		;
		c = c + 1
		v28 = c
		if !(v28 < CC) {
			break
		}
	}
	/* Decode fixed codebook */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _245
	_245:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _247
_247:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _249
	_249:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _251
_251:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _253
	_253:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _255
_255:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _257
	_257:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _259
_259:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3767, int32(1487))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _261
	_261:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _263
_263:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(C*nbEBands) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _265
	_265:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _267
_267:
	collapse_masks = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
	if C == int32(2) {
		v1 = X + uintptr(N)*4
	} else {
		v1 = libc.UintptrFromInt32(0)
	}
	Opus_quant_all_bands(tls, 0, mode, start, end, X, v1, collapse_masks, libc.UintptrFromInt32(0), pulses, shortBlocks, spread_decision, *(*int32)(unsafe.Pointer(bp + 76)), *(*int32)(unsafe.Pointer(bp + 72)), tf_res, len1*(libc.Int32FromInt32(8)<<libc.Int32FromInt32(BITRES))-anti_collapse_rsv, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 80)), dec, LM, codedBands, st1+48, 0, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdisable_inv)
	if anti_collapse_rsv > 0 {
		anti_collapse_on = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, uint32(1)))
	}
	v1 = dec
	v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _271
_271:
	Opus_unquant_energy_finalise(tls, mode, start, end, oldBandE, fine_quant, fine_priority, len1*int32(8)-v28, dec, C)
	if anti_collapse_on != 0 {
		Opus_anti_collapse(tls, mode, X, collapse_masks, LM, C, N, start, end, oldBandE, oldLogE, oldLogE2, pulses, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Frng, 0, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
	}
	if silence != 0 {
		i = 0
		for {
			if !(i < C*nbEBands) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4)) = -libc.Float32FromFloat32(28)
			goto _272
		_272:
			;
			i = i + 1
		}
	}
	if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fprefilter_and_fold != 0 {
		prefilter_and_fold(tls, st1, N)
	}
	celt_synthesis(tls, mode, X, bp+56, oldBandE, start, effEnd, C, CC, isTransient, LM, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample, silence, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
	c = 0
	for {
		if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period > int32(COMBFILTER_MINPERIOD) {
			v37 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period
		} else {
			v37 = int32(COMBFILTER_MINPERIOD)
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period = v37
		if (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old > int32(COMBFILTER_MINPERIOD) {
			v28 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old
		} else {
			v28 = int32(COMBFILTER_MINPERIOD)
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old = v28
		Opus_comb_filter(tls, (*(*[2]uintptr)(unsafe.Pointer(bp + 56)))[c], (*(*[2]uintptr)(unsafe.Pointer(bp + 56)))[c], (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
		if LM != 0 {
			Opus_comb_filter(tls, (*(*[2]uintptr)(unsafe.Pointer(bp + 56)))[c]+uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize)*4, (*(*[2]uintptr)(unsafe.Pointer(bp + 56)))[c]+uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize)*4, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, postfilter_pitch, N-(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, postfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, postfilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
		}
		goto _274
	_274:
		;
		c = c + 1
		v28 = c
		if !(v28 < CC) {
			break
		}
	}
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period = postfilter_pitch
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain = postfilter_gain
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset = postfilter_tapset
	if LM != 0 {
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset
	}
	if C == int32(1) {
		libc.Xmemcpy(tls, oldBandE+uintptr(nbEBands)*4, oldBandE, libc.Uint64FromInt32(nbEBands)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(oldBandE+uintptr(nbEBands)*4)-int64(oldBandE))/4)))
	}
	if !(isTransient != 0) {
		libc.Xmemcpy(tls, oldLogE2, oldLogE, libc.Uint64FromInt32(libc.Int32FromInt32(2)*nbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldLogE2)-int64(oldLogE))/4)))
		libc.Xmemcpy(tls, oldLogE, oldBandE, libc.Uint64FromInt32(libc.Int32FromInt32(2)*nbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldLogE)-int64(oldBandE))/4)))
	} else {
		i = 0
		for {
			if !(i < int32(2)*nbEBands) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4)) < *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4)) {
				v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4))
			} else {
				v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4)) = v35
			goto _277
		_277:
			;
			i = i + 1
		}
	}
	/* In normal circumstances, we only allow the noise floor to increase by
	   up to 2.4 dB/second, but when we're in DTX we give the weight of
	   all missing packets to the update packet. */
	if int32(160) < (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration+M {
		v28 = int32(160)
	} else {
		v28 = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration + M
	}
	max_background_increase = OpusT_celt_glog(float32(v28) * libc.Float32FromFloat32(0.001))
	i = 0
	for {
		if !(i < int32(2)*nbEBands) {
			break
		}
		if *(*OpusT_celt_glog)(unsafe.Pointer(backgroundLogE + uintptr(i)*4))+max_background_increase < *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4)) {
			v35 = *(*OpusT_celt_glog)(unsafe.Pointer(backgroundLogE + uintptr(i)*4)) + max_background_increase
		} else {
			v35 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(i)*4))
		}
		*(*OpusT_celt_glog)(unsafe.Pointer(backgroundLogE + uintptr(i)*4)) = v35
		goto _280
	_280:
		;
		i = i + 1
	}
	/* In case start or end were to change */
	c = 0
	for {
		i = 0
		for {
			if !(i < start) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) = libc.Float32FromInt32(0)
			v35 = -libc.Float32FromFloat32(28)
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4)) = v35
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4)) = v35
			goto _284
		_284:
			;
			i = i + 1
		}
		i = end
		for {
			if !(i < nbEBands) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) = libc.Float32FromInt32(0)
			v35 = -libc.Float32FromFloat32(28)
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(c*nbEBands+i)*4)) = v35
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(c*nbEBands+i)*4)) = v35
			goto _286
		_286:
			;
			i = i + 1
		}
		goto _283
	_283:
		;
		c = c + 1
		v28 = c
		if !(v28 < int32(2)) {
			break
		}
	}
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Frng = (*OpusT_ec_dec)(unsafe.Pointer(dec)).Frng
	deemphasis(tls, bp+56, pcm, N, CC, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample, mode+16, st1+104, accum)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Floss_duration = 0
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fplc_duration = 0
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Flast_frame_type = int32(FRAME_NORMAL)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fprefilter_and_fold = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _289
	_289:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _291
_291:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	v1 = dec
	v28 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _294
_294:
	if v28 > int32(8)*len1 {
		return -int32(3)
	}
	v28 = (*OpusT_ec_ctx)(unsafe.Pointer(dec)).Ferror1
	goto _296
_296:
	if v28 != 0 {
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Ferror1 = int32(1)
	}
	return frame_size / (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fdownsample
}

func Opus_celt_decode_with_ec(tls *libc.TLS, st uintptr, data uintptr, len1 int32, pcm uintptr, frame_size int32, dec uintptr, accum int32) (r int32) {
	return Opus_celt_decode_with_ec_dred(tls, st, data, len1, pcm, frame_size, dec, accum)
}

func Opus_opus_custom_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var decode_buffer_size, i int32
	var oldBandE, oldLogE, oldLogE2, value1, value10, value12, value5, value6, value7, value8 uintptr
	var value, value11, value2, value3, value4, value9 OpusT_opus_int32
	var v2 OpusT_celt_glog
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, decode_buffer_size, i, oldBandE, oldLogE, oldLogE2, value, value1, value10, value11, value12, value2, value3, value4, value5, value6, value7, value8, value9, v2
	ap = va
	switch request {
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value = libc.VaInt32(&ap)
		if value < 0 || value > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fcomplexity = value
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value1)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fcomplexity
	case int32(CELT_SET_START_BAND_REQUEST):
		value2 = libc.VaInt32(&ap)
		if value2 < 0 || value2 >= (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart = value2
	case int32(CELT_SET_END_BAND_REQUEST):
		value3 = libc.VaInt32(&ap)
		if value3 < int32(1) || value3 > (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend = value3
	case int32(CELT_SET_CHANNELS_REQUEST):
		value4 = libc.VaInt32(&ap)
		if value4 < int32(1) || value4 > int32(2) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels = value4
	case int32(CELT_GET_AND_CLEAR_ERROR_REQUEST):
		value5 = libc.VaUintptr(&ap)
		if value5 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value5)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Ferror1
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Ferror1 = 0
	case int32(OPUS_GET_LOOKAHEAD_REQUEST):
		value6 = libc.VaUintptr(&ap)
		if value6 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value6)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap / (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample
	case int32(OPUS_RESET_STATE):
		decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
		oldBandE = st + 112 + uintptr((decode_buffer_size+(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap)*(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels)*4
		oldLogE = oldBandE + uintptr(int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		oldLogE2 = oldLogE + uintptr(int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		libc.Xmemset(tls, st+48, 0, libc.Uint64FromInt64(int64(opus_custom_decoder_get_size(tls, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels))-(int64(st+48)-int64(st)))*uint64(1))
		i = 0
		for {
			if !(i < int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands) {
				break
			}
			v2 = -libc.Float32FromFloat32(28)
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(i)*4)) = v2
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4)) = v2
			goto _1
		_1:
			;
			i = i + 1
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fskip_plc = int32(1)
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Flast_frame_type = FRAME_NONE
	case int32(OPUS_GET_PITCH_REQUEST):
		value7 = libc.VaUintptr(&ap)
		if value7 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value7)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period
	case int32(CELT_GET_MODE_REQUEST):
		value8 = libc.VaUintptr(&ap)
		if value8 == uintptr(0) {
			goto bad_arg
		}
		*(*uintptr)(unsafe.Pointer(value8)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode
	case int32(CELT_SET_SIGNALLING_REQUEST):
		value9 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fsignalling = value9
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value10 = libc.VaUintptr(&ap)
		if value10 == uintptr(0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value10)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Frng
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value11 = libc.VaInt32(&ap)
		if value11 < 0 || value11 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv = value11
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value12 = libc.VaUintptr(&ap)
		if !(value12 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value12)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv
	default:
		goto bad_request
	}
	_ = ap
	return OPUS_OK
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
	goto bad_request
bad_request:
	;
	_ = ap
	return -int32(5)
}

const CELT_SIG_SCALE8 = "32768.f"
const Q31ONE2 = "1.0f"
const VERY_SMALL2 = "1e-30f"

var trim_icdf10 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf10 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf10 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff9 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff9 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

func find_best_pitch(tls *libc.TLS, xcorr uintptr, y uintptr, len1 int32, max_pitch int32, best_pitch uintptr) {
	var Syy, xcorr16, v3 OpusT_opus_val32
	var best_den [2]OpusT_opus_val32
	var best_num [2]OpusT_opus_val16
	var i, j int32
	var num OpusT_opus_val16
	_, _, _, _, _, _, _, _ = Syy, best_den, best_num, i, j, num, xcorr16, v3
	Syy = libc.Float32FromInt32(1)
	best_num[0] = float32(-libc.Int32FromInt32(1))
	best_num[int32(1)] = float32(-libc.Int32FromInt32(1))
	best_den[0] = libc.Float32FromInt32(0)
	best_den[int32(1)] = libc.Float32FromInt32(0)
	*(*int32)(unsafe.Pointer(best_pitch)) = 0
	*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = int32(1)
	j = 0
	for {
		if !(j < len1) {
			break
		}
		Syy = Syy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(j)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(j)*4)))
		goto _1
	_1:
		;
		j = j + 1
	}
	i = 0
	for {
		if !(i < max_pitch) {
			break
		}
		if *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i)*4)) > libc.Float32FromInt32(0) {
			xcorr16 = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i)*4))
			/* Considering the range of xcorr16, this should avoid both underflows
			   and overflows (inf) when squaring xcorr16 */
			xcorr16 = xcorr16 * libc.Float32FromFloat32(1e-12)
			num = OpusT_opus_val32(xcorr16 * xcorr16)
			if OpusT_opus_val16(num*best_den[int32(1)]) > OpusT_opus_val16(best_num[int32(1)]*Syy) {
				if OpusT_opus_val16(num*best_den[0]) > OpusT_opus_val16(best_num[0]*Syy) {
					best_num[int32(1)] = best_num[0]
					best_den[int32(1)] = best_den[0]
					*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = *(*int32)(unsafe.Pointer(best_pitch))
					best_num[0] = num
					best_den[0] = Syy
					*(*int32)(unsafe.Pointer(best_pitch)) = i
				} else {
					best_num[int32(1)] = num
					best_den[int32(1)] = Syy
					*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = i
				}
			}
		}
		Syy = Syy + (OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i+len1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i+len1)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i)*4))))
		if float32(libc.Int32FromInt32(1)) > Syy {
			v3 = float32(libc.Int32FromInt32(1))
		} else {
			v3 = Syy
		}
		Syy = v3
		goto _2
	_2:
		;
		i = i + 1
	}
}

func celt_fir5(tls *libc.TLS, x uintptr, num uintptr, N int32) {
	var i int32
	var mem0, mem1, mem2, mem3, mem4, sum OpusT_opus_val32
	var num0, num1, num2, num3, num4 OpusT_opus_val16
	_, _, _, _, _, _, _, _, _, _, _, _ = i, mem0, mem1, mem2, mem3, mem4, num0, num1, num2, num3, num4, sum
	num0 = *(*OpusT_opus_val16)(unsafe.Pointer(num))
	num1 = *(*OpusT_opus_val16)(unsafe.Pointer(num + 1*4))
	num2 = *(*OpusT_opus_val16)(unsafe.Pointer(num + 2*4))
	num3 = *(*OpusT_opus_val16)(unsafe.Pointer(num + 3*4))
	num4 = *(*OpusT_opus_val16)(unsafe.Pointer(num + 4*4))
	mem0 = libc.Float32FromInt32(0)
	mem1 = libc.Float32FromInt32(0)
	mem2 = libc.Float32FromInt32(0)
	mem3 = libc.Float32FromInt32(0)
	mem4 = libc.Float32FromInt32(0)
	i = 0
	for {
		if !(i < N) {
			break
		}
		sum = *(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))
		sum = sum + OpusT_opus_val32(num0*mem0)
		sum = sum + OpusT_opus_val32(num1*mem1)
		sum = sum + OpusT_opus_val32(num2*mem2)
		sum = sum + OpusT_opus_val32(num3*mem3)
		sum = sum + OpusT_opus_val32(num4*mem4)
		mem4 = mem3
		mem3 = mem2
		mem2 = mem1
		mem1 = mem0
		mem0 = *(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))
		*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4)) = sum
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_pitch_downsample(tls *libc.TLS, x uintptr, x_lp uintptr, len1 int32, C int32, factor int32, arch int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var c1, tmp OpusT_opus_val16
	var i, offset int32
	var _ /* ac at bp+0 */ [5]OpusT_opus_val32
	var _ /* lpc at bp+20 */ [4]OpusT_opus_val16
	var _ /* lpc2 at bp+36 */ [5]OpusT_opus_val16
	_, _, _, _ = c1, i, offset, tmp
	tmp = libc.Float32FromFloat32(1)
	c1 = libc.Float32FromFloat32(0.8)
	offset = factor / int32(2)
	i = int32(1)
	for {
		if !(i < len1) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i-offset)*4))) + float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i+offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_val16)(unsafe.Pointer(x_lp)) = float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)))))
	if C == int32(2) {
		i = int32(1)
		for {
			if !(i < len1) {
				break
			}
			*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4)) += float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i-offset)*4))) + float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i+offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp)) += float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)))))
	}
	Opus__celt_autocorr(tls, x_lp, bp, libc.UintptrFromInt32(0), 0, int32(4), len1, arch)
	/* Noise floor -40 dB */
	*(*OpusT_opus_val32)(unsafe.Pointer(bp)) *= libc.Float32FromFloat32(1.0001)
	/* Lag windowing */
	i = int32(1)
	for {
		if !(i <= int32(4)) {
			break
		}
		/*ac[i] *= exp(-.5*(2*M_PI*.002*i)*(2*M_PI*.002*i));*/
		*(*OpusT_opus_val32)(unsafe.Pointer(bp + uintptr(i)*4)) -= OpusT_opus_val32(OpusT_opus_val32((*(*[5]OpusT_opus_val32)(unsafe.Pointer(bp)))[i]*float32(libc.Float32FromFloat32(0.008)*float32(i))) * float32(libc.Float32FromFloat32(0.008)*float32(i)))
		goto _3
	_3:
		;
		i = i + 1
	}
	Opus__celt_lpc(tls, bp+20, bp, int32(4))
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		tmp = float32(libc.Float32FromFloat32(0.9) * tmp)
		(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[i] = OpusT_opus_val16((*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[i] * tmp)
		goto _4
	_4:
		;
		i = i + 1
	}
	/* Add a zero */
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[0] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[0] + libc.Float32FromFloat32(0.8)
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(1)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(1)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[0])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(2)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(2)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(1)])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(3)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(3)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(2)])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(4)] = OpusT_opus_val16(c1 * (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(3)])
	celt_fir5(tls, x_lp, bp+36, len1)
}

// C documentation
//
//	/* Pure C implementation. */
func Opus_celt_pitch_xcorr_c(tls *libc.TLS, _x uintptr, _y uintptr, xcorr uintptr, len1 int32, max_pitch int32, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, i1, j, v18, v21, v5 int32
	var sum2, xy, v28 OpusT_opus_val32
	var tmp, tmp1, tmp2, tmp3, y_0, y_1, y_2, y_3 OpusT_opus_val16
	var v10, v11, v12, v13, v14, v15, v16, v17, v19, v2, v20, v22, v23, v24, v25, v3, v4, v6, v7, v8 uintptr
	var _ /* sum at bp+0 */ [4]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, i1, j, sum2, tmp, tmp1, tmp2, tmp3, xy, y_0, y_1, y_2, y_3, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v2, v20, v21, v22, v23, v24, v25, v28, v3, v4, v5, v6, v7, v8
	/*The EDSP version requires that max_pitch is at least 1, and that _x is
	  32-bit aligned.
	 Since it's hard to put asserts in assembly, put them here.*/
	if !(max_pitch > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4629, __ccgo_ts+4659, int32(265))
	}
	_ = uint64(_x)&libc.Uint64FromInt32(3) == libc.Uint64FromInt32(0)
	i1 = 0
	for {
		if !(i1 < max_pitch-int32(3)) {
			break
		}
		*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)) = [4]OpusT_opus_val32{}
		_ = arch
		v2 = _x
		v3 = _y + uintptr(i1)*4
		v4 = bp
		v5 = len1
		if !(v5 >= libc.Int32FromInt32(3)) {
			Opus_celt_fatal(tls, __ccgo_ts+3349, __ccgo_ts+3374, int32(69))
		}
		y_3 = libc.Float32FromInt32(0)
		v6 = v3
		v3 += 4
		y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v6))
		v7 = v3
		v3 += 4
		y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v7))
		v8 = v3
		v3 += 4
		y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v8))
		j = libc.Int32FromInt32(0)
		for {
			if !(j < v5-libc.Int32FromInt32(3)) {
				break
			}
			v10 = v2
			v2 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v10))
			v11 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v11))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp*y_3)
			v12 = v2
			v2 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v12))
			v13 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v13))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp*y_0)
			v14 = v2
			v2 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v14))
			v15 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v15))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp*y_1)
			v16 = v2
			v2 += 4
			tmp = *(*OpusT_opus_val16)(unsafe.Pointer(v16))
			v17 = v3
			v3 += 4
			y_2 = *(*OpusT_opus_val16)(unsafe.Pointer(v17))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp*y_2)
			goto _9
		_9:
			;
			j = j + int32(4)
		}
		v18 = j
		j = j + 1
		if v18 < v5 {
			v19 = v2
			v2 += 4
			tmp1 = *(*OpusT_opus_val16)(unsafe.Pointer(v19))
			v20 = v3
			v3 += 4
			y_3 = *(*OpusT_opus_val16)(unsafe.Pointer(v20))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp1*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp1*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp1*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp1*y_3)
		}
		v21 = j
		j = j + 1
		if v21 < v5 {
			v22 = v2
			v2 += 4
			tmp2 = *(*OpusT_opus_val16)(unsafe.Pointer(v22))
			v23 = v3
			v3 += 4
			y_0 = *(*OpusT_opus_val16)(unsafe.Pointer(v23))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp2*y_1)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp2*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp2*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp2*y_0)
		}
		if j < v5 {
			v24 = v2
			v2 += 4
			tmp3 = *(*OpusT_opus_val16)(unsafe.Pointer(v24))
			v25 = v3
			v3 += 4
			y_1 = *(*OpusT_opus_val16)(unsafe.Pointer(v25))
			*(*OpusT_opus_val32)(unsafe.Pointer(v4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4)) + OpusT_opus_val32(tmp3*y_2)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 1*4)) + OpusT_opus_val32(tmp3*y_3)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 2*4)) + OpusT_opus_val32(tmp3*y_0)
			*(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(v4 + 3*4)) + OpusT_opus_val32(tmp3*y_1)
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1+int32(1))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)]
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1+int32(2))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(2)]
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1+int32(3))*4)) = (*(*[4]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(3)]
		goto _1
	_1:
		;
		i1 = i1 + int32(4)
	}
	/* In case max_pitch isn't a multiple of 4, do non-unrolled version. */
	for {
		if !(i1 < max_pitch) {
			break
		}
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < len1) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(_x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(_y + uintptr(i1)*4 + uintptr(i)*4)))
			goto _27
		_27:
			;
			i = i + 1
		}
		v28 = xy
		goto _29
	_29:
		sum2 = v28
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = sum2
		goto _26
	_26:
		;
		i1 = i1 + 1
	}
}

func Opus_pitch_search(tls *libc.TLS, x_lp uintptr, y1 uintptr, len1 int32, max_pitch int32, pitch uintptr, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, st, x_lp4, xcorr, y_lp4, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var a, b, c, sum, xy, v81 OpusT_opus_val32
	var i, i1, j, lag, offset int32
	var _ /* best_pitch at bp+0 */ [2]int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, a, b, c, i, i1, j, lag, offset, st, sum, x_lp4, xcorr, xy, y_lp4, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v81, v9
	*(*[2]int32)(unsafe.Pointer(bp)) = [2]int32{}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(len1 > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4675, __ccgo_ts+4659, int32(325))
	}
	if !(max_pitch > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4629, __ccgo_ts+4659, int32(326))
	}
	lag = len1 + max_pitch
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4659, int32(329))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	x_lp4 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4659, int32(330))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	y_lp4 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4659, int32(331))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	xcorr = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Downsample by 2 again */
	j = 0
	for {
		if !(j < len1>>int32(2)) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp4 + uintptr(j)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(int32(2)*j)*4))
		goto _77
	_77:
		;
		j = j + 1
	}
	j = 0
	for {
		if !(j < lag>>int32(2)) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y_lp4 + uintptr(j)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(int32(2)*j)*4))
		goto _78
	_78:
		;
		j = j + 1
	}
	/* Coarse search with 4x decimation */
	Opus_celt_pitch_xcorr_c(tls, x_lp4, y_lp4, xcorr, len1>>int32(2), max_pitch>>int32(2), arch)
	find_best_pitch(tls, xcorr, y_lp4, len1>>int32(2), max_pitch>>int32(2), bp)
	/* Finer search with 2x decimation */
	i1 = 0
	for {
		if !(i1 < max_pitch>>int32(1)) {
			break
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = libc.Float32FromInt32(0)
		if libc.Xabs(tls, i1-int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[0]) > int32(2) && libc.Xabs(tls, i1-int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)]) > int32(2) {
			goto _79
		}
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < len1>>int32(1)) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i1)*4 + uintptr(i)*4)))
			goto _80
		_80:
			;
			i = i + 1
		}
		v81 = xy
		goto _82
	_82:
		sum = v81
		if float32(-libc.Int32FromInt32(1)) > sum {
			v81 = float32(-libc.Int32FromInt32(1))
		} else {
			v81 = sum
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = v81
		goto _79
	_79:
		;
		i1 = i1 + 1
	}
	find_best_pitch(tls, xcorr, y1, len1>>int32(1), max_pitch>>int32(1), bp)
	/* Refine by pseudo-interpolation */
	if (*(*[2]int32)(unsafe.Pointer(bp)))[0] > 0 && (*(*[2]int32)(unsafe.Pointer(bp)))[0] < max_pitch>>int32(1)-int32(1) {
		a = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0]-int32(1))*4))
		b = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0])*4))
		c = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0]+int32(1))*4))
		if c-a > float32(libc.Float32FromFloat32(0.7)*(b-a)) {
			offset = int32(1)
		} else {
			if a-c > float32(libc.Float32FromFloat32(0.7)*(b-c)) {
				offset = -int32(1)
			} else {
				offset = 0
			}
		}
	} else {
		offset = 0
	}
	*(*int32)(unsafe.Pointer(pitch)) = int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[0] - offset
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _85
	_85:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _87
_87:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func compute_pitch_gain(tls *libc.TLS, xy OpusT_opus_val32, xx OpusT_opus_val32, yy OpusT_opus_val32) (r OpusT_opus_val16) {
	return xy / float32(libc.Xsqrt(tls, float64(libc.Float32FromInt32(1)+OpusT_opus_val32(xx*yy))))
}

var second_check = [16]int32{
	2:  int32(3),
	3:  int32(2),
	4:  int32(3),
	5:  int32(2),
	6:  int32(5),
	7:  int32(2),
	8:  int32(3),
	9:  int32(2),
	10: int32(3),
	11: int32(2),
	12: int32(5),
	13: int32(2),
	14: int32(3),
	15: int32(2),
}

func Opus_remove_doubling(tls *libc.TLS, x2 uintptr, maxperiod int32, minperiod int32, N2 int32, T0_ uintptr, prev_period int32, prev_gain OpusT_opus_val16, arch int32) (r OpusT_opus_val16) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var T, T0, T1, T1b, i, i1, i2, k, minperiod0, offset, v5 int32
	var _saved_stack, st, yy_lookup, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var best_xy, best_yy, xy, xy01, xy02, yy, v33 OpusT_opus_val32
	var cont, g, g0, g1, pg, thresh, v34 OpusT_opus_val16
	var xcorr [3]OpusT_opus_val32
	var v36, v37 OpusT_opus_uint32
	var v44 float32
	var _ /* xx at bp+4 */ OpusT_opus_val32
	var _ /* xy at bp+0 */ OpusT_opus_val32
	var _ /* xy2 at bp+8 */ OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = T, T0, T1, T1b, _saved_stack, best_xy, best_yy, cont, g, g0, g1, i, i1, i2, k, minperiod0, offset, pg, st, thresh, xcorr, xy, xy01, xy02, yy, yy_lookup, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v33, v34, v36, v37, v44, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	minperiod0 = minperiod
	maxperiod = maxperiod / int32(2)
	minperiod = minperiod / int32(2)
	*(*int32)(unsafe.Pointer(T0_)) /= int32(2)
	prev_period = prev_period / int32(2)
	N2 = N2 / int32(2)
	x2 = x2 + uintptr(maxperiod)*4
	if *(*int32)(unsafe.Pointer(T0_)) >= maxperiod {
		*(*int32)(unsafe.Pointer(T0_)) = maxperiod - int32(1)
	}
	v5 = *(*int32)(unsafe.Pointer(T0_))
	T0 = v5
	T = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4659, int32(479))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	yy_lookup = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	_ = arch
	v1 = x2
	xy01 = libc.Float32FromInt32(0)
	xy02 = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N2) {
			break
		}
		xy01 = xy01 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(i)*4)))
		xy02 = xy02 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 - uintptr(T0)*4 + uintptr(i)*4)))
		goto _31
	_31:
		;
		i = i + 1
	}
	*(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)) = xy01
	*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = xy02
	*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup)) = *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4))
	yy = *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4))
	i2 = int32(1)
	for {
		if !(i2 <= maxperiod) {
			break
		}
		yy = yy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-i2)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-i2)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(N2-i2)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(N2-i2)*4)))
		if float32(libc.Int32FromInt32(0)) > yy {
			v33 = float32(libc.Int32FromInt32(0))
		} else {
			v33 = yy
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(i2)*4)) = v33
		goto _32
	_32:
		;
		i2 = i2 + 1
	}
	yy = *(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T0)*4))
	best_xy = *(*OpusT_opus_val32)(unsafe.Pointer(bp))
	best_yy = yy
	v34 = compute_pitch_gain(tls, *(*OpusT_opus_val32)(unsafe.Pointer(bp)), *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)), yy)
	g0 = v34
	g = v34
	/* Look for any pitch at T/k */
	k = int32(2)
	for {
		if !(k <= int32(15)) {
			break
		}
		cont = libc.Float32FromInt32(0)
		v36 = libc.Uint32FromInt32(int32(2) * k)
		_ = v36 > libc.Uint32FromInt32(0)
		v37 = libc.Uint32FromInt32(int32(2)*T0+k) / v36
		goto _38
	_38:
		T1 = libc.Int32FromUint32(v37)
		if T1 < minperiod {
			break
		}
		/* Look for another strong correlation at T1b */
		if k == int32(2) {
			if T1+T0 > maxperiod {
				T1b = T0
			} else {
				T1b = T0 + T1
			}
		} else {
			v36 = libc.Uint32FromInt32(int32(2) * k)
			_ = v36 > libc.Uint32FromInt32(0)
			v37 = libc.Uint32FromInt32(int32(2)*second_check[k]*T0+k) / v36
			goto _41
		_41:
			T1b = libc.Int32FromUint32(v37)
		}
		_ = arch
		v1 = x2
		xy01 = libc.Float32FromInt32(0)
		xy02 = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N2) {
				break
			}
			xy01 = xy01 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-T1)*4 + uintptr(i)*4)))
			xy02 = xy02 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-T1b)*4 + uintptr(i)*4)))
			goto _43
		_43:
			;
			i = i + 1
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = xy01
		*(*OpusT_opus_val32)(unsafe.Pointer(bp + 8)) = xy02
		*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_val32)(unsafe.Pointer(bp)) + *(*OpusT_opus_val32)(unsafe.Pointer(bp + 8))))
		yy = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T1)*4)) + *(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T1b)*4))))
		g1 = compute_pitch_gain(tls, *(*OpusT_opus_val32)(unsafe.Pointer(bp)), *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)), yy)
		if libc.Xabs(tls, T1-prev_period) <= int32(1) {
			cont = prev_gain
		} else {
			if libc.Xabs(tls, T1-prev_period) <= int32(2) && int32(5)*k*k < T0 {
				cont = float32(libc.Float32FromFloat32(0.5) * prev_gain)
			} else {
				cont = libc.Float32FromInt32(0)
			}
		}
		if libc.Float32FromFloat32(0.3) > float32(libc.Float32FromFloat32(0.7)*g0)-cont {
			v44 = libc.Float32FromFloat32(0.3)
		} else {
			v44 = float32(libc.Float32FromFloat32(0.7)*g0) - cont
		}
		thresh = v44
		/* Bias against very high pitch (very short period) to avoid false-positives
		   due to short-term correlation */
		if T1 < int32(3)*minperiod {
			if libc.Float32FromFloat32(0.4) > float32(libc.Float32FromFloat32(0.85)*g0)-cont {
				v44 = libc.Float32FromFloat32(0.4)
			} else {
				v44 = float32(libc.Float32FromFloat32(0.85)*g0) - cont
			}
			thresh = v44
		} else {
			if T1 < int32(2)*minperiod {
				if libc.Float32FromFloat32(0.5) > float32(libc.Float32FromFloat32(0.9)*g0)-cont {
					v44 = libc.Float32FromFloat32(0.5)
				} else {
					v44 = float32(libc.Float32FromFloat32(0.9)*g0) - cont
				}
				thresh = v44
			}
		}
		if g1 > thresh {
			best_xy = *(*OpusT_opus_val32)(unsafe.Pointer(bp))
			best_yy = yy
			T = T1
			g = g1
		}
		goto _35
	_35:
		;
		k = k + 1
	}
	if float32(libc.Int32FromInt32(0)) > best_xy {
		v33 = float32(libc.Int32FromInt32(0))
	} else {
		v33 = best_xy
	}
	best_xy = v33
	if best_yy <= best_xy {
		pg = libc.Float32FromFloat32(1)
	} else {
		pg = best_xy / (best_yy + libc.Float32FromInt32(1))
	}
	k = 0
	for {
		if !(k < int32(3)) {
			break
		}
		_ = arch
		xy = libc.Float32FromInt32(0)
		i1 = libc.Int32FromInt32(0)
		for {
			if !(i1 < N2) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(i1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 - uintptr(T+k-libc.Int32FromInt32(1))*4 + uintptr(i1)*4)))
			goto _49
		_49:
			;
			i1 = i1 + 1
		}
		v33 = xy
		goto _51
	_51:
		xcorr[k] = v33
		goto _48
	_48:
		;
		k = k + 1
	}
	if xcorr[int32(2)]-xcorr[0] > float32(libc.Float32FromFloat32(0.7)*(xcorr[int32(1)]-xcorr[0])) {
		offset = int32(1)
	} else {
		if xcorr[0]-xcorr[int32(2)] > float32(libc.Float32FromFloat32(0.7)*(xcorr[int32(1)]-xcorr[int32(2)])) {
			offset = -int32(1)
		} else {
			offset = 0
		}
	}
	if pg > g {
		pg = g
	}
	*(*int32)(unsafe.Pointer(T0_)) = int32(2)*T + offset
	if *(*int32)(unsafe.Pointer(T0_)) < minperiod0 {
		*(*int32)(unsafe.Pointer(T0_)) = minperiod0
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _55
_55:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return pg
}

const Q15ONE2 = "1.0f"

/* Copyright (c) 2001-2008 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2001-2011 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* (C) COPYRIGHT 1994-2002 Xiph.Org Foundation */
/* Modified by Jean-Marc Valin */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* opus_types.h based on ogg_types.h from libogg */

/**
  @file opus_types.h
  @brief Opus reference implementation types
*/
/* Copyright (c) 2010-2011 Xiph.Org Foundation, Skype Limited
   Written by Jean-Marc Valin and Koen Vos */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @file opus_defines.h
 * @brief Opus reference implementation constants
 */

/*Constants used by the entropy encoder/decoder.*/

/*The number of bits to output at a time.*/
/*The total number of bits in each of the state registers.*/
/*The maximum symbol value.*/
/*Bits to shift by to move a symbol into the high-order position.*/
/*Carry bit of the high-order range symbol.*/
/*Low-order bit of the high-order range symbol.*/
/*The number of bits available for the last, partial symbol in the code field.*/

/*A range encoder.
  See entdec.c and the references for implementation details \cite{Mar79,MNW98}.

  @INPROCEEDINGS{Mar79,
   author="Martin, G.N.N.",
   title="Range encoding: an algorithm for removing redundancy from a digitised
    message",
   booktitle="Video \& Data Recording Conference",
   year=1979,
   address="Southampton",
   month=Jul
  }
  @ARTICLE{MNW98,
   author="Alistair Moffat and Radford Neal and Ian H. Witten",
   title="Arithmetic Coding Revisited",
   journal="{ACM} Transactions on Information Systems",
   year=1998,
   volume=16,
   number=3,
   pages="256--294",
   month=Jul,
   URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98ArithmCoding.pdf"
  }*/

func ec_write_byte(tls *libc.TLS, _this uintptr, _value uint32) (r int32) {
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _ = v1, v2
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
		return -int32(1)
	}
	v2 = _this + 28
	v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
	*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) + 1
	*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr(v1))) = uint8(_value)
	return 0
}

func ec_write_byte_at_end(tls *libc.TLS, _this uintptr, _value uint32) (r int32) {
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _ = v1, v2
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
		return -int32(1)
	}
	v2 = _this + 12
	*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) + 1
	v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
	*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-v1))) = uint8(_value)
	return 0
}

// C documentation
//
//	/*Outputs a symbol, with a carry bit.
//	  If there is a potential to propagate a carry over several symbols, they are
//	   buffered until it can be determined whether or not an actual carry will
//	   occur.
//	  If the counter for the buffered symbols overflows, then the stream becomes
//	   undecodable.
//	  This gives a theoretical limit of a few billion symbols in a single packet on
//	   32-bit systems.
//	  The alternative is to truncate the range in order to force a carry, but
//	   requires similar carry tracking in the decoder, needlessly slowing it down.*/
func ec_enc_carry_out(tls *libc.TLS, _this uintptr, _c int32) {
	var carry int32
	var sym uint32
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _, _, _ = carry, sym, v1, v2
	if libc.Uint32FromInt32(_c) != libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1) {
		carry = _c >> int32(EC_SYM_BITS)
		/*Don't output a byte on the first write.
		  This compare should be taken care of by branch-prediction thereafter.*/
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 {
			*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte(tls, _this, libc.Uint32FromInt32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem+carry))
		}
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext > uint32(0) {
			sym = (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1) + libc.Uint32FromInt32(carry)) & (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1))
			for {
				*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte(tls, _this, sym)
				goto _3
			_3:
				;
				v2 = _this + 40
				*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) - 1
				v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
				if !(v1 > uint32(0)) {
					break
				}
			}
		}
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = libc.Int32FromUint32(libc.Uint32FromInt32(_c) & (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1)))
	} else {
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext + 1
	}
}

func ec_enc_normalize(tls *libc.TLS, _this uintptr) {
	/*If the range is too small, output some bits and rescale it.*/
	for (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>libc.Int32FromInt32(EC_SYM_BITS) {
		ec_enc_carry_out(tls, _this, libc.Int32FromUint32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval>>(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))))
		/*Move the next-to-high-order symbol into the high-order position.*/
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval << libc.Int32FromInt32(EC_SYM_BITS) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) <<= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		*(*int32)(unsafe.Pointer(_this + 24)) += int32(EC_SYM_BITS)
	}
}

func Opus_ec_enc_init(tls *libc.TLS, _this uintptr, _buf uintptr, _size OpusT_opus_uint32) {
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf = _buf
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits = 0
	/*This is the offset from which ec_tell() will subtract partial bits.*/
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnbits_total = libc.Int32FromInt32(EC_CODE_BITS) + libc.Int32FromInt32(1)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = libc.Uint32FromUint32(1) << (libc.Int32FromInt32(EC_CODE_BITS) - libc.Int32FromInt32(1))
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = -int32(1)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage = _size
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = 0
}

func Opus_ec_encode(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _ft uint32) {
	var r, v1, v2 OpusT_opus_uint32
	_, _, _ = r, v1, v2
	v1 = _ft
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng / v1
	goto _3
_3:
	r = v2
	if _fl > uint32(0) {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*(_ft-_fl)
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * (_fh - _fl)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * (_ft - _fh)
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_encode_bin(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _bits uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _bits
	if _fl > uint32(0) {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*(uint32(1)<<_bits-_fl)
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * (_fh - _fl)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * (uint32(1)<<_bits - _fh)
	}
	ec_enc_normalize(tls, _this)
}

// C documentation
//
//	/*The probability of having a "one" is 1/(1<<_logp).*/
func Opus_ec_enc_bit_logp(tls *libc.TLS, _this uintptr, _val int32, _logp uint32) {
	var l, r, s OpusT_opus_uint32
	var v1 uint32
	_, _, _, _ = l, r, s, v1
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng
	l = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval
	s = r >> _logp
	r = r - s
	if _val != 0 {
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = l + r
	}
	if _val != 0 {
		v1 = s
	} else {
		v1 = r
	}
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = v1
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_icdf(tls *libc.TLS, _this uintptr, _s int32, _icdf uintptr, _ftb uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _ftb
	if _s > 0 {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s-int32(1)))))
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s-int32(1)))))-libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s)))))
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s))))
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_icdf16(tls *libc.TLS, _this uintptr, _s int32, _icdf uintptr, _ftb uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _ftb
	if _s > 0 {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s-int32(1))*2)))
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * libc.Uint32FromInt32(libc.Int32FromUint16(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s-int32(1))*2)))-libc.Int32FromUint16(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s)*2))))
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s)*2)))
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_uint(tls *libc.TLS, _this uintptr, _fl OpusT_opus_uint32, _ft OpusT_opus_uint32) {
	var fl, ft uint32
	var ftb int32
	_, _, _ = fl, ft, ftb
	/*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
	if !(_ft > libc.Uint32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+3569, __ccgo_ts+4699, int32(191))
	}
	_ft = _ft - 1
	ftb = libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, _ft)
	if ftb > int32(EC_UINT_BITS) {
		ftb = ftb - int32(EC_UINT_BITS)
		ft = _ft>>ftb + uint32(1)
		fl = _fl >> ftb
		Opus_ec_encode(tls, _this, fl, fl+uint32(1), ft)
		Opus_ec_enc_bits(tls, _this, _fl&(libc.Uint32FromInt32(1)<<ftb-uint32(1)), libc.Uint32FromInt32(ftb))
	} else {
		Opus_ec_encode(tls, _this, _fl, _fl+uint32(1), _ft+uint32(1))
	}
}

func Opus_ec_enc_bits(tls *libc.TLS, _this uintptr, _fl OpusT_opus_uint32, _bits uint32) {
	var used int32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _ = used, window, v1
	window = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window
	used = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits
	if !(_bits > libc.Uint32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4716, __ccgo_ts+4699, int32(209))
	}
	if libc.Uint32FromInt32(used)+_bits > libc.Uint32FromInt32(libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT)) {
		for cond := true; cond; cond = used >= int32(EC_SYM_BITS) {
			*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte_at_end(tls, _this, window&(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1)))
			window = window >> libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
			used = used - int32(EC_SYM_BITS)
		}
	}
	window = window | _fl<<used
	used = libc.Int32FromUint32(uint32(used) + _bits)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window = window
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits = used
	v1 = _this + 24
	*(*int32)(unsafe.Pointer(v1)) = int32(uint32(*(*int32)(unsafe.Pointer(v1))) + _bits)
}

func Opus_ec_enc_patch_initial_bits(tls *libc.TLS, _this uintptr, _val uint32, _nbits uint32) {
	var mask uint32
	var shift int32
	_, _ = mask, shift
	if !(_nbits <= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))) {
		Opus_celt_fatal(tls, __ccgo_ts+4742, __ccgo_ts+4699, int32(228))
	}
	shift = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS)) - _nbits)
	mask = libc.Uint32FromInt32((int32(1)<<_nbits - int32(1)) << shift)
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs > uint32(0) {
		/*The first byte has been finalized.*/
		*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf)) = uint8(uint32(*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf))) & ^mask | _val<<shift)
	} else {
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 {
			/*The first byte is still awaiting carry propagation.*/
			(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem) & ^mask | _val<<shift)
		} else {
			if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>_nbits {
				/*The renormalization loop has never been run.*/
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval & ^(mask<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))) | _val<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1)+shift)
			} else {
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
			}
		}
	}
}

func Opus_ec_enc_shrink(tls *libc.TLS, _this uintptr, _size OpusT_opus_uint32) {
	if !((*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs <= _size) {
		Opus_celt_fatal(tls, __ccgo_ts+4780, __ccgo_ts+4699, int32(249))
	}
	libc.Xmemmove(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr(_size)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs), (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs), uint64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)*uint64(1)+libc.Uint64FromInt64(0*(int64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr(_size)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs))-int64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)))))
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage = _size
}

func Opus_ec_enc_done(tls *libc.TLS, _this uintptr) {
	var end, msk OpusT_opus_uint32
	var l, used int32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _, _, _, _ = end, l, msk, used, window, v1
	/*We output the minimum number of bits that ensures that the symbols encoded
	  thus far will be decoded correctly regardless of the bits that follow.*/
	l = int32(EC_CODE_BITS) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng))
	msk = (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1)) >> l
	end = ((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval + msk) & ^msk
	if end|msk >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng {
		l = l + 1
		msk = msk >> uint32(1)
		end = ((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval + msk) & ^msk
	}
	for l > 0 {
		ec_enc_carry_out(tls, _this, libc.Int32FromUint32(end>>(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))))
		end = end << libc.Int32FromInt32(EC_SYM_BITS) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
		l = l - int32(EC_SYM_BITS)
	}
	/*If we have a buffered byte flush it into the output buffer.*/
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 || (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext > uint32(0) {
		ec_enc_carry_out(tls, _this, 0)
	}
	/*If we have buffered extra bits, flush them as well.*/
	window = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window
	used = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits
	for used >= int32(EC_SYM_BITS) {
		*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte_at_end(tls, _this, window&(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1)))
		window = window >> libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		used = used - int32(EC_SYM_BITS)
	}
	/*Clear any excess space and add any remaining extra bits to the last byte.*/
	if !((*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 != 0) {
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf != 0 {
			libc.Xmemset(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs), 0, uint64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)*uint64(1))
		}
		if used > 0 {
			/*If there's no range coder data at all, give up.*/
			if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
			} else {
				l = -l
				/*If we've busted, don't add too many extra bits to the last byte; it
				  would corrupt the range coder data, and that's more important.*/
				if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage && l < used {
					window = window & libc.Uint32FromInt32(int32(1)<<l-int32(1))
					(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
				}
				v1 = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs-uint32(1))
				*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(v1))) | libc.Int32FromUint8(uint8(window)))
			}
		}
	}
}

var trim_icdf11 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf11 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf11 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff10 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff10 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

// C documentation
//
//	/* prediction coefficients: 0.9, 0.8, 0.65, 0.5 */
var pred_coef = [4]OpusT_opus_val16{
	0: float32(libc.Float64FromInt32(29440) / libc.Float64FromFloat64(32768)),
	1: float32(libc.Float64FromInt32(26112) / libc.Float64FromFloat64(32768)),
	2: float32(libc.Float64FromInt32(21248) / libc.Float64FromFloat64(32768)),
	3: float32(libc.Float64FromInt32(16384) / libc.Float64FromFloat64(32768)),
}
var beta_coef = [4]OpusT_opus_val16{
	0: float32(libc.Float64FromInt32(30147) / libc.Float64FromFloat64(32768)),
	1: float32(libc.Float64FromInt32(22282) / libc.Float64FromFloat64(32768)),
	2: float32(libc.Float64FromInt32(12124) / libc.Float64FromFloat64(32768)),
	3: float32(libc.Float64FromInt32(6554) / libc.Float64FromFloat64(32768)),
}
var beta_intra = float32(libc.Float64FromInt32(4915) / libc.Float64FromFloat64(32768))

// C documentation
//
//	/*Parameters of the Laplace-like probability models used for the coarse energy.
//	  There is one pair of parameters for each frame size, prediction type
//	   (inter/intra), and band number.
//	  The first number of each pair is the probability of 0, and the second is the
//	   decay rate, both in Q8 precision.*/
var e_prob_model = [4][2][42]uint8{
	0: {
		0: {
			0:  uint8(72),
			1:  uint8(127),
			2:  uint8(65),
			3:  uint8(129),
			4:  uint8(66),
			5:  uint8(128),
			6:  uint8(65),
			7:  uint8(128),
			8:  uint8(64),
			9:  uint8(128),
			10: uint8(62),
			11: uint8(128),
			12: uint8(64),
			13: uint8(128),
			14: uint8(64),
			15: uint8(128),
			16: uint8(92),
			17: uint8(78),
			18: uint8(92),
			19: uint8(79),
			20: uint8(92),
			21: uint8(78),
			22: uint8(90),
			23: uint8(79),
			24: uint8(116),
			25: uint8(41),
			26: uint8(115),
			27: uint8(40),
			28: uint8(114),
			29: uint8(40),
			30: uint8(132),
			31: uint8(26),
			32: uint8(132),
			33: uint8(26),
			34: uint8(145),
			35: uint8(17),
			36: uint8(161),
			37: uint8(12),
			38: uint8(176),
			39: uint8(10),
			40: uint8(177),
			41: uint8(11),
		},
		1: {
			0:  uint8(24),
			1:  uint8(179),
			2:  uint8(48),
			3:  uint8(138),
			4:  uint8(54),
			5:  uint8(135),
			6:  uint8(54),
			7:  uint8(132),
			8:  uint8(53),
			9:  uint8(134),
			10: uint8(56),
			11: uint8(133),
			12: uint8(55),
			13: uint8(132),
			14: uint8(55),
			15: uint8(132),
			16: uint8(61),
			17: uint8(114),
			18: uint8(70),
			19: uint8(96),
			20: uint8(74),
			21: uint8(88),
			22: uint8(75),
			23: uint8(88),
			24: uint8(87),
			25: uint8(74),
			26: uint8(89),
			27: uint8(66),
			28: uint8(91),
			29: uint8(67),
			30: uint8(100),
			31: uint8(59),
			32: uint8(108),
			33: uint8(50),
			34: uint8(120),
			35: uint8(40),
			36: uint8(122),
			37: uint8(37),
			38: uint8(97),
			39: uint8(43),
			40: uint8(78),
			41: uint8(50),
		},
	},
	1: {
		0: {
			0:  uint8(83),
			1:  uint8(78),
			2:  uint8(84),
			3:  uint8(81),
			4:  uint8(88),
			5:  uint8(75),
			6:  uint8(86),
			7:  uint8(74),
			8:  uint8(87),
			9:  uint8(71),
			10: uint8(90),
			11: uint8(73),
			12: uint8(93),
			13: uint8(74),
			14: uint8(93),
			15: uint8(74),
			16: uint8(109),
			17: uint8(40),
			18: uint8(114),
			19: uint8(36),
			20: uint8(117),
			21: uint8(34),
			22: uint8(117),
			23: uint8(34),
			24: uint8(143),
			25: uint8(17),
			26: uint8(145),
			27: uint8(18),
			28: uint8(146),
			29: uint8(19),
			30: uint8(162),
			31: uint8(12),
			32: uint8(165),
			33: uint8(10),
			34: uint8(178),
			35: uint8(7),
			36: uint8(189),
			37: uint8(6),
			38: uint8(190),
			39: uint8(8),
			40: uint8(177),
			41: uint8(9),
		},
		1: {
			0:  uint8(23),
			1:  uint8(178),
			2:  uint8(54),
			3:  uint8(115),
			4:  uint8(63),
			5:  uint8(102),
			6:  uint8(66),
			7:  uint8(98),
			8:  uint8(69),
			9:  uint8(99),
			10: uint8(74),
			11: uint8(89),
			12: uint8(71),
			13: uint8(91),
			14: uint8(73),
			15: uint8(91),
			16: uint8(78),
			17: uint8(89),
			18: uint8(86),
			19: uint8(80),
			20: uint8(92),
			21: uint8(66),
			22: uint8(93),
			23: uint8(64),
			24: uint8(102),
			25: uint8(59),
			26: uint8(103),
			27: uint8(60),
			28: uint8(104),
			29: uint8(60),
			30: uint8(117),
			31: uint8(52),
			32: uint8(123),
			33: uint8(44),
			34: uint8(138),
			35: uint8(35),
			36: uint8(133),
			37: uint8(31),
			38: uint8(97),
			39: uint8(38),
			40: uint8(77),
			41: uint8(45),
		},
	},
	2: {
		0: {
			0:  uint8(61),
			1:  uint8(90),
			2:  uint8(93),
			3:  uint8(60),
			4:  uint8(105),
			5:  uint8(42),
			6:  uint8(107),
			7:  uint8(41),
			8:  uint8(110),
			9:  uint8(45),
			10: uint8(116),
			11: uint8(38),
			12: uint8(113),
			13: uint8(38),
			14: uint8(112),
			15: uint8(38),
			16: uint8(124),
			17: uint8(26),
			18: uint8(132),
			19: uint8(27),
			20: uint8(136),
			21: uint8(19),
			22: uint8(140),
			23: uint8(20),
			24: uint8(155),
			25: uint8(14),
			26: uint8(159),
			27: uint8(16),
			28: uint8(158),
			29: uint8(18),
			30: uint8(170),
			31: uint8(13),
			32: uint8(177),
			33: uint8(10),
			34: uint8(187),
			35: uint8(8),
			36: uint8(192),
			37: uint8(6),
			38: uint8(175),
			39: uint8(9),
			40: uint8(159),
			41: uint8(10),
		},
		1: {
			0:  uint8(21),
			1:  uint8(178),
			2:  uint8(59),
			3:  uint8(110),
			4:  uint8(71),
			5:  uint8(86),
			6:  uint8(75),
			7:  uint8(85),
			8:  uint8(84),
			9:  uint8(83),
			10: uint8(91),
			11: uint8(66),
			12: uint8(88),
			13: uint8(73),
			14: uint8(87),
			15: uint8(72),
			16: uint8(92),
			17: uint8(75),
			18: uint8(98),
			19: uint8(72),
			20: uint8(105),
			21: uint8(58),
			22: uint8(107),
			23: uint8(54),
			24: uint8(115),
			25: uint8(52),
			26: uint8(114),
			27: uint8(55),
			28: uint8(112),
			29: uint8(56),
			30: uint8(129),
			31: uint8(51),
			32: uint8(132),
			33: uint8(40),
			34: uint8(150),
			35: uint8(33),
			36: uint8(140),
			37: uint8(29),
			38: uint8(98),
			39: uint8(35),
			40: uint8(77),
			41: uint8(42),
		},
	},
	3: {
		0: {
			0:  uint8(42),
			1:  uint8(121),
			2:  uint8(96),
			3:  uint8(66),
			4:  uint8(108),
			5:  uint8(43),
			6:  uint8(111),
			7:  uint8(40),
			8:  uint8(117),
			9:  uint8(44),
			10: uint8(123),
			11: uint8(32),
			12: uint8(120),
			13: uint8(36),
			14: uint8(119),
			15: uint8(33),
			16: uint8(127),
			17: uint8(33),
			18: uint8(134),
			19: uint8(34),
			20: uint8(139),
			21: uint8(21),
			22: uint8(147),
			23: uint8(23),
			24: uint8(152),
			25: uint8(20),
			26: uint8(158),
			27: uint8(25),
			28: uint8(154),
			29: uint8(26),
			30: uint8(166),
			31: uint8(21),
			32: uint8(173),
			33: uint8(16),
			34: uint8(184),
			35: uint8(13),
			36: uint8(184),
			37: uint8(10),
			38: uint8(150),
			39: uint8(13),
			40: uint8(139),
			41: uint8(15),
		},
		1: {
			0:  uint8(22),
			1:  uint8(178),
			2:  uint8(63),
			3:  uint8(114),
			4:  uint8(74),
			5:  uint8(82),
			6:  uint8(84),
			7:  uint8(83),
			8:  uint8(92),
			9:  uint8(82),
			10: uint8(103),
			11: uint8(62),
			12: uint8(96),
			13: uint8(72),
			14: uint8(96),
			15: uint8(67),
			16: uint8(101),
			17: uint8(73),
			18: uint8(107),
			19: uint8(72),
			20: uint8(113),
			21: uint8(55),
			22: uint8(118),
			23: uint8(52),
			24: uint8(125),
			25: uint8(52),
			26: uint8(118),
			27: uint8(52),
			28: uint8(117),
			29: uint8(55),
			30: uint8(135),
			31: uint8(49),
			32: uint8(137),
			33: uint8(39),
			34: uint8(157),
			35: uint8(32),
			36: uint8(145),
			37: uint8(29),
			38: uint8(97),
			39: uint8(33),
			40: uint8(77),
			41: uint8(40),
		},
	},
}

var small_energy_icdf = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

func loss_distortion(tls *libc.TLS, eBands uintptr, oldEBands uintptr, start int32, end int32, len1 int32, C int32) (r OpusT_opus_val32) {
	var c, i, v1 int32
	var d OpusT_celt_glog
	var dist, v4 OpusT_opus_val32
	_, _, _, _, _, _ = c, d, dist, i, v1, v4
	dist = libc.Float32FromInt32(0)
	c = 0
	for {
		i = start
		for {
			if !(i < end) {
				break
			}
			d = *(*OpusT_celt_glog)(unsafe.Pointer(eBands + uintptr(i+c*len1)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*len1)*4))
			dist = dist + OpusT_opus_val32(d*d)
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	if float32(libc.Int32FromInt32(200)) < dist {
		v4 = float32(libc.Int32FromInt32(200))
	} else {
		v4 = dist
	}
	return v4
}

func quant_coarse_energy_impl(tls *libc.TLS, m uintptr, start int32, end int32, eBands uintptr, oldEBands uintptr, budget OpusT_opus_int32, tell OpusT_opus_int32, prob_model uintptr, error1 uintptr, enc uintptr, C int32, LM int32, intra int32, max_decay OpusT_celt_glog, lfe int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var badness, bits_left, c, i, pi, qi0, v2, v7, v9 int32
	var beta, coef OpusT_opus_val16
	var decay_bound, oldE, x OpusT_celt_glog
	var f, q, tmp OpusT_opus_val32
	var prev [2]OpusT_opus_val32
	var v4 float32
	var v6 uintptr
	var _ /* qi at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = badness, beta, bits_left, c, coef, decay_bound, f, i, oldE, pi, prev, q, qi0, tmp, x, v2, v4, v6, v7, v9
	badness = 0
	prev = [2]OpusT_opus_val32{}
	if tell+int32(3) <= budget {
		Opus_ec_enc_bit_logp(tls, enc, intra, uint32(3))
	}
	if intra != 0 {
		coef = libc.Float32FromInt32(0)
		beta = beta_intra
	} else {
		beta = beta_coef[LM]
		coef = pred_coef[LM]
	}
	/* Encode at a fixed coarse resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		c = 0
		for {
			x = *(*OpusT_celt_glog)(unsafe.Pointer(eBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			if -libc.Float32FromFloat32(9) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v4 = -libc.Float32FromFloat32(9)
			} else {
				v4 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			oldE = v4
			f = x - OpusT_celt_glog(coef*oldE) - prev[c]
			/* Rounding to nearest integer here is really important! */
			*(*int32)(unsafe.Pointer(bp)) = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+f)))
			if -libc.Float32FromFloat32(28) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v4 = -libc.Float32FromFloat32(28)
			} else {
				v4 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			decay_bound = v4 - max_decay
			/* Prevent the energy from going down too quickly (e.g. for bands
			   that have just one bin) */
			if *(*int32)(unsafe.Pointer(bp)) < 0 && x < decay_bound {
				*(*int32)(unsafe.Pointer(bp)) = *(*int32)(unsafe.Pointer(bp)) + int32(decay_bound-x)
				if *(*int32)(unsafe.Pointer(bp)) > 0 {
					*(*int32)(unsafe.Pointer(bp)) = 0
				}
			}
			qi0 = *(*int32)(unsafe.Pointer(bp))
			/* If we don't have enough bits to encode all the energy, just assume
			   something safe. */
			v6 = enc
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v6)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v6)).Frng))
			goto _8
		_8:
			tell = v2
			bits_left = budget - tell - int32(3)*C*(end-i)
			if i != start && bits_left < int32(30) {
				if bits_left < int32(24) {
					if int32(1) < *(*int32)(unsafe.Pointer(bp)) {
						v2 = int32(1)
					} else {
						v2 = *(*int32)(unsafe.Pointer(bp))
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
				}
				if bits_left < int32(16) {
					if -int32(1) > *(*int32)(unsafe.Pointer(bp)) {
						v2 = -int32(1)
					} else {
						v2 = *(*int32)(unsafe.Pointer(bp))
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
				}
			}
			if lfe != 0 && i >= int32(2) {
				if *(*int32)(unsafe.Pointer(bp)) < 0 {
					v2 = *(*int32)(unsafe.Pointer(bp))
				} else {
					v2 = 0
				}
				*(*int32)(unsafe.Pointer(bp)) = v2
			}
			if budget-tell >= int32(15) {
				if i < int32(20) {
					v2 = i
				} else {
					v2 = int32(20)
				}
				pi = int32(2) * v2
				Opus_ec_laplace_encode(tls, enc, bp, libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi))))<<int32(7)), libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi+int32(1)))))<<int32(6))
			} else {
				if budget-tell >= int32(2) {
					if *(*int32)(unsafe.Pointer(bp)) < int32(1) {
						v7 = *(*int32)(unsafe.Pointer(bp))
					} else {
						v7 = int32(1)
					}
					if -int32(1) > v7 {
						v2 = -int32(1)
					} else {
						if *(*int32)(unsafe.Pointer(bp)) < int32(1) {
							v9 = *(*int32)(unsafe.Pointer(bp))
						} else {
							v9 = int32(1)
						}
						v2 = v9
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
					Opus_ec_enc_icdf(tls, enc, int32(2)**(*int32)(unsafe.Pointer(bp))^-libc.BoolInt32(*(*int32)(unsafe.Pointer(bp)) < 0), uintptr(unsafe.Pointer(&small_energy_icdf)), uint32(2))
				} else {
					if budget-tell >= int32(1) {
						if 0 < *(*int32)(unsafe.Pointer(bp)) {
							v2 = 0
						} else {
							v2 = *(*int32)(unsafe.Pointer(bp))
						}
						*(*int32)(unsafe.Pointer(bp)) = v2
						Opus_ec_enc_bit_logp(tls, enc, -*(*int32)(unsafe.Pointer(bp)), uint32(1))
					} else {
						*(*int32)(unsafe.Pointer(bp)) = -int32(1)
					}
				}
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = f - float32(*(*int32)(unsafe.Pointer(bp)))
			badness = badness + libc.Xabs(tls, qi0-*(*int32)(unsafe.Pointer(bp)))
			q = float32(*(*int32)(unsafe.Pointer(bp)))
			tmp = OpusT_opus_val16(coef*oldE) + prev[c] + q
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = tmp
			prev[c] = prev[c] + q - OpusT_opus_val16(beta*q)
			goto _3
		_3:
			;
			c = c + 1
			v2 = c
			if !(v2 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if lfe != 0 {
		v2 = 0
	} else {
		v2 = badness
	}
	return v2
}

func Opus_quant_coarse_energy(tls *libc.TLS, m uintptr, start int32, end int32, effEnd int32, eBands uintptr, oldEBands uintptr, budget OpusT_opus_uint32, error1 uintptr, enc uintptr, C int32, LM int32, nbAvailableBytes int32, force_intra int32, delayedIntra uintptr, two_pass int32, loss_rate int32, lfe int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var _saved_stack, error_intra, intra_bits, intra_buf, oldEBands_intra, st, v1, v10, v12, v14, v16, v18, v20, v22, v24, v26, v3, v5 uintptr
	var badness1, badness2, intra, v6 int32
	var intra_bias, tell_intra OpusT_opus_int32
	var max_decay, v9 OpusT_celt_glog
	var new_distortion OpusT_opus_val32
	var nintra_bytes, nstart_bytes, save_bytes, tell, v58 OpusT_opus_uint32
	var _ /* enc_intra_state at bp+56 */ OpusT_ec_enc
	var _ /* enc_start_state at bp+0 */ OpusT_ec_enc
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, badness1, badness2, error_intra, intra, intra_bias, intra_bits, intra_buf, max_decay, new_distortion, nintra_bytes, nstart_bytes, oldEBands_intra, save_bytes, st, tell, tell_intra, v1, v10, v12, v14, v16, v18, v20, v22, v24, v26, v3, v5, v58, v6, v9
	badness1 = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	intra = libc.BoolInt32(force_intra != 0 || !(two_pass != 0) && *(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) > OpusT_opus_val32(int32(2)*C*(end-start)) && nbAvailableBytes > (end-start)*C)
	intra_bias = int32(OpusT_opus_val32(OpusT_opus_val32(float32(budget)**(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)))*float32(loss_rate)) / float32(C*libc.Int32FromInt32(512)))
	new_distortion = loss_distortion(tls, eBands, oldEBands, start, effEnd, (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands, C)
	v1 = enc
	v6 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _7
_7:
	tell = libc.Uint32FromInt32(v6)
	if tell+uint32(3) > budget {
		v6 = libc.Int32FromInt32(0)
		intra = v6
		two_pass = v6
	}
	max_decay = libc.Float32FromFloat32(16)
	if end-start > int32(10) {
		if max_decay < float32(libc.Float32FromFloat32(0.125)*float32(nbAvailableBytes)) {
			v9 = max_decay
		} else {
			v9 = float32(libc.Float32FromFloat32(0.125) * float32(nbAvailableBytes))
		}
		max_decay = v9
	}
	if lfe != 0 {
		max_decay = libc.Float32FromFloat32(3)
	}
	*(*OpusT_ec_enc)(unsafe.Pointer(bp)) = *(*OpusT_ec_enc)(unsafe.Pointer(enc))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _13
_13:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _17
_17:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v12 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v12
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v14 = st
	goto _21
_21:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v16 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v16
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v18 = st
	goto _25
_25:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4833, int32(297))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v20 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v20
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v22 = st
	goto _29
_29:
	*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v24 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v24
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v26 = st
	goto _33
_33:
	oldEBands_intra = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _37
_37:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _41
_41:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v12 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v12
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v14 = st
	goto _45
_45:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v16 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v16
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v18 = st
	goto _49
_49:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4833, int32(298))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v20 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v20
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v22 = st
	goto _53
_53:
	*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v24 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v24
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v26 = st
	goto _57
_57:
	error_intra = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	libc.Xmemcpy(tls, oldEBands_intra, oldEBands, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands_intra)-int64(oldEBands))/4)))
	if two_pass != 0 || intra != 0 {
		badness1 = quant_coarse_energy_impl(tls, m, start, end, eBands, oldEBands_intra, libc.Int32FromUint32(budget), libc.Int32FromUint32(tell), uintptr(unsafe.Pointer(&e_prob_model))+uintptr(LM)*84+1*42, error_intra, enc, C, LM, int32(1), max_decay, lfe)
	}
	if !(intra != 0) {
		tell_intra = libc.Int32FromUint32(Opus_ec_tell_frac(tls, enc))
		*(*OpusT_ec_enc)(unsafe.Pointer(bp + 56)) = *(*OpusT_ec_enc)(unsafe.Pointer(enc))
		v58 = (*OpusT_ec_ctx)(unsafe.Pointer(bp)).Foffs
		goto _59
	_59:
		nstart_bytes = v58
		v58 = (*OpusT_ec_ctx)(unsafe.Pointer(bp + 56)).Foffs
		goto _61
	_61:
		nintra_bytes = v58
		v1 = (*OpusT_ec_ctx)(unsafe.Pointer(bp + 56)).Fbuf
		goto _63
	_63:
		intra_buf = v1 + uintptr(nstart_bytes)
		save_bytes = nintra_bytes - nstart_bytes
		if save_bytes == uint32(0) {
			save_bytes = uint32(ALLOC_NONE)
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _65
		_65:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _67
	_67:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _69
		_69:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _71
	_71:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v12 = libc.Xmalloc(tls, uint64(16))
			goto _73
		_73:
			st = v12
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v14 = st
		goto _75
	_75:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v16 = libc.Xmalloc(tls, uint64(16))
			goto _77
		_77:
			st = v16
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v18 = st
		goto _79
	_79:
		if !(int64(libc.Int32FromUint64(uint64(save_bytes)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4833, int32(328))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v20 = libc.Xmalloc(tls, uint64(16))
			goto _81
		_81:
			st = v20
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v22 = st
		goto _83
	_83:
		*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(uint64(save_bytes) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v24 = libc.Xmalloc(tls, uint64(16))
			goto _85
		_85:
			st = v24
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v26 = st
		goto _87
	_87:
		intra_bits = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(uint64(save_bytes)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
		/* Copy bits from intra bit-stream */
		libc.Xmemcpy(tls, intra_bits, intra_buf, uint64(nintra_bytes-nstart_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(intra_bits)-int64(intra_buf))))
		*(*OpusT_ec_enc)(unsafe.Pointer(enc)) = *(*OpusT_ec_enc)(unsafe.Pointer(bp))
		badness2 = quant_coarse_energy_impl(tls, m, start, end, eBands, oldEBands, libc.Int32FromUint32(budget), libc.Int32FromUint32(tell), uintptr(unsafe.Pointer(&e_prob_model))+uintptr(LM)*84+uintptr(intra)*42, error1, enc, C, LM, 0, max_decay, lfe)
		if two_pass != 0 && (badness1 < badness2 || badness1 == badness2 && libc.Int32FromUint32(Opus_ec_tell_frac(tls, enc))+intra_bias > tell_intra) {
			*(*OpusT_ec_enc)(unsafe.Pointer(enc)) = *(*OpusT_ec_enc)(unsafe.Pointer(bp + 56))
			/* Copy intra bits to bit-stream */
			libc.Xmemcpy(tls, intra_buf, intra_bits, uint64(nintra_bytes-nstart_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(intra_buf)-int64(intra_bits))))
			libc.Xmemcpy(tls, oldEBands, oldEBands_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands)-int64(oldEBands_intra))/4)))
			libc.Xmemcpy(tls, error1, error_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(error1)-int64(error_intra))/4)))
			intra = int32(1)
		}
	} else {
		libc.Xmemcpy(tls, oldEBands, oldEBands_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands)-int64(oldEBands_intra))/4)))
		libc.Xmemcpy(tls, error1, error_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(error1)-int64(error_intra))/4)))
	}
	if intra != 0 {
		*(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) = new_distortion
	} else {
		*(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) = OpusT_opus_val16(OpusT_opus_val16(pred_coef[LM]*pred_coef[LM])**(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra))) + new_distortion
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _89
	_89:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _91
_91:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_quant_fine_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, error1 uintptr, prev_quant uintptr, extra_quant uintptr, enc uintptr, C int32) {
	var c, i, q2, v3 int32
	var extra, prev OpusT_opus_int16
	var offset OpusT_celt_glog
	var v2 uintptr
	_, _, _, _, _, _, _, _ = c, extra, i, offset, prev, q2, v2, v3
	/* Encode finer resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		extra = int16(int32(1) << *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))
		if *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) <= 0 {
			goto _1
		}
		v2 = enc
		v3 = (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Frng))
		goto _4
	_4:
		if v3+C**(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) > libc.Int32FromUint32((*OpusT_ec_enc)(unsafe.Pointer(enc)).Fstorage)*int32(8) {
			goto _1
		}
		if prev_quant != libc.UintptrFromInt32(0) {
			v3 = *(*int32)(unsafe.Pointer(prev_quant + uintptr(i)*4))
		} else {
			v3 = 0
		}
		prev = int16(v3)
		c = 0
		for {
			q2 = int32(libc.Xfloor(tls, float64((OpusT_celt_glog(*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))*float32(libc.Int32FromInt32(1)<<prev))+libc.Float32FromFloat32(0.5))*float32(extra))))
			if q2 > int32(extra)-int32(1) {
				q2 = int32(extra) - int32(1)
			}
			if q2 < 0 {
				q2 = 0
			}
			Opus_ec_enc_bits(tls, enc, libc.Uint32FromInt32(q2), libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4))))
			offset = float32(float32((float32(q2)+libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384))) - libc.Float32FromFloat32(0.5)
			offset = offset * OpusT_celt_glog(float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(prev)))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384)))
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
			*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) -= offset
			/*printf ("%f ", error[i] - offset);*/
			goto _7
		_7:
			;
			c = c + 1
			v3 = c
			if !(v3 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_quant_energy_finalise(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, error1 uintptr, fine_quant uintptr, fine_priority uintptr, bits_left int32, enc uintptr, C int32) {
	var c, i, prio, q2, v3, v5 int32
	var offset OpusT_celt_glog
	_, _, _, _, _, _, _ = c, i, offset, prio, q2, v3, v5
	/* Use up the remaining bits */
	prio = 0
	for {
		if !(prio < int32(2)) {
			break
		}
		i = start
		for {
			if !(i < end && bits_left >= C) {
				break
			}
			if *(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4)) >= int32(MAX_FINE_BITS) || *(*int32)(unsafe.Pointer(fine_priority + uintptr(i)*4)) != prio {
				goto _2
			}
			c = 0
			for {
				if *(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) < libc.Float32FromInt32(0) {
					v5 = 0
				} else {
					v5 = int32(1)
				}
				q2 = v5
				Opus_ec_enc_bits(tls, enc, libc.Uint32FromInt32(q2), uint32(1))
				offset = OpusT_celt_glog(float32((float32(q2)-libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4))-libc.Int32FromInt32(1)))) * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384)))
				if oldEBands != libc.UintptrFromInt32(0) {
					*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) -= offset
				bits_left = bits_left - 1
				goto _4
			_4:
				;
				c = c + 1
				v3 = c
				if !(v3 < C) {
					break
				}
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		prio = prio + 1
	}
}

func Opus_unquant_coarse_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, intra int32, dec uintptr, C int32, LM int32) {
	var beta, coef OpusT_opus_val16
	var budget, tell OpusT_opus_int32
	var c, i, pi, qi, v2 int32
	var prev [2]OpusT_opus_val64
	var prob_model, v4 uintptr
	var q, tmp OpusT_opus_val32
	var v8 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = beta, budget, c, coef, i, pi, prev, prob_model, q, qi, tell, tmp, v2, v4, v8
	prob_model = uintptr(unsafe.Pointer(&e_prob_model)) + uintptr(LM)*84 + uintptr(intra)*42
	prev = [2]OpusT_opus_val64{}
	if intra != 0 {
		coef = libc.Float32FromInt32(0)
		beta = beta_intra
	} else {
		beta = beta_coef[LM]
		coef = pred_coef[LM]
	}
	budget = libc.Int32FromUint32((*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage * uint32(8))
	/* Decode at a fixed coarse resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		c = 0
		for {
			/* It would be better to express this invariant as a
			   test on C at function entry, but that isn't enough
			   to make the static analyzer happy. */
			_ = c < libc.Int32FromInt32(2)
			v4 = dec
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v4)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v4)).Frng))
			goto _6
		_6:
			tell = v2
			if budget-tell >= int32(15) {
				if i < int32(20) {
					v2 = i
				} else {
					v2 = int32(20)
				}
				pi = int32(2) * v2
				qi = Opus_ec_laplace_decode(tls, dec, libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi))))<<int32(7)), libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi+int32(1)))))<<int32(6))
			} else {
				if budget-tell >= int32(2) {
					qi = Opus_ec_dec_icdf(tls, dec, uintptr(unsafe.Pointer(&small_energy_icdf)), uint32(2))
					qi = qi>>int32(1) ^ -(qi & int32(1))
				} else {
					if budget-tell >= int32(1) {
						qi = -Opus_ec_dec_bit_logp(tls, dec, uint32(1))
					} else {
						qi = -int32(1)
					}
				}
			}
			q = float32(qi)
			if -libc.Float32FromFloat32(9) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v8 = -libc.Float32FromFloat32(9)
			} else {
				v8 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = v8
			tmp = OpusT_opus_val16(coef**(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))) + prev[c] + q
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = tmp
			prev[c] = prev[c] + q - OpusT_opus_val16(beta*q)
			goto _3
		_3:
			;
			c = c + 1
			v2 = c
			if !(v2 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_unquant_fine_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, prev_quant uintptr, extra_quant uintptr, dec uintptr, C int32) {
	var c, i, q2, v3 int32
	var extra, prev OpusT_opus_int16
	var offset OpusT_celt_glog
	var v2 uintptr
	_, _, _, _, _, _, _, _ = c, extra, i, offset, prev, q2, v2, v3
	/* Decode finer resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		extra = int16(*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))
		if *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) <= 0 {
			goto _1
		}
		v2 = dec
		v3 = (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Frng))
		goto _4
	_4:
		if v3+C**(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) > libc.Int32FromUint32((*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage)*int32(8) {
			goto _1
		}
		if prev_quant != libc.UintptrFromInt32(0) {
			v3 = *(*int32)(unsafe.Pointer(prev_quant + uintptr(i)*4))
		} else {
			v3 = 0
		}
		prev = int16(v3)
		c = 0
		for {
			q2 = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, libc.Uint32FromInt16(extra)))
			offset = float32(float32((float32(q2)+libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(extra))))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384))) - libc.Float32FromFloat32(0.5)
			offset = offset * OpusT_celt_glog(float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(prev)))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384)))
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
			goto _7
		_7:
			;
			c = c + 1
			v3 = c
			if !(v3 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_unquant_energy_finalise(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, fine_quant uintptr, fine_priority uintptr, bits_left int32, dec uintptr, C int32) {
	var c, i, prio, q2, v3 int32
	var offset OpusT_celt_glog
	_, _, _, _, _, _ = c, i, offset, prio, q2, v3
	/* Use up the remaining bits */
	prio = 0
	for {
		if !(prio < int32(2)) {
			break
		}
		i = start
		for {
			if !(i < end && bits_left >= C) {
				break
			}
			if *(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4)) >= int32(MAX_FINE_BITS) || *(*int32)(unsafe.Pointer(fine_priority + uintptr(i)*4)) != prio {
				goto _2
			}
			c = 0
			for {
				q2 = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, uint32(1)))
				offset = OpusT_celt_glog(float32((float32(q2)-libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4))-libc.Int32FromInt32(1)))) * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384)))
				if oldEBands != libc.UintptrFromInt32(0) {
					*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
				}
				bits_left = bits_left - 1
				goto _4
			_4:
				;
				c = c + 1
				v3 = c
				if !(v3 < C) {
					break
				}
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		prio = prio + 1
	}
}

func Opus_amp2Log2(tls *libc.TLS, m uintptr, effEnd int32, end int32, bandE uintptr, bandLogE uintptr, C int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, i, v1 int32
	var integer, range_idx OpusT_opus_int32
	var v4 float32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _ = c, i, integer, range_idx, v1, v4
	c = 0
	for {
		i = 0
		for {
			if !(i < effEnd) {
				break
			}
			*(*float32)(unsafe.Pointer(bp)) = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)) - int32(127)
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
			range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(20) & uint32(0x7))
			*(*float32)(unsafe.Pointer(bp)) = float32(*(*float32)(unsafe.Pointer(bp))*log2_x_norm_coeff10[range_idx]) - libc.Float32FromFloat32(1.0625)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp))*-libc.Float32FromFloat32(0.2841544449329376))))))))
			v4 = float32(integer) + *(*float32)(unsafe.Pointer(bp)) + log2_y_norm_coeff10[range_idx]
			goto _5
		_5:
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = v4 - Opus_eMeans[i]
			goto _3
		_3:
			;
			i = i + 1
		}
		i = effEnd
		for {
			if !(i < end) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) = -libc.Float32FromFloat32(14)
			goto _6
		_6:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
}

const BITALLOC_SIZE = 11
const TOTAL_MODES = 1

var trim_icdf12 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf12 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf12 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff11 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff11 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2010 Xiph.Org Foundation
 * Copyright (c) 2013 Parrot */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var eband5ms = [22]OpusT_opus_int16{
	1:  int16(1),
	2:  int16(2),
	3:  int16(3),
	4:  int16(4),
	5:  int16(5),
	6:  int16(6),
	7:  int16(7),
	8:  int16(8),
	9:  int16(10),
	10: int16(12),
	11: int16(14),
	12: int16(16),
	13: int16(20),
	14: int16(24),
	15: int16(28),
	16: int16(34),
	17: int16(40),
	18: int16(48),
	19: int16(60),
	20: int16(78),
	21: int16(100),
}

// C documentation
//
//	/* Alternate tuning (partially derived from Vorbis) */
//	/* Bit allocation table in units of 1/32 bit/sample (0.1875 dB SNR) */
var band_allocation = [231]uint8{
	21:  uint8(90),
	22:  uint8(80),
	23:  uint8(75),
	24:  uint8(69),
	25:  uint8(63),
	26:  uint8(56),
	27:  uint8(49),
	28:  uint8(40),
	29:  uint8(34),
	30:  uint8(29),
	31:  uint8(20),
	32:  uint8(18),
	33:  uint8(10),
	42:  uint8(110),
	43:  uint8(100),
	44:  uint8(90),
	45:  uint8(84),
	46:  uint8(78),
	47:  uint8(71),
	48:  uint8(65),
	49:  uint8(58),
	50:  uint8(51),
	51:  uint8(45),
	52:  uint8(39),
	53:  uint8(32),
	54:  uint8(26),
	55:  uint8(20),
	56:  uint8(12),
	63:  uint8(118),
	64:  uint8(110),
	65:  uint8(103),
	66:  uint8(93),
	67:  uint8(86),
	68:  uint8(80),
	69:  uint8(75),
	70:  uint8(70),
	71:  uint8(65),
	72:  uint8(59),
	73:  uint8(53),
	74:  uint8(47),
	75:  uint8(40),
	76:  uint8(31),
	77:  uint8(23),
	78:  uint8(15),
	79:  uint8(4),
	84:  uint8(126),
	85:  uint8(119),
	86:  uint8(112),
	87:  uint8(104),
	88:  uint8(95),
	89:  uint8(89),
	90:  uint8(83),
	91:  uint8(78),
	92:  uint8(72),
	93:  uint8(66),
	94:  uint8(60),
	95:  uint8(54),
	96:  uint8(47),
	97:  uint8(39),
	98:  uint8(32),
	99:  uint8(25),
	100: uint8(17),
	101: uint8(12),
	102: uint8(1),
	105: uint8(134),
	106: uint8(127),
	107: uint8(120),
	108: uint8(114),
	109: uint8(103),
	110: uint8(97),
	111: uint8(91),
	112: uint8(85),
	113: uint8(78),
	114: uint8(72),
	115: uint8(66),
	116: uint8(60),
	117: uint8(54),
	118: uint8(47),
	119: uint8(41),
	120: uint8(35),
	121: uint8(29),
	122: uint8(23),
	123: uint8(16),
	124: uint8(10),
	125: uint8(1),
	126: uint8(144),
	127: uint8(137),
	128: uint8(130),
	129: uint8(124),
	130: uint8(113),
	131: uint8(107),
	132: uint8(101),
	133: uint8(95),
	134: uint8(88),
	135: uint8(82),
	136: uint8(76),
	137: uint8(70),
	138: uint8(64),
	139: uint8(57),
	140: uint8(51),
	141: uint8(45),
	142: uint8(39),
	143: uint8(33),
	144: uint8(26),
	145: uint8(15),
	146: uint8(1),
	147: uint8(152),
	148: uint8(145),
	149: uint8(138),
	150: uint8(132),
	151: uint8(123),
	152: uint8(117),
	153: uint8(111),
	154: uint8(105),
	155: uint8(98),
	156: uint8(92),
	157: uint8(86),
	158: uint8(80),
	159: uint8(74),
	160: uint8(67),
	161: uint8(61),
	162: uint8(55),
	163: uint8(49),
	164: uint8(43),
	165: uint8(36),
	166: uint8(20),
	167: uint8(1),
	168: uint8(162),
	169: uint8(155),
	170: uint8(148),
	171: uint8(142),
	172: uint8(133),
	173: uint8(127),
	174: uint8(121),
	175: uint8(115),
	176: uint8(108),
	177: uint8(102),
	178: uint8(96),
	179: uint8(90),
	180: uint8(84),
	181: uint8(77),
	182: uint8(71),
	183: uint8(65),
	184: uint8(59),
	185: uint8(53),
	186: uint8(46),
	187: uint8(30),
	188: uint8(1),
	189: uint8(172),
	190: uint8(165),
	191: uint8(158),
	192: uint8(152),
	193: uint8(143),
	194: uint8(137),
	195: uint8(131),
	196: uint8(125),
	197: uint8(118),
	198: uint8(112),
	199: uint8(106),
	200: uint8(100),
	201: uint8(94),
	202: uint8(87),
	203: uint8(81),
	204: uint8(75),
	205: uint8(69),
	206: uint8(63),
	207: uint8(56),
	208: uint8(45),
	209: uint8(20),
	210: uint8(200),
	211: uint8(200),
	212: uint8(200),
	213: uint8(200),
	214: uint8(200),
	215: uint8(200),
	216: uint8(200),
	217: uint8(200),
	218: uint8(198),
	219: uint8(193),
	220: uint8(188),
	221: uint8(183),
	222: uint8(178),
	223: uint8(173),
	224: uint8(168),
	225: uint8(163),
	226: uint8(158),
	227: uint8(153),
	228: uint8(148),
	229: uint8(129),
	230: uint8(104),
}
var window120 = [120]OpusT_celt_coef{
	0:   libc.Float32FromFloat32(6.7286966e-05),
	1:   libc.Float32FromFloat32(0.00060551348),
	2:   libc.Float32FromFloat32(0.001681597),
	3:   libc.Float32FromFloat32(0.0032947962),
	4:   libc.Float32FromFloat32(0.0054439943),
	5:   libc.Float32FromFloat32(0.0081276923),
	6:   libc.Float32FromFloat32(0.011344001),
	7:   libc.Float32FromFloat32(0.015090633),
	8:   libc.Float32FromFloat32(0.019364886),
	9:   libc.Float32FromFloat32(0.024163635),
	10:  libc.Float32FromFloat32(0.029483315),
	11:  libc.Float32FromFloat32(0.035319905),
	12:  libc.Float32FromFloat32(0.041668911),
	13:  libc.Float32FromFloat32(0.048525347),
	14:  libc.Float32FromFloat32(0.055883718),
	15:  libc.Float32FromFloat32(0.063737999),
	16:  libc.Float32FromFloat32(0.072081616),
	17:  libc.Float32FromFloat32(0.080907428),
	18:  libc.Float32FromFloat32(0.090207705),
	19:  libc.Float32FromFloat32(0.099974111),
	20:  libc.Float32FromFloat32(0.11019769),
	21:  libc.Float32FromFloat32(0.12086883),
	22:  libc.Float32FromFloat32(0.13197729),
	23:  libc.Float32FromFloat32(0.14351214),
	24:  libc.Float32FromFloat32(0.15546177),
	25:  libc.Float32FromFloat32(0.16781389),
	26:  libc.Float32FromFloat32(0.1805555),
	27:  libc.Float32FromFloat32(0.1936729),
	28:  libc.Float32FromFloat32(0.20715171),
	29:  libc.Float32FromFloat32(0.22097682),
	30:  libc.Float32FromFloat32(0.23513243),
	31:  libc.Float32FromFloat32(0.24960208),
	32:  libc.Float32FromFloat32(0.2643686),
	33:  libc.Float32FromFloat32(0.27941419),
	34:  libc.Float32FromFloat32(0.2947204),
	35:  libc.Float32FromFloat32(0.31026818),
	36:  libc.Float32FromFloat32(0.32603788),
	37:  libc.Float32FromFloat32(0.34200931),
	38:  libc.Float32FromFloat32(0.35816177),
	39:  libc.Float32FromFloat32(0.37447407),
	40:  libc.Float32FromFloat32(0.39092462),
	41:  libc.Float32FromFloat32(0.40749142),
	42:  libc.Float32FromFloat32(0.42415215),
	43:  libc.Float32FromFloat32(0.44088423),
	44:  libc.Float32FromFloat32(0.45766484),
	45:  libc.Float32FromFloat32(0.47447104),
	46:  libc.Float32FromFloat32(0.49127978),
	47:  libc.Float32FromFloat32(0.50806798),
	48:  libc.Float32FromFloat32(0.52481261),
	49:  libc.Float32FromFloat32(0.54149077),
	50:  libc.Float32FromFloat32(0.55807973),
	51:  libc.Float32FromFloat32(0.57455701),
	52:  libc.Float32FromFloat32(0.59090049),
	53:  libc.Float32FromFloat32(0.60708841),
	54:  libc.Float32FromFloat32(0.62309951),
	55:  libc.Float32FromFloat32(0.63891306),
	56:  libc.Float32FromFloat32(0.65450896),
	57:  libc.Float32FromFloat32(0.66986776),
	58:  libc.Float32FromFloat32(0.68497077),
	59:  libc.Float32FromFloat32(0.6998001),
	60:  libc.Float32FromFloat32(0.71433873),
	61:  libc.Float32FromFloat32(0.72857055),
	62:  libc.Float32FromFloat32(0.74248043),
	63:  libc.Float32FromFloat32(0.75605425),
	64:  libc.Float32FromFloat32(0.76927895),
	65:  libc.Float32FromFloat32(0.78214257),
	66:  libc.Float32FromFloat32(0.7946343),
	67:  libc.Float32FromFloat32(0.80674445),
	68:  libc.Float32FromFloat32(0.81846456),
	69:  libc.Float32FromFloat32(0.82978733),
	70:  libc.Float32FromFloat32(0.84070669),
	71:  libc.Float32FromFloat32(0.85121779),
	72:  libc.Float32FromFloat32(0.86131698),
	73:  libc.Float32FromFloat32(0.87100183),
	74:  libc.Float32FromFloat32(0.88027111),
	75:  libc.Float32FromFloat32(0.88912479),
	76:  libc.Float32FromFloat32(0.89756398),
	77:  libc.Float32FromFloat32(0.90559094),
	78:  libc.Float32FromFloat32(0.91320904),
	79:  libc.Float32FromFloat32(0.9204227),
	80:  libc.Float32FromFloat32(0.92723738),
	81:  libc.Float32FromFloat32(0.93365955),
	82:  libc.Float32FromFloat32(0.93969656),
	83:  libc.Float32FromFloat32(0.94535671),
	84:  libc.Float32FromFloat32(0.95064907),
	85:  libc.Float32FromFloat32(0.95558353),
	86:  libc.Float32FromFloat32(0.96017067),
	87:  libc.Float32FromFloat32(0.96442171),
	88:  libc.Float32FromFloat32(0.96834849),
	89:  libc.Float32FromFloat32(0.97196334),
	90:  libc.Float32FromFloat32(0.97527906),
	91:  libc.Float32FromFloat32(0.97830883),
	92:  libc.Float32FromFloat32(0.98106616),
	93:  libc.Float32FromFloat32(0.9835648),
	94:  libc.Float32FromFloat32(0.98581869),
	95:  libc.Float32FromFloat32(0.98784191),
	96:  libc.Float32FromFloat32(0.98964856),
	97:  libc.Float32FromFloat32(0.99125274),
	98:  libc.Float32FromFloat32(0.99266849),
	99:  libc.Float32FromFloat32(0.99390969),
	100: libc.Float32FromFloat32(0.99499004),
	101: libc.Float32FromFloat32(0.99592297),
	102: libc.Float32FromFloat32(0.99672162),
	103: libc.Float32FromFloat32(0.99739874),
	104: libc.Float32FromFloat32(0.99796667),
	105: libc.Float32FromFloat32(0.99843728),
	106: libc.Float32FromFloat32(0.99882195),
	107: libc.Float32FromFloat32(0.99913147),
	108: libc.Float32FromFloat32(0.99937606),
	109: libc.Float32FromFloat32(0.99956527),
	110: libc.Float32FromFloat32(0.99970802),
	111: libc.Float32FromFloat32(0.99981248),
	112: libc.Float32FromFloat32(0.99988613),
	113: libc.Float32FromFloat32(0.99993565),
	114: libc.Float32FromFloat32(0.99996697),
	115: libc.Float32FromFloat32(0.99998518),
	116: libc.Float32FromFloat32(0.99999457),
	117: libc.Float32FromFloat32(0.99999859),
	118: libc.Float32FromFloat32(0.99999982),
	119: libc.Float32FromFloat32(1),
}
var logN400 = [21]OpusT_opus_int16{
	8:  int16(8),
	9:  int16(8),
	10: int16(8),
	11: int16(8),
	12: int16(16),
	13: int16(16),
	14: int16(16),
	15: int16(21),
	16: int16(21),
	17: int16(24),
	18: int16(29),
	19: int16(34),
	20: int16(36),
}
var cache_index50 = [105]OpusT_opus_int16{
	0:   int16(-int32(1)),
	1:   int16(-int32(1)),
	2:   int16(-int32(1)),
	3:   int16(-int32(1)),
	4:   int16(-int32(1)),
	5:   int16(-int32(1)),
	6:   int16(-int32(1)),
	7:   int16(-int32(1)),
	12:  int16(41),
	13:  int16(41),
	14:  int16(41),
	15:  int16(82),
	16:  int16(82),
	17:  int16(123),
	18:  int16(164),
	19:  int16(200),
	20:  int16(222),
	29:  int16(41),
	30:  int16(41),
	31:  int16(41),
	32:  int16(41),
	33:  int16(123),
	34:  int16(123),
	35:  int16(123),
	36:  int16(164),
	37:  int16(164),
	38:  int16(240),
	39:  int16(266),
	40:  int16(283),
	41:  int16(295),
	42:  int16(41),
	43:  int16(41),
	44:  int16(41),
	45:  int16(41),
	46:  int16(41),
	47:  int16(41),
	48:  int16(41),
	49:  int16(41),
	50:  int16(123),
	51:  int16(123),
	52:  int16(123),
	53:  int16(123),
	54:  int16(240),
	55:  int16(240),
	56:  int16(240),
	57:  int16(266),
	58:  int16(266),
	59:  int16(305),
	60:  int16(318),
	61:  int16(328),
	62:  int16(336),
	63:  int16(123),
	64:  int16(123),
	65:  int16(123),
	66:  int16(123),
	67:  int16(123),
	68:  int16(123),
	69:  int16(123),
	70:  int16(123),
	71:  int16(240),
	72:  int16(240),
	73:  int16(240),
	74:  int16(240),
	75:  int16(305),
	76:  int16(305),
	77:  int16(305),
	78:  int16(318),
	79:  int16(318),
	80:  int16(343),
	81:  int16(351),
	82:  int16(358),
	83:  int16(364),
	84:  int16(240),
	85:  int16(240),
	86:  int16(240),
	87:  int16(240),
	88:  int16(240),
	89:  int16(240),
	90:  int16(240),
	91:  int16(240),
	92:  int16(305),
	93:  int16(305),
	94:  int16(305),
	95:  int16(305),
	96:  int16(343),
	97:  int16(343),
	98:  int16(343),
	99:  int16(351),
	100: int16(351),
	101: int16(370),
	102: int16(376),
	103: int16(382),
	104: int16(387),
}
var cache_bits50 = [392]uint8{
	0:   uint8(40),
	1:   uint8(7),
	2:   uint8(7),
	3:   uint8(7),
	4:   uint8(7),
	5:   uint8(7),
	6:   uint8(7),
	7:   uint8(7),
	8:   uint8(7),
	9:   uint8(7),
	10:  uint8(7),
	11:  uint8(7),
	12:  uint8(7),
	13:  uint8(7),
	14:  uint8(7),
	15:  uint8(7),
	16:  uint8(7),
	17:  uint8(7),
	18:  uint8(7),
	19:  uint8(7),
	20:  uint8(7),
	21:  uint8(7),
	22:  uint8(7),
	23:  uint8(7),
	24:  uint8(7),
	25:  uint8(7),
	26:  uint8(7),
	27:  uint8(7),
	28:  uint8(7),
	29:  uint8(7),
	30:  uint8(7),
	31:  uint8(7),
	32:  uint8(7),
	33:  uint8(7),
	34:  uint8(7),
	35:  uint8(7),
	36:  uint8(7),
	37:  uint8(7),
	38:  uint8(7),
	39:  uint8(7),
	40:  uint8(7),
	41:  uint8(40),
	42:  uint8(15),
	43:  uint8(23),
	44:  uint8(28),
	45:  uint8(31),
	46:  uint8(34),
	47:  uint8(36),
	48:  uint8(38),
	49:  uint8(39),
	50:  uint8(41),
	51:  uint8(42),
	52:  uint8(43),
	53:  uint8(44),
	54:  uint8(45),
	55:  uint8(46),
	56:  uint8(47),
	57:  uint8(47),
	58:  uint8(49),
	59:  uint8(50),
	60:  uint8(51),
	61:  uint8(52),
	62:  uint8(53),
	63:  uint8(54),
	64:  uint8(55),
	65:  uint8(55),
	66:  uint8(57),
	67:  uint8(58),
	68:  uint8(59),
	69:  uint8(60),
	70:  uint8(61),
	71:  uint8(62),
	72:  uint8(63),
	73:  uint8(63),
	74:  uint8(65),
	75:  uint8(66),
	76:  uint8(67),
	77:  uint8(68),
	78:  uint8(69),
	79:  uint8(70),
	80:  uint8(71),
	81:  uint8(71),
	82:  uint8(40),
	83:  uint8(20),
	84:  uint8(33),
	85:  uint8(41),
	86:  uint8(48),
	87:  uint8(53),
	88:  uint8(57),
	89:  uint8(61),
	90:  uint8(64),
	91:  uint8(66),
	92:  uint8(69),
	93:  uint8(71),
	94:  uint8(73),
	95:  uint8(75),
	96:  uint8(76),
	97:  uint8(78),
	98:  uint8(80),
	99:  uint8(82),
	100: uint8(85),
	101: uint8(87),
	102: uint8(89),
	103: uint8(91),
	104: uint8(92),
	105: uint8(94),
	106: uint8(96),
	107: uint8(98),
	108: uint8(101),
	109: uint8(103),
	110: uint8(105),
	111: uint8(107),
	112: uint8(108),
	113: uint8(110),
	114: uint8(112),
	115: uint8(114),
	116: uint8(117),
	117: uint8(119),
	118: uint8(121),
	119: uint8(123),
	120: uint8(124),
	121: uint8(126),
	122: uint8(128),
	123: uint8(40),
	124: uint8(23),
	125: uint8(39),
	126: uint8(51),
	127: uint8(60),
	128: uint8(67),
	129: uint8(73),
	130: uint8(79),
	131: uint8(83),
	132: uint8(87),
	133: uint8(91),
	134: uint8(94),
	135: uint8(97),
	136: uint8(100),
	137: uint8(102),
	138: uint8(105),
	139: uint8(107),
	140: uint8(111),
	141: uint8(115),
	142: uint8(118),
	143: uint8(121),
	144: uint8(124),
	145: uint8(126),
	146: uint8(129),
	147: uint8(131),
	148: uint8(135),
	149: uint8(139),
	150: uint8(142),
	151: uint8(145),
	152: uint8(148),
	153: uint8(150),
	154: uint8(153),
	155: uint8(155),
	156: uint8(159),
	157: uint8(163),
	158: uint8(166),
	159: uint8(169),
	160: uint8(172),
	161: uint8(174),
	162: uint8(177),
	163: uint8(179),
	164: uint8(35),
	165: uint8(28),
	166: uint8(49),
	167: uint8(65),
	168: uint8(78),
	169: uint8(89),
	170: uint8(99),
	171: uint8(107),
	172: uint8(114),
	173: uint8(120),
	174: uint8(126),
	175: uint8(132),
	176: uint8(136),
	177: uint8(141),
	178: uint8(145),
	179: uint8(149),
	180: uint8(153),
	181: uint8(159),
	182: uint8(165),
	183: uint8(171),
	184: uint8(176),
	185: uint8(180),
	186: uint8(185),
	187: uint8(189),
	188: uint8(192),
	189: uint8(199),
	190: uint8(205),
	191: uint8(211),
	192: uint8(216),
	193: uint8(220),
	194: uint8(225),
	195: uint8(229),
	196: uint8(232),
	197: uint8(239),
	198: uint8(245),
	199: uint8(251),
	200: uint8(21),
	201: uint8(33),
	202: uint8(58),
	203: uint8(79),
	204: uint8(97),
	205: uint8(112),
	206: uint8(125),
	207: uint8(137),
	208: uint8(148),
	209: uint8(157),
	210: uint8(166),
	211: uint8(174),
	212: uint8(182),
	213: uint8(189),
	214: uint8(195),
	215: uint8(201),
	216: uint8(207),
	217: uint8(217),
	218: uint8(227),
	219: uint8(235),
	220: uint8(243),
	221: uint8(251),
	222: uint8(17),
	223: uint8(35),
	224: uint8(63),
	225: uint8(86),
	226: uint8(106),
	227: uint8(123),
	228: uint8(139),
	229: uint8(152),
	230: uint8(165),
	231: uint8(177),
	232: uint8(187),
	233: uint8(197),
	234: uint8(206),
	235: uint8(214),
	236: uint8(222),
	237: uint8(230),
	238: uint8(237),
	239: uint8(250),
	240: uint8(25),
	241: uint8(31),
	242: uint8(55),
	243: uint8(75),
	244: uint8(91),
	245: uint8(105),
	246: uint8(117),
	247: uint8(128),
	248: uint8(138),
	249: uint8(146),
	250: uint8(154),
	251: uint8(161),
	252: uint8(168),
	253: uint8(174),
	254: uint8(180),
	255: uint8(185),
	256: uint8(190),
	257: uint8(200),
	258: uint8(208),
	259: uint8(215),
	260: uint8(222),
	261: uint8(229),
	262: uint8(235),
	263: uint8(240),
	264: uint8(245),
	265: uint8(255),
	266: uint8(16),
	267: uint8(36),
	268: uint8(65),
	269: uint8(89),
	270: uint8(110),
	271: uint8(128),
	272: uint8(144),
	273: uint8(159),
	274: uint8(173),
	275: uint8(185),
	276: uint8(196),
	277: uint8(207),
	278: uint8(217),
	279: uint8(226),
	280: uint8(234),
	281: uint8(242),
	282: uint8(250),
	283: uint8(11),
	284: uint8(41),
	285: uint8(74),
	286: uint8(103),
	287: uint8(128),
	288: uint8(151),
	289: uint8(172),
	290: uint8(191),
	291: uint8(209),
	292: uint8(225),
	293: uint8(241),
	294: uint8(255),
	295: uint8(9),
	296: uint8(43),
	297: uint8(79),
	298: uint8(110),
	299: uint8(138),
	300: uint8(163),
	301: uint8(186),
	302: uint8(207),
	303: uint8(227),
	304: uint8(246),
	305: uint8(12),
	306: uint8(39),
	307: uint8(71),
	308: uint8(99),
	309: uint8(123),
	310: uint8(144),
	311: uint8(164),
	312: uint8(182),
	313: uint8(198),
	314: uint8(214),
	315: uint8(228),
	316: uint8(241),
	317: uint8(253),
	318: uint8(9),
	319: uint8(44),
	320: uint8(81),
	321: uint8(113),
	322: uint8(142),
	323: uint8(168),
	324: uint8(192),
	325: uint8(214),
	326: uint8(235),
	327: uint8(255),
	328: uint8(7),
	329: uint8(49),
	330: uint8(90),
	331: uint8(127),
	332: uint8(160),
	333: uint8(191),
	334: uint8(220),
	335: uint8(247),
	336: uint8(6),
	337: uint8(51),
	338: uint8(95),
	339: uint8(134),
	340: uint8(170),
	341: uint8(203),
	342: uint8(234),
	343: uint8(7),
	344: uint8(47),
	345: uint8(87),
	346: uint8(123),
	347: uint8(155),
	348: uint8(184),
	349: uint8(212),
	350: uint8(237),
	351: uint8(6),
	352: uint8(52),
	353: uint8(97),
	354: uint8(137),
	355: uint8(174),
	356: uint8(208),
	357: uint8(240),
	358: uint8(5),
	359: uint8(57),
	360: uint8(106),
	361: uint8(151),
	362: uint8(192),
	363: uint8(231),
	364: uint8(5),
	365: uint8(59),
	366: uint8(111),
	367: uint8(158),
	368: uint8(202),
	369: uint8(243),
	370: uint8(5),
	371: uint8(55),
	372: uint8(103),
	373: uint8(147),
	374: uint8(187),
	375: uint8(224),
	376: uint8(5),
	377: uint8(60),
	378: uint8(113),
	379: uint8(161),
	380: uint8(206),
	381: uint8(248),
	382: uint8(4),
	383: uint8(65),
	384: uint8(122),
	385: uint8(175),
	386: uint8(224),
	387: uint8(4),
	388: uint8(67),
	389: uint8(127),
	390: uint8(182),
	391: uint8(234),
}
var cache_caps50 = [168]uint8{
	0:   uint8(224),
	1:   uint8(224),
	2:   uint8(224),
	3:   uint8(224),
	4:   uint8(224),
	5:   uint8(224),
	6:   uint8(224),
	7:   uint8(224),
	8:   uint8(160),
	9:   uint8(160),
	10:  uint8(160),
	11:  uint8(160),
	12:  uint8(185),
	13:  uint8(185),
	14:  uint8(185),
	15:  uint8(178),
	16:  uint8(178),
	17:  uint8(168),
	18:  uint8(134),
	19:  uint8(61),
	20:  uint8(37),
	21:  uint8(224),
	22:  uint8(224),
	23:  uint8(224),
	24:  uint8(224),
	25:  uint8(224),
	26:  uint8(224),
	27:  uint8(224),
	28:  uint8(224),
	29:  uint8(240),
	30:  uint8(240),
	31:  uint8(240),
	32:  uint8(240),
	33:  uint8(207),
	34:  uint8(207),
	35:  uint8(207),
	36:  uint8(198),
	37:  uint8(198),
	38:  uint8(183),
	39:  uint8(144),
	40:  uint8(66),
	41:  uint8(40),
	42:  uint8(160),
	43:  uint8(160),
	44:  uint8(160),
	45:  uint8(160),
	46:  uint8(160),
	47:  uint8(160),
	48:  uint8(160),
	49:  uint8(160),
	50:  uint8(185),
	51:  uint8(185),
	52:  uint8(185),
	53:  uint8(185),
	54:  uint8(193),
	55:  uint8(193),
	56:  uint8(193),
	57:  uint8(183),
	58:  uint8(183),
	59:  uint8(172),
	60:  uint8(138),
	61:  uint8(64),
	62:  uint8(38),
	63:  uint8(240),
	64:  uint8(240),
	65:  uint8(240),
	66:  uint8(240),
	67:  uint8(240),
	68:  uint8(240),
	69:  uint8(240),
	70:  uint8(240),
	71:  uint8(207),
	72:  uint8(207),
	73:  uint8(207),
	74:  uint8(207),
	75:  uint8(204),
	76:  uint8(204),
	77:  uint8(204),
	78:  uint8(193),
	79:  uint8(193),
	80:  uint8(180),
	81:  uint8(143),
	82:  uint8(66),
	83:  uint8(40),
	84:  uint8(185),
	85:  uint8(185),
	86:  uint8(185),
	87:  uint8(185),
	88:  uint8(185),
	89:  uint8(185),
	90:  uint8(185),
	91:  uint8(185),
	92:  uint8(193),
	93:  uint8(193),
	94:  uint8(193),
	95:  uint8(193),
	96:  uint8(193),
	97:  uint8(193),
	98:  uint8(193),
	99:  uint8(183),
	100: uint8(183),
	101: uint8(172),
	102: uint8(138),
	103: uint8(65),
	104: uint8(39),
	105: uint8(207),
	106: uint8(207),
	107: uint8(207),
	108: uint8(207),
	109: uint8(207),
	110: uint8(207),
	111: uint8(207),
	112: uint8(207),
	113: uint8(204),
	114: uint8(204),
	115: uint8(204),
	116: uint8(204),
	117: uint8(201),
	118: uint8(201),
	119: uint8(201),
	120: uint8(188),
	121: uint8(188),
	122: uint8(176),
	123: uint8(141),
	124: uint8(66),
	125: uint8(40),
	126: uint8(193),
	127: uint8(193),
	128: uint8(193),
	129: uint8(193),
	130: uint8(193),
	131: uint8(193),
	132: uint8(193),
	133: uint8(193),
	134: uint8(193),
	135: uint8(193),
	136: uint8(193),
	137: uint8(193),
	138: uint8(194),
	139: uint8(194),
	140: uint8(194),
	141: uint8(184),
	142: uint8(184),
	143: uint8(173),
	144: uint8(139),
	145: uint8(65),
	146: uint8(39),
	147: uint8(204),
	148: uint8(204),
	149: uint8(204),
	150: uint8(204),
	151: uint8(204),
	152: uint8(204),
	153: uint8(204),
	154: uint8(204),
	155: uint8(201),
	156: uint8(201),
	157: uint8(201),
	158: uint8(201),
	159: uint8(198),
	160: uint8(198),
	161: uint8(198),
	162: uint8(187),
	163: uint8(187),
	164: uint8(175),
	165: uint8(140),
	166: uint8(66),
	167: uint8(40),
}
var fft_twiddles48000_960 = [480]OpusT_kiss_twiddle_cpx{
	0: {
		Fr: libc.Float32FromFloat32(1),
		Fi: -libc.Float32FromFloat32(0),
	},
	1: {
		Fr: libc.Float32FromFloat32(0.99991433),
		Fi: -libc.Float32FromFloat32(0.013089596),
	},
	2: {
		Fr: libc.Float32FromFloat32(0.99965732),
		Fi: -libc.Float32FromFloat32(0.026176948),
	},
	3: {
		Fr: libc.Float32FromFloat32(0.99922904),
		Fi: -libc.Float32FromFloat32(0.039259816),
	},
	4: {
		Fr: libc.Float32FromFloat32(0.99862953),
		Fi: -libc.Float32FromFloat32(0.052335956),
	},
	5: {
		Fr: libc.Float32FromFloat32(0.99785892),
		Fi: -libc.Float32FromFloat32(0.065403129),
	},
	6: {
		Fr: libc.Float32FromFloat32(0.99691733),
		Fi: -libc.Float32FromFloat32(0.078459096),
	},
	7: {
		Fr: libc.Float32FromFloat32(0.99580493),
		Fi: -libc.Float32FromFloat32(0.091501619),
	},
	8: {
		Fr: libc.Float32FromFloat32(0.9945219),
		Fi: -libc.Float32FromFloat32(0.10452846),
	},
	9: {
		Fr: libc.Float32FromFloat32(0.99306846),
		Fi: -libc.Float32FromFloat32(0.1175374),
	},
	10: {
		Fr: libc.Float32FromFloat32(0.99144486),
		Fi: -libc.Float32FromFloat32(0.13052619),
	},
	11: {
		Fr: libc.Float32FromFloat32(0.98965139),
		Fi: -libc.Float32FromFloat32(0.14349262),
	},
	12: {
		Fr: libc.Float32FromFloat32(0.98768834),
		Fi: -libc.Float32FromFloat32(0.15643447),
	},
	13: {
		Fr: libc.Float32FromFloat32(0.98555606),
		Fi: -libc.Float32FromFloat32(0.1693495),
	},
	14: {
		Fr: libc.Float32FromFloat32(0.98325491),
		Fi: -libc.Float32FromFloat32(0.18223553),
	},
	15: {
		Fr: libc.Float32FromFloat32(0.98078528),
		Fi: -libc.Float32FromFloat32(0.19509032),
	},
	16: {
		Fr: libc.Float32FromFloat32(0.9781476),
		Fi: -libc.Float32FromFloat32(0.20791169),
	},
	17: {
		Fr: libc.Float32FromFloat32(0.97534232),
		Fi: -libc.Float32FromFloat32(0.22069744),
	},
	18: {
		Fr: libc.Float32FromFloat32(0.97236992),
		Fi: -libc.Float32FromFloat32(0.23344536),
	},
	19: {
		Fr: libc.Float32FromFloat32(0.96923091),
		Fi: -libc.Float32FromFloat32(0.24615329),
	},
	20: {
		Fr: libc.Float32FromFloat32(0.96592583),
		Fi: -libc.Float32FromFloat32(0.25881905),
	},
	21: {
		Fr: libc.Float32FromFloat32(0.96245524),
		Fi: -libc.Float32FromFloat32(0.27144045),
	},
	22: {
		Fr: libc.Float32FromFloat32(0.95881973),
		Fi: -libc.Float32FromFloat32(0.28401534),
	},
	23: {
		Fr: libc.Float32FromFloat32(0.95501994),
		Fi: -libc.Float32FromFloat32(0.29654157),
	},
	24: {
		Fr: libc.Float32FromFloat32(0.95105652),
		Fi: -libc.Float32FromFloat32(0.30901699),
	},
	25: {
		Fr: libc.Float32FromFloat32(0.94693013),
		Fi: -libc.Float32FromFloat32(0.32143947),
	},
	26: {
		Fr: libc.Float32FromFloat32(0.94264149),
		Fi: -libc.Float32FromFloat32(0.33380686),
	},
	27: {
		Fr: libc.Float32FromFloat32(0.93819134),
		Fi: -libc.Float32FromFloat32(0.34611706),
	},
	28: {
		Fr: libc.Float32FromFloat32(0.93358043),
		Fi: -libc.Float32FromFloat32(0.35836795),
	},
	29: {
		Fr: libc.Float32FromFloat32(0.92880955),
		Fi: -libc.Float32FromFloat32(0.37055744),
	},
	30: {
		Fr: libc.Float32FromFloat32(0.92387953),
		Fi: -libc.Float32FromFloat32(0.38268343),
	},
	31: {
		Fr: libc.Float32FromFloat32(0.91879121),
		Fi: -libc.Float32FromFloat32(0.39474386),
	},
	32: {
		Fr: libc.Float32FromFloat32(0.91354546),
		Fi: -libc.Float32FromFloat32(0.40673664),
	},
	33: {
		Fr: libc.Float32FromFloat32(0.90814317),
		Fi: -libc.Float32FromFloat32(0.41865974),
	},
	34: {
		Fr: libc.Float32FromFloat32(0.90258528),
		Fi: -libc.Float32FromFloat32(0.4305111),
	},
	35: {
		Fr: libc.Float32FromFloat32(0.89687274),
		Fi: -libc.Float32FromFloat32(0.44228869),
	},
	36: {
		Fr: libc.Float32FromFloat32(0.89100652),
		Fi: -libc.Float32FromFloat32(0.4539905),
	},
	37: {
		Fr: libc.Float32FromFloat32(0.88498764),
		Fi: -libc.Float32FromFloat32(0.46561452),
	},
	38: {
		Fr: libc.Float32FromFloat32(0.87881711),
		Fi: -libc.Float32FromFloat32(0.47715876),
	},
	39: {
		Fr: libc.Float32FromFloat32(0.87249601),
		Fi: -libc.Float32FromFloat32(0.48862124),
	},
	40: {
		Fr: libc.Float32FromFloat32(0.8660254),
		Fi: -libc.Float32FromFloat32(0.5),
	},
	41: {
		Fr: libc.Float32FromFloat32(0.85940641),
		Fi: -libc.Float32FromFloat32(0.51129309),
	},
	42: {
		Fr: libc.Float32FromFloat32(0.85264016),
		Fi: -libc.Float32FromFloat32(0.52249856),
	},
	43: {
		Fr: libc.Float32FromFloat32(0.84572782),
		Fi: -libc.Float32FromFloat32(0.53361452),
	},
	44: {
		Fr: libc.Float32FromFloat32(0.83867057),
		Fi: -libc.Float32FromFloat32(0.54463904),
	},
	45: {
		Fr: libc.Float32FromFloat32(0.83146961),
		Fi: -libc.Float32FromFloat32(0.55557023),
	},
	46: {
		Fr: libc.Float32FromFloat32(0.82412619),
		Fi: -libc.Float32FromFloat32(0.56640624),
	},
	47: {
		Fr: libc.Float32FromFloat32(0.81664156),
		Fi: -libc.Float32FromFloat32(0.57714519),
	},
	48: {
		Fr: libc.Float32FromFloat32(0.80901699),
		Fi: -libc.Float32FromFloat32(0.58778525),
	},
	49: {
		Fr: libc.Float32FromFloat32(0.80125381),
		Fi: -libc.Float32FromFloat32(0.5983246),
	},
	50: {
		Fr: libc.Float32FromFloat32(0.79335334),
		Fi: -libc.Float32FromFloat32(0.60876143),
	},
	51: {
		Fr: libc.Float32FromFloat32(0.78531693),
		Fi: -libc.Float32FromFloat32(0.61909395),
	},
	52: {
		Fr: libc.Float32FromFloat32(0.77714596),
		Fi: -libc.Float32FromFloat32(0.62932039),
	},
	53: {
		Fr: libc.Float32FromFloat32(0.76884183),
		Fi: -libc.Float32FromFloat32(0.639439),
	},
	54: {
		Fr: libc.Float32FromFloat32(0.76040597),
		Fi: -libc.Float32FromFloat32(0.64944805),
	},
	55: {
		Fr: libc.Float32FromFloat32(0.75183981),
		Fi: -libc.Float32FromFloat32(0.65934582),
	},
	56: {
		Fr: libc.Float32FromFloat32(0.74314483),
		Fi: -libc.Float32FromFloat32(0.66913061),
	},
	57: {
		Fr: libc.Float32FromFloat32(0.73432251),
		Fi: -libc.Float32FromFloat32(0.67880075),
	},
	58: {
		Fr: libc.Float32FromFloat32(0.72537437),
		Fi: -libc.Float32FromFloat32(0.68835458),
	},
	59: {
		Fr: libc.Float32FromFloat32(0.71630194),
		Fi: -libc.Float32FromFloat32(0.69779046),
	},
	60: {
		Fr: libc.Float32FromFloat32(0.70710678),
		Fi: -libc.Float32FromFloat32(0.70710678),
	},
	61: {
		Fr: libc.Float32FromFloat32(0.69779046),
		Fi: -libc.Float32FromFloat32(0.71630194),
	},
	62: {
		Fr: libc.Float32FromFloat32(0.68835458),
		Fi: -libc.Float32FromFloat32(0.72537437),
	},
	63: {
		Fr: libc.Float32FromFloat32(0.67880075),
		Fi: -libc.Float32FromFloat32(0.73432251),
	},
	64: {
		Fr: libc.Float32FromFloat32(0.66913061),
		Fi: -libc.Float32FromFloat32(0.74314483),
	},
	65: {
		Fr: libc.Float32FromFloat32(0.65934582),
		Fi: -libc.Float32FromFloat32(0.75183981),
	},
	66: {
		Fr: libc.Float32FromFloat32(0.64944805),
		Fi: -libc.Float32FromFloat32(0.76040597),
	},
	67: {
		Fr: libc.Float32FromFloat32(0.639439),
		Fi: -libc.Float32FromFloat32(0.76884183),
	},
	68: {
		Fr: libc.Float32FromFloat32(0.62932039),
		Fi: -libc.Float32FromFloat32(0.77714596),
	},
	69: {
		Fr: libc.Float32FromFloat32(0.61909395),
		Fi: -libc.Float32FromFloat32(0.78531693),
	},
	70: {
		Fr: libc.Float32FromFloat32(0.60876143),
		Fi: -libc.Float32FromFloat32(0.79335334),
	},
	71: {
		Fr: libc.Float32FromFloat32(0.5983246),
		Fi: -libc.Float32FromFloat32(0.80125381),
	},
	72: {
		Fr: libc.Float32FromFloat32(0.58778525),
		Fi: -libc.Float32FromFloat32(0.80901699),
	},
	73: {
		Fr: libc.Float32FromFloat32(0.57714519),
		Fi: -libc.Float32FromFloat32(0.81664156),
	},
	74: {
		Fr: libc.Float32FromFloat32(0.56640624),
		Fi: -libc.Float32FromFloat32(0.82412619),
	},
	75: {
		Fr: libc.Float32FromFloat32(0.55557023),
		Fi: -libc.Float32FromFloat32(0.83146961),
	},
	76: {
		Fr: libc.Float32FromFloat32(0.54463904),
		Fi: -libc.Float32FromFloat32(0.83867057),
	},
	77: {
		Fr: libc.Float32FromFloat32(0.53361452),
		Fi: -libc.Float32FromFloat32(0.84572782),
	},
	78: {
		Fr: libc.Float32FromFloat32(0.52249856),
		Fi: -libc.Float32FromFloat32(0.85264016),
	},
	79: {
		Fr: libc.Float32FromFloat32(0.51129309),
		Fi: -libc.Float32FromFloat32(0.85940641),
	},
	80: {
		Fr: libc.Float32FromFloat32(0.5),
		Fi: -libc.Float32FromFloat32(0.8660254),
	},
	81: {
		Fr: libc.Float32FromFloat32(0.48862124),
		Fi: -libc.Float32FromFloat32(0.87249601),
	},
	82: {
		Fr: libc.Float32FromFloat32(0.47715876),
		Fi: -libc.Float32FromFloat32(0.87881711),
	},
	83: {
		Fr: libc.Float32FromFloat32(0.46561452),
		Fi: -libc.Float32FromFloat32(0.88498764),
	},
	84: {
		Fr: libc.Float32FromFloat32(0.4539905),
		Fi: -libc.Float32FromFloat32(0.89100652),
	},
	85: {
		Fr: libc.Float32FromFloat32(0.44228869),
		Fi: -libc.Float32FromFloat32(0.89687274),
	},
	86: {
		Fr: libc.Float32FromFloat32(0.4305111),
		Fi: -libc.Float32FromFloat32(0.90258528),
	},
	87: {
		Fr: libc.Float32FromFloat32(0.41865974),
		Fi: -libc.Float32FromFloat32(0.90814317),
	},
	88: {
		Fr: libc.Float32FromFloat32(0.40673664),
		Fi: -libc.Float32FromFloat32(0.91354546),
	},
	89: {
		Fr: libc.Float32FromFloat32(0.39474386),
		Fi: -libc.Float32FromFloat32(0.91879121),
	},
	90: {
		Fr: libc.Float32FromFloat32(0.38268343),
		Fi: -libc.Float32FromFloat32(0.92387953),
	},
	91: {
		Fr: libc.Float32FromFloat32(0.37055744),
		Fi: -libc.Float32FromFloat32(0.92880955),
	},
	92: {
		Fr: libc.Float32FromFloat32(0.35836795),
		Fi: -libc.Float32FromFloat32(0.93358043),
	},
	93: {
		Fr: libc.Float32FromFloat32(0.34611706),
		Fi: -libc.Float32FromFloat32(0.93819134),
	},
	94: {
		Fr: libc.Float32FromFloat32(0.33380686),
		Fi: -libc.Float32FromFloat32(0.94264149),
	},
	95: {
		Fr: libc.Float32FromFloat32(0.32143947),
		Fi: -libc.Float32FromFloat32(0.94693013),
	},
	96: {
		Fr: libc.Float32FromFloat32(0.30901699),
		Fi: -libc.Float32FromFloat32(0.95105652),
	},
	97: {
		Fr: libc.Float32FromFloat32(0.29654157),
		Fi: -libc.Float32FromFloat32(0.95501994),
	},
	98: {
		Fr: libc.Float32FromFloat32(0.28401534),
		Fi: -libc.Float32FromFloat32(0.95881973),
	},
	99: {
		Fr: libc.Float32FromFloat32(0.27144045),
		Fi: -libc.Float32FromFloat32(0.96245524),
	},
	100: {
		Fr: libc.Float32FromFloat32(0.25881905),
		Fi: -libc.Float32FromFloat32(0.96592583),
	},
	101: {
		Fr: libc.Float32FromFloat32(0.24615329),
		Fi: -libc.Float32FromFloat32(0.96923091),
	},
	102: {
		Fr: libc.Float32FromFloat32(0.23344536),
		Fi: -libc.Float32FromFloat32(0.97236992),
	},
	103: {
		Fr: libc.Float32FromFloat32(0.22069744),
		Fi: -libc.Float32FromFloat32(0.97534232),
	},
	104: {
		Fr: libc.Float32FromFloat32(0.20791169),
		Fi: -libc.Float32FromFloat32(0.9781476),
	},
	105: {
		Fr: libc.Float32FromFloat32(0.19509032),
		Fi: -libc.Float32FromFloat32(0.98078528),
	},
	106: {
		Fr: libc.Float32FromFloat32(0.18223553),
		Fi: -libc.Float32FromFloat32(0.98325491),
	},
	107: {
		Fr: libc.Float32FromFloat32(0.1693495),
		Fi: -libc.Float32FromFloat32(0.98555606),
	},
	108: {
		Fr: libc.Float32FromFloat32(0.15643447),
		Fi: -libc.Float32FromFloat32(0.98768834),
	},
	109: {
		Fr: libc.Float32FromFloat32(0.14349262),
		Fi: -libc.Float32FromFloat32(0.98965139),
	},
	110: {
		Fr: libc.Float32FromFloat32(0.13052619),
		Fi: -libc.Float32FromFloat32(0.99144486),
	},
	111: {
		Fr: libc.Float32FromFloat32(0.1175374),
		Fi: -libc.Float32FromFloat32(0.99306846),
	},
	112: {
		Fr: libc.Float32FromFloat32(0.10452846),
		Fi: -libc.Float32FromFloat32(0.9945219),
	},
	113: {
		Fr: libc.Float32FromFloat32(0.091501619),
		Fi: -libc.Float32FromFloat32(0.99580493),
	},
	114: {
		Fr: libc.Float32FromFloat32(0.078459096),
		Fi: -libc.Float32FromFloat32(0.99691733),
	},
	115: {
		Fr: libc.Float32FromFloat32(0.065403129),
		Fi: -libc.Float32FromFloat32(0.99785892),
	},
	116: {
		Fr: libc.Float32FromFloat32(0.052335956),
		Fi: -libc.Float32FromFloat32(0.99862953),
	},
	117: {
		Fr: libc.Float32FromFloat32(0.039259816),
		Fi: -libc.Float32FromFloat32(0.99922904),
	},
	118: {
		Fr: libc.Float32FromFloat32(0.026176948),
		Fi: -libc.Float32FromFloat32(0.99965732),
	},
	119: {
		Fr: libc.Float32FromFloat32(0.013089596),
		Fi: -libc.Float32FromFloat32(0.99991433),
	},
	120: {
		Fr: libc.Float32FromFloat32(6.123234e-17),
		Fi: -libc.Float32FromFloat32(1),
	},
	121: {
		Fr: -libc.Float32FromFloat32(0.013089596),
		Fi: -libc.Float32FromFloat32(0.99991433),
	},
	122: {
		Fr: -libc.Float32FromFloat32(0.026176948),
		Fi: -libc.Float32FromFloat32(0.99965732),
	},
	123: {
		Fr: -libc.Float32FromFloat32(0.039259816),
		Fi: -libc.Float32FromFloat32(0.99922904),
	},
	124: {
		Fr: -libc.Float32FromFloat32(0.052335956),
		Fi: -libc.Float32FromFloat32(0.99862953),
	},
	125: {
		Fr: -libc.Float32FromFloat32(0.065403129),
		Fi: -libc.Float32FromFloat32(0.99785892),
	},
	126: {
		Fr: -libc.Float32FromFloat32(0.078459096),
		Fi: -libc.Float32FromFloat32(0.99691733),
	},
	127: {
		Fr: -libc.Float32FromFloat32(0.091501619),
		Fi: -libc.Float32FromFloat32(0.99580493),
	},
	128: {
		Fr: -libc.Float32FromFloat32(0.10452846),
		Fi: -libc.Float32FromFloat32(0.9945219),
	},
	129: {
		Fr: -libc.Float32FromFloat32(0.1175374),
		Fi: -libc.Float32FromFloat32(0.99306846),
	},
	130: {
		Fr: -libc.Float32FromFloat32(0.13052619),
		Fi: -libc.Float32FromFloat32(0.99144486),
	},
	131: {
		Fr: -libc.Float32FromFloat32(0.14349262),
		Fi: -libc.Float32FromFloat32(0.98965139),
	},
	132: {
		Fr: -libc.Float32FromFloat32(0.15643447),
		Fi: -libc.Float32FromFloat32(0.98768834),
	},
	133: {
		Fr: -libc.Float32FromFloat32(0.1693495),
		Fi: -libc.Float32FromFloat32(0.98555606),
	},
	134: {
		Fr: -libc.Float32FromFloat32(0.18223553),
		Fi: -libc.Float32FromFloat32(0.98325491),
	},
	135: {
		Fr: -libc.Float32FromFloat32(0.19509032),
		Fi: -libc.Float32FromFloat32(0.98078528),
	},
	136: {
		Fr: -libc.Float32FromFloat32(0.20791169),
		Fi: -libc.Float32FromFloat32(0.9781476),
	},
	137: {
		Fr: -libc.Float32FromFloat32(0.22069744),
		Fi: -libc.Float32FromFloat32(0.97534232),
	},
	138: {
		Fr: -libc.Float32FromFloat32(0.23344536),
		Fi: -libc.Float32FromFloat32(0.97236992),
	},
	139: {
		Fr: -libc.Float32FromFloat32(0.24615329),
		Fi: -libc.Float32FromFloat32(0.96923091),
	},
	140: {
		Fr: -libc.Float32FromFloat32(0.25881905),
		Fi: -libc.Float32FromFloat32(0.96592583),
	},
	141: {
		Fr: -libc.Float32FromFloat32(0.27144045),
		Fi: -libc.Float32FromFloat32(0.96245524),
	},
	142: {
		Fr: -libc.Float32FromFloat32(0.28401534),
		Fi: -libc.Float32FromFloat32(0.95881973),
	},
	143: {
		Fr: -libc.Float32FromFloat32(0.29654157),
		Fi: -libc.Float32FromFloat32(0.95501994),
	},
	144: {
		Fr: -libc.Float32FromFloat32(0.30901699),
		Fi: -libc.Float32FromFloat32(0.95105652),
	},
	145: {
		Fr: -libc.Float32FromFloat32(0.32143947),
		Fi: -libc.Float32FromFloat32(0.94693013),
	},
	146: {
		Fr: -libc.Float32FromFloat32(0.33380686),
		Fi: -libc.Float32FromFloat32(0.94264149),
	},
	147: {
		Fr: -libc.Float32FromFloat32(0.34611706),
		Fi: -libc.Float32FromFloat32(0.93819134),
	},
	148: {
		Fr: -libc.Float32FromFloat32(0.35836795),
		Fi: -libc.Float32FromFloat32(0.93358043),
	},
	149: {
		Fr: -libc.Float32FromFloat32(0.37055744),
		Fi: -libc.Float32FromFloat32(0.92880955),
	},
	150: {
		Fr: -libc.Float32FromFloat32(0.38268343),
		Fi: -libc.Float32FromFloat32(0.92387953),
	},
	151: {
		Fr: -libc.Float32FromFloat32(0.39474386),
		Fi: -libc.Float32FromFloat32(0.91879121),
	},
	152: {
		Fr: -libc.Float32FromFloat32(0.40673664),
		Fi: -libc.Float32FromFloat32(0.91354546),
	},
	153: {
		Fr: -libc.Float32FromFloat32(0.41865974),
		Fi: -libc.Float32FromFloat32(0.90814317),
	},
	154: {
		Fr: -libc.Float32FromFloat32(0.4305111),
		Fi: -libc.Float32FromFloat32(0.90258528),
	},
	155: {
		Fr: -libc.Float32FromFloat32(0.44228869),
		Fi: -libc.Float32FromFloat32(0.89687274),
	},
	156: {
		Fr: -libc.Float32FromFloat32(0.4539905),
		Fi: -libc.Float32FromFloat32(0.89100652),
	},
	157: {
		Fr: -libc.Float32FromFloat32(0.46561452),
		Fi: -libc.Float32FromFloat32(0.88498764),
	},
	158: {
		Fr: -libc.Float32FromFloat32(0.47715876),
		Fi: -libc.Float32FromFloat32(0.87881711),
	},
	159: {
		Fr: -libc.Float32FromFloat32(0.48862124),
		Fi: -libc.Float32FromFloat32(0.87249601),
	},
	160: {
		Fr: -libc.Float32FromFloat32(0.5),
		Fi: -libc.Float32FromFloat32(0.8660254),
	},
	161: {
		Fr: -libc.Float32FromFloat32(0.51129309),
		Fi: -libc.Float32FromFloat32(0.85940641),
	},
	162: {
		Fr: -libc.Float32FromFloat32(0.52249856),
		Fi: -libc.Float32FromFloat32(0.85264016),
	},
	163: {
		Fr: -libc.Float32FromFloat32(0.53361452),
		Fi: -libc.Float32FromFloat32(0.84572782),
	},
	164: {
		Fr: -libc.Float32FromFloat32(0.54463904),
		Fi: -libc.Float32FromFloat32(0.83867057),
	},
	165: {
		Fr: -libc.Float32FromFloat32(0.55557023),
		Fi: -libc.Float32FromFloat32(0.83146961),
	},
	166: {
		Fr: -libc.Float32FromFloat32(0.56640624),
		Fi: -libc.Float32FromFloat32(0.82412619),
	},
	167: {
		Fr: -libc.Float32FromFloat32(0.57714519),
		Fi: -libc.Float32FromFloat32(0.81664156),
	},
	168: {
		Fr: -libc.Float32FromFloat32(0.58778525),
		Fi: -libc.Float32FromFloat32(0.80901699),
	},
	169: {
		Fr: -libc.Float32FromFloat32(0.5983246),
		Fi: -libc.Float32FromFloat32(0.80125381),
	},
	170: {
		Fr: -libc.Float32FromFloat32(0.60876143),
		Fi: -libc.Float32FromFloat32(0.79335334),
	},
	171: {
		Fr: -libc.Float32FromFloat32(0.61909395),
		Fi: -libc.Float32FromFloat32(0.78531693),
	},
	172: {
		Fr: -libc.Float32FromFloat32(0.62932039),
		Fi: -libc.Float32FromFloat32(0.77714596),
	},
	173: {
		Fr: -libc.Float32FromFloat32(0.639439),
		Fi: -libc.Float32FromFloat32(0.76884183),
	},
	174: {
		Fr: -libc.Float32FromFloat32(0.64944805),
		Fi: -libc.Float32FromFloat32(0.76040597),
	},
	175: {
		Fr: -libc.Float32FromFloat32(0.65934582),
		Fi: -libc.Float32FromFloat32(0.75183981),
	},
	176: {
		Fr: -libc.Float32FromFloat32(0.66913061),
		Fi: -libc.Float32FromFloat32(0.74314483),
	},
	177: {
		Fr: -libc.Float32FromFloat32(0.67880075),
		Fi: -libc.Float32FromFloat32(0.73432251),
	},
	178: {
		Fr: -libc.Float32FromFloat32(0.68835458),
		Fi: -libc.Float32FromFloat32(0.72537437),
	},
	179: {
		Fr: -libc.Float32FromFloat32(0.69779046),
		Fi: -libc.Float32FromFloat32(0.71630194),
	},
	180: {
		Fr: -libc.Float32FromFloat32(0.70710678),
		Fi: -libc.Float32FromFloat32(0.70710678),
	},
	181: {
		Fr: -libc.Float32FromFloat32(0.71630194),
		Fi: -libc.Float32FromFloat32(0.69779046),
	},
	182: {
		Fr: -libc.Float32FromFloat32(0.72537437),
		Fi: -libc.Float32FromFloat32(0.68835458),
	},
	183: {
		Fr: -libc.Float32FromFloat32(0.73432251),
		Fi: -libc.Float32FromFloat32(0.67880075),
	},
	184: {
		Fr: -libc.Float32FromFloat32(0.74314483),
		Fi: -libc.Float32FromFloat32(0.66913061),
	},
	185: {
		Fr: -libc.Float32FromFloat32(0.75183981),
		Fi: -libc.Float32FromFloat32(0.65934582),
	},
	186: {
		Fr: -libc.Float32FromFloat32(0.76040597),
		Fi: -libc.Float32FromFloat32(0.64944805),
	},
	187: {
		Fr: -libc.Float32FromFloat32(0.76884183),
		Fi: -libc.Float32FromFloat32(0.639439),
	},
	188: {
		Fr: -libc.Float32FromFloat32(0.77714596),
		Fi: -libc.Float32FromFloat32(0.62932039),
	},
	189: {
		Fr: -libc.Float32FromFloat32(0.78531693),
		Fi: -libc.Float32FromFloat32(0.61909395),
	},
	190: {
		Fr: -libc.Float32FromFloat32(0.79335334),
		Fi: -libc.Float32FromFloat32(0.60876143),
	},
	191: {
		Fr: -libc.Float32FromFloat32(0.80125381),
		Fi: -libc.Float32FromFloat32(0.5983246),
	},
	192: {
		Fr: -libc.Float32FromFloat32(0.80901699),
		Fi: -libc.Float32FromFloat32(0.58778525),
	},
	193: {
		Fr: -libc.Float32FromFloat32(0.81664156),
		Fi: -libc.Float32FromFloat32(0.57714519),
	},
	194: {
		Fr: -libc.Float32FromFloat32(0.82412619),
		Fi: -libc.Float32FromFloat32(0.56640624),
	},
	195: {
		Fr: -libc.Float32FromFloat32(0.83146961),
		Fi: -libc.Float32FromFloat32(0.55557023),
	},
	196: {
		Fr: -libc.Float32FromFloat32(0.83867057),
		Fi: -libc.Float32FromFloat32(0.54463904),
	},
	197: {
		Fr: -libc.Float32FromFloat32(0.84572782),
		Fi: -libc.Float32FromFloat32(0.53361452),
	},
	198: {
		Fr: -libc.Float32FromFloat32(0.85264016),
		Fi: -libc.Float32FromFloat32(0.52249856),
	},
	199: {
		Fr: -libc.Float32FromFloat32(0.85940641),
		Fi: -libc.Float32FromFloat32(0.51129309),
	},
	200: {
		Fr: -libc.Float32FromFloat32(0.8660254),
		Fi: -libc.Float32FromFloat32(0.5),
	},
	201: {
		Fr: -libc.Float32FromFloat32(0.87249601),
		Fi: -libc.Float32FromFloat32(0.48862124),
	},
	202: {
		Fr: -libc.Float32FromFloat32(0.87881711),
		Fi: -libc.Float32FromFloat32(0.47715876),
	},
	203: {
		Fr: -libc.Float32FromFloat32(0.88498764),
		Fi: -libc.Float32FromFloat32(0.46561452),
	},
	204: {
		Fr: -libc.Float32FromFloat32(0.89100652),
		Fi: -libc.Float32FromFloat32(0.4539905),
	},
	205: {
		Fr: -libc.Float32FromFloat32(0.89687274),
		Fi: -libc.Float32FromFloat32(0.44228869),
	},
	206: {
		Fr: -libc.Float32FromFloat32(0.90258528),
		Fi: -libc.Float32FromFloat32(0.4305111),
	},
	207: {
		Fr: -libc.Float32FromFloat32(0.90814317),
		Fi: -libc.Float32FromFloat32(0.41865974),
	},
	208: {
		Fr: -libc.Float32FromFloat32(0.91354546),
		Fi: -libc.Float32FromFloat32(0.40673664),
	},
	209: {
		Fr: -libc.Float32FromFloat32(0.91879121),
		Fi: -libc.Float32FromFloat32(0.39474386),
	},
	210: {
		Fr: -libc.Float32FromFloat32(0.92387953),
		Fi: -libc.Float32FromFloat32(0.38268343),
	},
	211: {
		Fr: -libc.Float32FromFloat32(0.92880955),
		Fi: -libc.Float32FromFloat32(0.37055744),
	},
	212: {
		Fr: -libc.Float32FromFloat32(0.93358043),
		Fi: -libc.Float32FromFloat32(0.35836795),
	},
	213: {
		Fr: -libc.Float32FromFloat32(0.93819134),
		Fi: -libc.Float32FromFloat32(0.34611706),
	},
	214: {
		Fr: -libc.Float32FromFloat32(0.94264149),
		Fi: -libc.Float32FromFloat32(0.33380686),
	},
	215: {
		Fr: -libc.Float32FromFloat32(0.94693013),
		Fi: -libc.Float32FromFloat32(0.32143947),
	},
	216: {
		Fr: -libc.Float32FromFloat32(0.95105652),
		Fi: -libc.Float32FromFloat32(0.30901699),
	},
	217: {
		Fr: -libc.Float32FromFloat32(0.95501994),
		Fi: -libc.Float32FromFloat32(0.29654157),
	},
	218: {
		Fr: -libc.Float32FromFloat32(0.95881973),
		Fi: -libc.Float32FromFloat32(0.28401534),
	},
	219: {
		Fr: -libc.Float32FromFloat32(0.96245524),
		Fi: -libc.Float32FromFloat32(0.27144045),
	},
	220: {
		Fr: -libc.Float32FromFloat32(0.96592583),
		Fi: -libc.Float32FromFloat32(0.25881905),
	},
	221: {
		Fr: -libc.Float32FromFloat32(0.96923091),
		Fi: -libc.Float32FromFloat32(0.24615329),
	},
	222: {
		Fr: -libc.Float32FromFloat32(0.97236992),
		Fi: -libc.Float32FromFloat32(0.23344536),
	},
	223: {
		Fr: -libc.Float32FromFloat32(0.97534232),
		Fi: -libc.Float32FromFloat32(0.22069744),
	},
	224: {
		Fr: -libc.Float32FromFloat32(0.9781476),
		Fi: -libc.Float32FromFloat32(0.20791169),
	},
	225: {
		Fr: -libc.Float32FromFloat32(0.98078528),
		Fi: -libc.Float32FromFloat32(0.19509032),
	},
	226: {
		Fr: -libc.Float32FromFloat32(0.98325491),
		Fi: -libc.Float32FromFloat32(0.18223553),
	},
	227: {
		Fr: -libc.Float32FromFloat32(0.98555606),
		Fi: -libc.Float32FromFloat32(0.1693495),
	},
	228: {
		Fr: -libc.Float32FromFloat32(0.98768834),
		Fi: -libc.Float32FromFloat32(0.15643447),
	},
	229: {
		Fr: -libc.Float32FromFloat32(0.98965139),
		Fi: -libc.Float32FromFloat32(0.14349262),
	},
	230: {
		Fr: -libc.Float32FromFloat32(0.99144486),
		Fi: -libc.Float32FromFloat32(0.13052619),
	},
	231: {
		Fr: -libc.Float32FromFloat32(0.99306846),
		Fi: -libc.Float32FromFloat32(0.1175374),
	},
	232: {
		Fr: -libc.Float32FromFloat32(0.9945219),
		Fi: -libc.Float32FromFloat32(0.10452846),
	},
	233: {
		Fr: -libc.Float32FromFloat32(0.99580493),
		Fi: -libc.Float32FromFloat32(0.091501619),
	},
	234: {
		Fr: -libc.Float32FromFloat32(0.99691733),
		Fi: -libc.Float32FromFloat32(0.078459096),
	},
	235: {
		Fr: -libc.Float32FromFloat32(0.99785892),
		Fi: -libc.Float32FromFloat32(0.065403129),
	},
	236: {
		Fr: -libc.Float32FromFloat32(0.99862953),
		Fi: -libc.Float32FromFloat32(0.052335956),
	},
	237: {
		Fr: -libc.Float32FromFloat32(0.99922904),
		Fi: -libc.Float32FromFloat32(0.039259816),
	},
	238: {
		Fr: -libc.Float32FromFloat32(0.99965732),
		Fi: -libc.Float32FromFloat32(0.026176948),
	},
	239: {
		Fr: -libc.Float32FromFloat32(0.99991433),
		Fi: -libc.Float32FromFloat32(0.013089596),
	},
	240: {
		Fr: -libc.Float32FromFloat32(1),
		Fi: -libc.Float32FromFloat32(1.2246468e-16),
	},
	241: {
		Fr: -libc.Float32FromFloat32(0.99991433),
		Fi: libc.Float32FromFloat32(0.013089596),
	},
	242: {
		Fr: -libc.Float32FromFloat32(0.99965732),
		Fi: libc.Float32FromFloat32(0.026176948),
	},
	243: {
		Fr: -libc.Float32FromFloat32(0.99922904),
		Fi: libc.Float32FromFloat32(0.039259816),
	},
	244: {
		Fr: -libc.Float32FromFloat32(0.99862953),
		Fi: libc.Float32FromFloat32(0.052335956),
	},
	245: {
		Fr: -libc.Float32FromFloat32(0.99785892),
		Fi: libc.Float32FromFloat32(0.065403129),
	},
	246: {
		Fr: -libc.Float32FromFloat32(0.99691733),
		Fi: libc.Float32FromFloat32(0.078459096),
	},
	247: {
		Fr: -libc.Float32FromFloat32(0.99580493),
		Fi: libc.Float32FromFloat32(0.091501619),
	},
	248: {
		Fr: -libc.Float32FromFloat32(0.9945219),
		Fi: libc.Float32FromFloat32(0.10452846),
	},
	249: {
		Fr: -libc.Float32FromFloat32(0.99306846),
		Fi: libc.Float32FromFloat32(0.1175374),
	},
	250: {
		Fr: -libc.Float32FromFloat32(0.99144486),
		Fi: libc.Float32FromFloat32(0.13052619),
	},
	251: {
		Fr: -libc.Float32FromFloat32(0.98965139),
		Fi: libc.Float32FromFloat32(0.14349262),
	},
	252: {
		Fr: -libc.Float32FromFloat32(0.98768834),
		Fi: libc.Float32FromFloat32(0.15643447),
	},
	253: {
		Fr: -libc.Float32FromFloat32(0.98555606),
		Fi: libc.Float32FromFloat32(0.1693495),
	},
	254: {
		Fr: -libc.Float32FromFloat32(0.98325491),
		Fi: libc.Float32FromFloat32(0.18223553),
	},
	255: {
		Fr: -libc.Float32FromFloat32(0.98078528),
		Fi: libc.Float32FromFloat32(0.19509032),
	},
	256: {
		Fr: -libc.Float32FromFloat32(0.9781476),
		Fi: libc.Float32FromFloat32(0.20791169),
	},
	257: {
		Fr: -libc.Float32FromFloat32(0.97534232),
		Fi: libc.Float32FromFloat32(0.22069744),
	},
	258: {
		Fr: -libc.Float32FromFloat32(0.97236992),
		Fi: libc.Float32FromFloat32(0.23344536),
	},
	259: {
		Fr: -libc.Float32FromFloat32(0.96923091),
		Fi: libc.Float32FromFloat32(0.24615329),
	},
	260: {
		Fr: -libc.Float32FromFloat32(0.96592583),
		Fi: libc.Float32FromFloat32(0.25881905),
	},
	261: {
		Fr: -libc.Float32FromFloat32(0.96245524),
		Fi: libc.Float32FromFloat32(0.27144045),
	},
	262: {
		Fr: -libc.Float32FromFloat32(0.95881973),
		Fi: libc.Float32FromFloat32(0.28401534),
	},
	263: {
		Fr: -libc.Float32FromFloat32(0.95501994),
		Fi: libc.Float32FromFloat32(0.29654157),
	},
	264: {
		Fr: -libc.Float32FromFloat32(0.95105652),
		Fi: libc.Float32FromFloat32(0.30901699),
	},
	265: {
		Fr: -libc.Float32FromFloat32(0.94693013),
		Fi: libc.Float32FromFloat32(0.32143947),
	},
	266: {
		Fr: -libc.Float32FromFloat32(0.94264149),
		Fi: libc.Float32FromFloat32(0.33380686),
	},
	267: {
		Fr: -libc.Float32FromFloat32(0.93819134),
		Fi: libc.Float32FromFloat32(0.34611706),
	},
	268: {
		Fr: -libc.Float32FromFloat32(0.93358043),
		Fi: libc.Float32FromFloat32(0.35836795),
	},
	269: {
		Fr: -libc.Float32FromFloat32(0.92880955),
		Fi: libc.Float32FromFloat32(0.37055744),
	},
	270: {
		Fr: -libc.Float32FromFloat32(0.92387953),
		Fi: libc.Float32FromFloat32(0.38268343),
	},
	271: {
		Fr: -libc.Float32FromFloat32(0.91879121),
		Fi: libc.Float32FromFloat32(0.39474386),
	},
	272: {
		Fr: -libc.Float32FromFloat32(0.91354546),
		Fi: libc.Float32FromFloat32(0.40673664),
	},
	273: {
		Fr: -libc.Float32FromFloat32(0.90814317),
		Fi: libc.Float32FromFloat32(0.41865974),
	},
	274: {
		Fr: -libc.Float32FromFloat32(0.90258528),
		Fi: libc.Float32FromFloat32(0.4305111),
	},
	275: {
		Fr: -libc.Float32FromFloat32(0.89687274),
		Fi: libc.Float32FromFloat32(0.44228869),
	},
	276: {
		Fr: -libc.Float32FromFloat32(0.89100652),
		Fi: libc.Float32FromFloat32(0.4539905),
	},
	277: {
		Fr: -libc.Float32FromFloat32(0.88498764),
		Fi: libc.Float32FromFloat32(0.46561452),
	},
	278: {
		Fr: -libc.Float32FromFloat32(0.87881711),
		Fi: libc.Float32FromFloat32(0.47715876),
	},
	279: {
		Fr: -libc.Float32FromFloat32(0.87249601),
		Fi: libc.Float32FromFloat32(0.48862124),
	},
	280: {
		Fr: -libc.Float32FromFloat32(0.8660254),
		Fi: libc.Float32FromFloat32(0.5),
	},
	281: {
		Fr: -libc.Float32FromFloat32(0.85940641),
		Fi: libc.Float32FromFloat32(0.51129309),
	},
	282: {
		Fr: -libc.Float32FromFloat32(0.85264016),
		Fi: libc.Float32FromFloat32(0.52249856),
	},
	283: {
		Fr: -libc.Float32FromFloat32(0.84572782),
		Fi: libc.Float32FromFloat32(0.53361452),
	},
	284: {
		Fr: -libc.Float32FromFloat32(0.83867057),
		Fi: libc.Float32FromFloat32(0.54463904),
	},
	285: {
		Fr: -libc.Float32FromFloat32(0.83146961),
		Fi: libc.Float32FromFloat32(0.55557023),
	},
	286: {
		Fr: -libc.Float32FromFloat32(0.82412619),
		Fi: libc.Float32FromFloat32(0.56640624),
	},
	287: {
		Fr: -libc.Float32FromFloat32(0.81664156),
		Fi: libc.Float32FromFloat32(0.57714519),
	},
	288: {
		Fr: -libc.Float32FromFloat32(0.80901699),
		Fi: libc.Float32FromFloat32(0.58778525),
	},
	289: {
		Fr: -libc.Float32FromFloat32(0.80125381),
		Fi: libc.Float32FromFloat32(0.5983246),
	},
	290: {
		Fr: -libc.Float32FromFloat32(0.79335334),
		Fi: libc.Float32FromFloat32(0.60876143),
	},
	291: {
		Fr: -libc.Float32FromFloat32(0.78531693),
		Fi: libc.Float32FromFloat32(0.61909395),
	},
	292: {
		Fr: -libc.Float32FromFloat32(0.77714596),
		Fi: libc.Float32FromFloat32(0.62932039),
	},
	293: {
		Fr: -libc.Float32FromFloat32(0.76884183),
		Fi: libc.Float32FromFloat32(0.639439),
	},
	294: {
		Fr: -libc.Float32FromFloat32(0.76040597),
		Fi: libc.Float32FromFloat32(0.64944805),
	},
	295: {
		Fr: -libc.Float32FromFloat32(0.75183981),
		Fi: libc.Float32FromFloat32(0.65934582),
	},
	296: {
		Fr: -libc.Float32FromFloat32(0.74314483),
		Fi: libc.Float32FromFloat32(0.66913061),
	},
	297: {
		Fr: -libc.Float32FromFloat32(0.73432251),
		Fi: libc.Float32FromFloat32(0.67880075),
	},
	298: {
		Fr: -libc.Float32FromFloat32(0.72537437),
		Fi: libc.Float32FromFloat32(0.68835458),
	},
	299: {
		Fr: -libc.Float32FromFloat32(0.71630194),
		Fi: libc.Float32FromFloat32(0.69779046),
	},
	300: {
		Fr: -libc.Float32FromFloat32(0.70710678),
		Fi: libc.Float32FromFloat32(0.70710678),
	},
	301: {
		Fr: -libc.Float32FromFloat32(0.69779046),
		Fi: libc.Float32FromFloat32(0.71630194),
	},
	302: {
		Fr: -libc.Float32FromFloat32(0.68835458),
		Fi: libc.Float32FromFloat32(0.72537437),
	},
	303: {
		Fr: -libc.Float32FromFloat32(0.67880075),
		Fi: libc.Float32FromFloat32(0.73432251),
	},
	304: {
		Fr: -libc.Float32FromFloat32(0.66913061),
		Fi: libc.Float32FromFloat32(0.74314483),
	},
	305: {
		Fr: -libc.Float32FromFloat32(0.65934582),
		Fi: libc.Float32FromFloat32(0.75183981),
	},
	306: {
		Fr: -libc.Float32FromFloat32(0.64944805),
		Fi: libc.Float32FromFloat32(0.76040597),
	},
	307: {
		Fr: -libc.Float32FromFloat32(0.639439),
		Fi: libc.Float32FromFloat32(0.76884183),
	},
	308: {
		Fr: -libc.Float32FromFloat32(0.62932039),
		Fi: libc.Float32FromFloat32(0.77714596),
	},
	309: {
		Fr: -libc.Float32FromFloat32(0.61909395),
		Fi: libc.Float32FromFloat32(0.78531693),
	},
	310: {
		Fr: -libc.Float32FromFloat32(0.60876143),
		Fi: libc.Float32FromFloat32(0.79335334),
	},
	311: {
		Fr: -libc.Float32FromFloat32(0.5983246),
		Fi: libc.Float32FromFloat32(0.80125381),
	},
	312: {
		Fr: -libc.Float32FromFloat32(0.58778525),
		Fi: libc.Float32FromFloat32(0.80901699),
	},
	313: {
		Fr: -libc.Float32FromFloat32(0.57714519),
		Fi: libc.Float32FromFloat32(0.81664156),
	},
	314: {
		Fr: -libc.Float32FromFloat32(0.56640624),
		Fi: libc.Float32FromFloat32(0.82412619),
	},
	315: {
		Fr: -libc.Float32FromFloat32(0.55557023),
		Fi: libc.Float32FromFloat32(0.83146961),
	},
	316: {
		Fr: -libc.Float32FromFloat32(0.54463904),
		Fi: libc.Float32FromFloat32(0.83867057),
	},
	317: {
		Fr: -libc.Float32FromFloat32(0.53361452),
		Fi: libc.Float32FromFloat32(0.84572782),
	},
	318: {
		Fr: -libc.Float32FromFloat32(0.52249856),
		Fi: libc.Float32FromFloat32(0.85264016),
	},
	319: {
		Fr: -libc.Float32FromFloat32(0.51129309),
		Fi: libc.Float32FromFloat32(0.85940641),
	},
	320: {
		Fr: -libc.Float32FromFloat32(0.5),
		Fi: libc.Float32FromFloat32(0.8660254),
	},
	321: {
		Fr: -libc.Float32FromFloat32(0.48862124),
		Fi: libc.Float32FromFloat32(0.87249601),
	},
	322: {
		Fr: -libc.Float32FromFloat32(0.47715876),
		Fi: libc.Float32FromFloat32(0.87881711),
	},
	323: {
		Fr: -libc.Float32FromFloat32(0.46561452),
		Fi: libc.Float32FromFloat32(0.88498764),
	},
	324: {
		Fr: -libc.Float32FromFloat32(0.4539905),
		Fi: libc.Float32FromFloat32(0.89100652),
	},
	325: {
		Fr: -libc.Float32FromFloat32(0.44228869),
		Fi: libc.Float32FromFloat32(0.89687274),
	},
	326: {
		Fr: -libc.Float32FromFloat32(0.4305111),
		Fi: libc.Float32FromFloat32(0.90258528),
	},
	327: {
		Fr: -libc.Float32FromFloat32(0.41865974),
		Fi: libc.Float32FromFloat32(0.90814317),
	},
	328: {
		Fr: -libc.Float32FromFloat32(0.40673664),
		Fi: libc.Float32FromFloat32(0.91354546),
	},
	329: {
		Fr: -libc.Float32FromFloat32(0.39474386),
		Fi: libc.Float32FromFloat32(0.91879121),
	},
	330: {
		Fr: -libc.Float32FromFloat32(0.38268343),
		Fi: libc.Float32FromFloat32(0.92387953),
	},
	331: {
		Fr: -libc.Float32FromFloat32(0.37055744),
		Fi: libc.Float32FromFloat32(0.92880955),
	},
	332: {
		Fr: -libc.Float32FromFloat32(0.35836795),
		Fi: libc.Float32FromFloat32(0.93358043),
	},
	333: {
		Fr: -libc.Float32FromFloat32(0.34611706),
		Fi: libc.Float32FromFloat32(0.93819134),
	},
	334: {
		Fr: -libc.Float32FromFloat32(0.33380686),
		Fi: libc.Float32FromFloat32(0.94264149),
	},
	335: {
		Fr: -libc.Float32FromFloat32(0.32143947),
		Fi: libc.Float32FromFloat32(0.94693013),
	},
	336: {
		Fr: -libc.Float32FromFloat32(0.30901699),
		Fi: libc.Float32FromFloat32(0.95105652),
	},
	337: {
		Fr: -libc.Float32FromFloat32(0.29654157),
		Fi: libc.Float32FromFloat32(0.95501994),
	},
	338: {
		Fr: -libc.Float32FromFloat32(0.28401534),
		Fi: libc.Float32FromFloat32(0.95881973),
	},
	339: {
		Fr: -libc.Float32FromFloat32(0.27144045),
		Fi: libc.Float32FromFloat32(0.96245524),
	},
	340: {
		Fr: -libc.Float32FromFloat32(0.25881905),
		Fi: libc.Float32FromFloat32(0.96592583),
	},
	341: {
		Fr: -libc.Float32FromFloat32(0.24615329),
		Fi: libc.Float32FromFloat32(0.96923091),
	},
	342: {
		Fr: -libc.Float32FromFloat32(0.23344536),
		Fi: libc.Float32FromFloat32(0.97236992),
	},
	343: {
		Fr: -libc.Float32FromFloat32(0.22069744),
		Fi: libc.Float32FromFloat32(0.97534232),
	},
	344: {
		Fr: -libc.Float32FromFloat32(0.20791169),
		Fi: libc.Float32FromFloat32(0.9781476),
	},
	345: {
		Fr: -libc.Float32FromFloat32(0.19509032),
		Fi: libc.Float32FromFloat32(0.98078528),
	},
	346: {
		Fr: -libc.Float32FromFloat32(0.18223553),
		Fi: libc.Float32FromFloat32(0.98325491),
	},
	347: {
		Fr: -libc.Float32FromFloat32(0.1693495),
		Fi: libc.Float32FromFloat32(0.98555606),
	},
	348: {
		Fr: -libc.Float32FromFloat32(0.15643447),
		Fi: libc.Float32FromFloat32(0.98768834),
	},
	349: {
		Fr: -libc.Float32FromFloat32(0.14349262),
		Fi: libc.Float32FromFloat32(0.98965139),
	},
	350: {
		Fr: -libc.Float32FromFloat32(0.13052619),
		Fi: libc.Float32FromFloat32(0.99144486),
	},
	351: {
		Fr: -libc.Float32FromFloat32(0.1175374),
		Fi: libc.Float32FromFloat32(0.99306846),
	},
	352: {
		Fr: -libc.Float32FromFloat32(0.10452846),
		Fi: libc.Float32FromFloat32(0.9945219),
	},
	353: {
		Fr: -libc.Float32FromFloat32(0.091501619),
		Fi: libc.Float32FromFloat32(0.99580493),
	},
	354: {
		Fr: -libc.Float32FromFloat32(0.078459096),
		Fi: libc.Float32FromFloat32(0.99691733),
	},
	355: {
		Fr: -libc.Float32FromFloat32(0.065403129),
		Fi: libc.Float32FromFloat32(0.99785892),
	},
	356: {
		Fr: -libc.Float32FromFloat32(0.052335956),
		Fi: libc.Float32FromFloat32(0.99862953),
	},
	357: {
		Fr: -libc.Float32FromFloat32(0.039259816),
		Fi: libc.Float32FromFloat32(0.99922904),
	},
	358: {
		Fr: -libc.Float32FromFloat32(0.026176948),
		Fi: libc.Float32FromFloat32(0.99965732),
	},
	359: {
		Fr: -libc.Float32FromFloat32(0.013089596),
		Fi: libc.Float32FromFloat32(0.99991433),
	},
	360: {
		Fr: -libc.Float32FromFloat32(1.8369702e-16),
		Fi: libc.Float32FromFloat32(1),
	},
	361: {
		Fr: libc.Float32FromFloat32(0.013089596),
		Fi: libc.Float32FromFloat32(0.99991433),
	},
	362: {
		Fr: libc.Float32FromFloat32(0.026176948),
		Fi: libc.Float32FromFloat32(0.99965732),
	},
	363: {
		Fr: libc.Float32FromFloat32(0.039259816),
		Fi: libc.Float32FromFloat32(0.99922904),
	},
	364: {
		Fr: libc.Float32FromFloat32(0.052335956),
		Fi: libc.Float32FromFloat32(0.99862953),
	},
	365: {
		Fr: libc.Float32FromFloat32(0.065403129),
		Fi: libc.Float32FromFloat32(0.99785892),
	},
	366: {
		Fr: libc.Float32FromFloat32(0.078459096),
		Fi: libc.Float32FromFloat32(0.99691733),
	},
	367: {
		Fr: libc.Float32FromFloat32(0.091501619),
		Fi: libc.Float32FromFloat32(0.99580493),
	},
	368: {
		Fr: libc.Float32FromFloat32(0.10452846),
		Fi: libc.Float32FromFloat32(0.9945219),
	},
	369: {
		Fr: libc.Float32FromFloat32(0.1175374),
		Fi: libc.Float32FromFloat32(0.99306846),
	},
	370: {
		Fr: libc.Float32FromFloat32(0.13052619),
		Fi: libc.Float32FromFloat32(0.99144486),
	},
	371: {
		Fr: libc.Float32FromFloat32(0.14349262),
		Fi: libc.Float32FromFloat32(0.98965139),
	},
	372: {
		Fr: libc.Float32FromFloat32(0.15643447),
		Fi: libc.Float32FromFloat32(0.98768834),
	},
	373: {
		Fr: libc.Float32FromFloat32(0.1693495),
		Fi: libc.Float32FromFloat32(0.98555606),
	},
	374: {
		Fr: libc.Float32FromFloat32(0.18223553),
		Fi: libc.Float32FromFloat32(0.98325491),
	},
	375: {
		Fr: libc.Float32FromFloat32(0.19509032),
		Fi: libc.Float32FromFloat32(0.98078528),
	},
	376: {
		Fr: libc.Float32FromFloat32(0.20791169),
		Fi: libc.Float32FromFloat32(0.9781476),
	},
	377: {
		Fr: libc.Float32FromFloat32(0.22069744),
		Fi: libc.Float32FromFloat32(0.97534232),
	},
	378: {
		Fr: libc.Float32FromFloat32(0.23344536),
		Fi: libc.Float32FromFloat32(0.97236992),
	},
	379: {
		Fr: libc.Float32FromFloat32(0.24615329),
		Fi: libc.Float32FromFloat32(0.96923091),
	},
	380: {
		Fr: libc.Float32FromFloat32(0.25881905),
		Fi: libc.Float32FromFloat32(0.96592583),
	},
	381: {
		Fr: libc.Float32FromFloat32(0.27144045),
		Fi: libc.Float32FromFloat32(0.96245524),
	},
	382: {
		Fr: libc.Float32FromFloat32(0.28401534),
		Fi: libc.Float32FromFloat32(0.95881973),
	},
	383: {
		Fr: libc.Float32FromFloat32(0.29654157),
		Fi: libc.Float32FromFloat32(0.95501994),
	},
	384: {
		Fr: libc.Float32FromFloat32(0.30901699),
		Fi: libc.Float32FromFloat32(0.95105652),
	},
	385: {
		Fr: libc.Float32FromFloat32(0.32143947),
		Fi: libc.Float32FromFloat32(0.94693013),
	},
	386: {
		Fr: libc.Float32FromFloat32(0.33380686),
		Fi: libc.Float32FromFloat32(0.94264149),
	},
	387: {
		Fr: libc.Float32FromFloat32(0.34611706),
		Fi: libc.Float32FromFloat32(0.93819134),
	},
	388: {
		Fr: libc.Float32FromFloat32(0.35836795),
		Fi: libc.Float32FromFloat32(0.93358043),
	},
	389: {
		Fr: libc.Float32FromFloat32(0.37055744),
		Fi: libc.Float32FromFloat32(0.92880955),
	},
	390: {
		Fr: libc.Float32FromFloat32(0.38268343),
		Fi: libc.Float32FromFloat32(0.92387953),
	},
	391: {
		Fr: libc.Float32FromFloat32(0.39474386),
		Fi: libc.Float32FromFloat32(0.91879121),
	},
	392: {
		Fr: libc.Float32FromFloat32(0.40673664),
		Fi: libc.Float32FromFloat32(0.91354546),
	},
	393: {
		Fr: libc.Float32FromFloat32(0.41865974),
		Fi: libc.Float32FromFloat32(0.90814317),
	},
	394: {
		Fr: libc.Float32FromFloat32(0.4305111),
		Fi: libc.Float32FromFloat32(0.90258528),
	},
	395: {
		Fr: libc.Float32FromFloat32(0.44228869),
		Fi: libc.Float32FromFloat32(0.89687274),
	},
	396: {
		Fr: libc.Float32FromFloat32(0.4539905),
		Fi: libc.Float32FromFloat32(0.89100652),
	},
	397: {
		Fr: libc.Float32FromFloat32(0.46561452),
		Fi: libc.Float32FromFloat32(0.88498764),
	},
	398: {
		Fr: libc.Float32FromFloat32(0.47715876),
		Fi: libc.Float32FromFloat32(0.87881711),
	},
	399: {
		Fr: libc.Float32FromFloat32(0.48862124),
		Fi: libc.Float32FromFloat32(0.87249601),
	},
	400: {
		Fr: libc.Float32FromFloat32(0.5),
		Fi: libc.Float32FromFloat32(0.8660254),
	},
	401: {
		Fr: libc.Float32FromFloat32(0.51129309),
		Fi: libc.Float32FromFloat32(0.85940641),
	},
	402: {
		Fr: libc.Float32FromFloat32(0.52249856),
		Fi: libc.Float32FromFloat32(0.85264016),
	},
	403: {
		Fr: libc.Float32FromFloat32(0.53361452),
		Fi: libc.Float32FromFloat32(0.84572782),
	},
	404: {
		Fr: libc.Float32FromFloat32(0.54463904),
		Fi: libc.Float32FromFloat32(0.83867057),
	},
	405: {
		Fr: libc.Float32FromFloat32(0.55557023),
		Fi: libc.Float32FromFloat32(0.83146961),
	},
	406: {
		Fr: libc.Float32FromFloat32(0.56640624),
		Fi: libc.Float32FromFloat32(0.82412619),
	},
	407: {
		Fr: libc.Float32FromFloat32(0.57714519),
		Fi: libc.Float32FromFloat32(0.81664156),
	},
	408: {
		Fr: libc.Float32FromFloat32(0.58778525),
		Fi: libc.Float32FromFloat32(0.80901699),
	},
	409: {
		Fr: libc.Float32FromFloat32(0.5983246),
		Fi: libc.Float32FromFloat32(0.80125381),
	},
	410: {
		Fr: libc.Float32FromFloat32(0.60876143),
		Fi: libc.Float32FromFloat32(0.79335334),
	},
	411: {
		Fr: libc.Float32FromFloat32(0.61909395),
		Fi: libc.Float32FromFloat32(0.78531693),
	},
	412: {
		Fr: libc.Float32FromFloat32(0.62932039),
		Fi: libc.Float32FromFloat32(0.77714596),
	},
	413: {
		Fr: libc.Float32FromFloat32(0.639439),
		Fi: libc.Float32FromFloat32(0.76884183),
	},
	414: {
		Fr: libc.Float32FromFloat32(0.64944805),
		Fi: libc.Float32FromFloat32(0.76040597),
	},
	415: {
		Fr: libc.Float32FromFloat32(0.65934582),
		Fi: libc.Float32FromFloat32(0.75183981),
	},
	416: {
		Fr: libc.Float32FromFloat32(0.66913061),
		Fi: libc.Float32FromFloat32(0.74314483),
	},
	417: {
		Fr: libc.Float32FromFloat32(0.67880075),
		Fi: libc.Float32FromFloat32(0.73432251),
	},
	418: {
		Fr: libc.Float32FromFloat32(0.68835458),
		Fi: libc.Float32FromFloat32(0.72537437),
	},
	419: {
		Fr: libc.Float32FromFloat32(0.69779046),
		Fi: libc.Float32FromFloat32(0.71630194),
	},
	420: {
		Fr: libc.Float32FromFloat32(0.70710678),
		Fi: libc.Float32FromFloat32(0.70710678),
	},
	421: {
		Fr: libc.Float32FromFloat32(0.71630194),
		Fi: libc.Float32FromFloat32(0.69779046),
	},
	422: {
		Fr: libc.Float32FromFloat32(0.72537437),
		Fi: libc.Float32FromFloat32(0.68835458),
	},
	423: {
		Fr: libc.Float32FromFloat32(0.73432251),
		Fi: libc.Float32FromFloat32(0.67880075),
	},
	424: {
		Fr: libc.Float32FromFloat32(0.74314483),
		Fi: libc.Float32FromFloat32(0.66913061),
	},
	425: {
		Fr: libc.Float32FromFloat32(0.75183981),
		Fi: libc.Float32FromFloat32(0.65934582),
	},
	426: {
		Fr: libc.Float32FromFloat32(0.76040597),
		Fi: libc.Float32FromFloat32(0.64944805),
	},
	427: {
		Fr: libc.Float32FromFloat32(0.76884183),
		Fi: libc.Float32FromFloat32(0.639439),
	},
	428: {
		Fr: libc.Float32FromFloat32(0.77714596),
		Fi: libc.Float32FromFloat32(0.62932039),
	},
	429: {
		Fr: libc.Float32FromFloat32(0.78531693),
		Fi: libc.Float32FromFloat32(0.61909395),
	},
	430: {
		Fr: libc.Float32FromFloat32(0.79335334),
		Fi: libc.Float32FromFloat32(0.60876143),
	},
	431: {
		Fr: libc.Float32FromFloat32(0.80125381),
		Fi: libc.Float32FromFloat32(0.5983246),
	},
	432: {
		Fr: libc.Float32FromFloat32(0.80901699),
		Fi: libc.Float32FromFloat32(0.58778525),
	},
	433: {
		Fr: libc.Float32FromFloat32(0.81664156),
		Fi: libc.Float32FromFloat32(0.57714519),
	},
	434: {
		Fr: libc.Float32FromFloat32(0.82412619),
		Fi: libc.Float32FromFloat32(0.56640624),
	},
	435: {
		Fr: libc.Float32FromFloat32(0.83146961),
		Fi: libc.Float32FromFloat32(0.55557023),
	},
	436: {
		Fr: libc.Float32FromFloat32(0.83867057),
		Fi: libc.Float32FromFloat32(0.54463904),
	},
	437: {
		Fr: libc.Float32FromFloat32(0.84572782),
		Fi: libc.Float32FromFloat32(0.53361452),
	},
	438: {
		Fr: libc.Float32FromFloat32(0.85264016),
		Fi: libc.Float32FromFloat32(0.52249856),
	},
	439: {
		Fr: libc.Float32FromFloat32(0.85940641),
		Fi: libc.Float32FromFloat32(0.51129309),
	},
	440: {
		Fr: libc.Float32FromFloat32(0.8660254),
		Fi: libc.Float32FromFloat32(0.5),
	},
	441: {
		Fr: libc.Float32FromFloat32(0.87249601),
		Fi: libc.Float32FromFloat32(0.48862124),
	},
	442: {
		Fr: libc.Float32FromFloat32(0.87881711),
		Fi: libc.Float32FromFloat32(0.47715876),
	},
	443: {
		Fr: libc.Float32FromFloat32(0.88498764),
		Fi: libc.Float32FromFloat32(0.46561452),
	},
	444: {
		Fr: libc.Float32FromFloat32(0.89100652),
		Fi: libc.Float32FromFloat32(0.4539905),
	},
	445: {
		Fr: libc.Float32FromFloat32(0.89687274),
		Fi: libc.Float32FromFloat32(0.44228869),
	},
	446: {
		Fr: libc.Float32FromFloat32(0.90258528),
		Fi: libc.Float32FromFloat32(0.4305111),
	},
	447: {
		Fr: libc.Float32FromFloat32(0.90814317),
		Fi: libc.Float32FromFloat32(0.41865974),
	},
	448: {
		Fr: libc.Float32FromFloat32(0.91354546),
		Fi: libc.Float32FromFloat32(0.40673664),
	},
	449: {
		Fr: libc.Float32FromFloat32(0.91879121),
		Fi: libc.Float32FromFloat32(0.39474386),
	},
	450: {
		Fr: libc.Float32FromFloat32(0.92387953),
		Fi: libc.Float32FromFloat32(0.38268343),
	},
	451: {
		Fr: libc.Float32FromFloat32(0.92880955),
		Fi: libc.Float32FromFloat32(0.37055744),
	},
	452: {
		Fr: libc.Float32FromFloat32(0.93358043),
		Fi: libc.Float32FromFloat32(0.35836795),
	},
	453: {
		Fr: libc.Float32FromFloat32(0.93819134),
		Fi: libc.Float32FromFloat32(0.34611706),
	},
	454: {
		Fr: libc.Float32FromFloat32(0.94264149),
		Fi: libc.Float32FromFloat32(0.33380686),
	},
	455: {
		Fr: libc.Float32FromFloat32(0.94693013),
		Fi: libc.Float32FromFloat32(0.32143947),
	},
	456: {
		Fr: libc.Float32FromFloat32(0.95105652),
		Fi: libc.Float32FromFloat32(0.30901699),
	},
	457: {
		Fr: libc.Float32FromFloat32(0.95501994),
		Fi: libc.Float32FromFloat32(0.29654157),
	},
	458: {
		Fr: libc.Float32FromFloat32(0.95881973),
		Fi: libc.Float32FromFloat32(0.28401534),
	},
	459: {
		Fr: libc.Float32FromFloat32(0.96245524),
		Fi: libc.Float32FromFloat32(0.27144045),
	},
	460: {
		Fr: libc.Float32FromFloat32(0.96592583),
		Fi: libc.Float32FromFloat32(0.25881905),
	},
	461: {
		Fr: libc.Float32FromFloat32(0.96923091),
		Fi: libc.Float32FromFloat32(0.24615329),
	},
	462: {
		Fr: libc.Float32FromFloat32(0.97236992),
		Fi: libc.Float32FromFloat32(0.23344536),
	},
	463: {
		Fr: libc.Float32FromFloat32(0.97534232),
		Fi: libc.Float32FromFloat32(0.22069744),
	},
	464: {
		Fr: libc.Float32FromFloat32(0.9781476),
		Fi: libc.Float32FromFloat32(0.20791169),
	},
	465: {
		Fr: libc.Float32FromFloat32(0.98078528),
		Fi: libc.Float32FromFloat32(0.19509032),
	},
	466: {
		Fr: libc.Float32FromFloat32(0.98325491),
		Fi: libc.Float32FromFloat32(0.18223553),
	},
	467: {
		Fr: libc.Float32FromFloat32(0.98555606),
		Fi: libc.Float32FromFloat32(0.1693495),
	},
	468: {
		Fr: libc.Float32FromFloat32(0.98768834),
		Fi: libc.Float32FromFloat32(0.15643447),
	},
	469: {
		Fr: libc.Float32FromFloat32(0.98965139),
		Fi: libc.Float32FromFloat32(0.14349262),
	},
	470: {
		Fr: libc.Float32FromFloat32(0.99144486),
		Fi: libc.Float32FromFloat32(0.13052619),
	},
	471: {
		Fr: libc.Float32FromFloat32(0.99306846),
		Fi: libc.Float32FromFloat32(0.1175374),
	},
	472: {
		Fr: libc.Float32FromFloat32(0.9945219),
		Fi: libc.Float32FromFloat32(0.10452846),
	},
	473: {
		Fr: libc.Float32FromFloat32(0.99580493),
		Fi: libc.Float32FromFloat32(0.091501619),
	},
	474: {
		Fr: libc.Float32FromFloat32(0.99691733),
		Fi: libc.Float32FromFloat32(0.078459096),
	},
	475: {
		Fr: libc.Float32FromFloat32(0.99785892),
		Fi: libc.Float32FromFloat32(0.065403129),
	},
	476: {
		Fr: libc.Float32FromFloat32(0.99862953),
		Fi: libc.Float32FromFloat32(0.052335956),
	},
	477: {
		Fr: libc.Float32FromFloat32(0.99922904),
		Fi: libc.Float32FromFloat32(0.039259816),
	},
	478: {
		Fr: libc.Float32FromFloat32(0.99965732),
		Fi: libc.Float32FromFloat32(0.026176948),
	},
	479: {
		Fr: libc.Float32FromFloat32(0.99991433),
		Fi: libc.Float32FromFloat32(0.013089596),
	},
}
var fft_bitrev480 = [480]OpusT_opus_int16{
	1:   int16(96),
	2:   int16(192),
	3:   int16(288),
	4:   int16(384),
	5:   int16(32),
	6:   int16(128),
	7:   int16(224),
	8:   int16(320),
	9:   int16(416),
	10:  int16(64),
	11:  int16(160),
	12:  int16(256),
	13:  int16(352),
	14:  int16(448),
	15:  int16(8),
	16:  int16(104),
	17:  int16(200),
	18:  int16(296),
	19:  int16(392),
	20:  int16(40),
	21:  int16(136),
	22:  int16(232),
	23:  int16(328),
	24:  int16(424),
	25:  int16(72),
	26:  int16(168),
	27:  int16(264),
	28:  int16(360),
	29:  int16(456),
	30:  int16(16),
	31:  int16(112),
	32:  int16(208),
	33:  int16(304),
	34:  int16(400),
	35:  int16(48),
	36:  int16(144),
	37:  int16(240),
	38:  int16(336),
	39:  int16(432),
	40:  int16(80),
	41:  int16(176),
	42:  int16(272),
	43:  int16(368),
	44:  int16(464),
	45:  int16(24),
	46:  int16(120),
	47:  int16(216),
	48:  int16(312),
	49:  int16(408),
	50:  int16(56),
	51:  int16(152),
	52:  int16(248),
	53:  int16(344),
	54:  int16(440),
	55:  int16(88),
	56:  int16(184),
	57:  int16(280),
	58:  int16(376),
	59:  int16(472),
	60:  int16(4),
	61:  int16(100),
	62:  int16(196),
	63:  int16(292),
	64:  int16(388),
	65:  int16(36),
	66:  int16(132),
	67:  int16(228),
	68:  int16(324),
	69:  int16(420),
	70:  int16(68),
	71:  int16(164),
	72:  int16(260),
	73:  int16(356),
	74:  int16(452),
	75:  int16(12),
	76:  int16(108),
	77:  int16(204),
	78:  int16(300),
	79:  int16(396),
	80:  int16(44),
	81:  int16(140),
	82:  int16(236),
	83:  int16(332),
	84:  int16(428),
	85:  int16(76),
	86:  int16(172),
	87:  int16(268),
	88:  int16(364),
	89:  int16(460),
	90:  int16(20),
	91:  int16(116),
	92:  int16(212),
	93:  int16(308),
	94:  int16(404),
	95:  int16(52),
	96:  int16(148),
	97:  int16(244),
	98:  int16(340),
	99:  int16(436),
	100: int16(84),
	101: int16(180),
	102: int16(276),
	103: int16(372),
	104: int16(468),
	105: int16(28),
	106: int16(124),
	107: int16(220),
	108: int16(316),
	109: int16(412),
	110: int16(60),
	111: int16(156),
	112: int16(252),
	113: int16(348),
	114: int16(444),
	115: int16(92),
	116: int16(188),
	117: int16(284),
	118: int16(380),
	119: int16(476),
	120: int16(1),
	121: int16(97),
	122: int16(193),
	123: int16(289),
	124: int16(385),
	125: int16(33),
	126: int16(129),
	127: int16(225),
	128: int16(321),
	129: int16(417),
	130: int16(65),
	131: int16(161),
	132: int16(257),
	133: int16(353),
	134: int16(449),
	135: int16(9),
	136: int16(105),
	137: int16(201),
	138: int16(297),
	139: int16(393),
	140: int16(41),
	141: int16(137),
	142: int16(233),
	143: int16(329),
	144: int16(425),
	145: int16(73),
	146: int16(169),
	147: int16(265),
	148: int16(361),
	149: int16(457),
	150: int16(17),
	151: int16(113),
	152: int16(209),
	153: int16(305),
	154: int16(401),
	155: int16(49),
	156: int16(145),
	157: int16(241),
	158: int16(337),
	159: int16(433),
	160: int16(81),
	161: int16(177),
	162: int16(273),
	163: int16(369),
	164: int16(465),
	165: int16(25),
	166: int16(121),
	167: int16(217),
	168: int16(313),
	169: int16(409),
	170: int16(57),
	171: int16(153),
	172: int16(249),
	173: int16(345),
	174: int16(441),
	175: int16(89),
	176: int16(185),
	177: int16(281),
	178: int16(377),
	179: int16(473),
	180: int16(5),
	181: int16(101),
	182: int16(197),
	183: int16(293),
	184: int16(389),
	185: int16(37),
	186: int16(133),
	187: int16(229),
	188: int16(325),
	189: int16(421),
	190: int16(69),
	191: int16(165),
	192: int16(261),
	193: int16(357),
	194: int16(453),
	195: int16(13),
	196: int16(109),
	197: int16(205),
	198: int16(301),
	199: int16(397),
	200: int16(45),
	201: int16(141),
	202: int16(237),
	203: int16(333),
	204: int16(429),
	205: int16(77),
	206: int16(173),
	207: int16(269),
	208: int16(365),
	209: int16(461),
	210: int16(21),
	211: int16(117),
	212: int16(213),
	213: int16(309),
	214: int16(405),
	215: int16(53),
	216: int16(149),
	217: int16(245),
	218: int16(341),
	219: int16(437),
	220: int16(85),
	221: int16(181),
	222: int16(277),
	223: int16(373),
	224: int16(469),
	225: int16(29),
	226: int16(125),
	227: int16(221),
	228: int16(317),
	229: int16(413),
	230: int16(61),
	231: int16(157),
	232: int16(253),
	233: int16(349),
	234: int16(445),
	235: int16(93),
	236: int16(189),
	237: int16(285),
	238: int16(381),
	239: int16(477),
	240: int16(2),
	241: int16(98),
	242: int16(194),
	243: int16(290),
	244: int16(386),
	245: int16(34),
	246: int16(130),
	247: int16(226),
	248: int16(322),
	249: int16(418),
	250: int16(66),
	251: int16(162),
	252: int16(258),
	253: int16(354),
	254: int16(450),
	255: int16(10),
	256: int16(106),
	257: int16(202),
	258: int16(298),
	259: int16(394),
	260: int16(42),
	261: int16(138),
	262: int16(234),
	263: int16(330),
	264: int16(426),
	265: int16(74),
	266: int16(170),
	267: int16(266),
	268: int16(362),
	269: int16(458),
	270: int16(18),
	271: int16(114),
	272: int16(210),
	273: int16(306),
	274: int16(402),
	275: int16(50),
	276: int16(146),
	277: int16(242),
	278: int16(338),
	279: int16(434),
	280: int16(82),
	281: int16(178),
	282: int16(274),
	283: int16(370),
	284: int16(466),
	285: int16(26),
	286: int16(122),
	287: int16(218),
	288: int16(314),
	289: int16(410),
	290: int16(58),
	291: int16(154),
	292: int16(250),
	293: int16(346),
	294: int16(442),
	295: int16(90),
	296: int16(186),
	297: int16(282),
	298: int16(378),
	299: int16(474),
	300: int16(6),
	301: int16(102),
	302: int16(198),
	303: int16(294),
	304: int16(390),
	305: int16(38),
	306: int16(134),
	307: int16(230),
	308: int16(326),
	309: int16(422),
	310: int16(70),
	311: int16(166),
	312: int16(262),
	313: int16(358),
	314: int16(454),
	315: int16(14),
	316: int16(110),
	317: int16(206),
	318: int16(302),
	319: int16(398),
	320: int16(46),
	321: int16(142),
	322: int16(238),
	323: int16(334),
	324: int16(430),
	325: int16(78),
	326: int16(174),
	327: int16(270),
	328: int16(366),
	329: int16(462),
	330: int16(22),
	331: int16(118),
	332: int16(214),
	333: int16(310),
	334: int16(406),
	335: int16(54),
	336: int16(150),
	337: int16(246),
	338: int16(342),
	339: int16(438),
	340: int16(86),
	341: int16(182),
	342: int16(278),
	343: int16(374),
	344: int16(470),
	345: int16(30),
	346: int16(126),
	347: int16(222),
	348: int16(318),
	349: int16(414),
	350: int16(62),
	351: int16(158),
	352: int16(254),
	353: int16(350),
	354: int16(446),
	355: int16(94),
	356: int16(190),
	357: int16(286),
	358: int16(382),
	359: int16(478),
	360: int16(3),
	361: int16(99),
	362: int16(195),
	363: int16(291),
	364: int16(387),
	365: int16(35),
	366: int16(131),
	367: int16(227),
	368: int16(323),
	369: int16(419),
	370: int16(67),
	371: int16(163),
	372: int16(259),
	373: int16(355),
	374: int16(451),
	375: int16(11),
	376: int16(107),
	377: int16(203),
	378: int16(299),
	379: int16(395),
	380: int16(43),
	381: int16(139),
	382: int16(235),
	383: int16(331),
	384: int16(427),
	385: int16(75),
	386: int16(171),
	387: int16(267),
	388: int16(363),
	389: int16(459),
	390: int16(19),
	391: int16(115),
	392: int16(211),
	393: int16(307),
	394: int16(403),
	395: int16(51),
	396: int16(147),
	397: int16(243),
	398: int16(339),
	399: int16(435),
	400: int16(83),
	401: int16(179),
	402: int16(275),
	403: int16(371),
	404: int16(467),
	405: int16(27),
	406: int16(123),
	407: int16(219),
	408: int16(315),
	409: int16(411),
	410: int16(59),
	411: int16(155),
	412: int16(251),
	413: int16(347),
	414: int16(443),
	415: int16(91),
	416: int16(187),
	417: int16(283),
	418: int16(379),
	419: int16(475),
	420: int16(7),
	421: int16(103),
	422: int16(199),
	423: int16(295),
	424: int16(391),
	425: int16(39),
	426: int16(135),
	427: int16(231),
	428: int16(327),
	429: int16(423),
	430: int16(71),
	431: int16(167),
	432: int16(263),
	433: int16(359),
	434: int16(455),
	435: int16(15),
	436: int16(111),
	437: int16(207),
	438: int16(303),
	439: int16(399),
	440: int16(47),
	441: int16(143),
	442: int16(239),
	443: int16(335),
	444: int16(431),
	445: int16(79),
	446: int16(175),
	447: int16(271),
	448: int16(367),
	449: int16(463),
	450: int16(23),
	451: int16(119),
	452: int16(215),
	453: int16(311),
	454: int16(407),
	455: int16(55),
	456: int16(151),
	457: int16(247),
	458: int16(343),
	459: int16(439),
	460: int16(87),
	461: int16(183),
	462: int16(279),
	463: int16(375),
	464: int16(471),
	465: int16(31),
	466: int16(127),
	467: int16(223),
	468: int16(319),
	469: int16(415),
	470: int16(63),
	471: int16(159),
	472: int16(255),
	473: int16(351),
	474: int16(447),
	475: int16(95),
	476: int16(191),
	477: int16(287),
	478: int16(383),
	479: int16(479),
}
var fft_bitrev240 = [240]OpusT_opus_int16{
	1:   int16(48),
	2:   int16(96),
	3:   int16(144),
	4:   int16(192),
	5:   int16(16),
	6:   int16(64),
	7:   int16(112),
	8:   int16(160),
	9:   int16(208),
	10:  int16(32),
	11:  int16(80),
	12:  int16(128),
	13:  int16(176),
	14:  int16(224),
	15:  int16(4),
	16:  int16(52),
	17:  int16(100),
	18:  int16(148),
	19:  int16(196),
	20:  int16(20),
	21:  int16(68),
	22:  int16(116),
	23:  int16(164),
	24:  int16(212),
	25:  int16(36),
	26:  int16(84),
	27:  int16(132),
	28:  int16(180),
	29:  int16(228),
	30:  int16(8),
	31:  int16(56),
	32:  int16(104),
	33:  int16(152),
	34:  int16(200),
	35:  int16(24),
	36:  int16(72),
	37:  int16(120),
	38:  int16(168),
	39:  int16(216),
	40:  int16(40),
	41:  int16(88),
	42:  int16(136),
	43:  int16(184),
	44:  int16(232),
	45:  int16(12),
	46:  int16(60),
	47:  int16(108),
	48:  int16(156),
	49:  int16(204),
	50:  int16(28),
	51:  int16(76),
	52:  int16(124),
	53:  int16(172),
	54:  int16(220),
	55:  int16(44),
	56:  int16(92),
	57:  int16(140),
	58:  int16(188),
	59:  int16(236),
	60:  int16(1),
	61:  int16(49),
	62:  int16(97),
	63:  int16(145),
	64:  int16(193),
	65:  int16(17),
	66:  int16(65),
	67:  int16(113),
	68:  int16(161),
	69:  int16(209),
	70:  int16(33),
	71:  int16(81),
	72:  int16(129),
	73:  int16(177),
	74:  int16(225),
	75:  int16(5),
	76:  int16(53),
	77:  int16(101),
	78:  int16(149),
	79:  int16(197),
	80:  int16(21),
	81:  int16(69),
	82:  int16(117),
	83:  int16(165),
	84:  int16(213),
	85:  int16(37),
	86:  int16(85),
	87:  int16(133),
	88:  int16(181),
	89:  int16(229),
	90:  int16(9),
	91:  int16(57),
	92:  int16(105),
	93:  int16(153),
	94:  int16(201),
	95:  int16(25),
	96:  int16(73),
	97:  int16(121),
	98:  int16(169),
	99:  int16(217),
	100: int16(41),
	101: int16(89),
	102: int16(137),
	103: int16(185),
	104: int16(233),
	105: int16(13),
	106: int16(61),
	107: int16(109),
	108: int16(157),
	109: int16(205),
	110: int16(29),
	111: int16(77),
	112: int16(125),
	113: int16(173),
	114: int16(221),
	115: int16(45),
	116: int16(93),
	117: int16(141),
	118: int16(189),
	119: int16(237),
	120: int16(2),
	121: int16(50),
	122: int16(98),
	123: int16(146),
	124: int16(194),
	125: int16(18),
	126: int16(66),
	127: int16(114),
	128: int16(162),
	129: int16(210),
	130: int16(34),
	131: int16(82),
	132: int16(130),
	133: int16(178),
	134: int16(226),
	135: int16(6),
	136: int16(54),
	137: int16(102),
	138: int16(150),
	139: int16(198),
	140: int16(22),
	141: int16(70),
	142: int16(118),
	143: int16(166),
	144: int16(214),
	145: int16(38),
	146: int16(86),
	147: int16(134),
	148: int16(182),
	149: int16(230),
	150: int16(10),
	151: int16(58),
	152: int16(106),
	153: int16(154),
	154: int16(202),
	155: int16(26),
	156: int16(74),
	157: int16(122),
	158: int16(170),
	159: int16(218),
	160: int16(42),
	161: int16(90),
	162: int16(138),
	163: int16(186),
	164: int16(234),
	165: int16(14),
	166: int16(62),
	167: int16(110),
	168: int16(158),
	169: int16(206),
	170: int16(30),
	171: int16(78),
	172: int16(126),
	173: int16(174),
	174: int16(222),
	175: int16(46),
	176: int16(94),
	177: int16(142),
	178: int16(190),
	179: int16(238),
	180: int16(3),
	181: int16(51),
	182: int16(99),
	183: int16(147),
	184: int16(195),
	185: int16(19),
	186: int16(67),
	187: int16(115),
	188: int16(163),
	189: int16(211),
	190: int16(35),
	191: int16(83),
	192: int16(131),
	193: int16(179),
	194: int16(227),
	195: int16(7),
	196: int16(55),
	197: int16(103),
	198: int16(151),
	199: int16(199),
	200: int16(23),
	201: int16(71),
	202: int16(119),
	203: int16(167),
	204: int16(215),
	205: int16(39),
	206: int16(87),
	207: int16(135),
	208: int16(183),
	209: int16(231),
	210: int16(11),
	211: int16(59),
	212: int16(107),
	213: int16(155),
	214: int16(203),
	215: int16(27),
	216: int16(75),
	217: int16(123),
	218: int16(171),
	219: int16(219),
	220: int16(43),
	221: int16(91),
	222: int16(139),
	223: int16(187),
	224: int16(235),
	225: int16(15),
	226: int16(63),
	227: int16(111),
	228: int16(159),
	229: int16(207),
	230: int16(31),
	231: int16(79),
	232: int16(127),
	233: int16(175),
	234: int16(223),
	235: int16(47),
	236: int16(95),
	237: int16(143),
	238: int16(191),
	239: int16(239),
}
var fft_bitrev120 = [120]OpusT_opus_int16{
	1:   int16(24),
	2:   int16(48),
	3:   int16(72),
	4:   int16(96),
	5:   int16(8),
	6:   int16(32),
	7:   int16(56),
	8:   int16(80),
	9:   int16(104),
	10:  int16(16),
	11:  int16(40),
	12:  int16(64),
	13:  int16(88),
	14:  int16(112),
	15:  int16(4),
	16:  int16(28),
	17:  int16(52),
	18:  int16(76),
	19:  int16(100),
	20:  int16(12),
	21:  int16(36),
	22:  int16(60),
	23:  int16(84),
	24:  int16(108),
	25:  int16(20),
	26:  int16(44),
	27:  int16(68),
	28:  int16(92),
	29:  int16(116),
	30:  int16(1),
	31:  int16(25),
	32:  int16(49),
	33:  int16(73),
	34:  int16(97),
	35:  int16(9),
	36:  int16(33),
	37:  int16(57),
	38:  int16(81),
	39:  int16(105),
	40:  int16(17),
	41:  int16(41),
	42:  int16(65),
	43:  int16(89),
	44:  int16(113),
	45:  int16(5),
	46:  int16(29),
	47:  int16(53),
	48:  int16(77),
	49:  int16(101),
	50:  int16(13),
	51:  int16(37),
	52:  int16(61),
	53:  int16(85),
	54:  int16(109),
	55:  int16(21),
	56:  int16(45),
	57:  int16(69),
	58:  int16(93),
	59:  int16(117),
	60:  int16(2),
	61:  int16(26),
	62:  int16(50),
	63:  int16(74),
	64:  int16(98),
	65:  int16(10),
	66:  int16(34),
	67:  int16(58),
	68:  int16(82),
	69:  int16(106),
	70:  int16(18),
	71:  int16(42),
	72:  int16(66),
	73:  int16(90),
	74:  int16(114),
	75:  int16(6),
	76:  int16(30),
	77:  int16(54),
	78:  int16(78),
	79:  int16(102),
	80:  int16(14),
	81:  int16(38),
	82:  int16(62),
	83:  int16(86),
	84:  int16(110),
	85:  int16(22),
	86:  int16(46),
	87:  int16(70),
	88:  int16(94),
	89:  int16(118),
	90:  int16(3),
	91:  int16(27),
	92:  int16(51),
	93:  int16(75),
	94:  int16(99),
	95:  int16(11),
	96:  int16(35),
	97:  int16(59),
	98:  int16(83),
	99:  int16(107),
	100: int16(19),
	101: int16(43),
	102: int16(67),
	103: int16(91),
	104: int16(115),
	105: int16(7),
	106: int16(31),
	107: int16(55),
	108: int16(79),
	109: int16(103),
	110: int16(15),
	111: int16(39),
	112: int16(63),
	113: int16(87),
	114: int16(111),
	115: int16(23),
	116: int16(47),
	117: int16(71),
	118: int16(95),
	119: int16(119),
}
var fft_bitrev60 = [60]OpusT_opus_int16{
	1:  int16(12),
	2:  int16(24),
	3:  int16(36),
	4:  int16(48),
	5:  int16(4),
	6:  int16(16),
	7:  int16(28),
	8:  int16(40),
	9:  int16(52),
	10: int16(8),
	11: int16(20),
	12: int16(32),
	13: int16(44),
	14: int16(56),
	15: int16(1),
	16: int16(13),
	17: int16(25),
	18: int16(37),
	19: int16(49),
	20: int16(5),
	21: int16(17),
	22: int16(29),
	23: int16(41),
	24: int16(53),
	25: int16(9),
	26: int16(21),
	27: int16(33),
	28: int16(45),
	29: int16(57),
	30: int16(2),
	31: int16(14),
	32: int16(26),
	33: int16(38),
	34: int16(50),
	35: int16(6),
	36: int16(18),
	37: int16(30),
	38: int16(42),
	39: int16(54),
	40: int16(10),
	41: int16(22),
	42: int16(34),
	43: int16(46),
	44: int16(58),
	45: int16(3),
	46: int16(15),
	47: int16(27),
	48: int16(39),
	49: int16(51),
	50: int16(7),
	51: int16(19),
	52: int16(31),
	53: int16(43),
	54: int16(55),
	55: int16(11),
	56: int16(23),
	57: int16(35),
	58: int16(47),
	59: int16(59),
}
var fft_state48000_960_0 = OpusT_kiss_fft_state{
	Fnfft:  int32(480),
	Fscale: libc.Float32FromFloat32(0.0020833334),
	Fshift: -int32(1),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(96),
		2: int16(3),
		3: int16(32),
		4: int16(4),
		5: int16(8),
		6: int16(2),
		7: int16(4),
		8: int16(4),
		9: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev480)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_1 = OpusT_kiss_fft_state{
	Fnfft:  int32(240),
	Fscale: libc.Float32FromFloat32(0.0041666669),
	Fshift: int32(1),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(48),
		2: int16(3),
		3: int16(16),
		4: int16(4),
		5: int16(4),
		6: int16(4),
		7: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev240)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_2 = OpusT_kiss_fft_state{
	Fnfft:  int32(120),
	Fscale: libc.Float32FromFloat32(0.0083333338),
	Fshift: int32(2),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(24),
		2: int16(3),
		3: int16(8),
		4: int16(2),
		5: int16(4),
		6: int16(4),
		7: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev120)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_3 = OpusT_kiss_fft_state{
	Fnfft:  int32(60),
	Fscale: libc.Float32FromFloat32(0.016666668),
	Fshift: int32(3),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(12),
		2: int16(3),
		3: int16(4),
		4: int16(4),
		5: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev60)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var mdct_twiddles960 = [1800]OpusT_celt_coef{
	0:    libc.Float32FromFloat32(0.99999992),
	1:    libc.Float32FromFloat32(0.99999322),
	2:    libc.Float32FromFloat32(0.99997582),
	3:    libc.Float32FromFloat32(0.99994771),
	4:    libc.Float32FromFloat32(0.99990889),
	5:    libc.Float32FromFloat32(0.99985936),
	6:    libc.Float32FromFloat32(0.99979913),
	7:    libc.Float32FromFloat32(0.99972818),
	8:    libc.Float32FromFloat32(0.99964653),
	9:    libc.Float32FromFloat32(0.99955418),
	10:   libc.Float32FromFloat32(0.99945112),
	11:   libc.Float32FromFloat32(0.99933736),
	12:   libc.Float32FromFloat32(0.99921289),
	13:   libc.Float32FromFloat32(0.99907773),
	14:   libc.Float32FromFloat32(0.99893186),
	15:   libc.Float32FromFloat32(0.9987753),
	16:   libc.Float32FromFloat32(0.99860804),
	17:   libc.Float32FromFloat32(0.99843009),
	18:   libc.Float32FromFloat32(0.99824144),
	19:   libc.Float32FromFloat32(0.99804211),
	20:   libc.Float32FromFloat32(0.99783209),
	21:   libc.Float32FromFloat32(0.99761138),
	22:   libc.Float32FromFloat32(0.99737998),
	23:   libc.Float32FromFloat32(0.99713791),
	24:   libc.Float32FromFloat32(0.99688516),
	25:   libc.Float32FromFloat32(0.99662173),
	26:   libc.Float32FromFloat32(0.99634763),
	27:   libc.Float32FromFloat32(0.99606285),
	28:   libc.Float32FromFloat32(0.99576741),
	29:   libc.Float32FromFloat32(0.99546131),
	30:   libc.Float32FromFloat32(0.99514455),
	31:   libc.Float32FromFloat32(0.99481713),
	32:   libc.Float32FromFloat32(0.99447905),
	33:   libc.Float32FromFloat32(0.99413033),
	34:   libc.Float32FromFloat32(0.99377096),
	35:   libc.Float32FromFloat32(0.99340095),
	36:   libc.Float32FromFloat32(0.99302029),
	37:   libc.Float32FromFloat32(0.99262901),
	38:   libc.Float32FromFloat32(0.99222709),
	39:   libc.Float32FromFloat32(0.99181455),
	40:   libc.Float32FromFloat32(0.99139139),
	41:   libc.Float32FromFloat32(0.9909576),
	42:   libc.Float32FromFloat32(0.99051321),
	43:   libc.Float32FromFloat32(0.99005821),
	44:   libc.Float32FromFloat32(0.98959261),
	45:   libc.Float32FromFloat32(0.98911641),
	46:   libc.Float32FromFloat32(0.98862961),
	47:   libc.Float32FromFloat32(0.98813223),
	48:   libc.Float32FromFloat32(0.98762427),
	49:   libc.Float32FromFloat32(0.98710573),
	50:   libc.Float32FromFloat32(0.98657662),
	51:   libc.Float32FromFloat32(0.98603694),
	52:   libc.Float32FromFloat32(0.9854867),
	53:   libc.Float32FromFloat32(0.98492591),
	54:   libc.Float32FromFloat32(0.98435457),
	55:   libc.Float32FromFloat32(0.98377269),
	56:   libc.Float32FromFloat32(0.98318028),
	57:   libc.Float32FromFloat32(0.98257734),
	58:   libc.Float32FromFloat32(0.98196387),
	59:   libc.Float32FromFloat32(0.98133989),
	60:   libc.Float32FromFloat32(0.98070539),
	61:   libc.Float32FromFloat32(0.9800604),
	62:   libc.Float32FromFloat32(0.97940491),
	63:   libc.Float32FromFloat32(0.97873893),
	64:   libc.Float32FromFloat32(0.97806247),
	65:   libc.Float32FromFloat32(0.97737554),
	66:   libc.Float32FromFloat32(0.97667813),
	67:   libc.Float32FromFloat32(0.97597027),
	68:   libc.Float32FromFloat32(0.97525196),
	69:   libc.Float32FromFloat32(0.9745232),
	70:   libc.Float32FromFloat32(0.97378401),
	71:   libc.Float32FromFloat32(0.97303439),
	72:   libc.Float32FromFloat32(0.97227435),
	73:   libc.Float32FromFloat32(0.97150389),
	74:   libc.Float32FromFloat32(0.97072303),
	75:   libc.Float32FromFloat32(0.96993178),
	76:   libc.Float32FromFloat32(0.96913014),
	77:   libc.Float32FromFloat32(0.96831812),
	78:   libc.Float32FromFloat32(0.96749573),
	79:   libc.Float32FromFloat32(0.96666298),
	80:   libc.Float32FromFloat32(0.96581987),
	81:   libc.Float32FromFloat32(0.96496643),
	82:   libc.Float32FromFloat32(0.96410265),
	83:   libc.Float32FromFloat32(0.96322854),
	84:   libc.Float32FromFloat32(0.96234412),
	85:   libc.Float32FromFloat32(0.96144939),
	86:   libc.Float32FromFloat32(0.96054437),
	87:   libc.Float32FromFloat32(0.95962906),
	88:   libc.Float32FromFloat32(0.95870347),
	89:   libc.Float32FromFloat32(0.95776762),
	90:   libc.Float32FromFloat32(0.95682151),
	91:   libc.Float32FromFloat32(0.95586515),
	92:   libc.Float32FromFloat32(0.95489856),
	93:   libc.Float32FromFloat32(0.95392174),
	94:   libc.Float32FromFloat32(0.95293471),
	95:   libc.Float32FromFloat32(0.95193746),
	96:   libc.Float32FromFloat32(0.95093003),
	97:   libc.Float32FromFloat32(0.94991241),
	98:   libc.Float32FromFloat32(0.94888462),
	99:   libc.Float32FromFloat32(0.94784667),
	100:  libc.Float32FromFloat32(0.94679856),
	101:  libc.Float32FromFloat32(0.94574032),
	102:  libc.Float32FromFloat32(0.94467195),
	103:  libc.Float32FromFloat32(0.94359346),
	104:  libc.Float32FromFloat32(0.94250486),
	105:  libc.Float32FromFloat32(0.94140618),
	106:  libc.Float32FromFloat32(0.94029741),
	107:  libc.Float32FromFloat32(0.93917857),
	108:  libc.Float32FromFloat32(0.93804967),
	109:  libc.Float32FromFloat32(0.93691073),
	110:  libc.Float32FromFloat32(0.93576176),
	111:  libc.Float32FromFloat32(0.93460276),
	112:  libc.Float32FromFloat32(0.93343375),
	113:  libc.Float32FromFloat32(0.93225475),
	114:  libc.Float32FromFloat32(0.93106577),
	115:  libc.Float32FromFloat32(0.92986681),
	116:  libc.Float32FromFloat32(0.92865789),
	117:  libc.Float32FromFloat32(0.92743903),
	118:  libc.Float32FromFloat32(0.92621024),
	119:  libc.Float32FromFloat32(0.92497153),
	120:  libc.Float32FromFloat32(0.92372291),
	121:  libc.Float32FromFloat32(0.9224644),
	122:  libc.Float32FromFloat32(0.92119602),
	123:  libc.Float32FromFloat32(0.91991776),
	124:  libc.Float32FromFloat32(0.91862966),
	125:  libc.Float32FromFloat32(0.91733172),
	126:  libc.Float32FromFloat32(0.91602395),
	127:  libc.Float32FromFloat32(0.91470637),
	128:  libc.Float32FromFloat32(0.913379),
	129:  libc.Float32FromFloat32(0.91204185),
	130:  libc.Float32FromFloat32(0.91069493),
	131:  libc.Float32FromFloat32(0.90933825),
	132:  libc.Float32FromFloat32(0.90797184),
	133:  libc.Float32FromFloat32(0.9065957),
	134:  libc.Float32FromFloat32(0.90520986),
	135:  libc.Float32FromFloat32(0.90381432),
	136:  libc.Float32FromFloat32(0.9024091),
	137:  libc.Float32FromFloat32(0.90099422),
	138:  libc.Float32FromFloat32(0.89956969),
	139:  libc.Float32FromFloat32(0.89813553),
	140:  libc.Float32FromFloat32(0.89669174),
	141:  libc.Float32FromFloat32(0.89523836),
	142:  libc.Float32FromFloat32(0.89377538),
	143:  libc.Float32FromFloat32(0.89230284),
	144:  libc.Float32FromFloat32(0.89082074),
	145:  libc.Float32FromFloat32(0.8893291),
	146:  libc.Float32FromFloat32(0.88782793),
	147:  libc.Float32FromFloat32(0.88631726),
	148:  libc.Float32FromFloat32(0.8847971),
	149:  libc.Float32FromFloat32(0.88326746),
	150:  libc.Float32FromFloat32(0.88172836),
	151:  libc.Float32FromFloat32(0.88017982),
	152:  libc.Float32FromFloat32(0.87862185),
	153:  libc.Float32FromFloat32(0.87705448),
	154:  libc.Float32FromFloat32(0.87547771),
	155:  libc.Float32FromFloat32(0.87389156),
	156:  libc.Float32FromFloat32(0.87229606),
	157:  libc.Float32FromFloat32(0.87069121),
	158:  libc.Float32FromFloat32(0.86907704),
	159:  libc.Float32FromFloat32(0.86745357),
	160:  libc.Float32FromFloat32(0.8658208),
	161:  libc.Float32FromFloat32(0.86417876),
	162:  libc.Float32FromFloat32(0.86252747),
	163:  libc.Float32FromFloat32(0.86086694),
	164:  libc.Float32FromFloat32(0.85919719),
	165:  libc.Float32FromFloat32(0.85751824),
	166:  libc.Float32FromFloat32(0.8558301),
	167:  libc.Float32FromFloat32(0.85413281),
	168:  libc.Float32FromFloat32(0.85242636),
	169:  libc.Float32FromFloat32(0.85071078),
	170:  libc.Float32FromFloat32(0.8489861),
	171:  libc.Float32FromFloat32(0.84725232),
	172:  libc.Float32FromFloat32(0.84550947),
	173:  libc.Float32FromFloat32(0.84375756),
	174:  libc.Float32FromFloat32(0.84199662),
	175:  libc.Float32FromFloat32(0.84022666),
	176:  libc.Float32FromFloat32(0.83844771),
	177:  libc.Float32FromFloat32(0.83665977),
	178:  libc.Float32FromFloat32(0.83486287),
	179:  libc.Float32FromFloat32(0.83305704),
	180:  libc.Float32FromFloat32(0.83124228),
	181:  libc.Float32FromFloat32(0.82941862),
	182:  libc.Float32FromFloat32(0.82758608),
	183:  libc.Float32FromFloat32(0.82574467),
	184:  libc.Float32FromFloat32(0.82389442),
	185:  libc.Float32FromFloat32(0.82203535),
	186:  libc.Float32FromFloat32(0.82016748),
	187:  libc.Float32FromFloat32(0.81829082),
	188:  libc.Float32FromFloat32(0.8164054),
	189:  libc.Float32FromFloat32(0.81451123),
	190:  libc.Float32FromFloat32(0.81260835),
	191:  libc.Float32FromFloat32(0.81069676),
	192:  libc.Float32FromFloat32(0.80877649),
	193:  libc.Float32FromFloat32(0.80684755),
	194:  libc.Float32FromFloat32(0.80490998),
	195:  libc.Float32FromFloat32(0.80296379),
	196:  libc.Float32FromFloat32(0.80100899),
	197:  libc.Float32FromFloat32(0.79904562),
	198:  libc.Float32FromFloat32(0.7970737),
	199:  libc.Float32FromFloat32(0.79509323),
	200:  libc.Float32FromFloat32(0.79310425),
	201:  libc.Float32FromFloat32(0.79110678),
	202:  libc.Float32FromFloat32(0.78910084),
	203:  libc.Float32FromFloat32(0.78708644),
	204:  libc.Float32FromFloat32(0.78506362),
	205:  libc.Float32FromFloat32(0.78303239),
	206:  libc.Float32FromFloat32(0.78099277),
	207:  libc.Float32FromFloat32(0.77894479),
	208:  libc.Float32FromFloat32(0.77688847),
	209:  libc.Float32FromFloat32(0.77482382),
	210:  libc.Float32FromFloat32(0.77275088),
	211:  libc.Float32FromFloat32(0.77066967),
	212:  libc.Float32FromFloat32(0.7685802),
	213:  libc.Float32FromFloat32(0.7664825),
	214:  libc.Float32FromFloat32(0.76437659),
	215:  libc.Float32FromFloat32(0.7622625),
	216:  libc.Float32FromFloat32(0.76014024),
	217:  libc.Float32FromFloat32(0.75800984),
	218:  libc.Float32FromFloat32(0.75587132),
	219:  libc.Float32FromFloat32(0.75372471),
	220:  libc.Float32FromFloat32(0.75157003),
	221:  libc.Float32FromFloat32(0.7494073),
	222:  libc.Float32FromFloat32(0.74723654),
	223:  libc.Float32FromFloat32(0.74505779),
	224:  libc.Float32FromFloat32(0.74287105),
	225:  libc.Float32FromFloat32(0.74067635),
	226:  libc.Float32FromFloat32(0.73847373),
	227:  libc.Float32FromFloat32(0.7362632),
	228:  libc.Float32FromFloat32(0.73404478),
	229:  libc.Float32FromFloat32(0.7318185),
	230:  libc.Float32FromFloat32(0.72958438),
	231:  libc.Float32FromFloat32(0.72734245),
	232:  libc.Float32FromFloat32(0.72509273),
	233:  libc.Float32FromFloat32(0.72283525),
	234:  libc.Float32FromFloat32(0.72057002),
	235:  libc.Float32FromFloat32(0.71829708),
	236:  libc.Float32FromFloat32(0.71601644),
	237:  libc.Float32FromFloat32(0.71372814),
	238:  libc.Float32FromFloat32(0.7114322),
	239:  libc.Float32FromFloat32(0.70912863),
	240:  libc.Float32FromFloat32(0.70681747),
	241:  libc.Float32FromFloat32(0.70449874),
	242:  libc.Float32FromFloat32(0.70217247),
	243:  libc.Float32FromFloat32(0.69983868),
	244:  libc.Float32FromFloat32(0.69749739),
	245:  libc.Float32FromFloat32(0.69514863),
	246:  libc.Float32FromFloat32(0.69279243),
	247:  libc.Float32FromFloat32(0.69042881),
	248:  libc.Float32FromFloat32(0.6880578),
	249:  libc.Float32FromFloat32(0.68567941),
	250:  libc.Float32FromFloat32(0.68329369),
	251:  libc.Float32FromFloat32(0.68090064),
	252:  libc.Float32FromFloat32(0.67850031),
	253:  libc.Float32FromFloat32(0.6760927),
	254:  libc.Float32FromFloat32(0.67367786),
	255:  libc.Float32FromFloat32(0.6712558),
	256:  libc.Float32FromFloat32(0.66882656),
	257:  libc.Float32FromFloat32(0.66639015),
	258:  libc.Float32FromFloat32(0.66394661),
	259:  libc.Float32FromFloat32(0.66149595),
	260:  libc.Float32FromFloat32(0.65903821),
	261:  libc.Float32FromFloat32(0.65657341),
	262:  libc.Float32FromFloat32(0.65410159),
	263:  libc.Float32FromFloat32(0.65162275),
	264:  libc.Float32FromFloat32(0.64913694),
	265:  libc.Float32FromFloat32(0.64664418),
	266:  libc.Float32FromFloat32(0.64414449),
	267:  libc.Float32FromFloat32(0.6416379),
	268:  libc.Float32FromFloat32(0.63912444),
	269:  libc.Float32FromFloat32(0.63660414),
	270:  libc.Float32FromFloat32(0.63407702),
	271:  libc.Float32FromFloat32(0.63154311),
	272:  libc.Float32FromFloat32(0.62900244),
	273:  libc.Float32FromFloat32(0.62645503),
	274:  libc.Float32FromFloat32(0.62390091),
	275:  libc.Float32FromFloat32(0.62134011),
	276:  libc.Float32FromFloat32(0.61877265),
	277:  libc.Float32FromFloat32(0.61619857),
	278:  libc.Float32FromFloat32(0.61361789),
	279:  libc.Float32FromFloat32(0.61103064),
	280:  libc.Float32FromFloat32(0.60843685),
	281:  libc.Float32FromFloat32(0.60583654),
	282:  libc.Float32FromFloat32(0.60322974),
	283:  libc.Float32FromFloat32(0.60061648),
	284:  libc.Float32FromFloat32(0.59799679),
	285:  libc.Float32FromFloat32(0.59537069),
	286:  libc.Float32FromFloat32(0.59273822),
	287:  libc.Float32FromFloat32(0.5900994),
	288:  libc.Float32FromFloat32(0.58745427),
	289:  libc.Float32FromFloat32(0.58480284),
	290:  libc.Float32FromFloat32(0.58214514),
	291:  libc.Float32FromFloat32(0.57948122),
	292:  libc.Float32FromFloat32(0.57681109),
	293:  libc.Float32FromFloat32(0.57413478),
	294:  libc.Float32FromFloat32(0.57145232),
	295:  libc.Float32FromFloat32(0.56876374),
	296:  libc.Float32FromFloat32(0.56606907),
	297:  libc.Float32FromFloat32(0.56336834),
	298:  libc.Float32FromFloat32(0.56066158),
	299:  libc.Float32FromFloat32(0.55794881),
	300:  libc.Float32FromFloat32(0.55523006),
	301:  libc.Float32FromFloat32(0.55250537),
	302:  libc.Float32FromFloat32(0.54977477),
	303:  libc.Float32FromFloat32(0.54703827),
	304:  libc.Float32FromFloat32(0.54429592),
	305:  libc.Float32FromFloat32(0.54154774),
	306:  libc.Float32FromFloat32(0.53879376),
	307:  libc.Float32FromFloat32(0.53603401),
	308:  libc.Float32FromFloat32(0.53326852),
	309:  libc.Float32FromFloat32(0.53049731),
	310:  libc.Float32FromFloat32(0.52772043),
	311:  libc.Float32FromFloat32(0.5249379),
	312:  libc.Float32FromFloat32(0.52214974),
	313:  libc.Float32FromFloat32(0.51935599),
	314:  libc.Float32FromFloat32(0.51655668),
	315:  libc.Float32FromFloat32(0.51375184),
	316:  libc.Float32FromFloat32(0.51094149),
	317:  libc.Float32FromFloat32(0.50812568),
	318:  libc.Float32FromFloat32(0.50530442),
	319:  libc.Float32FromFloat32(0.50247775),
	320:  libc.Float32FromFloat32(0.4996457),
	321:  libc.Float32FromFloat32(0.4968083),
	322:  libc.Float32FromFloat32(0.49396558),
	323:  libc.Float32FromFloat32(0.49111757),
	324:  libc.Float32FromFloat32(0.4882643),
	325:  libc.Float32FromFloat32(0.4854058),
	326:  libc.Float32FromFloat32(0.4825421),
	327:  libc.Float32FromFloat32(0.47967323),
	328:  libc.Float32FromFloat32(0.47679923),
	329:  libc.Float32FromFloat32(0.47392012),
	330:  libc.Float32FromFloat32(0.47103594),
	331:  libc.Float32FromFloat32(0.46814671),
	332:  libc.Float32FromFloat32(0.46525247),
	333:  libc.Float32FromFloat32(0.46235324),
	334:  libc.Float32FromFloat32(0.45944907),
	335:  libc.Float32FromFloat32(0.45653997),
	336:  libc.Float32FromFloat32(0.45362599),
	337:  libc.Float32FromFloat32(0.45070714),
	338:  libc.Float32FromFloat32(0.44778347),
	339:  libc.Float32FromFloat32(0.44485501),
	340:  libc.Float32FromFloat32(0.44192178),
	341:  libc.Float32FromFloat32(0.43898381),
	342:  libc.Float32FromFloat32(0.43604115),
	343:  libc.Float32FromFloat32(0.43309382),
	344:  libc.Float32FromFloat32(0.43014185),
	345:  libc.Float32FromFloat32(0.42718527),
	346:  libc.Float32FromFloat32(0.42422412),
	347:  libc.Float32FromFloat32(0.42125842),
	348:  libc.Float32FromFloat32(0.41828822),
	349:  libc.Float32FromFloat32(0.41531353),
	350:  libc.Float32FromFloat32(0.4123344),
	351:  libc.Float32FromFloat32(0.40935085),
	352:  libc.Float32FromFloat32(0.40636291),
	353:  libc.Float32FromFloat32(0.40337063),
	354:  libc.Float32FromFloat32(0.40037402),
	355:  libc.Float32FromFloat32(0.39737313),
	356:  libc.Float32FromFloat32(0.39436798),
	357:  libc.Float32FromFloat32(0.39135861),
	358:  libc.Float32FromFloat32(0.38834505),
	359:  libc.Float32FromFloat32(0.38532733),
	360:  libc.Float32FromFloat32(0.38230548),
	361:  libc.Float32FromFloat32(0.37927953),
	362:  libc.Float32FromFloat32(0.37624953),
	363:  libc.Float32FromFloat32(0.3732155),
	364:  libc.Float32FromFloat32(0.37017747),
	365:  libc.Float32FromFloat32(0.36713547),
	366:  libc.Float32FromFloat32(0.36408955),
	367:  libc.Float32FromFloat32(0.36103972),
	368:  libc.Float32FromFloat32(0.35798603),
	369:  libc.Float32FromFloat32(0.3549285),
	370:  libc.Float32FromFloat32(0.35186718),
	371:  libc.Float32FromFloat32(0.34880208),
	372:  libc.Float32FromFloat32(0.34573325),
	373:  libc.Float32FromFloat32(0.34266072),
	374:  libc.Float32FromFloat32(0.33958451),
	375:  libc.Float32FromFloat32(0.33650468),
	376:  libc.Float32FromFloat32(0.33342123),
	377:  libc.Float32FromFloat32(0.33033422),
	378:  libc.Float32FromFloat32(0.32724367),
	379:  libc.Float32FromFloat32(0.32414961),
	380:  libc.Float32FromFloat32(0.32105209),
	381:  libc.Float32FromFloat32(0.31795112),
	382:  libc.Float32FromFloat32(0.31484675),
	383:  libc.Float32FromFloat32(0.31173901),
	384:  libc.Float32FromFloat32(0.30862793),
	385:  libc.Float32FromFloat32(0.30551354),
	386:  libc.Float32FromFloat32(0.30239588),
	387:  libc.Float32FromFloat32(0.29927499),
	388:  libc.Float32FromFloat32(0.29615089),
	389:  libc.Float32FromFloat32(0.29302362),
	390:  libc.Float32FromFloat32(0.28989321),
	391:  libc.Float32FromFloat32(0.28675969),
	392:  libc.Float32FromFloat32(0.2836231),
	393:  libc.Float32FromFloat32(0.28048348),
	394:  libc.Float32FromFloat32(0.27734085),
	395:  libc.Float32FromFloat32(0.27419526),
	396:  libc.Float32FromFloat32(0.27104672),
	397:  libc.Float32FromFloat32(0.26789529),
	398:  libc.Float32FromFloat32(0.26474098),
	399:  libc.Float32FromFloat32(0.26158384),
	400:  libc.Float32FromFloat32(0.2584239),
	401:  libc.Float32FromFloat32(0.25526119),
	402:  libc.Float32FromFloat32(0.25209575),
	403:  libc.Float32FromFloat32(0.24892761),
	404:  libc.Float32FromFloat32(0.2457568),
	405:  libc.Float32FromFloat32(0.24258336),
	406:  libc.Float32FromFloat32(0.23940732),
	407:  libc.Float32FromFloat32(0.23622872),
	408:  libc.Float32FromFloat32(0.23304759),
	409:  libc.Float32FromFloat32(0.22986396),
	410:  libc.Float32FromFloat32(0.22667787),
	411:  libc.Float32FromFloat32(0.22348935),
	412:  libc.Float32FromFloat32(0.22029844),
	413:  libc.Float32FromFloat32(0.21710517),
	414:  libc.Float32FromFloat32(0.21390958),
	415:  libc.Float32FromFloat32(0.21071169),
	416:  libc.Float32FromFloat32(0.20751155),
	417:  libc.Float32FromFloat32(0.20430919),
	418:  libc.Float32FromFloat32(0.20110463),
	419:  libc.Float32FromFloat32(0.19789793),
	420:  libc.Float32FromFloat32(0.1946891),
	421:  libc.Float32FromFloat32(0.19147819),
	422:  libc.Float32FromFloat32(0.18826523),
	423:  libc.Float32FromFloat32(0.18505026),
	424:  libc.Float32FromFloat32(0.1818333),
	425:  libc.Float32FromFloat32(0.17861439),
	426:  libc.Float32FromFloat32(0.17539357),
	427:  libc.Float32FromFloat32(0.17217088),
	428:  libc.Float32FromFloat32(0.16894634),
	429:  libc.Float32FromFloat32(0.16571999),
	430:  libc.Float32FromFloat32(0.16249186),
	431:  libc.Float32FromFloat32(0.159262),
	432:  libc.Float32FromFloat32(0.15603043),
	433:  libc.Float32FromFloat32(0.15279719),
	434:  libc.Float32FromFloat32(0.14956231),
	435:  libc.Float32FromFloat32(0.14632583),
	436:  libc.Float32FromFloat32(0.14308778),
	437:  libc.Float32FromFloat32(0.1398482),
	438:  libc.Float32FromFloat32(0.13660713),
	439:  libc.Float32FromFloat32(0.13336459),
	440:  libc.Float32FromFloat32(0.13012062),
	441:  libc.Float32FromFloat32(0.12687526),
	442:  libc.Float32FromFloat32(0.12362854),
	443:  libc.Float32FromFloat32(0.12038049),
	444:  libc.Float32FromFloat32(0.11713116),
	445:  libc.Float32FromFloat32(0.11388057),
	446:  libc.Float32FromFloat32(0.11062877),
	447:  libc.Float32FromFloat32(0.10737578),
	448:  libc.Float32FromFloat32(0.10412163),
	449:  libc.Float32FromFloat32(0.10086638),
	450:  libc.Float32FromFloat32(0.09761004),
	451:  libc.Float32FromFloat32(0.094352658),
	452:  libc.Float32FromFloat32(0.091094266),
	453:  libc.Float32FromFloat32(0.087834897),
	454:  libc.Float32FromFloat32(0.084574589),
	455:  libc.Float32FromFloat32(0.081313374),
	456:  libc.Float32FromFloat32(0.078051289),
	457:  libc.Float32FromFloat32(0.074788367),
	458:  libc.Float32FromFloat32(0.071524645),
	459:  libc.Float32FromFloat32(0.068260157),
	460:  libc.Float32FromFloat32(0.064994938),
	461:  libc.Float32FromFloat32(0.061729023),
	462:  libc.Float32FromFloat32(0.058462447),
	463:  libc.Float32FromFloat32(0.055195244),
	464:  libc.Float32FromFloat32(0.051927451),
	465:  libc.Float32FromFloat32(0.048659101),
	466:  libc.Float32FromFloat32(0.045390231),
	467:  libc.Float32FromFloat32(0.042120874),
	468:  libc.Float32FromFloat32(0.038851066),
	469:  libc.Float32FromFloat32(0.035580842),
	470:  libc.Float32FromFloat32(0.032310238),
	471:  libc.Float32FromFloat32(0.029039287),
	472:  libc.Float32FromFloat32(0.025768025),
	473:  libc.Float32FromFloat32(0.022496487),
	474:  libc.Float32FromFloat32(0.019224708),
	475:  libc.Float32FromFloat32(0.015952723),
	476:  libc.Float32FromFloat32(0.012680568),
	477:  libc.Float32FromFloat32(0.0094082767),
	478:  libc.Float32FromFloat32(0.0061358846),
	479:  libc.Float32FromFloat32(0.0028634269),
	480:  -libc.Float32FromFloat32(0.00040906153),
	481:  -libc.Float32FromFloat32(0.0036815456),
	482:  -libc.Float32FromFloat32(0.0069539902),
	483:  -libc.Float32FromFloat32(0.01022636),
	484:  -libc.Float32FromFloat32(0.013498621),
	485:  -libc.Float32FromFloat32(0.016770737),
	486:  -libc.Float32FromFloat32(0.020042673),
	487:  -libc.Float32FromFloat32(0.023314395),
	488:  -libc.Float32FromFloat32(0.026585867),
	489:  -libc.Float32FromFloat32(0.029857055),
	490:  -libc.Float32FromFloat32(0.033127923),
	491:  -libc.Float32FromFloat32(0.036398436),
	492:  -libc.Float32FromFloat32(0.039668559),
	493:  -libc.Float32FromFloat32(0.042938257),
	494:  -libc.Float32FromFloat32(0.046207495),
	495:  -libc.Float32FromFloat32(0.049476239),
	496:  -libc.Float32FromFloat32(0.052744453),
	497:  -libc.Float32FromFloat32(0.056012102),
	498:  -libc.Float32FromFloat32(0.059279151),
	499:  -libc.Float32FromFloat32(0.062545565),
	500:  -libc.Float32FromFloat32(0.065811309),
	501:  -libc.Float32FromFloat32(0.069076349),
	502:  -libc.Float32FromFloat32(0.072340649),
	503:  -libc.Float32FromFloat32(0.075604174),
	504:  -libc.Float32FromFloat32(0.07886689),
	505:  -libc.Float32FromFloat32(0.082128761),
	506:  -libc.Float32FromFloat32(0.085389752),
	507:  -libc.Float32FromFloat32(0.088649829),
	508:  -libc.Float32FromFloat32(0.091908956),
	509:  -libc.Float32FromFloat32(0.0951671),
	510:  -libc.Float32FromFloat32(0.098424224),
	511:  -libc.Float32FromFloat32(0.10168029),
	512:  -libc.Float32FromFloat32(0.10493528),
	513:  -libc.Float32FromFloat32(0.10818913),
	514:  -libc.Float32FromFloat32(0.11144183),
	515:  -libc.Float32FromFloat32(0.11469334),
	516:  -libc.Float32FromFloat32(0.11794361),
	517:  -libc.Float32FromFloat32(0.12119263),
	518:  -libc.Float32FromFloat32(0.12444034),
	519:  -libc.Float32FromFloat32(0.12768673),
	520:  -libc.Float32FromFloat32(0.13093174),
	521:  -libc.Float32FromFloat32(0.13417536),
	522:  -libc.Float32FromFloat32(0.13741753),
	523:  -libc.Float32FromFloat32(0.14065824),
	524:  -libc.Float32FromFloat32(0.14389744),
	525:  -libc.Float32FromFloat32(0.1471351),
	526:  -libc.Float32FromFloat32(0.15037118),
	527:  -libc.Float32FromFloat32(0.15360565),
	528:  -libc.Float32FromFloat32(0.15683848),
	529:  -libc.Float32FromFloat32(0.16006962),
	530:  -libc.Float32FromFloat32(0.16329906),
	531:  -libc.Float32FromFloat32(0.16652674),
	532:  -libc.Float32FromFloat32(0.16975264),
	533:  -libc.Float32FromFloat32(0.17297673),
	534:  -libc.Float32FromFloat32(0.17619896),
	535:  -libc.Float32FromFloat32(0.1794193),
	536:  -libc.Float32FromFloat32(0.18263772),
	537:  -libc.Float32FromFloat32(0.18585419),
	538:  -libc.Float32FromFloat32(0.18906866),
	539:  -libc.Float32FromFloat32(0.19228112),
	540:  -libc.Float32FromFloat32(0.19549151),
	541:  -libc.Float32FromFloat32(0.19869981),
	542:  -libc.Float32FromFloat32(0.20190598),
	543:  -libc.Float32FromFloat32(0.20510998),
	544:  -libc.Float32FromFloat32(0.2083118),
	545:  -libc.Float32FromFloat32(0.21151138),
	546:  -libc.Float32FromFloat32(0.21470869),
	547:  -libc.Float32FromFloat32(0.21790371),
	548:  -libc.Float32FromFloat32(0.22109639),
	549:  -libc.Float32FromFloat32(0.22428671),
	550:  -libc.Float32FromFloat32(0.22747462),
	551:  -libc.Float32FromFloat32(0.2306601),
	552:  -libc.Float32FromFloat32(0.2338431),
	553:  -libc.Float32FromFloat32(0.23702361),
	554:  -libc.Float32FromFloat32(0.24020157),
	555:  -libc.Float32FromFloat32(0.24337696),
	556:  -libc.Float32FromFloat32(0.24654975),
	557:  -libc.Float32FromFloat32(0.24971989),
	558:  -libc.Float32FromFloat32(0.25288736),
	559:  -libc.Float32FromFloat32(0.25605213),
	560:  -libc.Float32FromFloat32(0.25921415),
	561:  -libc.Float32FromFloat32(0.26237339),
	562:  -libc.Float32FromFloat32(0.26552983),
	563:  -libc.Float32FromFloat32(0.26868342),
	564:  -libc.Float32FromFloat32(0.27183413),
	565:  -libc.Float32FromFloat32(0.27498193),
	566:  -libc.Float32FromFloat32(0.27812679),
	567:  -libc.Float32FromFloat32(0.28126867),
	568:  -libc.Float32FromFloat32(0.28440754),
	569:  -libc.Float32FromFloat32(0.28754336),
	570:  -libc.Float32FromFloat32(0.2906761),
	571:  -libc.Float32FromFloat32(0.29380573),
	572:  -libc.Float32FromFloat32(0.29693221),
	573:  -libc.Float32FromFloat32(0.30005551),
	574:  -libc.Float32FromFloat32(0.3031756),
	575:  -libc.Float32FromFloat32(0.30629245),
	576:  -libc.Float32FromFloat32(0.30940601),
	577:  -libc.Float32FromFloat32(0.31251626),
	578:  -libc.Float32FromFloat32(0.31562316),
	579:  -libc.Float32FromFloat32(0.31872668),
	580:  -libc.Float32FromFloat32(0.32182679),
	581:  -libc.Float32FromFloat32(0.32492345),
	582:  -libc.Float32FromFloat32(0.32801664),
	583:  -libc.Float32FromFloat32(0.33110631),
	584:  -libc.Float32FromFloat32(0.33419243),
	585:  -libc.Float32FromFloat32(0.33727497),
	586:  -libc.Float32FromFloat32(0.34035391),
	587:  -libc.Float32FromFloat32(0.3434292),
	588:  -libc.Float32FromFloat32(0.34650081),
	589:  -libc.Float32FromFloat32(0.34956871),
	590:  -libc.Float32FromFloat32(0.35263286),
	591:  -libc.Float32FromFloat32(0.35569324),
	592:  -libc.Float32FromFloat32(0.35874981),
	593:  -libc.Float32FromFloat32(0.36180254),
	594:  -libc.Float32FromFloat32(0.36485139),
	595:  -libc.Float32FromFloat32(0.36789634),
	596:  -libc.Float32FromFloat32(0.37093735),
	597:  -libc.Float32FromFloat32(0.37397438),
	598:  -libc.Float32FromFloat32(0.37700741),
	599:  -libc.Float32FromFloat32(0.3800364),
	600:  -libc.Float32FromFloat32(0.38306132),
	601:  -libc.Float32FromFloat32(0.38608214),
	602:  -libc.Float32FromFloat32(0.38909883),
	603:  -libc.Float32FromFloat32(0.39211135),
	604:  -libc.Float32FromFloat32(0.39511967),
	605:  -libc.Float32FromFloat32(0.39812375),
	606:  -libc.Float32FromFloat32(0.40112358),
	607:  -libc.Float32FromFloat32(0.4041191),
	608:  -libc.Float32FromFloat32(0.40711031),
	609:  -libc.Float32FromFloat32(0.41009715),
	610:  -libc.Float32FromFloat32(0.41307959),
	611:  -libc.Float32FromFloat32(0.41605762),
	612:  -libc.Float32FromFloat32(0.41903119),
	613:  -libc.Float32FromFloat32(0.42200027),
	614:  -libc.Float32FromFloat32(0.42496483),
	615:  -libc.Float32FromFloat32(0.42792484),
	616:  -libc.Float32FromFloat32(0.43088027),
	617:  -libc.Float32FromFloat32(0.43383109),
	618:  -libc.Float32FromFloat32(0.43677726),
	619:  -libc.Float32FromFloat32(0.43971875),
	620:  -libc.Float32FromFloat32(0.44265553),
	621:  -libc.Float32FromFloat32(0.44558757),
	622:  -libc.Float32FromFloat32(0.44851484),
	623:  -libc.Float32FromFloat32(0.45143731),
	624:  -libc.Float32FromFloat32(0.45435494),
	625:  -libc.Float32FromFloat32(0.4572677),
	626:  -libc.Float32FromFloat32(0.46017557),
	627:  -libc.Float32FromFloat32(0.46307851),
	628:  -libc.Float32FromFloat32(0.4659765),
	629:  -libc.Float32FromFloat32(0.46886949),
	630:  -libc.Float32FromFloat32(0.47175746),
	631:  -libc.Float32FromFloat32(0.47464038),
	632:  -libc.Float32FromFloat32(0.47751821),
	633:  -libc.Float32FromFloat32(0.48039093),
	634:  -libc.Float32FromFloat32(0.48325851),
	635:  -libc.Float32FromFloat32(0.48612091),
	636:  -libc.Float32FromFloat32(0.48897811),
	637:  -libc.Float32FromFloat32(0.49183006),
	638:  -libc.Float32FromFloat32(0.49467676),
	639:  -libc.Float32FromFloat32(0.49751815),
	640:  -libc.Float32FromFloat32(0.50035422),
	641:  -libc.Float32FromFloat32(0.50318492),
	642:  -libc.Float32FromFloat32(0.50601024),
	643:  -libc.Float32FromFloat32(0.50883014),
	644:  -libc.Float32FromFloat32(0.51164459),
	645:  -libc.Float32FromFloat32(0.51445356),
	646:  -libc.Float32FromFloat32(0.51725703),
	647:  -libc.Float32FromFloat32(0.52005495),
	648:  -libc.Float32FromFloat32(0.5228473),
	649:  -libc.Float32FromFloat32(0.52563406),
	650:  -libc.Float32FromFloat32(0.52841518),
	651:  -libc.Float32FromFloat32(0.53119065),
	652:  -libc.Float32FromFloat32(0.53396043),
	653:  -libc.Float32FromFloat32(0.53672449),
	654:  -libc.Float32FromFloat32(0.5394828),
	655:  -libc.Float32FromFloat32(0.54223533),
	656:  -libc.Float32FromFloat32(0.54498206),
	657:  -libc.Float32FromFloat32(0.54772295),
	658:  -libc.Float32FromFloat32(0.55045797),
	659:  -libc.Float32FromFloat32(0.5531871),
	660:  -libc.Float32FromFloat32(0.55591031),
	661:  -libc.Float32FromFloat32(0.55862756),
	662:  -libc.Float32FromFloat32(0.56133883),
	663:  -libc.Float32FromFloat32(0.56404409),
	664:  -libc.Float32FromFloat32(0.56674331),
	665:  -libc.Float32FromFloat32(0.56943646),
	666:  -libc.Float32FromFloat32(0.57212351),
	667:  -libc.Float32FromFloat32(0.57480443),
	668:  -libc.Float32FromFloat32(0.5774792),
	669:  -libc.Float32FromFloat32(0.58014778),
	670:  -libc.Float32FromFloat32(0.58281015),
	671:  -libc.Float32FromFloat32(0.58546628),
	672:  -libc.Float32FromFloat32(0.58811614),
	673:  -libc.Float32FromFloat32(0.5907597),
	674:  -libc.Float32FromFloat32(0.59339694),
	675:  -libc.Float32FromFloat32(0.59602782),
	676:  -libc.Float32FromFloat32(0.59865231),
	677:  -libc.Float32FromFloat32(0.6012704),
	678:  -libc.Float32FromFloat32(0.60388204),
	679:  -libc.Float32FromFloat32(0.60648722),
	680:  -libc.Float32FromFloat32(0.60908591),
	681:  -libc.Float32FromFloat32(0.61167807),
	682:  -libc.Float32FromFloat32(0.61426368),
	683:  -libc.Float32FromFloat32(0.61684271),
	684:  -libc.Float32FromFloat32(0.61941514),
	685:  -libc.Float32FromFloat32(0.62198093),
	686:  -libc.Float32FromFloat32(0.62454007),
	687:  -libc.Float32FromFloat32(0.62709251),
	688:  -libc.Float32FromFloat32(0.62963824),
	689:  -libc.Float32FromFloat32(0.63217722),
	690:  -libc.Float32FromFloat32(0.63470944),
	691:  -libc.Float32FromFloat32(0.63723486),
	692:  -libc.Float32FromFloat32(0.63975345),
	693:  -libc.Float32FromFloat32(0.64226519),
	694:  -libc.Float32FromFloat32(0.64477006),
	695:  -libc.Float32FromFloat32(0.64726802),
	696:  -libc.Float32FromFloat32(0.64975905),
	697:  -libc.Float32FromFloat32(0.65224312),
	698:  -libc.Float32FromFloat32(0.6547202),
	699:  -libc.Float32FromFloat32(0.65719027),
	700:  -libc.Float32FromFloat32(0.65965331),
	701:  -libc.Float32FromFloat32(0.66210928),
	702:  -libc.Float32FromFloat32(0.66455816),
	703:  -libc.Float32FromFloat32(0.66699992),
	704:  -libc.Float32FromFloat32(0.66943454),
	705:  -libc.Float32FromFloat32(0.67186199),
	706:  -libc.Float32FromFloat32(0.67428225),
	707:  -libc.Float32FromFloat32(0.67669528),
	708:  -libc.Float32FromFloat32(0.67910107),
	709:  -libc.Float32FromFloat32(0.68149959),
	710:  -libc.Float32FromFloat32(0.6838908),
	711:  -libc.Float32FromFloat32(0.6862747),
	712:  -libc.Float32FromFloat32(0.68865124),
	713:  -libc.Float32FromFloat32(0.69102041),
	714:  -libc.Float32FromFloat32(0.69338218),
	715:  -libc.Float32FromFloat32(0.69573652),
	716:  -libc.Float32FromFloat32(0.69808341),
	717:  -libc.Float32FromFloat32(0.70042283),
	718:  -libc.Float32FromFloat32(0.70275474),
	719:  -libc.Float32FromFloat32(0.70507913),
	720:  -libc.Float32FromFloat32(0.70739597),
	721:  -libc.Float32FromFloat32(0.70970524),
	722:  -libc.Float32FromFloat32(0.7120069),
	723:  -libc.Float32FromFloat32(0.71430093),
	724:  -libc.Float32FromFloat32(0.71658732),
	725:  -libc.Float32FromFloat32(0.71886604),
	726:  -libc.Float32FromFloat32(0.72113705),
	727:  -libc.Float32FromFloat32(0.72340034),
	728:  -libc.Float32FromFloat32(0.72565589),
	729:  -libc.Float32FromFloat32(0.72790366),
	730:  -libc.Float32FromFloat32(0.73014364),
	731:  -libc.Float32FromFloat32(0.7323758),
	732:  -libc.Float32FromFloat32(0.73460012),
	733:  -libc.Float32FromFloat32(0.73681657),
	734:  -libc.Float32FromFloat32(0.73902513),
	735:  -libc.Float32FromFloat32(0.74122577),
	736:  -libc.Float32FromFloat32(0.74341848),
	737:  -libc.Float32FromFloat32(0.74560322),
	738:  -libc.Float32FromFloat32(0.74777998),
	739:  -libc.Float32FromFloat32(0.74994874),
	740:  -libc.Float32FromFloat32(0.75210946),
	741:  -libc.Float32FromFloat32(0.75426212),
	742:  -libc.Float32FromFloat32(0.75640671),
	743:  -libc.Float32FromFloat32(0.7585432),
	744:  -libc.Float32FromFloat32(0.76067157),
	745:  -libc.Float32FromFloat32(0.76279178),
	746:  -libc.Float32FromFloat32(0.76490383),
	747:  -libc.Float32FromFloat32(0.76700769),
	748:  -libc.Float32FromFloat32(0.76910334),
	749:  -libc.Float32FromFloat32(0.77119075),
	750:  -libc.Float32FromFloat32(0.77326989),
	751:  -libc.Float32FromFloat32(0.77534076),
	752:  -libc.Float32FromFloat32(0.77740333),
	753:  -libc.Float32FromFloat32(0.77945757),
	754:  -libc.Float32FromFloat32(0.78150346),
	755:  -libc.Float32FromFloat32(0.78354098),
	756:  -libc.Float32FromFloat32(0.78557011),
	757:  -libc.Float32FromFloat32(0.78759083),
	758:  -libc.Float32FromFloat32(0.78960312),
	759:  -libc.Float32FromFloat32(0.79160694),
	760:  -libc.Float32FromFloat32(0.79360229),
	761:  -libc.Float32FromFloat32(0.79558915),
	762:  -libc.Float32FromFloat32(0.79756748),
	763:  -libc.Float32FromFloat32(0.79953727),
	764:  -libc.Float32FromFloat32(0.8014985),
	765:  -libc.Float32FromFloat32(0.80345114),
	766:  -libc.Float32FromFloat32(0.80539518),
	767:  -libc.Float32FromFloat32(0.8073306),
	768:  -libc.Float32FromFloat32(0.80925737),
	769:  -libc.Float32FromFloat32(0.81117547),
	770:  -libc.Float32FromFloat32(0.81308489),
	771:  -libc.Float32FromFloat32(0.81498559),
	772:  -libc.Float32FromFloat32(0.81687757),
	773:  -libc.Float32FromFloat32(0.81876081),
	774:  -libc.Float32FromFloat32(0.82063527),
	775:  -libc.Float32FromFloat32(0.82250095),
	776:  -libc.Float32FromFloat32(0.82435781),
	777:  -libc.Float32FromFloat32(0.82620585),
	778:  -libc.Float32FromFloat32(0.82804505),
	779:  -libc.Float32FromFloat32(0.82987537),
	780:  -libc.Float32FromFloat32(0.83169681),
	781:  -libc.Float32FromFloat32(0.83350933),
	782:  -libc.Float32FromFloat32(0.83531294),
	783:  -libc.Float32FromFloat32(0.8371076),
	784:  -libc.Float32FromFloat32(0.83889329),
	785:  -libc.Float32FromFloat32(0.84067),
	786:  -libc.Float32FromFloat32(0.8424377),
	787:  -libc.Float32FromFloat32(0.84419639),
	788:  -libc.Float32FromFloat32(0.84594603),
	789:  -libc.Float32FromFloat32(0.84768662),
	790:  -libc.Float32FromFloat32(0.84941812),
	791:  -libc.Float32FromFloat32(0.85114053),
	792:  -libc.Float32FromFloat32(0.85285383),
	793:  -libc.Float32FromFloat32(0.85455799),
	794:  -libc.Float32FromFloat32(0.856253),
	795:  -libc.Float32FromFloat32(0.85793884),
	796:  -libc.Float32FromFloat32(0.85961549),
	797:  -libc.Float32FromFloat32(0.86128294),
	798:  -libc.Float32FromFloat32(0.86294116),
	799:  -libc.Float32FromFloat32(0.86459014),
	800:  -libc.Float32FromFloat32(0.86622986),
	801:  -libc.Float32FromFloat32(0.86786031),
	802:  -libc.Float32FromFloat32(0.86948146),
	803:  -libc.Float32FromFloat32(0.8710933),
	804:  -libc.Float32FromFloat32(0.87269581),
	805:  -libc.Float32FromFloat32(0.87428898),
	806:  -libc.Float32FromFloat32(0.87587278),
	807:  -libc.Float32FromFloat32(0.8774472),
	808:  -libc.Float32FromFloat32(0.87901223),
	809:  -libc.Float32FromFloat32(0.88056784),
	810:  -libc.Float32FromFloat32(0.88211402),
	811:  -libc.Float32FromFloat32(0.88365076),
	812:  -libc.Float32FromFloat32(0.88517803),
	813:  -libc.Float32FromFloat32(0.88669582),
	814:  -libc.Float32FromFloat32(0.88820412),
	815:  -libc.Float32FromFloat32(0.8897029),
	816:  -libc.Float32FromFloat32(0.89119216),
	817:  -libc.Float32FromFloat32(0.89267187),
	818:  -libc.Float32FromFloat32(0.89414203),
	819:  -libc.Float32FromFloat32(0.8956026),
	820:  -libc.Float32FromFloat32(0.89705359),
	821:  -libc.Float32FromFloat32(0.89849497),
	822:  -libc.Float32FromFloat32(0.89992673),
	823:  -libc.Float32FromFloat32(0.90134885),
	824:  -libc.Float32FromFloat32(0.90276131),
	825:  -libc.Float32FromFloat32(0.90416411),
	826:  -libc.Float32FromFloat32(0.90555723),
	827:  -libc.Float32FromFloat32(0.90694065),
	828:  -libc.Float32FromFloat32(0.90831436),
	829:  -libc.Float32FromFloat32(0.90967833),
	830:  -libc.Float32FromFloat32(0.91103257),
	831:  -libc.Float32FromFloat32(0.91237705),
	832:  -libc.Float32FromFloat32(0.91371176),
	833:  -libc.Float32FromFloat32(0.91503669),
	834:  -libc.Float32FromFloat32(0.91635181),
	835:  -libc.Float32FromFloat32(0.91765712),
	836:  -libc.Float32FromFloat32(0.91895261),
	837:  -libc.Float32FromFloat32(0.92023825),
	838:  -libc.Float32FromFloat32(0.92151404),
	839:  -libc.Float32FromFloat32(0.92277996),
	840:  -libc.Float32FromFloat32(0.924036),
	841:  -libc.Float32FromFloat32(0.92528214),
	842:  -libc.Float32FromFloat32(0.92651837),
	843:  -libc.Float32FromFloat32(0.92774468),
	844:  -libc.Float32FromFloat32(0.92896106),
	845:  -libc.Float32FromFloat32(0.93016748),
	846:  -libc.Float32FromFloat32(0.93136395),
	847:  -libc.Float32FromFloat32(0.93255044),
	848:  -libc.Float32FromFloat32(0.93372694),
	849:  -libc.Float32FromFloat32(0.93489345),
	850:  -libc.Float32FromFloat32(0.93604994),
	851:  -libc.Float32FromFloat32(0.93719641),
	852:  -libc.Float32FromFloat32(0.93833284),
	853:  -libc.Float32FromFloat32(0.93945922),
	854:  -libc.Float32FromFloat32(0.94057555),
	855:  -libc.Float32FromFloat32(0.9416818),
	856:  -libc.Float32FromFloat32(0.94277796),
	857:  -libc.Float32FromFloat32(0.94386403),
	858:  -libc.Float32FromFloat32(0.94493999),
	859:  -libc.Float32FromFloat32(0.94600583),
	860:  -libc.Float32FromFloat32(0.94706154),
	861:  -libc.Float32FromFloat32(0.94810711),
	862:  -libc.Float32FromFloat32(0.94914252),
	863:  -libc.Float32FromFloat32(0.95016777),
	864:  -libc.Float32FromFloat32(0.95118284),
	865:  -libc.Float32FromFloat32(0.95218773),
	866:  -libc.Float32FromFloat32(0.95318242),
	867:  -libc.Float32FromFloat32(0.9541669),
	868:  -libc.Float32FromFloat32(0.95514117),
	869:  -libc.Float32FromFloat32(0.9561052),
	870:  -libc.Float32FromFloat32(0.957059),
	871:  -libc.Float32FromFloat32(0.95800255),
	872:  -libc.Float32FromFloat32(0.95893583),
	873:  -libc.Float32FromFloat32(0.95985885),
	874:  -libc.Float32FromFloat32(0.96077159),
	875:  -libc.Float32FromFloat32(0.96167404),
	876:  -libc.Float32FromFloat32(0.96256619),
	877:  -libc.Float32FromFloat32(0.96344803),
	878:  -libc.Float32FromFloat32(0.96431956),
	879:  -libc.Float32FromFloat32(0.96518076),
	880:  -libc.Float32FromFloat32(0.96603162),
	881:  -libc.Float32FromFloat32(0.96687213),
	882:  -libc.Float32FromFloat32(0.9677023),
	883:  -libc.Float32FromFloat32(0.96852209),
	884:  -libc.Float32FromFloat32(0.96933152),
	885:  -libc.Float32FromFloat32(0.97013057),
	886:  -libc.Float32FromFloat32(0.97091922),
	887:  -libc.Float32FromFloat32(0.97169748),
	888:  -libc.Float32FromFloat32(0.97246533),
	889:  -libc.Float32FromFloat32(0.97322277),
	890:  -libc.Float32FromFloat32(0.97396979),
	891:  -libc.Float32FromFloat32(0.97470637),
	892:  -libc.Float32FromFloat32(0.97543252),
	893:  -libc.Float32FromFloat32(0.97614822),
	894:  -libc.Float32FromFloat32(0.97685347),
	895:  -libc.Float32FromFloat32(0.97754825),
	896:  -libc.Float32FromFloat32(0.97823257),
	897:  -libc.Float32FromFloat32(0.97890641),
	898:  -libc.Float32FromFloat32(0.97956977),
	899:  -libc.Float32FromFloat32(0.98022263),
	900:  -libc.Float32FromFloat32(0.980865),
	901:  -libc.Float32FromFloat32(0.98149687),
	902:  -libc.Float32FromFloat32(0.98211822),
	903:  -libc.Float32FromFloat32(0.98272906),
	904:  -libc.Float32FromFloat32(0.98332937),
	905:  -libc.Float32FromFloat32(0.98391915),
	906:  -libc.Float32FromFloat32(0.9844984),
	907:  -libc.Float32FromFloat32(0.9850671),
	908:  -libc.Float32FromFloat32(0.98562525),
	909:  -libc.Float32FromFloat32(0.98617285),
	910:  -libc.Float32FromFloat32(0.98670988),
	911:  -libc.Float32FromFloat32(0.98723635),
	912:  -libc.Float32FromFloat32(0.98775225),
	913:  -libc.Float32FromFloat32(0.98825757),
	914:  -libc.Float32FromFloat32(0.9887523),
	915:  -libc.Float32FromFloat32(0.98923645),
	916:  -libc.Float32FromFloat32(0.98971),
	917:  -libc.Float32FromFloat32(0.99017295),
	918:  -libc.Float32FromFloat32(0.9906253),
	919:  -libc.Float32FromFloat32(0.99106704),
	920:  -libc.Float32FromFloat32(0.99149817),
	921:  -libc.Float32FromFloat32(0.99191868),
	922:  -libc.Float32FromFloat32(0.99232857),
	923:  -libc.Float32FromFloat32(0.99272783),
	924:  -libc.Float32FromFloat32(0.99311645),
	925:  -libc.Float32FromFloat32(0.99349445),
	926:  -libc.Float32FromFloat32(0.9938618),
	927:  -libc.Float32FromFloat32(0.99421851),
	928:  -libc.Float32FromFloat32(0.99456457),
	929:  -libc.Float32FromFloat32(0.99489998),
	930:  -libc.Float32FromFloat32(0.99522474),
	931:  -libc.Float32FromFloat32(0.99553884),
	932:  -libc.Float32FromFloat32(0.99584227),
	933:  -libc.Float32FromFloat32(0.99613505),
	934:  -libc.Float32FromFloat32(0.99641715),
	935:  -libc.Float32FromFloat32(0.99668858),
	936:  -libc.Float32FromFloat32(0.99694934),
	937:  -libc.Float32FromFloat32(0.99719943),
	938:  -libc.Float32FromFloat32(0.99743883),
	939:  -libc.Float32FromFloat32(0.99766756),
	940:  -libc.Float32FromFloat32(0.99788559),
	941:  -libc.Float32FromFloat32(0.99809295),
	942:  -libc.Float32FromFloat32(0.99828961),
	943:  -libc.Float32FromFloat32(0.99847558),
	944:  -libc.Float32FromFloat32(0.99865086),
	945:  -libc.Float32FromFloat32(0.99881544),
	946:  -libc.Float32FromFloat32(0.99896933),
	947:  -libc.Float32FromFloat32(0.99911252),
	948:  -libc.Float32FromFloat32(0.99924501),
	949:  -libc.Float32FromFloat32(0.9993668),
	950:  -libc.Float32FromFloat32(0.99947789),
	951:  -libc.Float32FromFloat32(0.99957827),
	952:  -libc.Float32FromFloat32(0.99966795),
	953:  -libc.Float32FromFloat32(0.99974692),
	954:  -libc.Float32FromFloat32(0.99981519),
	955:  -libc.Float32FromFloat32(0.99987275),
	956:  -libc.Float32FromFloat32(0.9999196),
	957:  -libc.Float32FromFloat32(0.99995574),
	958:  -libc.Float32FromFloat32(0.99998118),
	959:  -libc.Float32FromFloat32(0.9999959),
	960:  libc.Float32FromFloat32(0.99999967),
	961:  libc.Float32FromFloat32(0.99997289),
	962:  libc.Float32FromFloat32(0.99990328),
	963:  libc.Float32FromFloat32(0.99979084),
	964:  libc.Float32FromFloat32(0.99963557),
	965:  libc.Float32FromFloat32(0.99943748),
	966:  libc.Float32FromFloat32(0.99919658),
	967:  libc.Float32FromFloat32(0.99891288),
	968:  libc.Float32FromFloat32(0.99858638),
	969:  libc.Float32FromFloat32(0.99821711),
	970:  libc.Float32FromFloat32(0.99780508),
	971:  libc.Float32FromFloat32(0.99735031),
	972:  libc.Float32FromFloat32(0.99685281),
	973:  libc.Float32FromFloat32(0.99631261),
	974:  libc.Float32FromFloat32(0.99572973),
	975:  libc.Float32FromFloat32(0.9951042),
	976:  libc.Float32FromFloat32(0.99443605),
	977:  libc.Float32FromFloat32(0.99372529),
	978:  libc.Float32FromFloat32(0.99297196),
	979:  libc.Float32FromFloat32(0.9921761),
	980:  libc.Float32FromFloat32(0.99133774),
	981:  libc.Float32FromFloat32(0.99045692),
	982:  libc.Float32FromFloat32(0.98953366),
	983:  libc.Float32FromFloat32(0.98856802),
	984:  libc.Float32FromFloat32(0.98756003),
	985:  libc.Float32FromFloat32(0.98650973),
	986:  libc.Float32FromFloat32(0.98541718),
	987:  libc.Float32FromFloat32(0.98428242),
	988:  libc.Float32FromFloat32(0.98310549),
	989:  libc.Float32FromFloat32(0.98188645),
	990:  libc.Float32FromFloat32(0.98062534),
	991:  libc.Float32FromFloat32(0.97932224),
	992:  libc.Float32FromFloat32(0.97797718),
	993:  libc.Float32FromFloat32(0.97659022),
	994:  libc.Float32FromFloat32(0.97516144),
	995:  libc.Float32FromFloat32(0.97369088),
	996:  libc.Float32FromFloat32(0.97217861),
	997:  libc.Float32FromFloat32(0.97062469),
	998:  libc.Float32FromFloat32(0.9690292),
	999:  libc.Float32FromFloat32(0.9673922),
	1000: libc.Float32FromFloat32(0.96571376),
	1001: libc.Float32FromFloat32(0.96399395),
	1002: libc.Float32FromFloat32(0.96223284),
	1003: libc.Float32FromFloat32(0.96043052),
	1004: libc.Float32FromFloat32(0.95858705),
	1005: libc.Float32FromFloat32(0.95670253),
	1006: libc.Float32FromFloat32(0.95477702),
	1007: libc.Float32FromFloat32(0.95281061),
	1008: libc.Float32FromFloat32(0.95080338),
	1009: libc.Float32FromFloat32(0.94875543),
	1010: libc.Float32FromFloat32(0.94666684),
	1011: libc.Float32FromFloat32(0.94453769),
	1012: libc.Float32FromFloat32(0.94236808),
	1013: libc.Float32FromFloat32(0.9401581),
	1014: libc.Float32FromFloat32(0.93790786),
	1015: libc.Float32FromFloat32(0.93561743),
	1016: libc.Float32FromFloat32(0.93328693),
	1017: libc.Float32FromFloat32(0.93091644),
	1018: libc.Float32FromFloat32(0.92850608),
	1019: libc.Float32FromFloat32(0.92605595),
	1020: libc.Float32FromFloat32(0.92356614),
	1021: libc.Float32FromFloat32(0.92103677),
	1022: libc.Float32FromFloat32(0.91846795),
	1023: libc.Float32FromFloat32(0.91585979),
	1024: libc.Float32FromFloat32(0.91321239),
	1025: libc.Float32FromFloat32(0.91052587),
	1026: libc.Float32FromFloat32(0.90780035),
	1027: libc.Float32FromFloat32(0.90503595),
	1028: libc.Float32FromFloat32(0.90223277),
	1029: libc.Float32FromFloat32(0.89939095),
	1030: libc.Float32FromFloat32(0.89651059),
	1031: libc.Float32FromFloat32(0.89359184),
	1032: libc.Float32FromFloat32(0.89063481),
	1033: libc.Float32FromFloat32(0.88763962),
	1034: libc.Float32FromFloat32(0.88460641),
	1035: libc.Float32FromFloat32(0.88153531),
	1036: libc.Float32FromFloat32(0.87842644),
	1037: libc.Float32FromFloat32(0.87527995),
	1038: libc.Float32FromFloat32(0.87209596),
	1039: libc.Float32FromFloat32(0.86887462),
	1040: libc.Float32FromFloat32(0.86561605),
	1041: libc.Float32FromFloat32(0.86232041),
	1042: libc.Float32FromFloat32(0.85898782),
	1043: libc.Float32FromFloat32(0.85561844),
	1044: libc.Float32FromFloat32(0.85221241),
	1045: libc.Float32FromFloat32(0.84876987),
	1046: libc.Float32FromFloat32(0.84529098),
	1047: libc.Float32FromFloat32(0.84177587),
	1048: libc.Float32FromFloat32(0.83822471),
	1049: libc.Float32FromFloat32(0.83463763),
	1050: libc.Float32FromFloat32(0.83101481),
	1051: libc.Float32FromFloat32(0.82735639),
	1052: libc.Float32FromFloat32(0.82366252),
	1053: libc.Float32FromFloat32(0.81993338),
	1054: libc.Float32FromFloat32(0.81616911),
	1055: libc.Float32FromFloat32(0.81236987),
	1056: libc.Float32FromFloat32(0.80853584),
	1057: libc.Float32FromFloat32(0.80466718),
	1058: libc.Float32FromFloat32(0.80076404),
	1059: libc.Float32FromFloat32(0.7968266),
	1060: libc.Float32FromFloat32(0.79285503),
	1061: libc.Float32FromFloat32(0.7888495),
	1062: libc.Float32FromFloat32(0.78481017),
	1063: libc.Float32FromFloat32(0.78073723),
	1064: libc.Float32FromFloat32(0.77663084),
	1065: libc.Float32FromFloat32(0.77249118),
	1066: libc.Float32FromFloat32(0.76831844),
	1067: libc.Float32FromFloat32(0.76411277),
	1068: libc.Float32FromFloat32(0.75987438),
	1069: libc.Float32FromFloat32(0.75560344),
	1070: libc.Float32FromFloat32(0.75130013),
	1071: libc.Float32FromFloat32(0.74696464),
	1072: libc.Float32FromFloat32(0.74259715),
	1073: libc.Float32FromFloat32(0.73819784),
	1074: libc.Float32FromFloat32(0.73376692),
	1075: libc.Float32FromFloat32(0.72930457),
	1076: libc.Float32FromFloat32(0.72481097),
	1077: libc.Float32FromFloat32(0.72028632),
	1078: libc.Float32FromFloat32(0.71573083),
	1079: libc.Float32FromFloat32(0.71114467),
	1080: libc.Float32FromFloat32(0.70652804),
	1081: libc.Float32FromFloat32(0.70188116),
	1082: libc.Float32FromFloat32(0.6972042),
	1083: libc.Float32FromFloat32(0.69249738),
	1084: libc.Float32FromFloat32(0.6877609),
	1085: libc.Float32FromFloat32(0.68299495),
	1086: libc.Float32FromFloat32(0.67819975),
	1087: libc.Float32FromFloat32(0.6733755),
	1088: libc.Float32FromFloat32(0.6685224),
	1089: libc.Float32FromFloat32(0.66364066),
	1090: libc.Float32FromFloat32(0.6587305),
	1091: libc.Float32FromFloat32(0.65379211),
	1092: libc.Float32FromFloat32(0.64882573),
	1093: libc.Float32FromFloat32(0.64383154),
	1094: libc.Float32FromFloat32(0.63880978),
	1095: libc.Float32FromFloat32(0.63376065),
	1096: libc.Float32FromFloat32(0.62868438),
	1097: libc.Float32FromFloat32(0.62358117),
	1098: libc.Float32FromFloat32(0.61845126),
	1099: libc.Float32FromFloat32(0.61329485),
	1100: libc.Float32FromFloat32(0.60811216),
	1101: libc.Float32FromFloat32(0.60290343),
	1102: libc.Float32FromFloat32(0.59766888),
	1103: libc.Float32FromFloat32(0.59240872),
	1104: libc.Float32FromFloat32(0.58712318),
	1105: libc.Float32FromFloat32(0.58181249),
	1106: libc.Float32FromFloat32(0.57647688),
	1107: libc.Float32FromFloat32(0.57111658),
	1108: libc.Float32FromFloat32(0.56573181),
	1109: libc.Float32FromFloat32(0.56032281),
	1110: libc.Float32FromFloat32(0.5548898),
	1111: libc.Float32FromFloat32(0.54943303),
	1112: libc.Float32FromFloat32(0.54395272),
	1113: libc.Float32FromFloat32(0.53844911),
	1114: libc.Float32FromFloat32(0.53292243),
	1115: libc.Float32FromFloat32(0.52737292),
	1116: libc.Float32FromFloat32(0.52180083),
	1117: libc.Float32FromFloat32(0.51620638),
	1118: libc.Float32FromFloat32(0.51058981),
	1119: libc.Float32FromFloat32(0.50495138),
	1120: libc.Float32FromFloat32(0.49929132),
	1121: libc.Float32FromFloat32(0.49360987),
	1122: libc.Float32FromFloat32(0.48790727),
	1123: libc.Float32FromFloat32(0.48218377),
	1124: libc.Float32FromFloat32(0.47643962),
	1125: libc.Float32FromFloat32(0.47067506),
	1126: libc.Float32FromFloat32(0.46489034),
	1127: libc.Float32FromFloat32(0.4590857),
	1128: libc.Float32FromFloat32(0.45326139),
	1129: libc.Float32FromFloat32(0.44741768),
	1130: libc.Float32FromFloat32(0.44155479),
	1131: libc.Float32FromFloat32(0.43567299),
	1132: libc.Float32FromFloat32(0.42977253),
	1133: libc.Float32FromFloat32(0.42385365),
	1134: libc.Float32FromFloat32(0.41791662),
	1135: libc.Float32FromFloat32(0.41196169),
	1136: libc.Float32FromFloat32(0.40598911),
	1137: libc.Float32FromFloat32(0.39999914),
	1138: libc.Float32FromFloat32(0.39399204),
	1139: libc.Float32FromFloat32(0.38796806),
	1140: libc.Float32FromFloat32(0.38192746),
	1141: libc.Float32FromFloat32(0.3758705),
	1142: libc.Float32FromFloat32(0.36979743),
	1143: libc.Float32FromFloat32(0.36370853),
	1144: libc.Float32FromFloat32(0.35760405),
	1145: libc.Float32FromFloat32(0.35148424),
	1146: libc.Float32FromFloat32(0.34534939),
	1147: libc.Float32FromFloat32(0.33919973),
	1148: libc.Float32FromFloat32(0.33303555),
	1149: libc.Float32FromFloat32(0.3268571),
	1150: libc.Float32FromFloat32(0.32066465),
	1151: libc.Float32FromFloat32(0.31445847),
	1152: libc.Float32FromFloat32(0.30823881),
	1153: libc.Float32FromFloat32(0.30200595),
	1154: libc.Float32FromFloat32(0.29576015),
	1155: libc.Float32FromFloat32(0.28950169),
	1156: libc.Float32FromFloat32(0.28323082),
	1157: libc.Float32FromFloat32(0.27694782),
	1158: libc.Float32FromFloat32(0.27065295),
	1159: libc.Float32FromFloat32(0.26434649),
	1160: libc.Float32FromFloat32(0.25802871),
	1161: libc.Float32FromFloat32(0.25169988),
	1162: libc.Float32FromFloat32(0.24536026),
	1163: libc.Float32FromFloat32(0.23901013),
	1164: libc.Float32FromFloat32(0.23264977),
	1165: libc.Float32FromFloat32(0.22627944),
	1166: libc.Float32FromFloat32(0.21989941),
	1167: libc.Float32FromFloat32(0.21350997),
	1168: libc.Float32FromFloat32(0.20711138),
	1169: libc.Float32FromFloat32(0.20070391),
	1170: libc.Float32FromFloat32(0.19428785),
	1171: libc.Float32FromFloat32(0.18786347),
	1172: libc.Float32FromFloat32(0.18143104),
	1173: libc.Float32FromFloat32(0.17499084),
	1174: libc.Float32FromFloat32(0.16854314),
	1175: libc.Float32FromFloat32(0.16208822),
	1176: libc.Float32FromFloat32(0.15562636),
	1177: libc.Float32FromFloat32(0.14915783),
	1178: libc.Float32FromFloat32(0.14268292),
	1179: libc.Float32FromFloat32(0.13620189),
	1180: libc.Float32FromFloat32(0.12971502),
	1181: libc.Float32FromFloat32(0.1232226),
	1182: libc.Float32FromFloat32(0.11672491),
	1183: libc.Float32FromFloat32(0.11022221),
	1184: libc.Float32FromFloat32(0.10371479),
	1185: libc.Float32FromFloat32(0.097202924),
	1186: libc.Float32FromFloat32(0.090686897),
	1187: libc.Float32FromFloat32(0.084166986),
	1188: libc.Float32FromFloat32(0.077643468),
	1189: libc.Float32FromFloat32(0.071116625),
	1190: libc.Float32FromFloat32(0.064586736),
	1191: libc.Float32FromFloat32(0.05805408),
	1192: libc.Float32FromFloat32(0.051518937),
	1193: libc.Float32FromFloat32(0.044981587),
	1194: libc.Float32FromFloat32(0.03844231),
	1195: libc.Float32FromFloat32(0.031901387),
	1196: libc.Float32FromFloat32(0.025359097),
	1197: libc.Float32FromFloat32(0.018815721),
	1198: libc.Float32FromFloat32(0.012271538),
	1199: libc.Float32FromFloat32(0.0057268303),
	1200: -libc.Float32FromFloat32(0.000818123),
	1201: -libc.Float32FromFloat32(0.0073630412),
	1202: -libc.Float32FromFloat32(0.013907644),
	1203: -libc.Float32FromFloat32(0.020451651),
	1204: -libc.Float32FromFloat32(0.026994782),
	1205: -libc.Float32FromFloat32(0.033536757),
	1206: -libc.Float32FromFloat32(0.040077295),
	1207: -libc.Float32FromFloat32(0.046616116),
	1208: -libc.Float32FromFloat32(0.053152941),
	1209: -libc.Float32FromFloat32(0.059687488),
	1210: -libc.Float32FromFloat32(0.066219479),
	1211: -libc.Float32FromFloat32(0.072748633),
	1212: -libc.Float32FromFloat32(0.07927467),
	1213: -libc.Float32FromFloat32(0.085797312),
	1214: -libc.Float32FromFloat32(0.092316279),
	1215: -libc.Float32FromFloat32(0.098831291),
	1216: -libc.Float32FromFloat32(0.10534207),
	1217: -libc.Float32FromFloat32(0.11184834),
	1218: -libc.Float32FromFloat32(0.11834981),
	1219: -libc.Float32FromFloat32(0.12484622),
	1220: -libc.Float32FromFloat32(0.13133727),
	1221: -libc.Float32FromFloat32(0.1378227),
	1222: -libc.Float32FromFloat32(0.14430223),
	1223: -libc.Float32FromFloat32(0.15077558),
	1224: -libc.Float32FromFloat32(0.15724246),
	1225: -libc.Float32FromFloat32(0.16370261),
	1226: -libc.Float32FromFloat32(0.17015575),
	1227: -libc.Float32FromFloat32(0.1766016),
	1228: -libc.Float32FromFloat32(0.18303989),
	1229: -libc.Float32FromFloat32(0.18947033),
	1230: -libc.Float32FromFloat32(0.19589266),
	1231: -libc.Float32FromFloat32(0.2023066),
	1232: -libc.Float32FromFloat32(0.20871187),
	1233: -libc.Float32FromFloat32(0.2151082),
	1234: -libc.Float32FromFloat32(0.22149531),
	1235: -libc.Float32FromFloat32(0.22787294),
	1236: -libc.Float32FromFloat32(0.2342408),
	1237: -libc.Float32FromFloat32(0.24059864),
	1238: -libc.Float32FromFloat32(0.24694616),
	1239: -libc.Float32FromFloat32(0.25328311),
	1240: -libc.Float32FromFloat32(0.2596092),
	1241: -libc.Float32FromFloat32(0.26592418),
	1242: -libc.Float32FromFloat32(0.27222777),
	1243: -libc.Float32FromFloat32(0.27851969),
	1244: -libc.Float32FromFloat32(0.28479968),
	1245: -libc.Float32FromFloat32(0.29106748),
	1246: -libc.Float32FromFloat32(0.2973228),
	1247: -libc.Float32FromFloat32(0.30356539),
	1248: -libc.Float32FromFloat32(0.30979497),
	1249: -libc.Float32FromFloat32(0.31601129),
	1250: -libc.Float32FromFloat32(0.32221406),
	1251: -libc.Float32FromFloat32(0.32840304),
	1252: -libc.Float32FromFloat32(0.33457794),
	1253: -libc.Float32FromFloat32(0.34073852),
	1254: -libc.Float32FromFloat32(0.3468845),
	1255: -libc.Float32FromFloat32(0.35301562),
	1256: -libc.Float32FromFloat32(0.35913161),
	1257: -libc.Float32FromFloat32(0.36523223),
	1258: -libc.Float32FromFloat32(0.37131719),
	1259: -libc.Float32FromFloat32(0.37738626),
	1260: -libc.Float32FromFloat32(0.38343915),
	1261: -libc.Float32FromFloat32(0.38947562),
	1262: -libc.Float32FromFloat32(0.39549541),
	1263: -libc.Float32FromFloat32(0.40149825),
	1264: -libc.Float32FromFloat32(0.4074839),
	1265: -libc.Float32FromFloat32(0.41345209),
	1266: -libc.Float32FromFloat32(0.41940257),
	1267: -libc.Float32FromFloat32(0.42533508),
	1268: -libc.Float32FromFloat32(0.43124938),
	1269: -libc.Float32FromFloat32(0.4371452),
	1270: -libc.Float32FromFloat32(0.44302229),
	1271: -libc.Float32FromFloat32(0.44888041),
	1272: -libc.Float32FromFloat32(0.4547193),
	1273: -libc.Float32FromFloat32(0.46053871),
	1274: -libc.Float32FromFloat32(0.46633839),
	1275: -libc.Float32FromFloat32(0.4721181),
	1276: -libc.Float32FromFloat32(0.47787758),
	1277: -libc.Float32FromFloat32(0.48361659),
	1278: -libc.Float32FromFloat32(0.48933489),
	1279: -libc.Float32FromFloat32(0.49503222),
	1280: -libc.Float32FromFloat32(0.50070835),
	1281: -libc.Float32FromFloat32(0.50636303),
	1282: -libc.Float32FromFloat32(0.51199602),
	1283: -libc.Float32FromFloat32(0.51760707),
	1284: -libc.Float32FromFloat32(0.52319595),
	1285: -libc.Float32FromFloat32(0.52876243),
	1286: -libc.Float32FromFloat32(0.53430625),
	1287: -libc.Float32FromFloat32(0.53982718),
	1288: -libc.Float32FromFloat32(0.54532499),
	1289: -libc.Float32FromFloat32(0.55079944),
	1290: -libc.Float32FromFloat32(0.55625029),
	1291: -libc.Float32FromFloat32(0.56167732),
	1292: -libc.Float32FromFloat32(0.56708028),
	1293: -libc.Float32FromFloat32(0.57245896),
	1294: -libc.Float32FromFloat32(0.57781311),
	1295: -libc.Float32FromFloat32(0.58314251),
	1296: -libc.Float32FromFloat32(0.58844693),
	1297: -libc.Float32FromFloat32(0.59372614),
	1298: -libc.Float32FromFloat32(0.59897992),
	1299: -libc.Float32FromFloat32(0.60420805),
	1300: -libc.Float32FromFloat32(0.60941029),
	1301: -libc.Float32FromFloat32(0.61458642),
	1302: -libc.Float32FromFloat32(0.61973623),
	1303: -libc.Float32FromFloat32(0.62485949),
	1304: -libc.Float32FromFloat32(0.62995598),
	1305: -libc.Float32FromFloat32(0.63502549),
	1306: -libc.Float32FromFloat32(0.6400678),
	1307: -libc.Float32FromFloat32(0.64508268),
	1308: -libc.Float32FromFloat32(0.65006994),
	1309: -libc.Float32FromFloat32(0.65502934),
	1310: -libc.Float32FromFloat32(0.65996069),
	1311: -libc.Float32FromFloat32(0.66486377),
	1312: -libc.Float32FromFloat32(0.66973837),
	1313: -libc.Float32FromFloat32(0.67458427),
	1314: -libc.Float32FromFloat32(0.67940128),
	1315: -libc.Float32FromFloat32(0.68418919),
	1316: -libc.Float32FromFloat32(0.68894779),
	1317: -libc.Float32FromFloat32(0.69367688),
	1318: -libc.Float32FromFloat32(0.69837625),
	1319: -libc.Float32FromFloat32(0.70304571),
	1320: -libc.Float32FromFloat32(0.70768504),
	1321: -libc.Float32FromFloat32(0.71229407),
	1322: -libc.Float32FromFloat32(0.71687258),
	1323: -libc.Float32FromFloat32(0.72142039),
	1324: -libc.Float32FromFloat32(0.72593729),
	1325: -libc.Float32FromFloat32(0.73042309),
	1326: -libc.Float32FromFloat32(0.73487761),
	1327: -libc.Float32FromFloat32(0.73930064),
	1328: -libc.Float32FromFloat32(0.74369201),
	1329: -libc.Float32FromFloat32(0.74805152),
	1330: -libc.Float32FromFloat32(0.75237898),
	1331: -libc.Float32FromFloat32(0.75667422),
	1332: -libc.Float32FromFloat32(0.76093704),
	1333: -libc.Float32FromFloat32(0.76516727),
	1334: -libc.Float32FromFloat32(0.76936471),
	1335: -libc.Float32FromFloat32(0.77352921),
	1336: -libc.Float32FromFloat32(0.77766056),
	1337: -libc.Float32FromFloat32(0.78175861),
	1338: -libc.Float32FromFloat32(0.78582316),
	1339: -libc.Float32FromFloat32(0.78985406),
	1340: -libc.Float32FromFloat32(0.79385112),
	1341: -libc.Float32FromFloat32(0.79781417),
	1342: -libc.Float32FromFloat32(0.80174305),
	1343: -libc.Float32FromFloat32(0.80563758),
	1344: -libc.Float32FromFloat32(0.8094976),
	1345: -libc.Float32FromFloat32(0.81332295),
	1346: -libc.Float32FromFloat32(0.81711346),
	1347: -libc.Float32FromFloat32(0.82086896),
	1348: -libc.Float32FromFloat32(0.8245893),
	1349: -libc.Float32FromFloat32(0.82827432),
	1350: -libc.Float32FromFloat32(0.83192386),
	1351: -libc.Float32FromFloat32(0.83553776),
	1352: -libc.Float32FromFloat32(0.83911587),
	1353: -libc.Float32FromFloat32(0.84265803),
	1354: -libc.Float32FromFloat32(0.8461641),
	1355: -libc.Float32FromFloat32(0.84963392),
	1356: -libc.Float32FromFloat32(0.85306735),
	1357: -libc.Float32FromFloat32(0.85646423),
	1358: -libc.Float32FromFloat32(0.85982442),
	1359: -libc.Float32FromFloat32(0.86314779),
	1360: -libc.Float32FromFloat32(0.86643418),
	1361: -libc.Float32FromFloat32(0.86968345),
	1362: -libc.Float32FromFloat32(0.87289547),
	1363: -libc.Float32FromFloat32(0.87607009),
	1364: -libc.Float32FromFloat32(0.87920719),
	1365: -libc.Float32FromFloat32(0.88230663),
	1366: -libc.Float32FromFloat32(0.88536827),
	1367: -libc.Float32FromFloat32(0.88839199),
	1368: -libc.Float32FromFloat32(0.89137765),
	1369: -libc.Float32FromFloat32(0.89432512),
	1370: -libc.Float32FromFloat32(0.89723429),
	1371: -libc.Float32FromFloat32(0.90010502),
	1372: -libc.Float32FromFloat32(0.90293719),
	1373: -libc.Float32FromFloat32(0.90573069),
	1374: -libc.Float32FromFloat32(0.90848539),
	1375: -libc.Float32FromFloat32(0.91120117),
	1376: -libc.Float32FromFloat32(0.91387791),
	1377: -libc.Float32FromFloat32(0.91651551),
	1378: -libc.Float32FromFloat32(0.91911385),
	1379: -libc.Float32FromFloat32(0.92167282),
	1380: -libc.Float32FromFloat32(0.92419231),
	1381: -libc.Float32FromFloat32(0.9266722),
	1382: -libc.Float32FromFloat32(0.9291124),
	1383: -libc.Float32FromFloat32(0.9315128),
	1384: -libc.Float32FromFloat32(0.9338733),
	1385: -libc.Float32FromFloat32(0.9361938),
	1386: -libc.Float32FromFloat32(0.93847419),
	1387: -libc.Float32FromFloat32(0.94071438),
	1388: -libc.Float32FromFloat32(0.94291427),
	1389: -libc.Float32FromFloat32(0.94507377),
	1390: -libc.Float32FromFloat32(0.94719279),
	1391: -libc.Float32FromFloat32(0.94927123),
	1392: -libc.Float32FromFloat32(0.95130901),
	1393: -libc.Float32FromFloat32(0.95330604),
	1394: -libc.Float32FromFloat32(0.95526223),
	1395: -libc.Float32FromFloat32(0.9571775),
	1396: -libc.Float32FromFloat32(0.95905177),
	1397: -libc.Float32FromFloat32(0.96088496),
	1398: -libc.Float32FromFloat32(0.96267699),
	1399: -libc.Float32FromFloat32(0.96442777),
	1400: -libc.Float32FromFloat32(0.96613725),
	1401: -libc.Float32FromFloat32(0.96780534),
	1402: -libc.Float32FromFloat32(0.96943197),
	1403: -libc.Float32FromFloat32(0.97101707),
	1404: -libc.Float32FromFloat32(0.97256058),
	1405: -libc.Float32FromFloat32(0.97406243),
	1406: -libc.Float32FromFloat32(0.97552255),
	1407: -libc.Float32FromFloat32(0.97694089),
	1408: -libc.Float32FromFloat32(0.97831737),
	1409: -libc.Float32FromFloat32(0.97965195),
	1410: -libc.Float32FromFloat32(0.98094456),
	1411: -libc.Float32FromFloat32(0.98219515),
	1412: -libc.Float32FromFloat32(0.98340367),
	1413: -libc.Float32FromFloat32(0.98457006),
	1414: -libc.Float32FromFloat32(0.98569428),
	1415: -libc.Float32FromFloat32(0.98677627),
	1416: -libc.Float32FromFloat32(0.98781599),
	1417: -libc.Float32FromFloat32(0.9888134),
	1418: -libc.Float32FromFloat32(0.98976845),
	1419: -libc.Float32FromFloat32(0.9906811),
	1420: -libc.Float32FromFloat32(0.99155132),
	1421: -libc.Float32FromFloat32(0.99237906),
	1422: -libc.Float32FromFloat32(0.99316428),
	1423: -libc.Float32FromFloat32(0.99390697),
	1424: -libc.Float32FromFloat32(0.99460708),
	1425: -libc.Float32FromFloat32(0.99526458),
	1426: -libc.Float32FromFloat32(0.99587945),
	1427: -libc.Float32FromFloat32(0.99645166),
	1428: -libc.Float32FromFloat32(0.99698119),
	1429: -libc.Float32FromFloat32(0.99746801),
	1430: -libc.Float32FromFloat32(0.9979121),
	1431: -libc.Float32FromFloat32(0.99831344),
	1432: -libc.Float32FromFloat32(0.99867202),
	1433: -libc.Float32FromFloat32(0.99898782),
	1434: -libc.Float32FromFloat32(0.99926082),
	1435: -libc.Float32FromFloat32(0.99949102),
	1436: -libc.Float32FromFloat32(0.99967841),
	1437: -libc.Float32FromFloat32(0.99982297),
	1438: -libc.Float32FromFloat32(0.9999247),
	1439: -libc.Float32FromFloat32(0.9999836),
	1440: libc.Float32FromFloat32(0.99999866),
	1441: libc.Float32FromFloat32(0.99989157),
	1442: libc.Float32FromFloat32(0.99961315),
	1443: libc.Float32FromFloat32(0.99916346),
	1444: libc.Float32FromFloat32(0.99854256),
	1445: libc.Float32FromFloat32(0.99775057),
	1446: libc.Float32FromFloat32(0.99678762),
	1447: libc.Float32FromFloat32(0.99565388),
	1448: libc.Float32FromFloat32(0.99434953),
	1449: libc.Float32FromFloat32(0.99287481),
	1450: libc.Float32FromFloat32(0.99122996),
	1451: libc.Float32FromFloat32(0.98941527),
	1452: libc.Float32FromFloat32(0.98743105),
	1453: libc.Float32FromFloat32(0.98527764),
	1454: libc.Float32FromFloat32(0.98295541),
	1455: libc.Float32FromFloat32(0.98046475),
	1456: libc.Float32FromFloat32(0.9778061),
	1457: libc.Float32FromFloat32(0.9749799),
	1458: libc.Float32FromFloat32(0.97198664),
	1459: libc.Float32FromFloat32(0.96882685),
	1460: libc.Float32FromFloat32(0.96550104),
	1461: libc.Float32FromFloat32(0.9620098),
	1462: libc.Float32FromFloat32(0.95835373),
	1463: libc.Float32FromFloat32(0.95453345),
	1464: libc.Float32FromFloat32(0.95054962),
	1465: libc.Float32FromFloat32(0.94640291),
	1466: libc.Float32FromFloat32(0.94209404),
	1467: libc.Float32FromFloat32(0.93762375),
	1468: libc.Float32FromFloat32(0.9329928),
	1469: libc.Float32FromFloat32(0.92820199),
	1470: libc.Float32FromFloat32(0.92325213),
	1471: libc.Float32FromFloat32(0.91814408),
	1472: libc.Float32FromFloat32(0.91287871),
	1473: libc.Float32FromFloat32(0.90745693),
	1474: libc.Float32FromFloat32(0.90187965),
	1475: libc.Float32FromFloat32(0.89614785),
	1476: libc.Float32FromFloat32(0.89026249),
	1477: libc.Float32FromFloat32(0.88422459),
	1478: libc.Float32FromFloat32(0.87803519),
	1479: libc.Float32FromFloat32(0.87169533),
	1480: libc.Float32FromFloat32(0.86520612),
	1481: libc.Float32FromFloat32(0.85856866),
	1482: libc.Float32FromFloat32(0.85178409),
	1483: libc.Float32FromFloat32(0.84485357),
	1484: libc.Float32FromFloat32(0.83777828),
	1485: libc.Float32FromFloat32(0.83055945),
	1486: libc.Float32FromFloat32(0.82319831),
	1487: libc.Float32FromFloat32(0.81569611),
	1488: libc.Float32FromFloat32(0.80805415),
	1489: libc.Float32FromFloat32(0.80027373),
	1490: libc.Float32FromFloat32(0.7923562),
	1491: libc.Float32FromFloat32(0.78430289),
	1492: libc.Float32FromFloat32(0.7761152),
	1493: libc.Float32FromFloat32(0.76779452),
	1494: libc.Float32FromFloat32(0.75934229),
	1495: libc.Float32FromFloat32(0.75075995),
	1496: libc.Float32FromFloat32(0.74204897),
	1497: libc.Float32FromFloat32(0.73321084),
	1498: libc.Float32FromFloat32(0.72424708),
	1499: libc.Float32FromFloat32(0.71515923),
	1500: libc.Float32FromFloat32(0.70594883),
	1501: libc.Float32FromFloat32(0.69661748),
	1502: libc.Float32FromFloat32(0.68716676),
	1503: libc.Float32FromFloat32(0.6775983),
	1504: libc.Float32FromFloat32(0.66791374),
	1505: libc.Float32FromFloat32(0.65811474),
	1506: libc.Float32FromFloat32(0.64820297),
	1507: libc.Float32FromFloat32(0.63818013),
	1508: libc.Float32FromFloat32(0.62804795),
	1509: libc.Float32FromFloat32(0.61780815),
	1510: libc.Float32FromFloat32(0.60746249),
	1511: libc.Float32FromFloat32(0.59701275),
	1512: libc.Float32FromFloat32(0.58646072),
	1513: libc.Float32FromFloat32(0.57580819),
	1514: libc.Float32FromFloat32(0.56505701),
	1515: libc.Float32FromFloat32(0.554209),
	1516: libc.Float32FromFloat32(0.54326604),
	1517: libc.Float32FromFloat32(0.53222998),
	1518: libc.Float32FromFloat32(0.52110274),
	1519: libc.Float32FromFloat32(0.5098862),
	1520: libc.Float32FromFloat32(0.4985823),
	1521: libc.Float32FromFloat32(0.48719297),
	1522: libc.Float32FromFloat32(0.47572016),
	1523: libc.Float32FromFloat32(0.46416584),
	1524: libc.Float32FromFloat32(0.45253199),
	1525: libc.Float32FromFloat32(0.44082059),
	1526: libc.Float32FromFloat32(0.42903367),
	1527: libc.Float32FromFloat32(0.41717323),
	1528: libc.Float32FromFloat32(0.40524131),
	1529: libc.Float32FromFloat32(0.39323996),
	1530: libc.Float32FromFloat32(0.38117123),
	1531: libc.Float32FromFloat32(0.36903718),
	1532: libc.Float32FromFloat32(0.3568399),
	1533: libc.Float32FromFloat32(0.34458148),
	1534: libc.Float32FromFloat32(0.33226402),
	1535: libc.Float32FromFloat32(0.31988962),
	1536: libc.Float32FromFloat32(0.30746042),
	1537: libc.Float32FromFloat32(0.29497853),
	1538: libc.Float32FromFloat32(0.2824461),
	1539: libc.Float32FromFloat32(0.26986527),
	1540: libc.Float32FromFloat32(0.25723821),
	1541: libc.Float32FromFloat32(0.24456706),
	1542: libc.Float32FromFloat32(0.23185402),
	1543: libc.Float32FromFloat32(0.21910124),
	1544: libc.Float32FromFloat32(0.20631092),
	1545: libc.Float32FromFloat32(0.19348526),
	1546: libc.Float32FromFloat32(0.18062644),
	1547: libc.Float32FromFloat32(0.16773667),
	1548: libc.Float32FromFloat32(0.15481816),
	1549: libc.Float32FromFloat32(0.14187312),
	1550: libc.Float32FromFloat32(0.12890377),
	1551: libc.Float32FromFloat32(0.11591234),
	1552: libc.Float32FromFloat32(0.10290104),
	1553: libc.Float32FromFloat32(0.089872115),
	1554: libc.Float32FromFloat32(0.076827789),
	1555: libc.Float32FromFloat32(0.0637703),
	1556: libc.Float32FromFloat32(0.050701883),
	1557: libc.Float32FromFloat32(0.037624779),
	1558: libc.Float32FromFloat32(0.024541229),
	1559: libc.Float32FromFloat32(0.011453473),
	1560: -libc.Float32FromFloat32(0.0016362454),
	1561: -libc.Float32FromFloat32(0.014725683),
	1562: -libc.Float32FromFloat32(0.027812598),
	1563: -libc.Float32FromFloat32(0.040894747),
	1564: -libc.Float32FromFloat32(0.053969889),
	1565: -libc.Float32FromFloat32(0.067035784),
	1566: -libc.Float32FromFloat32(0.080090192),
	1567: -libc.Float32FromFloat32(0.093130877),
	1568: -libc.Float32FromFloat32(0.10615561),
	1569: -libc.Float32FromFloat32(0.11916214),
	1570: -libc.Float32FromFloat32(0.13214826),
	1571: -libc.Float32FromFloat32(0.14511174),
	1572: -libc.Float32FromFloat32(0.15805036),
	1573: -libc.Float32FromFloat32(0.17096189),
	1574: -libc.Float32FromFloat32(0.18384413),
	1575: -libc.Float32FromFloat32(0.19669487),
	1576: -libc.Float32FromFloat32(0.2095119),
	1577: -libc.Float32FromFloat32(0.22229304),
	1578: -libc.Float32FromFloat32(0.23503609),
	1579: -libc.Float32FromFloat32(0.24773886),
	1580: -libc.Float32FromFloat32(0.26039919),
	1581: -libc.Float32FromFloat32(0.2730149),
	1582: -libc.Float32FromFloat32(0.28558383),
	1583: -libc.Float32FromFloat32(0.29810383),
	1584: -libc.Float32FromFloat32(0.31057274),
	1585: -libc.Float32FromFloat32(0.32298845),
	1586: -libc.Float32FromFloat32(0.33534881),
	1587: -libc.Float32FromFloat32(0.34765171),
	1588: -libc.Float32FromFloat32(0.35989504),
	1589: -libc.Float32FromFloat32(0.3720767),
	1590: -libc.Float32FromFloat32(0.38419461),
	1591: -libc.Float32FromFloat32(0.3962467),
	1592: -libc.Float32FromFloat32(0.40823088),
	1593: -libc.Float32FromFloat32(0.42014512),
	1594: -libc.Float32FromFloat32(0.43198737),
	1595: -libc.Float32FromFloat32(0.4437556),
	1596: -libc.Float32FromFloat32(0.4554478),
	1597: -libc.Float32FromFloat32(0.46706195),
	1598: -libc.Float32FromFloat32(0.47859608),
	1599: -libc.Float32FromFloat32(0.49004821),
	1600: -libc.Float32FromFloat32(0.50141636),
	1601: -libc.Float32FromFloat32(0.5126986),
	1602: -libc.Float32FromFloat32(0.52389299),
	1603: -libc.Float32FromFloat32(0.53499762),
	1604: -libc.Float32FromFloat32(0.54601058),
	1605: -libc.Float32FromFloat32(0.55692998),
	1606: -libc.Float32FromFloat32(0.56775395),
	1607: -libc.Float32FromFloat32(0.57848064),
	1608: -libc.Float32FromFloat32(0.58910822),
	1609: -libc.Float32FromFloat32(0.59963485),
	1610: -libc.Float32FromFloat32(0.61005873),
	1611: -libc.Float32FromFloat32(0.62037809),
	1612: -libc.Float32FromFloat32(0.63059115),
	1613: -libc.Float32FromFloat32(0.64069616),
	1614: -libc.Float32FromFloat32(0.65069139),
	1615: -libc.Float32FromFloat32(0.66057513),
	1616: -libc.Float32FromFloat32(0.67034568),
	1617: -libc.Float32FromFloat32(0.68000137),
	1618: -libc.Float32FromFloat32(0.68954054),
	1619: -libc.Float32FromFloat32(0.69896157),
	1620: -libc.Float32FromFloat32(0.70826283),
	1621: -libc.Float32FromFloat32(0.71744274),
	1622: -libc.Float32FromFloat32(0.72649972),
	1623: -libc.Float32FromFloat32(0.73543221),
	1624: -libc.Float32FromFloat32(0.74423869),
	1625: -libc.Float32FromFloat32(0.75291765),
	1626: -libc.Float32FromFloat32(0.7614676),
	1627: -libc.Float32FromFloat32(0.76988708),
	1628: -libc.Float32FromFloat32(0.77817464),
	1629: -libc.Float32FromFloat32(0.78632887),
	1630: -libc.Float32FromFloat32(0.79434836),
	1631: -libc.Float32FromFloat32(0.80223175),
	1632: -libc.Float32FromFloat32(0.80997767),
	1633: -libc.Float32FromFloat32(0.81758481),
	1634: -libc.Float32FromFloat32(0.82505187),
	1635: -libc.Float32FromFloat32(0.83237755),
	1636: -libc.Float32FromFloat32(0.83956061),
	1637: -libc.Float32FromFloat32(0.84659981),
	1638: -libc.Float32FromFloat32(0.85349396),
	1639: -libc.Float32FromFloat32(0.86024186),
	1640: -libc.Float32FromFloat32(0.86684237),
	1641: -libc.Float32FromFloat32(0.87329434),
	1642: -libc.Float32FromFloat32(0.87959669),
	1643: -libc.Float32FromFloat32(0.88574831),
	1644: -libc.Float32FromFloat32(0.89174817),
	1645: -libc.Float32FromFloat32(0.89759523),
	1646: -libc.Float32FromFloat32(0.9032885),
	1647: -libc.Float32FromFloat32(0.90882699),
	1648: -libc.Float32FromFloat32(0.91420976),
	1649: -libc.Float32FromFloat32(0.91943588),
	1650: -libc.Float32FromFloat32(0.92450446),
	1651: -libc.Float32FromFloat32(0.92941463),
	1652: -libc.Float32FromFloat32(0.93416555),
	1653: -libc.Float32FromFloat32(0.93875641),
	1654: -libc.Float32FromFloat32(0.94318642),
	1655: -libc.Float32FromFloat32(0.94745482),
	1656: -libc.Float32FromFloat32(0.95156087),
	1657: -libc.Float32FromFloat32(0.95550388),
	1658: -libc.Float32FromFloat32(0.95928317),
	1659: -libc.Float32FromFloat32(0.96289809),
	1660: -libc.Float32FromFloat32(0.96634802),
	1661: -libc.Float32FromFloat32(0.96963238),
	1662: -libc.Float32FromFloat32(0.97275059),
	1663: -libc.Float32FromFloat32(0.97570213),
	1664: -libc.Float32FromFloat32(0.97848649),
	1665: -libc.Float32FromFloat32(0.98110318),
	1666: -libc.Float32FromFloat32(0.98355177),
	1667: -libc.Float32FromFloat32(0.98583184),
	1668: -libc.Float32FromFloat32(0.98794298),
	1669: -libc.Float32FromFloat32(0.98988485),
	1670: -libc.Float32FromFloat32(0.99165711),
	1671: -libc.Float32FromFloat32(0.99325945),
	1672: -libc.Float32FromFloat32(0.9946916),
	1673: -libc.Float32FromFloat32(0.99595331),
	1674: -libc.Float32FromFloat32(0.99704438),
	1675: -libc.Float32FromFloat32(0.9979646),
	1676: -libc.Float32FromFloat32(0.99871383),
	1677: -libc.Float32FromFloat32(0.99929194),
	1678: -libc.Float32FromFloat32(0.99969882),
	1679: -libc.Float32FromFloat32(0.99993441),
	1680: libc.Float32FromFloat32(0.99999465),
	1681: libc.Float32FromFloat32(0.99956631),
	1682: libc.Float32FromFloat32(0.99845292),
	1683: libc.Float32FromFloat32(0.99665524),
	1684: libc.Float32FromFloat32(0.9941745),
	1685: libc.Float32FromFloat32(0.99101241),
	1686: libc.Float32FromFloat32(0.98717112),
	1687: libc.Float32FromFloat32(0.98265328),
	1688: libc.Float32FromFloat32(0.97746197),
	1689: libc.Float32FromFloat32(0.97160077),
	1690: libc.Float32FromFloat32(0.96507367),
	1691: libc.Float32FromFloat32(0.95788516),
	1692: libc.Float32FromFloat32(0.95004017),
	1693: libc.Float32FromFloat32(0.94154407),
	1694: libc.Float32FromFloat32(0.93240267),
	1695: libc.Float32FromFloat32(0.92262226),
	1696: libc.Float32FromFloat32(0.91220953),
	1697: libc.Float32FromFloat32(0.90117161),
	1698: libc.Float32FromFloat32(0.88951608),
	1699: libc.Float32FromFloat32(0.87725091),
	1700: libc.Float32FromFloat32(0.86438452),
	1701: libc.Float32FromFloat32(0.85092573),
	1702: libc.Float32FromFloat32(0.83688375),
	1703: libc.Float32FromFloat32(0.82226822),
	1704: libc.Float32FromFloat32(0.80708914),
	1705: libc.Float32FromFloat32(0.79135693),
	1706: libc.Float32FromFloat32(0.77508236),
	1707: libc.Float32FromFloat32(0.75827658),
	1708: libc.Float32FromFloat32(0.74095113),
	1709: libc.Float32FromFloat32(0.72311786),
	1710: libc.Float32FromFloat32(0.704789),
	1711: libc.Float32FromFloat32(0.68597711),
	1712: libc.Float32FromFloat32(0.66669509),
	1713: libc.Float32FromFloat32(0.64695615),
	1714: libc.Float32FromFloat32(0.62677382),
	1715: libc.Float32FromFloat32(0.60616193),
	1716: libc.Float32FromFloat32(0.58513461),
	1717: libc.Float32FromFloat32(0.56370626),
	1718: libc.Float32FromFloat32(0.54189158),
	1719: libc.Float32FromFloat32(0.51970551),
	1720: libc.Float32FromFloat32(0.49716327),
	1721: libc.Float32FromFloat32(0.47428029),
	1722: libc.Float32FromFloat32(0.45107226),
	1723: libc.Float32FromFloat32(0.42755509),
	1724: libc.Float32FromFloat32(0.4037449),
	1725: libc.Float32FromFloat32(0.379658),
	1726: libc.Float32FromFloat32(0.3553109),
	1727: libc.Float32FromFloat32(0.33072029),
	1728: libc.Float32FromFloat32(0.30590302),
	1729: libc.Float32FromFloat32(0.2808761),
	1730: libc.Float32FromFloat32(0.25565668),
	1731: libc.Float32FromFloat32(0.23026205),
	1732: libc.Float32FromFloat32(0.2047096),
	1733: libc.Float32FromFloat32(0.17901686),
	1734: libc.Float32FromFloat32(0.15320143),
	1735: libc.Float32FromFloat32(0.127281),
	1736: libc.Float32FromFloat32(0.10127334),
	1737: libc.Float32FromFloat32(0.075196277),
	1738: libc.Float32FromFloat32(0.049067674),
	1739: libc.Float32FromFloat32(0.022905443),
	1740: -libc.Float32FromFloat32(0.0032724865),
	1741: -libc.Float32FromFloat32(0.029448173),
	1742: -libc.Float32FromFloat32(0.055603678),
	1743: -libc.Float32FromFloat32(0.081721074),
	1744: -libc.Float32FromFloat32(0.10778246),
	1745: -libc.Float32FromFloat32(0.13376998),
	1746: -libc.Float32FromFloat32(0.15966582),
	1747: -libc.Float32FromFloat32(0.18545224),
	1748: -libc.Float32FromFloat32(0.21111155),
	1749: -libc.Float32FromFloat32(0.23662618),
	1750: -libc.Float32FromFloat32(0.26197864),
	1751: -libc.Float32FromFloat32(0.28715155),
	1752: -libc.Float32FromFloat32(0.31212766),
	1753: -libc.Float32FromFloat32(0.33688985),
	1754: -libc.Float32FromFloat32(0.36142116),
	1755: -libc.Float32FromFloat32(0.38570477),
	1756: -libc.Float32FromFloat32(0.40972403),
	1757: -libc.Float32FromFloat32(0.43346249),
	1758: -libc.Float32FromFloat32(0.45690388),
	1759: -libc.Float32FromFloat32(0.48003212),
	1760: -libc.Float32FromFloat32(0.50283138),
	1761: -libc.Float32FromFloat32(0.52528602),
	1762: -libc.Float32FromFloat32(0.54738066),
	1763: -libc.Float32FromFloat32(0.56910015),
	1764: -libc.Float32FromFloat32(0.5904296),
	1765: -libc.Float32FromFloat32(0.61135441),
	1766: -libc.Float32FromFloat32(0.63186022),
	1767: -libc.Float32FromFloat32(0.65193299),
	1768: -libc.Float32FromFloat32(0.67155895),
	1769: -libc.Float32FromFloat32(0.69072467),
	1770: -libc.Float32FromFloat32(0.70941699),
	1771: -libc.Float32FromFloat32(0.72762312),
	1772: -libc.Float32FromFloat32(0.74533057),
	1773: -libc.Float32FromFloat32(0.7625272),
	1774: -libc.Float32FromFloat32(0.77920124),
	1775: -libc.Float32FromFloat32(0.79534126),
	1776: -libc.Float32FromFloat32(0.81093618),
	1777: -libc.Float32FromFloat32(0.82597533),
	1778: -libc.Float32FromFloat32(0.8404484),
	1779: -libc.Float32FromFloat32(0.85434547),
	1780: -libc.Float32FromFloat32(0.86765701),
	1781: -libc.Float32FromFloat32(0.8803739),
	1782: -libc.Float32FromFloat32(0.89248743),
	1783: -libc.Float32FromFloat32(0.90398929),
	1784: -libc.Float32FromFloat32(0.91487161),
	1785: -libc.Float32FromFloat32(0.92512691),
	1786: -libc.Float32FromFloat32(0.93474818),
	1787: -libc.Float32FromFloat32(0.94372882),
	1788: -libc.Float32FromFloat32(0.95206268),
	1789: -libc.Float32FromFloat32(0.95974404),
	1790: -libc.Float32FromFloat32(0.96676764),
	1791: -libc.Float32FromFloat32(0.97312866),
	1792: -libc.Float32FromFloat32(0.97882275),
	1793: -libc.Float32FromFloat32(0.98384601),
	1794: -libc.Float32FromFloat32(0.98819498),
	1795: -libc.Float32FromFloat32(0.9918667),
	1796: -libc.Float32FromFloat32(0.99485864),
	1797: -libc.Float32FromFloat32(0.99716875),
	1798: -libc.Float32FromFloat32(0.99879546),
	1799: -libc.Float32FromFloat32(0.99973764),
}
var mode48000_960_120 = OpusT_OpusCustomMode{
	FFs:        int32(48000),
	Foverlap:   int32(120),
	FnbEBands:  int32(21),
	FeffEBands: int32(21),
	Fpreemph: [4]OpusT_opus_val16{
		0: libc.Float32FromFloat32(0.8500061),
		2: libc.Float32FromFloat32(1),
		3: libc.Float32FromFloat32(1),
	},
	FeBands:         uintptr(unsafe.Pointer(&eband5ms)),
	FmaxLM:          int32(3),
	FnbShortMdcts:   int32(8),
	FshortMdctSize:  int32(120),
	FnbAllocVectors: int32(11),
	FallocVectors:   uintptr(unsafe.Pointer(&band_allocation)),
	FlogN:           uintptr(unsafe.Pointer(&logN400)),
	Fwindow:         uintptr(unsafe.Pointer(&window120)),
	Fmdct: OpusT_mdct_lookup{
		Fn:        int32(1920),
		Fmaxshift: int32(3),
		Fkfft: [4]uintptr{
			0: uintptr(unsafe.Pointer(&fft_state48000_960_0)),
			1: uintptr(unsafe.Pointer(&fft_state48000_960_1)),
			2: uintptr(unsafe.Pointer(&fft_state48000_960_2)),
			3: uintptr(unsafe.Pointer(&fft_state48000_960_3)),
		},
		Ftrig: uintptr(unsafe.Pointer(&mdct_twiddles960)),
	},
	Fcache: OpusT_PulseCache{
		Fsize:  int32(392),
		Findex: uintptr(unsafe.Pointer(&cache_index50)),
		Fbits:  uintptr(unsafe.Pointer(&cache_bits50)),
		Fcaps:  uintptr(unsafe.Pointer(&cache_caps50)),
	},
}
var static_mode_list = [1]uintptr{
	0: uintptr(unsafe.Pointer(&mode48000_960_120)),
}

func Opus_opus_custom_mode_create(tls *libc.TLS, Fs OpusT_opus_int32, frame_size int32, error1 uintptr) (r uintptr) {
	var i, j int32
	_, _ = i, j
	i = 0
	for {
		if !(i < int32(TOTAL_MODES)) {
			break
		}
		j = 0
		for {
			if !(j < int32(4)) {
				break
			}
			if Fs == (*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FFs && frame_size<<j == (*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FshortMdctSize*(*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FnbShortMdcts {
				if error1 != 0 {
					*(*int32)(unsafe.Pointer(error1)) = OPUS_OK
				}
				return static_mode_list[i]
			}
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = -int32(1)
	}
	return libc.UintptrFromInt32(0)
}

const EPSILON1 = 1e-15
const Q15ONE3 = 1

var log2_x_norm_coeff12 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff12 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf13 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf13 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf13 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func exp_rotation1(tls *libc.TLS, X uintptr, len1 int32, stride int32, c OpusT_opus_val16, s OpusT_opus_val16) {
	var Xptr, v2 uintptr
	var i int32
	var ms OpusT_opus_val16
	var x1, x11, x2, x21 OpusT_celt_norm
	_, _, _, _, _, _, _, _ = Xptr, i, ms, x1, x11, x2, x21, v2
	Xptr = X
	ms = -s
	i = 0
	for {
		if !(i < len1-stride) {
			break
		}
		x1 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr))
		x2 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4)) = OpusT_opus_val32(c*x2) + OpusT_opus_val32(s*x1)
		v2 = Xptr
		Xptr += 4
		*(*OpusT_celt_norm)(unsafe.Pointer(v2)) = OpusT_opus_val32(c*x1) + OpusT_opus_val32(ms*x2)
		goto _1
	_1:
		;
		i = i + 1
	}
	Xptr = X + uintptr(len1-int32(2)*stride-int32(1))*4
	i = len1 - int32(2)*stride - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		x11 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr))
		x21 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4)) = OpusT_opus_val32(c*x21) + OpusT_opus_val32(s*x11)
		v2 = Xptr
		Xptr -= 4
		*(*OpusT_celt_norm)(unsafe.Pointer(v2)) = OpusT_opus_val32(c*x11) + OpusT_opus_val32(ms*x21)
		goto _3
	_3:
		;
		i = i - 1
	}
}

func Opus_exp_rotation(tls *libc.TLS, X uintptr, len1 int32, dir int32, stride int32, K int32, spread int32) {
	var c, gain, s, theta OpusT_opus_val16
	var factor, i, stride2 int32
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _ = c, factor, gain, i, s, stride2, theta, v1, v2
	stride2 = 0
	if int32(2)*K >= len1 || spread == SPREAD_NONE {
		return
	}
	factor = SPREAD_FACTOR[spread-int32(1)]
	gain = OpusT_opus_val32(libc.Float32FromFloat32(1)*float32(len1)) / float32(len1+factor*K)
	theta = float32(libc.Float32FromFloat32(0.5) * OpusT_opus_val16(gain*gain))
	c = float32(libc.Xcos(tls, float64(float64(libc.Float64FromFloat32(0.5)*libc.Float64FromFloat64(3.141592653589793))*float64(theta))))
	s = float32(libc.Xcos(tls, float64(float64(libc.Float64FromFloat32(0.5)*libc.Float64FromFloat64(3.141592653589793))*float64(libc.Float32FromFloat32(1)-theta)))) /*  sin(theta) */
	if len1 >= int32(8)*stride {
		stride2 = int32(1)
		/* This is just a simple (equivalent) way of computing sqrt(len/stride) with rounding.
		   It's basically incrementing long as (stride2+0.5)^2 < len/stride. */
		for (stride2*stride2+stride2)*stride+stride>>int32(2) < len1 {
			stride2 = stride2 + 1
		}
	}
	/*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
	  extract_collapse_mask().*/
	v1 = libc.Uint32FromInt32(stride)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(len1) / v1
	goto _3
_3:
	len1 = libc.Int32FromUint32(v2)
	i = 0
	for {
		if !(i < stride) {
			break
		}
		if dir < 0 {
			if stride2 != 0 {
				exp_rotation1(tls, X+uintptr(i*len1)*4, len1, stride2, s, c)
			}
			exp_rotation1(tls, X+uintptr(i*len1)*4, len1, int32(1), c, s)
		} else {
			exp_rotation1(tls, X+uintptr(i*len1)*4, len1, int32(1), c, -s)
			if stride2 != 0 {
				exp_rotation1(tls, X+uintptr(i*len1)*4, len1, stride2, s, -c)
			}
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

var SPREAD_FACTOR = [3]int32{
	0: int32(15),
	1: int32(10),
	2: int32(5),
}

// C documentation
//
//	/** Normalizes the decoded integer pvq codeword to unit norm. */
func normalise_residual(tls *libc.TLS, iy uintptr, X uintptr, N int32, Ryy OpusT_opus_val32, gain OpusT_opus_val32, shift int32) {
	var g, t OpusT_opus_val32
	var i, v1 int32
	_, _, _, _ = g, i, t, v1
	t = Ryy
	g = float32(libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t))) * gain)
	i = 0
	_ = shift
	for {
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i)*4)) = OpusT_opus_val32(float32(*(*int32)(unsafe.Pointer(iy + uintptr(i)*4))) * g)
		goto _2
	_2:
		;
		i = i + 1
		v1 = i
		if !(v1 < N) {
			break
		}
	}
}

func extract_collapse_mask(tls *libc.TLS, iy uintptr, N int32, B int32) (r uint32) {
	var N0, i, j, v4 int32
	var collapse_mask, tmp uint32
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _ = N0, collapse_mask, i, j, tmp, v1, v2, v4
	if B <= int32(1) {
		return uint32(1)
	}
	/*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
	  exp_rotation().*/
	v1 = libc.Uint32FromInt32(B)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(N) / v1
	goto _3
_3:
	N0 = libc.Int32FromUint32(v2)
	collapse_mask = uint32(0)
	i = 0
	for {
		tmp = uint32(0)
		j = 0
		for {
			tmp = tmp | libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(iy + uintptr(i*N0+j)*4)))
			goto _7
		_7:
			;
			j = j + 1
			v4 = j
			if !(v4 < N0) {
				break
			}
		}
		collapse_mask = collapse_mask | libc.Uint32FromInt32(libc.BoolInt32(tmp != uint32(0))<<i)
		goto _5
	_5:
		;
		i = i + 1
		v4 = i
		if !(v4 < B) {
			break
		}
	}
	return collapse_mask
}

func Opus_op_pvq_search_c(tls *libc.TLS, X uintptr, iy uintptr, K int32, N int32, arch int32) (r OpusT_opus_val16) {
	var Rxy, Ryy, best_den, rcp, tmp, yy, v55 OpusT_opus_val16
	var _saved_stack, signx, st, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var best_id, i, j, pulsesLeft, v53 int32
	var best_num, sum, xy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Rxy, Ryy, _saved_stack, best_den, best_id, best_num, i, j, pulsesLeft, rcp, signx, st, sum, tmp, xy, y, yy, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v53, v55, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = arch
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4855, int32(217))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	y = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4855, int32(218))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	signx = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Get rid of the sign */
	sum = libc.Float32FromInt32(0)
	j = 0
	for {
		*(*int32)(unsafe.Pointer(signx + uintptr(j)*4)) = libc.BoolInt32(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) < libc.Float32FromInt32(0))
		/* OPT: Make sure the compiler doesn't use a branch on ABS16(). */
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = float32(libc.Xfabs(tls, float64(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))))
		*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = 0
		*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) = libc.Float32FromInt32(0)
		goto _54
	_54:
		;
		j = j + 1
		v53 = j
		if !(v53 < N) {
			break
		}
	}
	v55 = libc.Float32FromInt32(0)
	yy = v55
	xy = v55
	pulsesLeft = K
	/* Do a pre-search by projecting on the pyramid */
	if K > N>>int32(1) {
		j = 0
		for {
			sum = sum + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))
			goto _57
		_57:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
		/* If X is too small, just replace it with a pulse at 0 */
		/* Prevents infinities and NaNs from causing too many pulses
		   to be allocated. 64 is an approximation of infinity here. */
		if !(sum > libc.Float32FromFloat32(1e-15) && sum < libc.Float32FromInt32(64)) {
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = libc.Float32FromFloat32(1)
			j = int32(1)
			for {
				*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = libc.Float32FromInt32(0)
				goto _59
			_59:
				;
				j = j + 1
				v53 = j
				if !(v53 < N) {
					break
				}
			}
			sum = libc.Float32FromFloat32(1)
		}
		/* Using K+e with e < 1 guarantees we cannot get more than K pulses. */
		rcp = float32((float32(K) + libc.Float32FromFloat32(0.8)) * (libc.Float32FromFloat32(1) / sum))
		j = 0
		for {
			*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = int32(libc.Xfloor(tls, float64(rcp**(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))))
			*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) = float32(*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)))
			yy = yy + OpusT_opus_val16(*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)))
			xy = xy + OpusT_opus_val32(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) *= libc.Float32FromInt32(2)
			pulsesLeft = pulsesLeft - *(*int32)(unsafe.Pointer(iy + uintptr(j)*4))
			goto _61
		_61:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
	}
	_ = pulsesLeft >= libc.Int32FromInt32(0)
	/* This should never happen, but just in case it does (e.g. on silence)
	   we fill the first bin with pulses. */
	if pulsesLeft > N+int32(3) {
		tmp = float32(pulsesLeft)
		yy = yy + OpusT_opus_val16(tmp*tmp)
		yy = yy + OpusT_opus_val16(tmp**(*OpusT_celt_norm)(unsafe.Pointer(y)))
		*(*int32)(unsafe.Pointer(iy)) += pulsesLeft
		pulsesLeft = 0
	}
	i = 0
	for {
		if !(i < pulsesLeft) {
			break
		}
		best_id = 0
		/* The squared magnitude term gets added anyway, so we might as well
		   add it outside the loop */
		yy = yy + float32(libc.Int32FromInt32(1))
		/* Calculations for position 0 are out of the loop, in part to reduce
		   mispredicted branches (since the if condition is usually false)
		   in the loop. */
		/* Temporary sums of the new pulse(s) */
		Rxy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X))
		/* We're multiplying y[j] by two so we don't have to do it here */
		Ryy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y))
		/* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
		   Rxy is positive because the sign is pre-computed) */
		Rxy = OpusT_opus_val16(Rxy * Rxy)
		best_den = Ryy
		best_num = Rxy
		j = int32(1)
		for {
			/* Temporary sums of the new pulse(s) */
			Rxy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))
			/* We're multiplying y[j] by two so we don't have to do it here */
			Ryy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4))
			/* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
			   Rxy is positive because the sign is pre-computed) */
			Rxy = OpusT_opus_val16(Rxy * Rxy)
			/* The idea is to check for num/den >= best_num/best_den, but that way
			   we can do it without any division */
			/* OPT: It's not clear whether a cmov is faster than a branch here
			   since the condition is more often false than true and using
			   a cmov introduces data dependencies across iterations. The optimal
			   choice may be architecture-dependent. */
			if libc.BoolInt64(!!(OpusT_opus_val32(best_den*Rxy) > OpusT_opus_val32(Ryy*best_num))) != 0 {
				best_den = Ryy
				best_num = Rxy
				best_id = j
			}
			goto _64
		_64:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
		/* Updating the sums of the new pulse(s) */
		xy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(best_id)*4))
		/* We're multiplying y[j] by two so we don't have to do it here */
		yy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(best_id)*4))
		/* Only now that we've made the final choice, update y/iy */
		/* Multiplying y[j] by 2 so we don't have to do it everywhere else */
		*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(best_id)*4)) += libc.Float32FromInt32(2)
		*(*int32)(unsafe.Pointer(iy + uintptr(best_id)*4)) = *(*int32)(unsafe.Pointer(iy + uintptr(best_id)*4)) + 1
		goto _62
	_62:
		;
		i = i + 1
	}
	/* Put the original sign back */
	j = 0
	for {
		/*iy[j] = signx[j] ? -iy[j] : iy[j];*/
		/* OPT: The is more likely to be compiled without a branch than the code above
		   but has the same performance otherwise. */
		*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) ^ -*(*int32)(unsafe.Pointer(signx + uintptr(j)*4)) + *(*int32)(unsafe.Pointer(signx + uintptr(j)*4))
		goto _66
	_66:
		;
		j = j + 1
		v53 = j
		if !(v53 < N) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _70
_70:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return yy
}

func Opus_alg_quant(tls *libc.TLS, X uintptr, N int32, K int32, spread int32, B int32, enc uintptr, gain OpusT_opus_val32, resynth int32, arch int32) (r uint32) {
	var _saved_stack, iy, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var collapse_mask uint32
	var yy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, collapse_mask, iy, st, yy, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4868, __ccgo_ts+4855, int32(562))
	}
	if !(N > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+4927, __ccgo_ts+4855, int32(563))
	}
	/* Covers vectorization by up to 4. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N+libc.Int32FromInt32(3))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4855, int32(566))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N+libc.Int32FromInt32(3)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	iy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N+libc.Int32FromInt32(3))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_exp_rotation(tls, X, N, int32(1), B, K, spread)
	yy = Opus_op_pvq_search_c(tls, X, iy, K, N, arch)
	collapse_mask = extract_collapse_mask(tls, iy, N, B)
	Opus_encode_pulses(tls, iy, N, K, enc)
	if resynth != 0 {
		normalise_residual(tls, iy, X, N, yy, gain, 0)
	}
	if resynth != 0 {
		Opus_exp_rotation(tls, X, N, -int32(1), B, K, spread)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return collapse_mask
}

// C documentation
//
//	/** Decode pulse vector and combine the result with the pitch vector to produce
//	    the final normalised signal in the current band. */
func Opus_alg_unquant(tls *libc.TLS, X uintptr, N int32, K int32, spread int32, B int32, dec uintptr, gain OpusT_opus_val32) (r uint32) {
	var Ryy OpusT_opus_val32
	var _saved_stack, iy, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var collapse_mask uint32
	var yy_shift int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Ryy, _saved_stack, collapse_mask, iy, st, yy_shift, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	yy_shift = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+4991, __ccgo_ts+4855, int32(629))
	}
	if !(N > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+5052, __ccgo_ts+4855, int32(630))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4855, int32(631))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	iy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Ryy = Opus_decode_pulses(tls, iy, N, K, dec)
	normalise_residual(tls, iy, X, N, Ryy, gain, yy_shift)
	Opus_exp_rotation(tls, X, N, -int32(1), B, K, spread)
	collapse_mask = extract_collapse_mask(tls, iy, N, B)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return collapse_mask
}

func Opus_renormalise_vector(tls *libc.TLS, X uintptr, N1 int32, gain OpusT_opus_val32, arch int32) {
	var E, t, xy, v2 OpusT_opus_val32
	var g OpusT_opus_val16
	var i, i1 int32
	var xptr uintptr
	_, _, _, _, _, _, _, _ = E, g, i, i1, t, xptr, xy, v2
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	v2 = xy
	goto _3
_3:
	E = libc.Float32FromFloat32(1e-15) + v2
	t = E
	g = float32(libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t))) * gain)
	xptr = X
	i1 = 0
	for {
		if !(i1 < N1) {
			break
		}
		*(*OpusT_celt_norm)(unsafe.Pointer(xptr)) = OpusT_opus_val32(g * *(*OpusT_celt_norm)(unsafe.Pointer(xptr)))
		xptr += 4
		goto _4
	_4:
		;
		i1 = i1 + 1
	}
	/*return celt_sqrt(E);*/
}

func Opus_stereo_itheta(tls *libc.TLS, X uintptr, Y uintptr, stereo int32, N1 int32, arch int32) (r OpusT_opus_int32) {
	var Emid, Eside, mid, side, xy, v1 OpusT_opus_val32
	var i, i1, itheta int32
	var m, s OpusT_celt_norm
	var x_sq, v10, v11, v13, v14, v16, v17, v9 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Emid, Eside, i, i1, itheta, m, mid, s, side, x_sq, xy, v1, v10, v11, v13, v14, v16, v17, v9
	v1 = libc.Float32FromInt32(0)
	Eside = v1
	Emid = v1
	if stereo != 0 {
		i1 = 0
		for {
			if !(i1 < N1) {
				break
			}
			m = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i1)*4)) + *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(i1)*4))
			s = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i1)*4)) - *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(i1)*4))
			Emid = Emid + OpusT_opus_val32(m*m)
			Eside = Eside + OpusT_opus_val32(s*s)
			goto _2
		_2:
			;
			i1 = i1 + 1
		}
	} else {
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N1) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
			goto _3
		_3:
			;
			i = i + 1
		}
		v1 = xy
		goto _5
	_5:
		Emid = Emid + v1
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N1) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
			goto _6
		_6:
			;
			i = i + 1
		}
		v1 = xy
		goto _8
	_8:
		Eside = Eside + v1
	}
	mid = float32(libc.Xsqrt(tls, float64(Emid)))
	side = float32(libc.Xsqrt(tls, float64(Eside)))
	v9 = side
	v10 = mid
	_ = v10 >= libc.Float32FromInt32(0) && v9 >= libc.Float32FromInt32(0)
	if float32(v10*v10)+float32(v9*v9) < libc.Float32FromFloat32(1e-18) {
		v11 = libc.Float32FromInt32(0)
		goto _12
	}
	if v9 < v10 {
		v13 = v9 / v10
		x_sq = float32(v13 * v13)
		v14 = float32(libc.Float32FromFloat32(0.636619772367581) * (v13 + float32(float32(v13*x_sq)*(-libc.Float32FromFloat32(0.3333165943622589)+float32(x_sq*(libc.Float32FromFloat32(0.19962704181671143)+float32(x_sq*(-libc.Float32FromFloat32(0.13976582884788513)+float32(x_sq*(libc.Float32FromFloat32(0.09794234484434128)+float32(x_sq*(-libc.Float32FromFloat32(0.057773590087890625)+float32(x_sq*(libc.Float32FromFloat32(0.023040136322379112)+float32(x_sq*-libc.Float32FromFloat32(0.0043554059229791164))))))))))))))))
		goto _15
	_15:
		v11 = v14
		goto _12
	} else {
		v16 = v10 / v9
		x_sq = float32(v16 * v16)
		v17 = float32(libc.Float32FromFloat32(0.636619772367581) * (v16 + float32(float32(v16*x_sq)*(-libc.Float32FromFloat32(0.3333165943622589)+float32(x_sq*(libc.Float32FromFloat32(0.19962704181671143)+float32(x_sq*(-libc.Float32FromFloat32(0.13976582884788513)+float32(x_sq*(libc.Float32FromFloat32(0.09794234484434128)+float32(x_sq*(-libc.Float32FromFloat32(0.057773590087890625)+float32(x_sq*(libc.Float32FromFloat32(0.023040136322379112)+float32(x_sq*-libc.Float32FromFloat32(0.0043554059229791164))))))))))))))))
		goto _18
	_18:
		v11 = libc.Float32FromFloat32(1) - v17
		goto _12
	}
_12:
	itheta = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+float32(float32(libc.Float32FromFloat32(65536)*libc.Float32FromInt32(16384))*v11))))
	return itheta
}

const ALLOC_STEPS = 6
const EPSILON2 = "1e-15f"
const Q15ONE4 = "1.0f"

var trim_icdf14 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf14 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf14 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff13 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff13 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var LOG2_FRAC_TABLE = [24]uint8{
	1:  uint8(8),
	2:  uint8(13),
	3:  uint8(16),
	4:  uint8(19),
	5:  uint8(21),
	6:  uint8(23),
	7:  uint8(24),
	8:  uint8(26),
	9:  uint8(27),
	10: uint8(28),
	11: uint8(29),
	12: uint8(30),
	13: uint8(31),
	14: uint8(32),
	15: uint8(32),
	16: uint8(33),
	17: uint8(34),
	18: uint8(34),
	19: uint8(35),
	20: uint8(36),
	21: uint8(36),
	22: uint8(37),
	23: uint8(37),
}

func interp_bits2pulses(tls *libc.TLS, m uintptr, start int32, end int32, skip_start int32, bits1 uintptr, bits2 uintptr, thresh uintptr, cap1 uintptr, total OpusT_opus_int32, _balance uintptr, skip_rsv int32, intensity uintptr, intensity_rsv int32, dual_stereo uintptr, dual_stereo_rsv int32, bits uintptr, ebits uintptr, fine_priority uintptr, C int32, LM int32, ec uintptr, encode int32, prev int32, signalBandwidth int32) (r int32) {
	var N, N0, NClogN, alloc_floor, band_bits, band_width, codedBands, den, depth_threshold, done, extra_bits, extra_fine, hi, i, j, lo, logM, mid, offset, rem, stereo, tmp, tmp1, tmp2, v7, v8 int32
	var _saved_stack, st, v1, v3 uintptr
	var balance, bit, excess, left, percoeff, psum OpusT_opus_int32
	var v13, v14 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N0, NClogN, _saved_stack, alloc_floor, balance, band_bits, band_width, bit, codedBands, den, depth_threshold, done, excess, extra_bits, extra_fine, hi, i, j, left, lo, logM, mid, offset, percoeff, psum, rem, st, stereo, tmp, tmp1, tmp2, v1, v13, v14, v3, v7, v8
	codedBands = -int32(1)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	alloc_floor = C << int32(BITRES)
	stereo = libc.BoolInt32(C > int32(1))
	logM = LM << int32(BITRES)
	lo = 0
	hi = libc.Int32FromInt32(1) << libc.Int32FromInt32(ALLOC_STEPS)
	i = 0
	for {
		if !(i < int32(ALLOC_STEPS)) {
			break
		}
		mid = (lo + hi) >> int32(1)
		psum = 0
		done = 0
		j = end
		for {
			v7 = j
			j = j - 1
			if !(v7 > start) {
				break
			}
			tmp = *(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) + mid**(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4))>>int32(ALLOC_STEPS)
			if tmp >= *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) || done != 0 {
				done = int32(1)
				/* Don't allocate more than we can actually use */
				if tmp < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
					v7 = tmp
				} else {
					v7 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
				}
				psum = psum + v7
			} else {
				if tmp >= alloc_floor {
					psum = psum + alloc_floor
				}
			}
			goto _6
		_6:
		}
		if psum > total {
			hi = mid
		} else {
			lo = mid
		}
		goto _5
	_5:
		;
		i = i + 1
	}
	psum = 0
	/*printf ("interp bisection gave %d\n", lo);*/
	done = 0
	j = end
	for {
		v7 = j
		j = j - 1
		if !(v7 > start) {
			break
		}
		tmp1 = *(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) + lo**(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4))>>int32(ALLOC_STEPS)
		if tmp1 < *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) && !(done != 0) {
			if tmp1 >= alloc_floor {
				tmp1 = alloc_floor
			} else {
				tmp1 = 0
			}
		} else {
			done = int32(1)
		}
		/* Don't allocate more than we can actually use */
		if tmp1 < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
			v7 = tmp1
		} else {
			v7 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
		}
		tmp1 = v7
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = tmp1
		psum = psum + tmp1
		goto _9
	_9:
	}
	/* Decide which bands to skip, working backwards from the end. */
	codedBands = end
	for {
		j = codedBands - int32(1)
		/* Never skip the first band, nor a band that has been boosted by
		    dynalloc.
		   In the first case, we'd be coding a bit to signal we're going to waste
		    all the other bits.
		   In the second case, we'd be coding a bit to redistribute all the bits
		    we just signaled should be concentrated in this band. */
		if j <= skip_start {
			/* Give the bit we reserved to end skipping back. */
			total = total + skip_rsv
			break
		}
		/*Figure out how many left-over bits we would be adding to this band.
		  This can include bits we've stolen back from higher, skipped bands.*/
		left = total - psum
		v13 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
		_ = v13 > libc.Uint32FromInt32(0)
		v14 = libc.Uint32FromInt32(left) / v13
		goto _15
	_15:
		percoeff = libc.Int32FromUint32(v14)
		left = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))*percoeff
		if left-(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2)))) > 0 {
			v7 = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
		} else {
			v7 = 0
		}
		rem = v7
		band_width = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		band_bits = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + percoeff*band_width + rem
		/*Only code a skip decision if we're above the threshold for this band.
		  Otherwise it is force-skipped.
		  This ensures that we have enough bits to code the skip flag.*/
		if *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) > alloc_floor+libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
			v7 = *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4))
		} else {
			v7 = alloc_floor + libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
		}
		if band_bits >= v7 {
			if encode != 0 {
				/*We choose a threshold with some hysteresis to keep bands from
				  fluctuating in and out, but we try not to fold below a certain point. */
				if codedBands > int32(17) {
					if j < prev {
						v8 = int32(7)
					} else {
						v8 = int32(9)
					}
					depth_threshold = v8
				} else {
					depth_threshold = 0
				}
				if codedBands <= start+int32(2) || band_bits > depth_threshold*band_width<<LM<<int32(BITRES)>>int32(4) && j <= signalBandwidth {
					Opus_ec_enc_bit_logp(tls, ec, int32(1), uint32(1))
					break
				}
				Opus_ec_enc_bit_logp(tls, ec, 0, uint32(1))
			} else {
				if Opus_ec_dec_bit_logp(tls, ec, uint32(1)) != 0 {
					break
				}
			}
			/*We used a bit to skip this band.*/
			psum = psum + libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
			band_bits = band_bits - libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
		}
		/*Reclaim the bits originally allocated to this band.*/
		psum = psum - (*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + intensity_rsv)
		if intensity_rsv > 0 {
			intensity_rsv = libc.Int32FromUint8(LOG2_FRAC_TABLE[j-start])
		}
		psum = psum + intensity_rsv
		if band_bits >= alloc_floor {
			/*If we have enough for a fine energy bit per channel, use it.*/
			psum = psum + alloc_floor
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = alloc_floor
		} else {
			/*Otherwise this band gets nothing at all.*/
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = 0
		}
		goto _12
	_12:
		;
		codedBands = codedBands - 1
	}
	if !(codedBands > start) {
		Opus_celt_fatal(tls, __ccgo_ts+5118, __ccgo_ts+5155, int32(394))
	}
	/* Code the intensity and dual stereo parameters. */
	if intensity_rsv > 0 {
		if encode != 0 {
			if *(*int32)(unsafe.Pointer(intensity)) < codedBands {
				v7 = *(*int32)(unsafe.Pointer(intensity))
			} else {
				v7 = codedBands
			}
			*(*int32)(unsafe.Pointer(intensity)) = v7
			Opus_ec_enc_uint(tls, ec, libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(intensity))-start), libc.Uint32FromInt32(codedBands+int32(1)-start))
		} else {
			*(*int32)(unsafe.Pointer(intensity)) = libc.Int32FromUint32(libc.Uint32FromInt32(start) + Opus_ec_dec_uint(tls, ec, libc.Uint32FromInt32(codedBands+int32(1)-start)))
		}
	} else {
		*(*int32)(unsafe.Pointer(intensity)) = 0
	}
	if *(*int32)(unsafe.Pointer(intensity)) <= start {
		total = total + dual_stereo_rsv
		dual_stereo_rsv = 0
	}
	if dual_stereo_rsv > 0 {
		if encode != 0 {
			Opus_ec_enc_bit_logp(tls, ec, *(*int32)(unsafe.Pointer(dual_stereo)), uint32(1))
		} else {
			*(*int32)(unsafe.Pointer(dual_stereo)) = Opus_ec_dec_bit_logp(tls, ec, uint32(1))
		}
	} else {
		*(*int32)(unsafe.Pointer(dual_stereo)) = 0
	}
	/* Allocate the remaining bits */
	left = total - psum
	v13 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
	_ = v13 > libc.Uint32FromInt32(0)
	v14 = libc.Uint32FromInt32(left) / v13
	goto _22
_22:
	percoeff = libc.Int32FromUint32(v14)
	left = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))*percoeff
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) += percoeff * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))
		goto _23
	_23:
		;
		j = j + 1
	}
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		if left < int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))) {
			v7 = left
		} else {
			v7 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		}
		tmp2 = v7
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) += tmp2
		left = left - tmp2
		goto _24
	_24:
		;
		j = j + 1
	}
	/*for (j=0;j<end;j++)printf("%d ", bits[j]);printf("\n");*/
	balance = 0
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		if !(*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5170, __ccgo_ts+5155, int32(445))
		}
		N0 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		N = N0 << LM
		bit = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + balance
		if N > int32(1) {
			if bit-*(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) > 0 {
				v7 = bit - *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
			} else {
				v7 = 0
			}
			excess = v7
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = bit - excess
			/* Compensate for the extra DoF in stereo */
			if C == int32(2) && N > int32(2) && !(*(*int32)(unsafe.Pointer(dual_stereo)) != 0) && j < *(*int32)(unsafe.Pointer(intensity)) {
				v7 = int32(1)
			} else {
				v7 = 0
			}
			den = C*N + v7
			NClogN = den * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FlogN + uintptr(j)*2))) + logM)
			/* Offset for the number of fine bits by log2(N)/2 + FINE_OFFSET
			   compared to their "fair share" of total/N */
			offset = NClogN>>int32(1) - den*int32(FINE_OFFSET)
			/* N=2 is the only point that doesn't match the curve */
			if N == int32(2) {
				offset = offset + den<<int32(BITRES)>>int32(2)
			}
			/* Changing the offset for allocating the second and third
			   fine energy bit */
			if *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset < den*int32(2)<<int32(BITRES) {
				offset = offset + NClogN>>int32(2)
			} else {
				if *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset < den*int32(3)<<int32(BITRES) {
					offset = offset + NClogN>>int32(3)
				}
			}
			/* Divide with rounding */
			if 0 > *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset+den<<(libc.Int32FromInt32(BITRES)-libc.Int32FromInt32(1)) {
				v7 = 0
			} else {
				v7 = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + offset + den<<(libc.Int32FromInt32(BITRES)-libc.Int32FromInt32(1))
			}
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = v7
			v13 = libc.Uint32FromInt32(den)
			_ = v13 > libc.Uint32FromInt32(0)
			v14 = libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))) / v13
			goto _32
		_32:
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = libc.Int32FromUint32(v14 >> int32(BITRES))
			/* Make sure not to bust */
			if C**(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) > *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))>>int32(BITRES) {
				*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >> stereo >> int32(BITRES)
			}
			/* More than that is useless because that's about as far as PVQ can go */
			if *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) < int32(MAX_FINE_BITS) {
				v7 = *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))
			} else {
				v7 = int32(MAX_FINE_BITS)
			}
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = v7
			/* If we rounded down or capped this band, make it a candidate for the
			   final fine energy pass */
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))*(den<<int32(BITRES)) >= *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset)
			/* Remove the allocated fine bits; the rest are assigned to PVQ */
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) -= C * *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) << int32(BITRES)
		} else {
			/* For N=1, all bits go to fine energy except for a single sign bit */
			if 0 > bit-C<<int32(BITRES) {
				v7 = 0
			} else {
				v7 = bit - C<<int32(BITRES)
			}
			excess = v7
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = bit - excess
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = 0
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = int32(1)
		}
		/* Fine energy can't take advantage of the re-balancing in
		   quant_all_bands().
		  Instead, do the re-balancing here.*/
		if excess > 0 {
			if excess>>(stereo+libc.Int32FromInt32(BITRES)) < int32(MAX_FINE_BITS)-*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) {
				v7 = excess >> (stereo + libc.Int32FromInt32(BITRES))
			} else {
				v7 = int32(MAX_FINE_BITS) - *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))
			}
			extra_fine = v7
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) += extra_fine
			extra_bits = extra_fine * C << int32(BITRES)
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(extra_bits >= excess-balance)
			excess = excess - extra_bits
		}
		balance = excess
		if !(*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5170, __ccgo_ts+5155, int32(516))
		}
		if !(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5201, __ccgo_ts+5155, int32(517))
		}
		goto _26
	_26:
		;
		j = j + 1
	}
	/* Save any remaining bits over the cap for the rebalancing in
	   quant_all_bands(). */
	*(*OpusT_opus_int32)(unsafe.Pointer(_balance)) = balance
	/* The skipped bands use all their bits for fine energy. */
	for {
		if !(j < end) {
			break
		}
		*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >> stereo >> int32(BITRES)
		if !(C**(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))<<libc.Int32FromInt32(BITRES) == *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))) {
			Opus_celt_fatal(tls, __ccgo_ts+5233, __ccgo_ts+5155, int32(527))
		}
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = 0
		*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) < int32(1))
		goto _36
	_36:
		;
		j = j + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _40
_40:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return codedBands
}

func Opus_clt_compute_allocation(tls *libc.TLS, m uintptr, start int32, end int32, offsets uintptr, cap1 uintptr, alloc_trim int32, intensity uintptr, dual_stereo uintptr, total OpusT_opus_int32, balance uintptr, pulses uintptr, ebits uintptr, fine_priority uintptr, C int32, LM int32, ec uintptr, encode int32, prev int32, signalBandwidth int32) (r int32) {
	var N, N1, bits1j, bits2j, bitsj, codedBands, done, dual_stereo_rsv, hi, intensity_rsv, j, len1, lo, mid, psum, skip_rsv, skip_start, v5 int32
	var _saved_stack, bits1, bits2, st, thresh, trim_offset, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N1, _saved_stack, bits1, bits1j, bits2, bits2j, bitsj, codedBands, done, dual_stereo_rsv, hi, intensity_rsv, j, len1, lo, mid, psum, skip_rsv, skip_start, st, thresh, trim_offset, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v5, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if total > 0 {
		v5 = total
	} else {
		v5 = 0
	}
	total = v5
	len1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands
	skip_start = start
	/* Reserve a bit to signal the end of manually skipped bands. */
	if total >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
		v5 = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
	} else {
		v5 = 0
	}
	skip_rsv = v5
	total = total - skip_rsv
	/* Reserve bits for the intensity and dual stereo parameters. */
	v5 = libc.Int32FromInt32(0)
	dual_stereo_rsv = v5
	intensity_rsv = v5
	if C == int32(2) {
		intensity_rsv = libc.Int32FromUint8(LOG2_FRAC_TABLE[end-start])
		if intensity_rsv > total {
			intensity_rsv = 0
		} else {
			total = total - intensity_rsv
			if total >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
				v5 = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
			} else {
				v5 = 0
			}
			dual_stereo_rsv = v5
			total = total - dual_stereo_rsv
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _12
_12:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5155, int32(570))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _32
_32:
	bits1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5155, int32(571))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _56
_56:
	bits2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _60
_60:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5155, int32(572))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _80
_80:
	thresh = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _84
_84:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _88
_88:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _92
_92:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _96
_96:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5155, int32(573))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _100
_100:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _102
	_102:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _104
_104:
	trim_offset = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	j = start
	for {
		if !(j < end) {
			break
		}
		/* Below this threshold, we're sure not to allocate any PVQ bits */
		if C<<int32(BITRES) > int32(3)*(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))<<LM<<int32(BITRES)>>int32(4) {
			v5 = C << int32(BITRES)
		} else {
			v5 = int32(3) * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))) << LM << int32(BITRES) >> int32(4)
		}
		*(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) = v5
		/* Tilt of the allocation curve */
		*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) = C * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))) * (alloc_trim - int32(5) - LM) * (end - j - int32(1)) * (int32(1) << (LM + int32(BITRES))) >> int32(6)
		/* Giving less resolution to single-coefficient bands because they get
		   more benefit from having one coarse value per coefficient*/
		if (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))<<LM == int32(1) {
			*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) -= C << int32(BITRES)
		}
		goto _105
	_105:
		;
		j = j + 1
	}
	lo = int32(1)
	hi = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbAllocVectors - int32(1)
	for cond := true; cond; cond = lo <= hi {
		done = 0
		psum = 0
		mid = (lo + hi) >> int32(1)
		j = end
		for {
			v5 = j
			j = j - 1
			if !(v5 > start) {
				break
			}
			N = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
			bitsj = C * N * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(mid*len1+j)))) << LM >> int32(2)
			if bitsj > 0 {
				if 0 > bitsj+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
					v5 = 0
				} else {
					v5 = bitsj + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
				}
				bitsj = v5
			}
			bitsj = bitsj + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
			if bitsj >= *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) || done != 0 {
				done = int32(1)
				/* Don't allocate more than we can actually use */
				if bitsj < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
					v5 = bitsj
				} else {
					v5 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
				}
				psum = psum + v5
			} else {
				if bitsj >= C<<int32(BITRES) {
					psum = psum + C<<int32(BITRES)
				}
			}
			goto _107
		_107:
		}
		if psum > total {
			hi = mid - int32(1)
		} else {
			lo = mid + int32(1)
		}
		/*printf ("lo = %d, hi = %d\n", lo, hi);*/
	}
	v5 = lo
	lo = lo - 1
	hi = v5
	/*printf ("interp between %d and %d\n", lo, hi);*/
	j = start
	for {
		if !(j < end) {
			break
		}
		N1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		bits1j = C * N1 * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(lo*len1+j)))) << LM >> int32(2)
		if hi >= (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbAllocVectors {
			v5 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
		} else {
			v5 = C * N1 * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(hi*len1+j)))) << LM >> int32(2)
		}
		bits2j = v5
		if bits1j > 0 {
			if 0 > bits1j+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
				v5 = 0
			} else {
				v5 = bits1j + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
			}
			bits1j = v5
		}
		if bits2j > 0 {
			if 0 > bits2j+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
				v5 = 0
			} else {
				v5 = bits2j + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
			}
			bits2j = v5
		}
		if lo > 0 {
			bits1j = bits1j + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
		}
		bits2j = bits2j + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
		if *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4)) > 0 {
			skip_start = j
		}
		if 0 > bits2j-bits1j {
			v5 = 0
		} else {
			v5 = bits2j - bits1j
		}
		bits2j = v5
		*(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) = bits1j
		*(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4)) = bits2j
		goto _112
	_112:
		;
		j = j + 1
	}
	codedBands = interp_bits2pulses(tls, m, start, end, skip_start, bits1, bits2, thresh, cap1, total, balance, skip_rsv, intensity, intensity_rsv, dual_stereo, dual_stereo_rsv, pulses, ebits, fine_priority, C, LM, ec, encode, prev, signalBandwidth)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _118
	_118:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _120
_120:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return codedBands
}

/* Copyright (c) 2003-2008 Jean-Marc Valin
   Copyright (c) 2007-2008 CSIRO
   Copyright (c) 2007-2009 Xiph.Org Foundation
   Written by Jean-Marc Valin */
/**
  @file arch.h
  @brief Various architecture definitions for CELT
*/
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// C documentation
//
//	/* This is a faster version of ec_tell_frac() that takes advantage
//	   of the low (1/8 bit) resolution to use just a linear function
//	   followed by a lookup to determine the exact transition thresholds. */
func Opus_ec_tell_frac(tls *libc.TLS, _this uintptr) (r1 OpusT_opus_uint32) {
	var b uint32
	var l int32
	var nbits, r OpusT_opus_uint32
	_, _, _, _ = b, l, nbits, r
	nbits = libc.Uint32FromInt32((*OpusT_ec_ctx)(unsafe.Pointer(_this)).Fnbits_total << int32(BITRES))
	l = libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(_this)).Frng)
	r = (*OpusT_ec_ctx)(unsafe.Pointer(_this)).Frng >> (l - int32(16))
	b = r>>libc.Int32FromInt32(12) - uint32(8)
	b = b + libc.BoolUint32(r > correction[b])
	l = libc.Int32FromUint32(libc.Uint32FromInt32(l<<libc.Int32FromInt32(3)) + b)
	return nbits - libc.Uint32FromInt32(l)
}

var correction = [8]uint32{
	0: uint32(35733),
	1: uint32(38967),
	2: uint32(42495),
	3: uint32(46340),
	4: uint32(50535),
	5: uint32(55109),
	6: uint32(60097),
	7: uint32(65535),
}

const EPSILON3 = 1e-15
const MIN_STEREO_ENERGY = 1e-10
const NORM_SCALING1 = 1
const Q31ONE3 = 1

var trim_icdf15 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf15 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf15 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff14 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff14 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

func Opus_hysteresis_decision(tls *libc.TLS, val OpusT_opus_val16, thresholds uintptr, hysteresis uintptr, N int32, prev int32) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < N) {
			break
		}
		if val < *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(i)*4)) {
			break
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if i > prev && val < *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(prev)*4))+*(*OpusT_opus_val16)(unsafe.Pointer(hysteresis + uintptr(prev)*4)) {
		i = prev
	}
	if i < prev && val > *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(prev-int32(1))*4))-*(*OpusT_opus_val16)(unsafe.Pointer(hysteresis + uintptr(prev-int32(1))*4)) {
		i = prev
	}
	return i
}

func Opus_celt_lcg_rand(tls *libc.TLS, seed OpusT_opus_uint32) (r OpusT_opus_uint32) {
	return uint32(1664525)*seed + uint32(1013904223)
}

// C documentation
//
//	/* This is a cos() approximation designed to be bit-exact on any platform. Bit exactness
//	   with this approximation is important because it has an impact on the bit allocation */
func Opus_bitexact_cos(tls *libc.TLS, x OpusT_opus_int16) (r OpusT_opus_int16) {
	var tmp OpusT_opus_int32
	var x2 OpusT_opus_int16
	_, _ = tmp, x2
	tmp = (int32(4096) + int32(x)*int32(x)) >> int32(13)
	_ = tmp <= libc.Int32FromInt32(32767)
	x2 = int16(tmp)
	x2 = int16(int32(32767) - int32(x2) + (int32(16384)+int32(x2)*int32(int16(-libc.Int32FromInt32(7651)+(libc.Int32FromInt32(16384)+int32(x2)*int32(int16(libc.Int32FromInt32(8277)+(libc.Int32FromInt32(16384)+int32(int16(-libc.Int32FromInt32(626)))*int32(x2))>>libc.Int32FromInt32(15))))>>libc.Int32FromInt32(15))))>>int32(15))
	_ = int32(x2) <= libc.Int32FromInt32(32766)
	return int16(int32(1) + int32(x2))
}

func Opus_bitexact_log2tan(tls *libc.TLS, isin int32, icos int32) (r int32) {
	var lc, ls int32
	_, _ = lc, ls
	lc = libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(icos))
	ls = libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(isin))
	icos = icos << (int32(15) - lc)
	isin = isin << (int32(15) - ls)
	return (ls-lc)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(11)) + (int32(16384)+int32(int16(isin))*int32(int16((libc.Int32FromInt32(16384)+int32(int16(isin))*int32(int16(-libc.Int32FromInt32(2597))))>>libc.Int32FromInt32(15)+libc.Int32FromInt32(7932))))>>int32(15) - (int32(16384)+int32(int16(icos))*int32(int16((libc.Int32FromInt32(16384)+int32(int16(icos))*int32(int16(-libc.Int32FromInt32(2597))))>>libc.Int32FromInt32(15)+libc.Int32FromInt32(7932))))>>int32(15)
}

// C documentation
//
//	/* Compute the amplitude (sqrt energy) in each of the bands */
func Opus_compute_band_energies(tls *libc.TLS, m uintptr, X uintptr, bandE uintptr, end int32, C int32, LM int32, arch int32) {
	var N1, c, i, i1, v1 int32
	var eBands uintptr
	var sum, xy, v5 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _ = N1, c, eBands, i, i1, sum, xy, v1, v5
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize << LM
	c = 0
	for {
		i1 = 0
		for {
			if !(i1 < end) {
				break
			}
			_ = arch
			xy = libc.Float32FromInt32(0)
			i = libc.Int32FromInt32(0)
			for {
				if !(i < (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))<<LM) {
					break
				}
				xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(c*N1+int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(c*N1+int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4)))
				goto _4
			_4:
				;
				i = i + 1
			}
			v5 = xy
			goto _6
		_6:
			sum = libc.Float32FromFloat32(1e-27) + v5
			*(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = float32(libc.Xsqrt(tls, float64(sum)))
			/*printf ("%f ", bandE[i+c*m->nbEBands]);*/
			goto _3
		_3:
			;
			i1 = i1 + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	/*printf ("\n");*/
}

// C documentation
//
//	/* Normalise each band such that the energy is one. */
func Opus_normalise_bands(tls *libc.TLS, m uintptr, freq uintptr, X uintptr, bandE uintptr, end int32, C int32, M int32) {
	var N, c, i, j, v1 int32
	var eBands uintptr
	var g OpusT_opus_val16
	_, _, _, _, _, _, _ = N, c, eBands, g, i, j, v1
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	c = 0
	for {
		i = 0
		for {
			if !(i < end) {
				break
			}
			g = libc.Float32FromFloat32(1) / (libc.Float32FromFloat32(1e-27) + *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)))
			j = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))
			for {
				if !(j < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j+c*N)*4)) = OpusT_celt_norm(*(*OpusT_celt_sig)(unsafe.Pointer(freq + uintptr(j+c*N)*4)) * g)
				goto _4
			_4:
				;
				j = j + 1
			}
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
}

// C documentation
//
//	/* De-normalise the energy to produce the synthesis from the unit-energy bands */
func Opus_denormalise_bands(tls *libc.TLS, m uintptr, X uintptr, freq uintptr, bandLogE uintptr, start int32, end int32, M int32, downsample int32, silence int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var N, band_end, bound, i, j, v1 int32
	var eBands, f, x1, v4 uintptr
	var frac, v6, v7, v8 float32
	var g OpusT_opus_val32
	var integer OpusT_opus_int32
	var lg OpusT_celt_glog
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, band_end, bound, eBands, f, frac, g, i, integer, j, lg, x1, v1, v4, v6, v7, v8
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	bound = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end)*2)))
	if downsample != int32(1) {
		if bound < N/downsample {
			v1 = bound
		} else {
			v1 = N / downsample
		}
		bound = v1
	}
	if silence != 0 {
		bound = 0
		v1 = libc.Int32FromInt32(0)
		end = v1
		start = v1
	}
	f = freq
	x1 = X + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))*4
	if start != 0 {
		i = 0
		for {
			if !(i < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2)))) {
				break
			}
			v4 = f
			f += 4
			*(*OpusT_celt_sig)(unsafe.Pointer(v4)) = libc.Float32FromInt32(0)
			goto _3
		_3:
			;
			i = i + 1
		}
	} else {
		f = f + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))*4
	}
	i = start
	for {
		if !(i < end) {
			break
		}
		j = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))
		band_end = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))
		lg = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4)) + Opus_eMeans[i]
		if libc.Float32FromFloat32(32) < lg {
			v6 = libc.Float32FromFloat32(32)
		} else {
			v6 = lg
		}
		v7 = v6
		integer = int32(libc.Xfloor(tls, float64(v7)))
		if integer < -libc.Int32FromInt32(50) {
			v8 = libc.Float32FromInt32(0)
			goto _9
		}
		frac = v7 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v8 = *(*float32)(unsafe.Pointer(bp))
		goto _9
	_9:
		g = v8
		for {
			v4 = f
			f += 4
			*(*OpusT_celt_sig)(unsafe.Pointer(v4)) = OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x1)) * g)
			x1 += 4
			goto _11
		_11:
			;
			j = j + 1
			v1 = j
			if !(v1 < band_end) {
				break
			}
		}
		goto _5
	_5:
		;
		i = i + 1
	}
	if !(start <= end) {
		Opus_celt_fatal(tls, __ccgo_ts+5281, __ccgo_ts+5312, int32(254))
	}
	libc.Xmemset(tls, freq+uintptr(bound)*4, 0, libc.Uint64FromInt32(N-bound)*uint64(4))
}

// C documentation
//
//	/* This prevents energy collapse for transients with multiple short MDCTs */
func Opus_anti_collapse(tls *libc.TLS, m uintptr, X_ uintptr, collapse_masks uintptr, LM int32, C int32, size int32, start int32, end int32, logE uintptr, prev1logE uintptr, prev2logE uintptr, pulses uintptr, seed OpusT_opus_uint32, encode int32, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var Ediff, v13 OpusT_opus_val32
	var N0, c, depth, i, j, k, renormalize, v8 int32
	var X uintptr
	var frac, v5, v6 float32
	var integer OpusT_opus_int32
	var prev1, prev2, v10 OpusT_celt_glog
	var r, v20 OpusT_celt_norm
	var sqrt_1, thresh, v17 OpusT_opus_val16
	var v2, v3 OpusT_opus_uint32
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Ediff, N0, X, c, depth, frac, i, integer, j, k, prev1, prev2, r, renormalize, sqrt_1, thresh, v10, v13, v17, v2, v20, v3, v5, v6, v8
	i = start
	for {
		if !(i < end) {
			break
		}
		N0 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))
		/* depth in 1/8 bits */
		_ = *(*int32)(unsafe.Pointer(pulses + uintptr(i)*4)) >= libc.Int32FromInt32(0)
		v2 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2))))
		_ = v2 > libc.Uint32FromInt32(0)
		v3 = libc.Uint32FromInt32(int32(1)+*(*int32)(unsafe.Pointer(pulses + uintptr(i)*4))) / v2
		goto _4
	_4:
		depth = libc.Int32FromUint32(v3 >> LM)
		v5 = float32(-libc.Float32FromFloat32(0.125) * float32(depth))
		integer = int32(libc.Xfloor(tls, float64(v5)))
		if integer < -libc.Int32FromInt32(50) {
			v6 = libc.Float32FromInt32(0)
			goto _7
		}
		frac = v5 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v6 = *(*float32)(unsafe.Pointer(bp))
		goto _7
	_7:
		thresh = OpusT_opus_val16(libc.Float32FromFloat32(0.5) * v6)
		sqrt_1 = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(N0<<LM)))
		c = 0
		for {
			renormalize = 0
			prev1 = *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
			prev2 = *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
			if !(encode != 0) && C == int32(1) {
				if prev1 > *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) {
					v10 = prev1
				} else {
					v10 = *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
				}
				prev1 = v10
				if prev2 > *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) {
					v10 = prev2
				} else {
					v10 = *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
				}
				prev2 = v10
			}
			if prev1 < prev2 {
				v10 = prev1
			} else {
				v10 = prev2
			}
			Ediff = *(*OpusT_celt_glog)(unsafe.Pointer(logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) - v10
			if float32(libc.Int32FromInt32(0)) > Ediff {
				v13 = float32(libc.Int32FromInt32(0))
			} else {
				v13 = Ediff
			}
			Ediff = v13
			/* r needs to be multiplied by 2 or 2*sqrt(2) depending on LM because
			   short blocks don't have the same energy as long */
			v5 = -Ediff
			integer = int32(libc.Xfloor(tls, float64(v5)))
			if integer < -libc.Int32FromInt32(50) {
				v6 = libc.Float32FromInt32(0)
				goto _16
			}
			frac = v5 - float32(integer)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
			v6 = *(*float32)(unsafe.Pointer(bp))
			goto _16
		_16:
			r = OpusT_celt_norm(libc.Float32FromFloat32(2) * v6)
			if LM == int32(3) {
				r = r * libc.Float32FromFloat32(1.41421356)
			}
			if thresh < r {
				v17 = thresh
			} else {
				v17 = r
			}
			r = v17
			r = OpusT_celt_norm(r * sqrt_1)
			X = X_ + uintptr(c*size)*4 + uintptr(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))<<LM)*4
			k = 0
			for {
				if !(k < int32(1)<<LM) {
					break
				}
				/* Detect collapse */
				if !(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i*C+c))))&(libc.Int32FromInt32(1)<<k) != 0) {
					/* Fill with noise */
					j = 0
					for {
						if !(j < N0) {
							break
						}
						seed = Opus_celt_lcg_rand(tls, seed)
						if seed&uint32(0x8000) != 0 {
							v20 = r
						} else {
							v20 = -r
						}
						*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j<<LM+k)*4)) = v20
						goto _19
					_19:
						;
						j = j + 1
					}
					renormalize = int32(1)
				}
				goto _18
			_18:
				;
				k = k + 1
			}
			/* We just added some energy, so we need to renormalise */
			if renormalize != 0 {
				Opus_renormalise_vector(tls, X, N0<<LM, libc.Float32FromFloat32(1), arch)
			}
			goto _9
		_9:
			;
			c = c + 1
			v8 = c
			if !(v8 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Compute the weights to use for optimizing normalized distortion across
//	   channels. We use the amplitude to weight square distortion, which means
//	   that we use the square root of the value we would have been using if we
//	   wanted to minimize the MSE in the non-normalized domain. This roughly
//	   corresponds to some quick-and-dirty perceptual experiments I ran to
//	   measure inter-aural masking (there doesn't seem to be any published data
//	   on the topic). */
func compute_channel_weights(tls *libc.TLS, Ex OpusT_celt_ener, Ey OpusT_celt_ener, w uintptr) {
	var minE, v1 OpusT_celt_ener
	_, _ = minE, v1
	if Ex < Ey {
		v1 = Ex
	} else {
		v1 = Ey
	}
	minE = v1
	/* Adjustment to make the weights a bit more conservative. */
	Ex = Ex + minE/libc.Float32FromInt32(3)
	Ey = Ey + minE/libc.Float32FromInt32(3)
	*(*OpusT_opus_val16)(unsafe.Pointer(w)) = Ex
	*(*OpusT_opus_val16)(unsafe.Pointer(w + 1*4)) = Ey
}

func intensity_stereo(tls *libc.TLS, m uintptr, X uintptr, Y uintptr, bandE uintptr, bandID int32, N int32) {
	var a1, a2, left, norm, right OpusT_opus_val16
	var i, j int32
	_, _, _, _, _, _, _ = a1, a2, i, j, left, norm, right
	i = bandID
	left = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i)*4))
	right = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
	norm = libc.Float32FromFloat32(1e-15) + float32(libc.Xsqrt(tls, float64(libc.Float32FromFloat32(1e-15)+OpusT_opus_val32(left*left)+OpusT_opus_val32(right*right))))
	a1 = left / norm
	a2 = right / norm
	j = 0
	for {
		if !(j < N) {
			break
		}
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = OpusT_opus_val16(a1**(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))) + OpusT_opus_val16(a2**(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)))
		/* Side is not encoded, no need to calculate */
		goto _1
	_1:
		;
		j = j + 1
	}
}

func stereo_split(tls *libc.TLS, X uintptr, Y uintptr, N int32) {
	var j int32
	var l, r OpusT_opus_val32
	_, _, _ = j, l, r
	j = 0
	for {
		if !(j < N) {
			break
		}
		l = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
		r = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)))
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = l + r
		*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = r - l
		goto _1
	_1:
		;
		j = j + 1
	}
}

func stereo_merge(tls *libc.TLS, X uintptr, Y uintptr, mid OpusT_opus_val32, N1 int32, arch int32) {
	var El, Er, lgain, rgain, side, t, xp, xy, v2 OpusT_opus_val32
	var i, j int32
	var l, r OpusT_celt_norm
	_, _, _, _, _, _, _, _, _, _, _, _, _ = El, Er, i, j, l, lgain, r, rgain, side, t, xp, xy, v2
	xp = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	/* Compute the norm of X+Y and X-Y as |X|^2 + |Y|^2 +/- sum(xy) */
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	v2 = xy
	goto _3
_3:
	xp = v2
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
		goto _4
	_4:
		;
		i = i + 1
	}
	v2 = xy
	goto _6
_6:
	side = v2
	/* Compensating for the mid normalization */
	xp = OpusT_opus_val32(mid * xp)
	/* mid and side are in Q15, not Q14 like X and Y */
	El = OpusT_opus_val32(mid*mid) + side - OpusT_opus_val32(libc.Float32FromInt32(2)*xp)
	Er = OpusT_opus_val32(mid*mid) + side + OpusT_opus_val32(libc.Float32FromInt32(2)*xp)
	if Er < libc.Float32FromFloat32(0.0006) || El < libc.Float32FromFloat32(0.0006) {
		libc.Xmemcpy(tls, Y, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(X))/4)))
		return
	}
	t = El
	lgain = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t)))
	t = Er
	rgain = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t)))
	j = 0
	for {
		if !(j < N1) {
			break
		}
		/* Apply mid scaling (side is already scaled) */
		l = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
		r = *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = OpusT_opus_val32(lgain * (l - r))
		*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = OpusT_opus_val32(rgain * (l + r))
		goto _7
	_7:
		;
		j = j + 1
	}
}

// C documentation
//
//	/* Decide whether we should spread the pulses in the current frame */
func Opus_spreading_decision(tls *libc.TLS, m uintptr, X uintptr, average uintptr, last_decision int32, hf_average uintptr, tapset_decision uintptr, update_hf int32, end int32, C int32, M int32, spread_weight uintptr) (r int32) {
	var N, N0, c, decision, hf_sum, i, j, nbBands, sum, tmp, v1 int32
	var eBands, x uintptr
	var tcount [3]int32
	var x2N OpusT_opus_val32
	var v5, v6 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N0, c, decision, eBands, hf_sum, i, j, nbBands, sum, tcount, tmp, x, x2N, v1, v5, v6
	sum = 0
	nbBands = 0
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	hf_sum = 0
	if !(end > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5328, __ccgo_ts+5312, int32(480))
	}
	N0 = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	if M*(int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end-int32(1))*2)))) <= int32(8) {
		return SPREAD_NONE
	}
	c = 0
	for {
		i = 0
		for {
			if !(i < end) {
				break
			}
			tmp = 0
			tcount = [3]int32{}
			x = X + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2))))*4 + uintptr(c*N0)*4
			N = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2))))
			if N <= int32(8) {
				goto _3
			}
			/* Compute rough CDF of |x[j]| */
			j = 0
			for {
				if !(j < N) {
					break
				}
				/* Q13 */
				x2N = OpusT_opus_val32(OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(x + uintptr(j)*4))) * float32(N))
				if x2N < libc.Float32FromFloat32(0.25) {
					tcount[0] = tcount[0] + 1
				}
				if x2N < libc.Float32FromFloat32(0.0625) {
					tcount[int32(1)] = tcount[int32(1)] + 1
				}
				if x2N < libc.Float32FromFloat32(0.015625) {
					tcount[int32(2)] = tcount[int32(2)] + 1
				}
				goto _4
			_4:
				;
				j = j + 1
			}
			/* Only include four last bands (8 kHz and up) */
			if i > (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(4) {
				v5 = libc.Uint32FromInt32(N)
				_ = v5 > libc.Uint32FromInt32(0)
				v6 = libc.Uint32FromInt32(int32(32)*(tcount[int32(1)]+tcount[0])) / v5
				goto _7
			_7:
				hf_sum = libc.Int32FromUint32(uint32(hf_sum) + v6)
			}
			tmp = libc.BoolInt32(int32(2)*tcount[int32(2)] >= N) + libc.BoolInt32(int32(2)*tcount[int32(1)] >= N) + libc.BoolInt32(int32(2)*tcount[0] >= N)
			sum = sum + tmp**(*int32)(unsafe.Pointer(spread_weight + uintptr(i)*4))
			nbBands = nbBands + *(*int32)(unsafe.Pointer(spread_weight + uintptr(i)*4))
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	if update_hf != 0 {
		if hf_sum != 0 {
			v5 = libc.Uint32FromInt32(C * (int32(4) - (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands + end))
			_ = v5 > libc.Uint32FromInt32(0)
			v6 = libc.Uint32FromInt32(hf_sum) / v5
			goto _10
		_10:
			hf_sum = libc.Int32FromUint32(v6)
		}
		*(*int32)(unsafe.Pointer(hf_average)) = (*(*int32)(unsafe.Pointer(hf_average)) + hf_sum) >> int32(1)
		hf_sum = *(*int32)(unsafe.Pointer(hf_average))
		if *(*int32)(unsafe.Pointer(tapset_decision)) == int32(2) {
			hf_sum = hf_sum + int32(4)
		} else {
			if *(*int32)(unsafe.Pointer(tapset_decision)) == 0 {
				hf_sum = hf_sum - int32(4)
			}
		}
		if hf_sum > int32(22) {
			*(*int32)(unsafe.Pointer(tapset_decision)) = int32(2)
		} else {
			if hf_sum > int32(18) {
				*(*int32)(unsafe.Pointer(tapset_decision)) = int32(1)
			} else {
				*(*int32)(unsafe.Pointer(tapset_decision)) = 0
			}
		}
	}
	/*printf("%d %d %d\n", hf_sum, *hf_average, *tapset_decision);*/
	if !(nbBands > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5352, __ccgo_ts+5312, int32(536))
	} /* end has to be non-zero */
	if !(sum >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5380, __ccgo_ts+5312, int32(537))
	}
	v5 = libc.Uint32FromInt32(nbBands)
	_ = v5 > libc.Uint32FromInt32(0)
	v6 = libc.Uint32FromInt32(sum<<int32(8)) / v5
	goto _13
_13:
	sum = libc.Int32FromUint32(v6)
	/* Recursive averaging */
	sum = (sum + *(*int32)(unsafe.Pointer(average))) >> int32(1)
	*(*int32)(unsafe.Pointer(average)) = sum
	/* Hysteresis */
	sum = (int32(3)*sum + ((int32(3)-last_decision)<<int32(7) + int32(64)) + int32(2)) >> int32(2)
	if sum < int32(80) {
		decision = int32(SPREAD_AGGRESSIVE)
	} else {
		if sum < int32(256) {
			decision = int32(SPREAD_NORMAL)
		} else {
			if sum < int32(384) {
				decision = int32(SPREAD_LIGHT)
			} else {
				decision = SPREAD_NONE
			}
		}
	}
	return decision
}

// C documentation
//
//	/* Indexing table for converting from natural Hadamard to ordery Hadamard
//	   This is essentially a bit-reversed Gray, on top of which we've added
//	   an inversion of the order because we want the DC at the end rather than
//	   the beginning. The lines are for N=2, 4, 8, 16 */
var ordery_table = [30]int32{
	0:  int32(1),
	2:  int32(3),
	4:  int32(2),
	5:  int32(1),
	6:  int32(7),
	8:  int32(4),
	9:  int32(3),
	10: int32(6),
	11: int32(1),
	12: int32(5),
	13: int32(2),
	14: int32(15),
	16: int32(8),
	17: int32(7),
	18: int32(12),
	19: int32(3),
	20: int32(11),
	21: int32(4),
	22: int32(14),
	23: int32(1),
	24: int32(9),
	25: int32(6),
	26: int32(13),
	27: int32(2),
	28: int32(10),
	29: int32(5),
}

func deinterleave_hadamard(tls *libc.TLS, X uintptr, N0 int32, stride int32, hadamard int32) {
	var N, i, j int32
	var _saved_stack, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, _saved_stack, i, j, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	N = N0 * stride
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(581))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if !(stride > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5405, __ccgo_ts+5312, int32(582))
	}
	if hadamard != 0 {
		ordery = uintptr(unsafe.Pointer(&ordery_table)) + uintptr(stride)*4 - uintptr(2)*4
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(*(*int32)(unsafe.Pointer(ordery + uintptr(i)*4))*N0+j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j*stride+i)*4))
				goto _30
			_30:
				;
				j = j + 1
			}
			goto _29
		_29:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(i*N0+j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j*stride+i)*4))
				goto _32
			_32:
				;
				j = j + 1
			}
			goto _31
		_31:
			;
			i = i + 1
		}
	}
	libc.Xmemcpy(tls, X, tmp, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(tmp))/4)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func interleave_hadamard(tls *libc.TLS, X uintptr, N0 int32, stride int32, hadamard int32) {
	var N, i, j int32
	var _saved_stack, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, _saved_stack, i, j, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	N = N0 * stride
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(607))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if hadamard != 0 {
		ordery = uintptr(unsafe.Pointer(&ordery_table)) + uintptr(stride)*4 - uintptr(2)*4
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(j*stride+i)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(*(*int32)(unsafe.Pointer(ordery + uintptr(i)*4))*N0+j)*4))
				goto _30
			_30:
				;
				j = j + 1
			}
			goto _29
		_29:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(j*stride+i)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i*N0+j)*4))
				goto _32
			_32:
				;
				j = j + 1
			}
			goto _31
		_31:
			;
			i = i + 1
		}
	}
	libc.Xmemcpy(tls, X, tmp, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(tmp))/4)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_haar1(tls *libc.TLS, X uintptr, N0 int32, stride int32) {
	var i, j int32
	var tmp1, tmp2 OpusT_opus_val32
	_, _, _, _ = i, j, tmp1, tmp2
	N0 = N0 >> int32(1)
	i = 0
	for {
		if !(i < stride) {
			break
		}
		j = 0
		for {
			if !(j < N0) {
				break
			}
			tmp1 = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*int32(2)*j+i)*4)))
			tmp2 = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*(int32(2)*j+int32(1))+i)*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*int32(2)*j+i)*4)) = tmp1 + tmp2
			*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*(int32(2)*j+int32(1))+i)*4)) = tmp1 - tmp2
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func compute_qn(tls *libc.TLS, N int32, b int32, offset int32, pulse_cap int32, stereo int32) (r int32) {
	var N2, qb, qn, v4 int32
	var v1, v2 OpusT_opus_int32
	_, _, _, _, _, _ = N2, qb, qn, v1, v2, v4
	N2 = int32(2)*N - int32(1)
	if stereo != 0 && N == int32(2) {
		N2 = N2 - 1
	}
	/* The upper limit ensures that in a stereo split with itheta==16384, we'll
	   always have enough bits left over to code at least one pulse in the
	   side; otherwise it would collapse, since it doesn't get folded. */
	v1 = N2
	_ = v1 > libc.Int32FromInt32(0)
	v2 = (b + N2*offset) / v1
	goto _3
_3:
	qb = v2
	if b-pulse_cap-libc.Int32FromInt32(4)<<libc.Int32FromInt32(BITRES) < qb {
		v4 = b - pulse_cap - libc.Int32FromInt32(4)<<libc.Int32FromInt32(BITRES)
	} else {
		v4 = qb
	}
	qb = v4
	if libc.Int32FromInt32(8)<<libc.Int32FromInt32(BITRES) < qb {
		v4 = libc.Int32FromInt32(8) << libc.Int32FromInt32(BITRES)
	} else {
		v4 = qb
	}
	qb = v4
	if qb < libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)>>libc.Int32FromInt32(1) {
		qn = int32(1)
	} else {
		qn = int32(exp2_table8[qb&int32(0x7)]) >> (int32(14) - qb>>int32(BITRES))
		qn = (qn + int32(1)) >> int32(1) << int32(1)
	}
	if !(qn <= libc.Int32FromInt32(256)) {
		Opus_celt_fatal(tls, __ccgo_ts+5432, __ccgo_ts+5312, int32(660))
	}
	return qn
}

var exp2_table8 = [8]OpusT_opus_int16{
	0: int16(16384),
	1: int16(17866),
	2: int16(19483),
	3: int16(21247),
	4: int16(23170),
	5: int16(25267),
	6: int16(27554),
	7: int16(30048),
}

type band_ctx = struct {
	Fencode            int32
	Fresynth           int32
	Fm                 uintptr
	Fi                 int32
	Fintensity         int32
	Fspread            int32
	Ftf_change         int32
	Fec                uintptr
	Fremaining_bits    OpusT_opus_int32
	FbandE             uintptr
	Fseed              OpusT_opus_uint32
	Farch              int32
	Ftheta_round       int32
	Fdisable_inv       int32
	Favoid_split_noise int32
}

type split_ctx = struct {
	Finv    int32
	Fimid   int32
	Fiside  int32
	Fdelta  int32
	Fitheta int32
	Fqalloc int32
}

func compute_theta(tls *libc.TLS, ctx uintptr, sctx uintptr, X uintptr, Y uintptr, N int32, b uintptr, B int32, B0 int32, LM int32, stereo int32, fill uintptr) {
	var bandE, ec, m uintptr
	var bias, delta, down, encode, fl, fl1, fm, fs, fs1, ft, ft1, i, imid, intensity, inv, iside, itheta, itheta_q30, j, offset, p0, pulse_cap, qalloc, qn, unquantized, x, x0, v1, v5, v6, v7 int32
	var tell OpusT_opus_int32
	var v2, v3 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bandE, bias, delta, down, ec, encode, fl, fl1, fm, fs, fs1, ft, ft1, i, imid, intensity, inv, iside, itheta, itheta_q30, j, m, offset, p0, pulse_cap, qalloc, qn, tell, unquantized, x, x0, v1, v2, v3, v5, v6, v7
	itheta = 0
	itheta_q30 = 0
	inv = 0
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	m = (*band_ctx)(unsafe.Pointer(ctx)).Fm
	i = (*band_ctx)(unsafe.Pointer(ctx)).Fi
	intensity = (*band_ctx)(unsafe.Pointer(ctx)).Fintensity
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	bandE = (*band_ctx)(unsafe.Pointer(ctx)).FbandE
	/* Decide on the resolution to give to the split parameter theta */
	pulse_cap = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FlogN + uintptr(i)*2))) + LM*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES))
	if stereo != 0 && N == int32(2) {
		v1 = int32(QTHETA_OFFSET_TWOPHASE)
	} else {
		v1 = int32(QTHETA_OFFSET)
	}
	offset = pulse_cap>>int32(1) - v1
	qn = compute_qn(tls, N, *(*int32)(unsafe.Pointer(b)), offset, pulse_cap, stereo)
	if stereo != 0 && i >= intensity {
		qn = int32(1)
	}
	if encode != 0 {
		/* theta is the atan() of the ratio between the (normalized)
		   side and mid. With just that parameter, we can re-scale both
		   mid and side because we know that 1) they have unit norm and
		   2) they are orthogonal. */
		itheta_q30 = Opus_stereo_itheta(tls, X, Y, stereo, N, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
		itheta = itheta_q30 >> int32(16)
	}
	tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec))
	if qn != int32(1) {
		if encode != 0 {
			if !(stereo != 0) || (*band_ctx)(unsafe.Pointer(ctx)).Ftheta_round == 0 {
				itheta = (itheta*qn + int32(8192)) >> int32(14)
				if !(stereo != 0) && (*band_ctx)(unsafe.Pointer(ctx)).Favoid_split_noise != 0 && itheta > 0 && itheta < qn {
					v2 = libc.Uint32FromInt32(qn)
					_ = v2 > libc.Uint32FromInt32(0)
					v3 = libc.Uint32FromInt32(itheta*int32(16384)) / v2
					goto _4
				_4:
					/* Check if the selected value of theta will cause the bit allocation
					   to inject noise on one side. If so, make sure the energy of that side
					   is zero. */
					unquantized = libc.Int32FromUint32(v3)
					imid = int32(Opus_bitexact_cos(tls, int16(unquantized)))
					iside = int32(Opus_bitexact_cos(tls, int16(libc.Int32FromInt32(16384)-unquantized)))
					delta = (int32(16384) + int32(int16((N-libc.Int32FromInt32(1))<<libc.Int32FromInt32(7)))*int32(int16(Opus_bitexact_log2tan(tls, iside, imid)))) >> int32(15)
					if delta > *(*int32)(unsafe.Pointer(b)) {
						itheta = qn
					} else {
						if delta < -*(*int32)(unsafe.Pointer(b)) {
							itheta = 0
						}
					}
				}
			} else {
				if itheta > int32(8192) {
					v1 = int32(32767) / qn
				} else {
					v1 = -int32(32767) / qn
				}
				/* Bias quantization towards itheta=0 and itheta=16384. */
				bias = v1
				if 0 > (itheta*qn+bias)>>int32(14) {
					v6 = 0
				} else {
					v6 = (itheta*qn + bias) >> int32(14)
				}
				if qn-int32(1) < v6 {
					v5 = qn - int32(1)
				} else {
					if 0 > (itheta*qn+bias)>>int32(14) {
						v7 = 0
					} else {
						v7 = (itheta*qn + bias) >> int32(14)
					}
					v5 = v7
				}
				down = v5
				if (*band_ctx)(unsafe.Pointer(ctx)).Ftheta_round < 0 {
					itheta = down
				} else {
					itheta = down + int32(1)
				}
			}
		}
		/* Entropy coding of the angle. We use a uniform pdf for the
		   time split, a step for stereo, and a triangular one for the rest. */
		if stereo != 0 && N > int32(2) {
			p0 = int32(3)
			x = itheta
			x0 = qn / int32(2)
			ft = p0*(x0+int32(1)) + x0
			/* Use a probability of p0 up to itheta=8192 and then use 1 after */
			if encode != 0 {
				if x <= x0 {
					v1 = p0 * x
				} else {
					v1 = x - int32(1) - x0 + (x0+int32(1))*p0
				}
				if x <= x0 {
					v5 = p0 * (x + int32(1))
				} else {
					v5 = x - x0 + (x0+int32(1))*p0
				}
				Opus_ec_encode(tls, ec, libc.Uint32FromInt32(v1), libc.Uint32FromInt32(v5), libc.Uint32FromInt32(ft))
			} else {
				fs = libc.Int32FromUint32(Opus_ec_decode(tls, ec, libc.Uint32FromInt32(ft)))
				if fs < (x0+int32(1))*p0 {
					x = fs / p0
				} else {
					x = x0 + int32(1) + (fs - (x0+int32(1))*p0)
				}
				if x <= x0 {
					v1 = p0 * x
				} else {
					v1 = x - int32(1) - x0 + (x0+int32(1))*p0
				}
				if x <= x0 {
					v5 = p0 * (x + int32(1))
				} else {
					v5 = x - x0 + (x0+int32(1))*p0
				}
				Opus_ec_dec_update(tls, ec, libc.Uint32FromInt32(v1), libc.Uint32FromInt32(v5), libc.Uint32FromInt32(ft))
				itheta = x
			}
		} else {
			if B0 > int32(1) || stereo != 0 {
				/* Uniform pdf */
				if encode != 0 {
					Opus_ec_enc_uint(tls, ec, libc.Uint32FromInt32(itheta), libc.Uint32FromInt32(qn+int32(1)))
				} else {
					itheta = libc.Int32FromUint32(Opus_ec_dec_uint(tls, ec, libc.Uint32FromInt32(qn+int32(1))))
				}
			} else {
				fs1 = int32(1)
				ft1 = (qn>>int32(1) + int32(1)) * (qn>>int32(1) + int32(1))
				if encode != 0 {
					if itheta <= qn>>int32(1) {
						v1 = itheta + int32(1)
					} else {
						v1 = qn + int32(1) - itheta
					}
					fs1 = v1
					if itheta <= qn>>int32(1) {
						v1 = itheta * (itheta + int32(1)) >> int32(1)
					} else {
						v1 = ft1 - (qn+int32(1)-itheta)*(qn+int32(2)-itheta)>>int32(1)
					}
					fl = v1
					Opus_ec_encode(tls, ec, libc.Uint32FromInt32(fl), libc.Uint32FromInt32(fl+fs1), libc.Uint32FromInt32(ft1))
				} else {
					/* Triangular pdf */
					fl1 = 0
					fm = libc.Int32FromUint32(Opus_ec_decode(tls, ec, libc.Uint32FromInt32(ft1)))
					if fm < qn>>int32(1)*(qn>>int32(1)+int32(1))>>int32(1) {
						itheta = libc.Int32FromUint32((Opus_isqrt32(tls, uint32(8)*libc.Uint32FromInt32(fm)+uint32(1)) - uint32(1)) >> int32(1))
						fs1 = itheta + int32(1)
						fl1 = itheta * (itheta + int32(1)) >> int32(1)
					} else {
						itheta = libc.Int32FromUint32((libc.Uint32FromInt32(int32(2)*(qn+int32(1))) - Opus_isqrt32(tls, uint32(8)*libc.Uint32FromInt32(ft1-fm-libc.Int32FromInt32(1))+uint32(1))) >> int32(1))
						fs1 = qn + int32(1) - itheta
						fl1 = ft1 - (qn+int32(1)-itheta)*(qn+int32(2)-itheta)>>int32(1)
					}
					Opus_ec_dec_update(tls, ec, libc.Uint32FromInt32(fl1), libc.Uint32FromInt32(fl1+fs1), libc.Uint32FromInt32(ft1))
				}
			}
		}
		if !(itheta >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5460, __ccgo_ts+5312, int32(840))
		}
		v2 = libc.Uint32FromInt32(qn)
		_ = v2 > libc.Uint32FromInt32(0)
		v3 = libc.Uint32FromInt32(itheta*int32(16384)) / v2
		goto _17
	_17:
		itheta = libc.Int32FromUint32(v3)
		if encode != 0 && stereo != 0 {
			if itheta == 0 {
				intensity_stereo(tls, m, X, Y, bandE, i, N)
			} else {
				stereo_split(tls, X, Y, N)
			}
		}
		/* NOTE: Renormalising X and Y *may* help fixed-point a bit at very high rate.
		   Let's do that at higher complexity */
	} else {
		if stereo != 0 {
			if encode != 0 {
				inv = libc.BoolInt32(itheta > int32(8192) && !((*band_ctx)(unsafe.Pointer(ctx)).Fdisable_inv != 0))
				if inv != 0 {
					j = 0
					for {
						if !(j < N) {
							break
						}
						*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = -*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
						goto _18
					_18:
						;
						j = j + 1
					}
				}
				intensity_stereo(tls, m, X, Y, bandE, i, N)
			}
			if *(*int32)(unsafe.Pointer(b)) > libc.Int32FromInt32(2)<<libc.Int32FromInt32(BITRES) && (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits > libc.Int32FromInt32(2)<<libc.Int32FromInt32(BITRES) {
				if encode != 0 {
					Opus_ec_enc_bit_logp(tls, ec, inv, uint32(2))
				} else {
					inv = Opus_ec_dec_bit_logp(tls, ec, uint32(2))
				}
			} else {
				inv = 0
			}
			/* inv flag override to avoid problems with downmixing. */
			if (*band_ctx)(unsafe.Pointer(ctx)).Fdisable_inv != 0 {
				inv = 0
			}
			itheta = 0
			itheta_q30 = 0
		}
	}
	qalloc = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec) - libc.Uint32FromInt32(tell))
	*(*int32)(unsafe.Pointer(b)) -= qalloc
	if itheta == 0 {
		imid = int32(32767)
		iside = 0
		*(*int32)(unsafe.Pointer(fill)) &= int32(1)<<B - int32(1)
		delta = -int32(16384)
	} else {
		if itheta == int32(16384) {
			imid = 0
			iside = int32(32767)
			*(*int32)(unsafe.Pointer(fill)) &= (int32(1)<<B - int32(1)) << B
			delta = int32(16384)
		} else {
			imid = int32(Opus_bitexact_cos(tls, int16(itheta)))
			iside = int32(Opus_bitexact_cos(tls, int16(libc.Int32FromInt32(16384)-itheta)))
			/* This is the mid vs side allocation that minimizes squared error
			   in that band. */
			delta = (int32(16384) + int32(int16((N-libc.Int32FromInt32(1))<<libc.Int32FromInt32(7)))*int32(int16(Opus_bitexact_log2tan(tls, iside, imid)))) >> int32(15)
		}
	}
	(*split_ctx)(unsafe.Pointer(sctx)).Finv = inv
	(*split_ctx)(unsafe.Pointer(sctx)).Fimid = imid
	(*split_ctx)(unsafe.Pointer(sctx)).Fiside = iside
	(*split_ctx)(unsafe.Pointer(sctx)).Fdelta = delta
	(*split_ctx)(unsafe.Pointer(sctx)).Fitheta = itheta
	(*split_ctx)(unsafe.Pointer(sctx)).Fqalloc = qalloc
}

func quant_band_n1(tls *libc.TLS, ctx uintptr, X uintptr, Y uintptr, lowband_out uintptr) (r uint32) {
	var c, encode, sign, stereo, v1 int32
	var ec, x uintptr
	var v3 float32
	_, _, _, _, _, _, _, _ = c, ec, encode, sign, stereo, x, v1, v3
	x = X
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	stereo = libc.BoolInt32(Y != libc.UintptrFromInt32(0))
	c = 0
	for {
		sign = 0
		if (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
			if encode != 0 {
				sign = libc.BoolInt32(*(*OpusT_celt_norm)(unsafe.Pointer(x)) < libc.Float32FromInt32(0))
				Opus_ec_enc_bits(tls, ec, libc.Uint32FromInt32(sign), uint32(1))
			} else {
				sign = libc.Int32FromUint32(Opus_ec_dec_bits(tls, ec, uint32(1)))
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
		}
		if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
			if sign != 0 {
				v3 = -libc.Float32FromFloat32(1)
			} else {
				v3 = libc.Float32FromFloat32(1)
			}
			*(*OpusT_celt_norm)(unsafe.Pointer(x)) = v3
		}
		x = Y
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < int32(1)+stereo) {
			break
		}
	}
	if lowband_out != 0 {
		*(*OpusT_celt_norm)(unsafe.Pointer(lowband_out)) = *(*OpusT_celt_norm)(unsafe.Pointer(X))
	}
	return uint32(1)
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a mono partition.
//	   It can split the band in two and transmit the energy difference with
//	   the two half-bands. It can be called recursively so bands can end up being
//	   split in 8 parts. */
func quant_partition(tls *libc.TLS, ctx uintptr, X uintptr, N int32, _b int32, B int32, lowband uintptr, LM2 int32, gain OpusT_opus_val32, _fill int32) (r uint32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*int32)(unsafe.Pointer(bp)) = _b
	*(*int32)(unsafe.Pointer(bp + 4)) = _fill
	var B0, K, curr_bits, delta, encode, hi, i1, i2, imid, iside, itheta, j, lo, mbits, mid, q, qalloc, sbits, spread, v1, v2, v3, v4 int32
	var Y, cache, cache1, cache2, ec, m2, next_lowband2, v5 uintptr
	var cm, cm_mask uint32
	var mid1, side OpusT_opus_val32
	var rebalance OpusT_opus_int32
	var tmp, v30 OpusT_opus_val16
	var _ /* sctx at bp+8 */ split_ctx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B0, K, Y, cache, cache1, cache2, cm, cm_mask, curr_bits, delta, ec, encode, hi, i1, i2, imid, iside, itheta, j, lo, m2, mbits, mid, mid1, next_lowband2, q, qalloc, rebalance, sbits, side, spread, tmp, v1, v2, v3, v30, v4, v5
	imid = 0
	iside = 0
	B0 = B
	mid1 = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	cm = uint32(0)
	Y = libc.UintptrFromInt32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	m2 = (*band_ctx)(unsafe.Pointer(ctx)).Fm
	i2 = (*band_ctx)(unsafe.Pointer(ctx)).Fi
	spread = (*band_ctx)(unsafe.Pointer(ctx)).Fspread
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	/* If we need 1.5 more bit than we can produce, split the band in two. */
	cache2 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).Fcache.Findex + uintptr((LM2+int32(1))*(*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).FnbEBands+i2)*2)))
	if LM2 != -int32(1) && *(*int32)(unsafe.Pointer(bp)) > libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache2 + uintptr(*(*uint8)(unsafe.Pointer(cache2))))))+int32(12) && N > int32(2) {
		next_lowband2 = libc.UintptrFromInt32(0)
		N = N >> int32(1)
		Y = X + uintptr(N)*4
		LM2 = LM2 - int32(1)
		if B == int32(1) {
			*(*int32)(unsafe.Pointer(bp + 4)) = *(*int32)(unsafe.Pointer(bp + 4))&int32(1) | *(*int32)(unsafe.Pointer(bp + 4))<<int32(1)
		}
		B = (B + int32(1)) >> int32(1)
		compute_theta(tls, ctx, bp+8, X, Y, N, bp, B, B0, LM2, 0, bp+4)
		imid = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fimid
		iside = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fiside
		delta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fdelta
		itheta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fitheta
		qalloc = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fqalloc
		mid1 = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(imid))
		side = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(iside))
		/* Give more bits to low-energy MDCTs than they would otherwise deserve */
		if B0 > int32(1) && itheta&int32(0x3fff) != 0 {
			if itheta > int32(8192) {
				/* Rough approximation for pre-echo masking */
				delta = delta - delta>>(int32(4)-LM2)
			} else {
				/* Corresponds to a forward-masking slope of 1.5 dB per 10 ms */
				if 0 < delta+N<<int32(BITRES)>>(int32(5)-LM2) {
					v1 = 0
				} else {
					v1 = delta + N<<int32(BITRES)>>(int32(5)-LM2)
				}
				delta = v1
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
			v2 = *(*int32)(unsafe.Pointer(bp))
		} else {
			v2 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
		}
		if 0 > v2 {
			v1 = 0
		} else {
			if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
				v3 = *(*int32)(unsafe.Pointer(bp))
			} else {
				v3 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
			}
			v1 = v3
		}
		mbits = v1
		sbits = *(*int32)(unsafe.Pointer(bp)) - mbits
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc
		if lowband != 0 {
			next_lowband2 = lowband + uintptr(N)*4
		} /* >32-bit split case */
		rebalance = (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits
		if mbits >= sbits {
			cm = quant_partition(tls, ctx, X, N, mbits, B, lowband, LM2, OpusT_opus_val32(gain*mid1), *(*int32)(unsafe.Pointer(bp + 4)))
			rebalance = mbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != 0 {
				sbits = sbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			cm = cm | quant_partition(tls, ctx, Y, N, sbits, B, next_lowband2, LM2, OpusT_opus_val32(gain*side), *(*int32)(unsafe.Pointer(bp + 4))>>B)<<(B0>>int32(1))
		} else {
			cm = quant_partition(tls, ctx, Y, N, sbits, B, next_lowband2, LM2, OpusT_opus_val32(gain*side), *(*int32)(unsafe.Pointer(bp + 4))>>B) << (B0 >> int32(1))
			rebalance = sbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != int32(16384) {
				mbits = mbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			cm = cm | quant_partition(tls, ctx, X, N, mbits, B, lowband, LM2, OpusT_opus_val32(gain*mid1), *(*int32)(unsafe.Pointer(bp + 4)))
		}
	} else {
		/* This is the basic no-split case */
		v5 = m2
		v1 = LM2
		v2 = *(*int32)(unsafe.Pointer(bp))
		v1 = v1 + 1
		cache = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
		lo = 0
		hi = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache)))
		v2 = v2 - 1
		i1 = libc.Int32FromInt32(0)
		for {
			if !(i1 < libc.Int32FromInt32(LOG_MAX_PSEUDO)) {
				break
			}
			mid = (lo + hi + int32(1)) >> int32(1)
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(mid)))) >= v2 {
				hi = mid
			} else {
				lo = mid
			}
			goto _8
		_8:
			;
			i1 = i1 + 1
		}
		if lo == 0 {
			v3 = -int32(1)
		} else {
			v3 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(lo))))
		}
		if v2-v3 <= libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(hi))))-v2 {
			v4 = lo
			goto _11
		} else {
			v4 = hi
			goto _11
		}
	_11:
		q = v4
		v5 = m2
		v1 = LM2
		v2 = q
		v1 = v1 + 1
		cache1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
		if v2 == 0 {
			v4 = 0
		} else {
			v4 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache1 + uintptr(v2)))) + int32(1)
		}
		v3 = v4
		goto _16
	_16:
		curr_bits = v3
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= curr_bits
		/* Ensures we can never bust the budget */
		for (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits < 0 && q > 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) += curr_bits
			q = q - 1
			v5 = m2
			v1 = LM2
			v2 = q
			v1 = v1 + 1
			cache1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
			if v2 == 0 {
				v4 = 0
			} else {
				v4 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache1 + uintptr(v2)))) + int32(1)
			}
			v3 = v4
			goto _22
		_22:
			curr_bits = v3
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= curr_bits
		}
		if q != 0 {
			v1 = q
			if v1 < int32(8) {
				v3 = v1
			} else {
				v3 = (int32(8) + v1&int32(7)) << (v1>>int32(3) - int32(1))
			}
			v2 = v3
			goto _26
		_26:
			K = v2
			/* Finally do the actual quantization */
			if encode != 0 {
				cm = Opus_alg_quant(tls, X, N, K, spread, B, ec, gain, (*band_ctx)(unsafe.Pointer(ctx)).Fresynth, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
			} else {
				cm = Opus_alg_unquant(tls, X, N, K, spread, B, ec, gain)
			}
		} else {
			if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
				/* B can be as large as 16, so this shift might overflow an int on a
				   16-bit platform; use a long to get defined behavior.*/
				cm_mask = uint32(libc.Uint64FromUint64(1)<<B) - uint32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = libc.Int32FromUint32(uint32(*(*int32)(unsafe.Pointer(bp + 4))) & cm_mask)
				if !(*(*int32)(unsafe.Pointer(bp + 4)) != 0) {
					libc.Xmemset(tls, X, 0, libc.Uint64FromInt32(N)*uint64(4))
				} else {
					if lowband == libc.UintptrFromInt32(0) {
						/* Noise */
						j = 0
						for {
							if !(j < N) {
								break
							}
							(*band_ctx)(unsafe.Pointer(ctx)).Fseed = Opus_celt_lcg_rand(tls, (*band_ctx)(unsafe.Pointer(ctx)).Fseed)
							*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = float32(libc.Int32FromUint32((*band_ctx)(unsafe.Pointer(ctx)).Fseed) >> libc.Int32FromInt32(20))
							goto _28
						_28:
							;
							j = j + 1
						}
						cm = cm_mask
					} else {
						/* Folded spectrum */
						j = 0
						for {
							if !(j < N) {
								break
							}
							(*band_ctx)(unsafe.Pointer(ctx)).Fseed = Opus_celt_lcg_rand(tls, (*band_ctx)(unsafe.Pointer(ctx)).Fseed)
							/* About 48 dB below the "normal" folding level */
							tmp = libc.Float32FromFloat32(1) / libc.Float32FromInt32(256)
							if (*band_ctx)(unsafe.Pointer(ctx)).Fseed&uint32(0x8000) != 0 {
								v30 = tmp
							} else {
								v30 = -tmp
							}
							tmp = v30
							*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(lowband + uintptr(j)*4)) + tmp
							goto _29
						_29:
							;
							j = j + 1
						}
						cm = libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp + 4)))
					}
					Opus_renormalise_vector(tls, X, N, gain, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
				}
			}
		}
	}
	return cm
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a band for the mono case. */
func quant_band(tls *libc.TLS, ctx uintptr, X uintptr, N int32, b int32, B int32, lowband uintptr, LM int32, lowband_out uintptr, gain OpusT_opus_val32, lowband_scratch uintptr, fill int32) (r uint32) {
	var B0, N0, N_B, N_B0, encode, j, k, longBlocks, recombine, tf_change, time_divide int32
	var cm uint32
	var n1 OpusT_opus_val16
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B0, N0, N_B, N_B0, cm, encode, j, k, longBlocks, n1, recombine, tf_change, time_divide, v1, v2
	N0 = N
	N_B = N
	B0 = B
	time_divide = 0
	recombine = 0
	cm = uint32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	tf_change = (*band_ctx)(unsafe.Pointer(ctx)).Ftf_change
	longBlocks = libc.BoolInt32(B0 == int32(1))
	v1 = libc.Uint32FromInt32(B)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(N_B) / v1
	goto _3
_3:
	N_B = libc.Int32FromUint32(v2)
	/* Special case for one sample */
	if N == int32(1) {
		return quant_band_n1(tls, ctx, X, libc.UintptrFromInt32(0), lowband_out)
	}
	if tf_change > 0 {
		recombine = tf_change
	}
	/* Band recombining to increase frequency resolution */
	if lowband_scratch != 0 && lowband != 0 && (recombine != 0 || N_B&int32(1) == 0 && tf_change < 0 || B0 > int32(1)) {
		libc.Xmemcpy(tls, lowband_scratch, lowband, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(lowband_scratch)-int64(lowband))/4)))
		lowband = lowband_scratch
	}
	k = 0
	for {
		if !(k < recombine) {
			break
		}
		if encode != 0 {
			Opus_haar1(tls, X, N>>k, int32(1)<<k)
		}
		if lowband != 0 {
			Opus_haar1(tls, lowband, N>>k, int32(1)<<k)
		}
		fill = libc.Int32FromUint8(bit_interleave_table[fill&int32(0xF)]) | libc.Int32FromUint8(bit_interleave_table[fill>>int32(4)])<<int32(2)
		goto _4
	_4:
		;
		k = k + 1
	}
	B = B >> recombine
	N_B = N_B << recombine
	/* Increasing the time resolution */
	for N_B&int32(1) == 0 && tf_change < 0 {
		if encode != 0 {
			Opus_haar1(tls, X, N_B, B)
		}
		if lowband != 0 {
			Opus_haar1(tls, lowband, N_B, B)
		}
		fill = fill | fill<<B
		B = B << int32(1)
		N_B = N_B >> int32(1)
		time_divide = time_divide + 1
		tf_change = tf_change + 1
	}
	B0 = B
	N_B0 = N_B
	/* Reorganize the samples in time order instead of frequency order */
	if B0 > int32(1) {
		if encode != 0 {
			deinterleave_hadamard(tls, X, N_B>>recombine, B0<<recombine, longBlocks)
		}
		if lowband != 0 {
			deinterleave_hadamard(tls, lowband, N_B>>recombine, B0<<recombine, longBlocks)
		}
	}
	cm = quant_partition(tls, ctx, X, N, b, B, lowband, LM, gain, fill)
	/* This code is used by the decoder and by the resynthesis-enabled encoder */
	if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
		/* Undo the sample reorganization going from time order to frequency order */
		if B0 > int32(1) {
			interleave_hadamard(tls, X, N_B>>recombine, B0<<recombine, longBlocks)
		}
		/* Undo time-freq changes that we did earlier */
		N_B = N_B0
		B = B0
		k = 0
		for {
			if !(k < time_divide) {
				break
			}
			B = B >> int32(1)
			N_B = N_B << int32(1)
			cm = cm | cm>>B
			Opus_haar1(tls, X, N_B, B)
			goto _5
		_5:
			;
			k = k + 1
		}
		k = 0
		for {
			if !(k < recombine) {
				break
			}
			cm = uint32(bit_deinterleave_table[cm])
			Opus_haar1(tls, X, N0>>k, int32(1)<<k)
			goto _6
		_6:
			;
			k = k + 1
		}
		B = B << recombine
		/* Scale output for later folding */
		if lowband_out != 0 {
			n1 = float32(libc.Xsqrt(tls, float64(N0)))
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(lowband_out + uintptr(j)*4)) = OpusT_opus_val16(n1 * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
				goto _7
			_7:
				;
				j = j + 1
			}
		}
		cm = cm & libc.Uint32FromInt32(int32(1)<<B-int32(1))
	}
	return cm
}

var bit_interleave_table = [16]uint8{
	1:  uint8(1),
	2:  uint8(1),
	3:  uint8(1),
	4:  uint8(2),
	5:  uint8(3),
	6:  uint8(3),
	7:  uint8(3),
	8:  uint8(2),
	9:  uint8(3),
	10: uint8(3),
	11: uint8(3),
	12: uint8(2),
	13: uint8(3),
	14: uint8(3),
	15: uint8(3),
}

var bit_deinterleave_table = [16]uint8{
	1:  uint8(0x03),
	2:  uint8(0x0C),
	3:  uint8(0x0F),
	4:  uint8(0x30),
	5:  uint8(0x33),
	6:  uint8(0x3C),
	7:  uint8(0x3F),
	8:  uint8(0xC0),
	9:  uint8(0xC3),
	10: uint8(0xCC),
	11: uint8(0xCF),
	12: uint8(0xF0),
	13: uint8(0xF3),
	14: uint8(0xFC),
	15: uint8(0xFF),
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a band for the stereo case. */
func quant_band_stereo(tls *libc.TLS, ctx uintptr, X uintptr, Y uintptr, N int32, _b int32, B int32, lowband uintptr, LM int32, lowband_out uintptr, lowband_scratch uintptr, _fill int32) (r uint32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*int32)(unsafe.Pointer(bp)) = _b
	*(*int32)(unsafe.Pointer(bp + 4)) = _fill
	var c, delta, encode, imid, inv, iside, itheta, j, mbits, orig_fill, qalloc, sbits, sign, v3, v4, v5 int32
	var cm uint32
	var ec, x2, y2, v1 uintptr
	var mid, side OpusT_opus_val32
	var rebalance OpusT_opus_int32
	var tmp OpusT_celt_norm
	var _ /* sctx at bp+8 */ split_ctx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, cm, delta, ec, encode, imid, inv, iside, itheta, j, mbits, mid, orig_fill, qalloc, rebalance, sbits, side, sign, tmp, x2, y2, v1, v3, v4, v5
	imid = 0
	iside = 0
	inv = 0
	mid = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	cm = uint32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	/* Special case for one sample */
	if N == int32(1) {
		return quant_band_n1(tls, ctx, X, Y, lowband_out)
	}
	orig_fill = *(*int32)(unsafe.Pointer(bp + 4))
	if encode != 0 {
		if *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) < libc.Float32FromFloat32(1e-10) || *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).Fm)).FnbEBands+(*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) < libc.Float32FromFloat32(1e-10) {
			if *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) > *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).Fm)).FnbEBands+(*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) {
				libc.Xmemcpy(tls, Y, X, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(X))/4)))
			} else {
				libc.Xmemcpy(tls, X, Y, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(Y))/4)))
			}
		}
	}
	compute_theta(tls, ctx, bp+8, X, Y, N, bp, B, B, LM, int32(1), bp+4)
	inv = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Finv
	imid = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fimid
	iside = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fiside
	delta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fdelta
	itheta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fitheta
	qalloc = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fqalloc
	mid = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(imid))
	side = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(iside))
	/* This is a special case for N=2 that only works for stereo and takes
	   advantage of the fact that mid and side are orthogonal to encode
	   the side with just one bit. */
	if N == int32(2) {
		sign = 0
		mbits = *(*int32)(unsafe.Pointer(bp))
		sbits = 0
		/* Only need one bit for the side. */
		if itheta != 0 && itheta != int32(16384) {
			sbits = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
		}
		mbits = mbits - sbits
		c = libc.BoolInt32(itheta > int32(8192))
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc + sbits
		if c != 0 {
			v1 = Y
		} else {
			v1 = X
		}
		x2 = v1
		if c != 0 {
			v1 = X
		} else {
			v1 = Y
		}
		y2 = v1
		if sbits != 0 {
			if encode != 0 {
				/* Here we only need to encode a sign for the side. */
				/* FIXME: Need to increase fixed-point precision? */
				sign = libc.BoolInt32(OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x2))**(*OpusT_celt_norm)(unsafe.Pointer(y2 + 1*4)))-OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x2 + 1*4))**(*OpusT_celt_norm)(unsafe.Pointer(y2))) < libc.Float32FromInt32(0))
				Opus_ec_enc_bits(tls, ec, libc.Uint32FromInt32(sign), uint32(1))
			} else {
				sign = libc.Int32FromUint32(Opus_ec_dec_bits(tls, ec, uint32(1)))
			}
		}
		sign = int32(1) - int32(2)*sign
		/* We use orig_fill here because we want to fold the side, but if
		   itheta==16384, we'll have cleared the low bits of fill. */
		cm = quant_band(tls, ctx, x2, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, orig_fill)
		/* We don't split N=2 bands, so cm is either 1 or 0 (for a fold-collapse),
		   and there's no need to worry about mixing with the other channel. */
		*(*OpusT_celt_norm)(unsafe.Pointer(y2)) = OpusT_celt_norm(float32(-sign) * *(*OpusT_celt_norm)(unsafe.Pointer(x2 + 1*4)))
		*(*OpusT_celt_norm)(unsafe.Pointer(y2 + 1*4)) = OpusT_celt_norm(float32(sign) * *(*OpusT_celt_norm)(unsafe.Pointer(x2)))
		if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X)))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)) = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y)) = OpusT_opus_val32(side * *(*OpusT_celt_norm)(unsafe.Pointer(Y)))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)) = OpusT_opus_val32(side * *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)))
			tmp = *(*OpusT_celt_norm)(unsafe.Pointer(X))
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = tmp - *(*OpusT_celt_norm)(unsafe.Pointer(Y))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y)) = tmp + *(*OpusT_celt_norm)(unsafe.Pointer(Y))
			tmp = *(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)) = tmp - *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)) = tmp + *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4))
		}
	} else {
		if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
			v4 = *(*int32)(unsafe.Pointer(bp))
		} else {
			v4 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
		}
		if 0 > v4 {
			v3 = 0
		} else {
			if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
				v5 = *(*int32)(unsafe.Pointer(bp))
			} else {
				v5 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
			}
			v3 = v5
		}
		mbits = v3
		sbits = *(*int32)(unsafe.Pointer(bp)) - mbits
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc
		rebalance = (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits
		if mbits >= sbits {
			/* In stereo mode, we do not apply a scaling to the mid because we need the normalized
			   mid for folding later. */
			cm = quant_band(tls, ctx, X, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, *(*int32)(unsafe.Pointer(bp + 4)))
			rebalance = mbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != 0 {
				sbits = sbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			/* For a stereo split, the high bits of fill are always zero, so no
			   folding will be done to the side. */
			cm = cm | quant_band(tls, ctx, Y, N, sbits, B, libc.UintptrFromInt32(0), LM, libc.UintptrFromInt32(0), side, libc.UintptrFromInt32(0), *(*int32)(unsafe.Pointer(bp + 4))>>B)
		} else {
			/* For a stereo split, the high bits of fill are always zero, so no
			   folding will be done to the side. */
			cm = quant_band(tls, ctx, Y, N, sbits, B, libc.UintptrFromInt32(0), LM, libc.UintptrFromInt32(0), side, libc.UintptrFromInt32(0), *(*int32)(unsafe.Pointer(bp + 4))>>B)
			rebalance = sbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != int32(16384) {
				mbits = mbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			/* In stereo mode, we do not apply a scaling to the mid because we need the normalized
			   mid for folding later. */
			cm = cm | quant_band(tls, ctx, X, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, *(*int32)(unsafe.Pointer(bp + 4)))
		}
	}
	/* This code is used by the decoder and by the resynthesis-enabled encoder */
	if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
		if N != int32(2) {
			stereo_merge(tls, X, Y, mid, N, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
		}
		if inv != 0 {
			j = 0
			for {
				if !(j < N) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = -*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
				goto _6
			_6:
				;
				j = j + 1
			}
		}
	}
	return cm
}

func special_hybrid_folding(tls *libc.TLS, m uintptr, norm uintptr, norm2 uintptr, start int32, M int32, dual_stereo int32) {
	var eBands uintptr
	var n1, n2 int32
	_, _, _ = eBands, n1, n2
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	n1 = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))
	n2 = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(2))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(1))*2))))
	/* Duplicate enough of the first band folding data to be able to fold the second band.
	   Copies no data for CELT-only mode. */
	libc.Xmemcpy(tls, norm+uintptr(n1)*4, norm+uintptr(int32(2)*n1-n2)*4, libc.Uint64FromInt32(n2-n1)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(norm+uintptr(n1)*4)-OpusT___predefined_ptrdiff_t(norm+uintptr(int32(2)*n1-n2)*4))/4)))
	if dual_stereo != 0 {
		libc.Xmemcpy(tls, norm2+uintptr(n1)*4, norm2+uintptr(int32(2)*n1-n2)*4, libc.Uint64FromInt32(n2-n1)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(norm2+uintptr(n1)*4)-OpusT___predefined_ptrdiff_t(norm2+uintptr(int32(2)*n1-n2)*4))/4)))
	}
}

func Opus_quant_all_bands(tls *libc.TLS, encode int32, m uintptr, start int32, end int32, X_ uintptr, Y_ uintptr, collapse_masks uintptr, bandE uintptr, pulses uintptr, shortBlocks int32, spread int32, dual_stereo int32, intensity int32, tf_res uintptr, total_bits OpusT_opus_int32, balance OpusT_opus_int32, ec uintptr, LM int32, codedBands int32, seed uintptr, complexity int32, arch int32, disable_inv int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var B, C, M, N1, b, effective_lowband, fold_end, fold_i, fold_start, i, i1, j, last, lowband_offset, nend_bytes, norm_offset, nstart_bytes, resynth, resynth_alloc, save_bytes, tf_change, theta_rdo, update_lowband, v1, v183, v196, v201, v203, v207, v6 int32
	var X, X_save, X_save2, Y, Y_save, Y_save2, _lowband_scratch, _norm, _saved_stack, bytes_buf, bytes_save, eBands, lowband_scratch, norm, norm2, norm_save2, st, v11, v13, v15, v17, v19, v2, v21, v23, v25, v4, v7, v9 uintptr
	var cm, cm2, x_cm, y_cm, v217 uint32
	var ctx_save, ctx_save2 band_ctx
	var curr_balance, remaining_bits, tell, v204, v205 OpusT_opus_int32
	var dist0, dist1, xy, v229, v232 OpusT_opus_val32
	var ec_save, ec_save2 OpusT_ec_ctx
	var _ /* ctx at bp+0 */ band_ctx
	var _ /* w at bp+80 */ [2]OpusT_opus_val16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B, C, M, N1, X, X_save, X_save2, Y, Y_save, Y_save2, _lowband_scratch, _norm, _saved_stack, b, bytes_buf, bytes_save, cm, cm2, ctx_save, ctx_save2, curr_balance, dist0, dist1, eBands, ec_save, ec_save2, effective_lowband, fold_end, fold_i, fold_start, i, i1, j, last, lowband_offset, lowband_scratch, nend_bytes, norm, norm2, norm_offset, norm_save2, nstart_bytes, remaining_bits, resynth, resynth_alloc, save_bytes, st, tell, tf_change, theta_rdo, update_lowband, x_cm, xy, y_cm, v1, v11, v13, v15, v17, v183, v19, v196, v2, v201, v203, v204, v205, v207, v21, v217, v229, v23, v232, v25, v4, v6, v7, v9
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	update_lowband = int32(1)
	if Y_ != libc.UintptrFromInt32(0) {
		v1 = int32(2)
	} else {
		v1 = int32(1)
	}
	C = v1
	theta_rdo = libc.BoolInt32(encode != 0 && Y_ != libc.UintptrFromInt32(0) && !(dual_stereo != 0) && complexity >= int32(8))
	resynth = libc.BoolInt32(!(encode != 0) || theta_rdo != 0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _3
	_3:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _5
_5:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v4)).Fglobal_stack
	M = int32(1) << LM
	if shortBlocks != 0 {
		v1 = M
	} else {
		v1 = int32(1)
	}
	B = v1
	norm_offset = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2)))
	/* No need to allocate norm for the last band because we don't need an
	   output in that band. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _8
	_8:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _10
_10:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _12
	_12:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _14
_14:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _16
	_16:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _18
_18:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _20
	_20:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _22
_22:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1638))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _26
_26:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _30
_30:
	_norm = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	norm = _norm
	norm2 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2))))*4 - uintptr(norm_offset)*4
	/* For decoding, we can use the last band as scratch space because we don't need that
	   scratch space for the last band and we don't care about the data there until we're
	   decoding the last band. */
	if encode != 0 && resynth != 0 {
		resynth_alloc = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2))))
	} else {
		resynth_alloc = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1649))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _54
_54:
	_lowband_scratch = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if encode != 0 && resynth != 0 {
		lowband_scratch = _lowband_scratch
	} else {
		lowband_scratch = X_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeffEBands-int32(1))*2))))*4
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _56
	_56:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _58
_58:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _60
	_60:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _62
_62:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _64
	_64:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _66
_66:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _70
_70:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1654))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _72
	_72:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _74
_74:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _76
	_76:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _78
_78:
	X_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _82
_82:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _86
_86:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _88
	_88:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _90
_90:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _92
	_92:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _94
_94:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1655))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _96
	_96:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _98
_98:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _100
	_100:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _102
_102:
	Y_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _104
	_104:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _106
_106:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _108
	_108:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _110
_110:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _112
	_112:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _114
_114:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _116
	_116:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _118
_118:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1656))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _120
	_120:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _122
_122:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _126
_126:
	X_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _128
	_128:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _130
_130:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _132
	_132:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _134
_134:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _136
	_136:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _138
_138:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _140
	_140:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _142
_142:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1657))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _144
	_144:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _146
_146:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _148
	_148:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _150
_150:
	Y_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _152
	_152:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _154
_154:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _156
	_156:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _158
_158:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _160
	_160:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _162
_162:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _164
	_164:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _166
_166:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1658))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _168
	_168:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _170
_170:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _172
	_172:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _174
_174:
	norm_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	lowband_offset = 0
	(*(*band_ctx)(unsafe.Pointer(bp))).FbandE = bandE
	(*(*band_ctx)(unsafe.Pointer(bp))).Fec = ec
	(*(*band_ctx)(unsafe.Pointer(bp))).Fencode = encode
	(*(*band_ctx)(unsafe.Pointer(bp))).Fintensity = intensity
	(*(*band_ctx)(unsafe.Pointer(bp))).Fm = m
	(*(*band_ctx)(unsafe.Pointer(bp))).Fseed = *(*OpusT_opus_uint32)(unsafe.Pointer(seed))
	(*(*band_ctx)(unsafe.Pointer(bp))).Fspread = spread
	(*(*band_ctx)(unsafe.Pointer(bp))).Farch = arch
	(*(*band_ctx)(unsafe.Pointer(bp))).Fdisable_inv = disable_inv
	(*(*band_ctx)(unsafe.Pointer(bp))).Fresynth = resynth
	(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _176
	_176:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _178
_178:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _180
	_180:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _182
_182:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
	if theta_rdo != 0 {
		v1 = int32(1275)
	} else {
		v1 = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _185
	_185:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _187
_187:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _189
	_189:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _191
_191:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(v1)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5312, int32(1679))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _193
	_193:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _195
_195:
	if theta_rdo != 0 {
		v6 = int32(1275)
	} else {
		v6 = ALLOC_NONE
	}
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(v6) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _198
	_198:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _200
_200:
	if theta_rdo != 0 {
		v183 = int32(1275)
	} else {
		v183 = ALLOC_NONE
	}
	bytes_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(v183)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
	/* Avoid injecting noise in the first band on transients. */
	(*(*band_ctx)(unsafe.Pointer(bp))).Favoid_split_noise = libc.BoolInt32(B > int32(1))
	i1 = start
	for {
		if !(i1 < end) {
			break
		}
		effective_lowband = -int32(1)
		tf_change = 0
		(*(*band_ctx)(unsafe.Pointer(bp))).Fi = i1
		last = libc.BoolInt32(i1 == end-int32(1))
		X = X_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4
		if Y_ != libc.UintptrFromInt32(0) {
			Y = Y_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4
		} else {
			Y = libc.UintptrFromInt32(0)
		}
		N1 = M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1+int32(1))*2))) - M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))
		if !(N1 > libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5488, __ccgo_ts+5312, int32(1705))
		}
		tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec))
		/* Compute how many bits we want to allocate to this band */
		if i1 != start {
			balance = balance - tell
		}
		remaining_bits = total_bits - tell - int32(1)
		(*(*band_ctx)(unsafe.Pointer(bp))).Fremaining_bits = remaining_bits
		if i1 <= codedBands-int32(1) {
			if int32(3) < codedBands-i1 {
				v1 = int32(3)
			} else {
				v1 = codedBands - i1
			}
			v204 = v1
			_ = v204 > libc.Int32FromInt32(0)
			v205 = balance / v204
			goto _206
		_206:
			curr_balance = v205
			if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
				v183 = remaining_bits + int32(1)
			} else {
				v183 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
			}
			if int32(16383) < v183 {
				v6 = int32(16383)
			} else {
				if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
					v196 = remaining_bits + int32(1)
				} else {
					v196 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
				}
				v6 = v196
			}
			if 0 > v6 {
				v1 = 0
			} else {
				if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
					v203 = remaining_bits + int32(1)
				} else {
					v203 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
				}
				if int32(16383) < v203 {
					v201 = int32(16383)
				} else {
					if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
						v207 = remaining_bits + int32(1)
					} else {
						v207 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
					}
					v201 = v207
				}
				v1 = v201
			}
			b = v1
		} else {
			b = 0
		}
		if resynth != 0 && (M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))-N1 >= M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))) || i1 == start+int32(1)) && (update_lowband != 0 || lowband_offset == 0) {
			lowband_offset = i1
		}
		if i1 == start+int32(1) {
			special_hybrid_folding(tls, m, norm, norm2, start, M, dual_stereo)
		}
		tf_change = *(*int32)(unsafe.Pointer(tf_res + uintptr(i1)*4))
		(*(*band_ctx)(unsafe.Pointer(bp))).Ftf_change = tf_change
		if i1 >= (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeffEBands {
			X = norm
			if Y_ != libc.UintptrFromInt32(0) {
				Y = norm
			}
			lowband_scratch = libc.UintptrFromInt32(0)
		}
		if last != 0 && !(theta_rdo != 0) {
			lowband_scratch = libc.UintptrFromInt32(0)
		}
		/* Get a conservative estimate of the collapse_mask's for the bands we're
		   going to be folding from. */
		if lowband_offset != 0 && (spread != int32(SPREAD_AGGRESSIVE) || B > int32(1) || tf_change < 0) {
			/* This ensures we never repeat spectral content within one band */
			if 0 > M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(lowband_offset)*2)))-norm_offset-N1 {
				v1 = 0
			} else {
				v1 = M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(lowband_offset)*2))) - norm_offset - N1
			}
			effective_lowband = v1
			fold_start = lowband_offset
			for {
				fold_start = fold_start - 1
				v1 = fold_start
				if !(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(v1)*2))) > effective_lowband+norm_offset) {
					break
				}
			}
			fold_end = lowband_offset - int32(1)
			for {
				fold_end = fold_end + 1
				v1 = fold_end
				if !(v1 < i1 && M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(fold_end)*2))) < effective_lowband+norm_offset+N1) {
					break
				}
			}
			v217 = libc.Uint32FromInt32(0)
			y_cm = v217
			x_cm = v217
			fold_i = fold_start
			for {
				x_cm = x_cm | uint32(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(fold_i*C+0))))
				y_cm = y_cm | uint32(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(fold_i*C+C-int32(1)))))
				goto _219
			_219:
				;
				fold_i = fold_i + 1
				v1 = fold_i
				if !(v1 < fold_end) {
					break
				}
			}
		} else {
			v217 = libc.Uint32FromInt32(libc.Int32FromInt32(1)<<B - libc.Int32FromInt32(1))
			y_cm = v217
			x_cm = v217
		}
		if dual_stereo != 0 && i1 == intensity {
			/* Switch off dual stereo to do intensity. */
			dual_stereo = 0
			if resynth != 0 {
				j = 0
				for {
					if !(j < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))-norm_offset) {
						break
					}
					*(*OpusT_celt_norm)(unsafe.Pointer(norm + uintptr(j)*4)) = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_celt_norm)(unsafe.Pointer(norm + uintptr(j)*4)) + *(*OpusT_celt_norm)(unsafe.Pointer(norm2 + uintptr(j)*4))))
					goto _221
				_221:
					;
					j = j + 1
				}
			}
		}
		if dual_stereo != 0 {
			if effective_lowband != -int32(1) {
				v2 = norm + uintptr(effective_lowband)*4
			} else {
				v2 = libc.UintptrFromInt32(0)
			}
			if last != 0 {
				v4 = libc.UintptrFromInt32(0)
			} else {
				v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
			}
			x_cm = quant_band(tls, bp, X, N1, b/int32(2), B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(x_cm))
			if effective_lowband != -int32(1) {
				v2 = norm2 + uintptr(effective_lowband)*4
			} else {
				v2 = libc.UintptrFromInt32(0)
			}
			if last != 0 {
				v4 = libc.UintptrFromInt32(0)
			} else {
				v4 = norm2 + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
			}
			y_cm = quant_band(tls, bp, Y, N1, b/int32(2), B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(y_cm))
		} else {
			if Y != libc.UintptrFromInt32(0) {
				if theta_rdo != 0 && i1 < intensity {
					compute_channel_weights(tls, *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1)*4)), *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1+(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)), bp+80)
					/* Make a copy. */
					cm = x_cm | y_cm
					ec_save = *(*OpusT_ec_ctx)(unsafe.Pointer(ec))
					ctx_save = *(*band_ctx)(unsafe.Pointer(bp))
					libc.Xmemcpy(tls, X_save, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X_save)-int64(X))/4)))
					libc.Xmemcpy(tls, Y_save, Y, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y_save)-int64(Y))/4)))
					/* Encode and round down. */
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = -int32(1)
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(cm))
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
						goto _228
					_228:
						;
						i = i + 1
					}
					v229 = xy
					goto _230
				_230:
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
						goto _231
					_231:
						;
						i = i + 1
					}
					v232 = xy
					goto _233
				_233:
					dist0 = OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[0]*v229) + OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[int32(1)]*v232)
					/* Save first result. */
					cm2 = x_cm
					ec_save2 = *(*OpusT_ec_ctx)(unsafe.Pointer(ec))
					ctx_save2 = *(*band_ctx)(unsafe.Pointer(bp))
					libc.Xmemcpy(tls, X_save2, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X_save2)-int64(X))/4)))
					libc.Xmemcpy(tls, Y_save2, Y, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y_save2)-int64(Y))/4)))
					if !(last != 0) {
						libc.Xmemcpy(tls, norm_save2, norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(norm_save2)-int64(norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4))/4)))
					}
					nstart_bytes = libc.Int32FromUint32(ec_save.Foffs)
					nend_bytes = libc.Int32FromUint32(ec_save.Fstorage)
					bytes_buf = ec_save.Fbuf + uintptr(nstart_bytes)
					save_bytes = nend_bytes - nstart_bytes
					libc.Xmemcpy(tls, bytes_save, bytes_buf, libc.Uint64FromInt32(save_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(bytes_save)-int64(bytes_buf))))
					/* Restore */
					*(*OpusT_ec_ctx)(unsafe.Pointer(ec)) = ec_save
					*(*band_ctx)(unsafe.Pointer(bp)) = ctx_save
					libc.Xmemcpy(tls, X, X_save, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(X_save))/4)))
					libc.Xmemcpy(tls, Y, Y_save, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(Y_save))/4)))
					if i1 == start+int32(1) {
						special_hybrid_folding(tls, m, norm, norm2, start, M, dual_stereo)
					}
					/* Encode and round up. */
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = int32(1)
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(cm))
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
						goto _236
					_236:
						;
						i = i + 1
					}
					v229 = xy
					goto _238
				_238:
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
						goto _239
					_239:
						;
						i = i + 1
					}
					v232 = xy
					goto _241
				_241:
					dist1 = OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[0]*v229) + OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[int32(1)]*v232)
					if dist0 >= dist1 {
						x_cm = cm2
						*(*OpusT_ec_ctx)(unsafe.Pointer(ec)) = ec_save2
						*(*band_ctx)(unsafe.Pointer(bp)) = ctx_save2
						libc.Xmemcpy(tls, X, X_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(X_save2))/4)))
						libc.Xmemcpy(tls, Y, Y_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(Y_save2))/4)))
						if !(last != 0) {
							libc.Xmemcpy(tls, norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4, norm_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4)-int64(norm_save2))/4)))
						}
						libc.Xmemcpy(tls, bytes_buf, bytes_save, libc.Uint64FromInt32(save_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(bytes_buf)-int64(bytes_save))))
					}
				} else {
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = 0
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(x_cm|y_cm))
				}
			} else {
				if effective_lowband != -int32(1) {
					v2 = norm + uintptr(effective_lowband)*4
				} else {
					v2 = libc.UintptrFromInt32(0)
				}
				if last != 0 {
					v4 = libc.UintptrFromInt32(0)
				} else {
					v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
				}
				x_cm = quant_band(tls, bp, X, N1, b, B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(x_cm|y_cm))
			}
			y_cm = x_cm
		}
		*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i1*C+0))) = uint8(x_cm)
		*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i1*C+C-int32(1)))) = uint8(y_cm)
		balance = balance + (*(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + tell)
		/* Update the folding position only as long as we have 1 bit/sample depth. */
		update_lowband = libc.BoolInt32(b > N1<<int32(BITRES))
		/* We only need to avoid noise on a split for the first band. After that, we
		   have folding. */
		(*(*band_ctx)(unsafe.Pointer(bp))).Favoid_split_noise = 0
		goto _202
	_202:
		;
		i1 = i1 + 1
	}
	*(*OpusT_opus_uint32)(unsafe.Pointer(seed)) = (*(*band_ctx)(unsafe.Pointer(bp))).Fseed
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _247
	_247:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _249
_249:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v4)).Fglobal_stack = _saved_stack
}

const EPSILON4 = "1e-15f"
const NORM_SCALING2 = "1.f"
const Q31ONE4 = "1.0f"

var log2_x_norm_coeff15 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff15 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

// C documentation
//
//	/* Forward MDCT trashes the input array */
func Opus_clt_mdct_forward_c(tls *libc.TLS, l uintptr, in uintptr, out uintptr, window uintptr, overlap int32, shift int32, stride int32, arch int32) {
	var N, N2, N4, i int32
	var _saved_stack, f, f2, fp, st, st1, t, t1, trig, wp1, wp2, xp1, xp2, yp, yp1, yp11, yp2, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var im, re, t0, t01, t11, t12, yi, yi1, yr, yr1 float32
	var scale OpusT_celt_coef
	var yc OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N2, N4, _saved_stack, f, f2, fp, i, im, re, scale, st, st1, t, t0, t01, t1, t11, t12, trig, wp1, wp2, xp1, xp2, yc, yi, yi1, yp, yp1, yp11, yp2, yr, yr1, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8
	st1 = *(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = arch
	scale = (*OpusT_kiss_fft_state)(unsafe.Pointer(st1)).Fscale
	N = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Fn
	trig = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Ftrig
	i = 0
	for {
		if !(i < shift) {
			break
		}
		N = N >> int32(1)
		trig = trig + uintptr(N)*4
		goto _5
	_5:
		;
		i = i + 1
	}
	N2 = N >> int32(1)
	N4 = N >> int32(2)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5512, int32(152))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(N2) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	f = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _37
_37:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _41
_41:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _45
_45:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N4)*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5512, int32(153))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _49
_49:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(N4) * (libc.Uint64FromInt64(8) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _53
_53:
	f2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N4)*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))
	/* Consider the input to be composed of four blocks: [a, b, c, d] */
	/* Window, shuffle, fold */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	xp1 = in + uintptr(overlap>>libc.Int32FromInt32(1))*4
	xp2 = in + uintptr(N2)*4 - uintptr(1)*4 + uintptr(overlap>>libc.Int32FromInt32(1))*4
	yp = f
	wp1 = window + uintptr(overlap>>libc.Int32FromInt32(1))*4
	wp2 = window + uintptr(overlap>>libc.Int32FromInt32(1))*4 - uintptr(1)*4
	i = 0
	for {
		if !(i < (overlap+int32(3))>>int32(2)) {
			break
		}
		/* Real part arranged as -d-cR, Imag part arranged as -b+aR*/
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1 + uintptr(N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) + float32(*(*float32)(unsafe.Pointer(xp2))**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1))**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) - float32(*(*float32)(unsafe.Pointer(xp2 + uintptr(-N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		wp1 = wp1 + uintptr(2)*4
		wp2 = wp2 - uintptr(2)*4
		goto _54
	_54:
		;
		i = i + 1
	}
	wp1 = window
	wp2 = window + uintptr(overlap)*4 - uintptr(1)*4
	for {
		if !(i < N4-(overlap+int32(3))>>int32(2)) {
			break
		}
		/* Real part arranged as a-bR, Imag part arranged as -c-dR */
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = *(*float32)(unsafe.Pointer(xp2))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = *(*float32)(unsafe.Pointer(xp1))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		goto _57
	_57:
		;
		i = i + 1
	}
	for {
		if !(i < N4) {
			break
		}
		/* Real part arranged as a-bR, Imag part arranged as -c-dR */
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = -float32(*(*float32)(unsafe.Pointer(xp1 + uintptr(-N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) + float32(*(*float32)(unsafe.Pointer(xp2))**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1))**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) + float32(*(*float32)(unsafe.Pointer(xp2 + uintptr(N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		wp1 = wp1 + uintptr(2)*4
		wp2 = wp2 - uintptr(2)*4
		goto _60
	_60:
		;
		i = i + 1
	}
	/* Pre-rotation */
	yp1 = f
	t = trig
	i = 0
	for {
		if !(i < N4) {
			break
		}
		t0 = *(*float32)(unsafe.Pointer(t + uintptr(i)*4))
		t11 = *(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4))
		v1 = yp1
		yp1 += 4
		re = *(*float32)(unsafe.Pointer(v1))
		v1 = yp1
		yp1 += 4
		im = *(*float32)(unsafe.Pointer(v1))
		yr = float32(re*t0) - float32(im*t11)
		yi = float32(im*t0) + float32(re*t11)
		/* For QEXT, it's best to scale before the FFT, but otherwise it's best to scale after.
		   For floating-point it doesn't matter. */
		yc.Fr = float32(yr * scale)
		yc.Fi = float32(yi * scale)
		*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(f2 + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st1)).Fbitrev + uintptr(i)*2)))*8)) = yc
		goto _63
	_63:
		;
		i = i + 1
	}
	/* N/4 complex FFT, does not downscale anymore */
	Opus_opus_fft_impl(tls, st1, f2)
	/* Post-rotate */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	fp = f2
	yp11 = out
	yp2 = out + uintptr(stride*(N2-int32(1)))*4
	t1 = trig
	/* Temp pointers to make it really clear to the compiler what we're doing */
	i = 0
	for {
		if !(i < N4) {
			break
		}
		t01 = *(*float32)(unsafe.Pointer(t1 + uintptr(i)*4))
		t12 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4+i)*4))
		yr1 = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fi*t12) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fr*t01)
		yi1 = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fr*t12) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fi*t01)
		*(*float32)(unsafe.Pointer(yp11)) = yr1
		*(*float32)(unsafe.Pointer(yp2)) = yi1
		fp += 8
		yp11 = yp11 + uintptr(int32(2)*stride)*4
		yp2 = yp2 - uintptr(int32(2)*stride)*4
		goto _66
	_66:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _70
_70:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_clt_mdct_backward_c(tls *libc.TLS, l uintptr, in uintptr, out uintptr, window uintptr, overlap int32, shift int32, stride int32, arch int32) {
	var N, N2, N4, i, rev int32
	var bitrev, t, t1, trig, wp1, wp2, xp1, xp11, xp2, yp, yp0, yp1, yp11, v3 uintptr
	var im, re, t0, t11, x11, x21, yi, yi1, yr, yr1 float32
	var x1, x2 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N2, N4, bitrev, i, im, re, rev, t, t0, t1, t11, trig, wp1, wp2, x1, x11, x2, x21, xp1, xp11, xp2, yi, yi1, yp, yp0, yp1, yp11, yr, yr1, v3
	_ = arch
	N = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Fn
	trig = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Ftrig
	i = 0
	for {
		if !(i < shift) {
			break
		}
		N = N >> int32(1)
		trig = trig + uintptr(N)*4
		goto _1
	_1:
		;
		i = i + 1
	}
	N2 = N >> int32(1)
	N4 = N >> int32(2)
	/* Pre-rotate */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	xp1 = in
	xp2 = in + uintptr(stride*(N2-int32(1)))*4
	yp = out + uintptr(overlap>>libc.Int32FromInt32(1))*4
	t = trig
	bitrev = (*OpusT_kiss_fft_state)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8)))).Fbitrev
	i = 0
	for {
		if !(i < N4) {
			break
		}
		v3 = bitrev
		bitrev += 2
		rev = int32(*(*OpusT_opus_int16)(unsafe.Pointer(v3)))
		x1 = *(*float32)(unsafe.Pointer(xp1))
		x2 = *(*float32)(unsafe.Pointer(xp2))
		yr = OpusT_opus_val32(x2**(*float32)(unsafe.Pointer(t + uintptr(i)*4))) + OpusT_opus_val32(x1**(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4)))
		yi = OpusT_opus_val32(x1**(*float32)(unsafe.Pointer(t + uintptr(i)*4))) - OpusT_opus_val32(x2**(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4)))
		/* We swap real and imag because we use an FFT instead of an IFFT. */
		*(*float32)(unsafe.Pointer(yp + uintptr(int32(2)*rev+int32(1))*4)) = yr
		*(*float32)(unsafe.Pointer(yp + uintptr(int32(2)*rev)*4)) = yi
		/* Storing the pre-rotation directly in the bitrev order. */
		xp1 = xp1 + uintptr(int32(2)*stride)*4
		xp2 = xp2 - uintptr(int32(2)*stride)*4
		goto _2
	_2:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, *(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8)), out+uintptr(overlap>>libc.Int32FromInt32(1))*4)
	/* Post-rotate and de-shuffle from both ends of the buffer at once to make
	   it in-place. */
	yp0 = out + uintptr(overlap>>libc.Int32FromInt32(1))*4
	yp1 = out + uintptr(overlap>>libc.Int32FromInt32(1))*4 + uintptr(N2)*4 - uintptr(2)*4
	t1 = trig
	/* Loop to (N4+1)>>1 to handle odd N4. When N4 is odd, the
	   middle pair will be computed twice. */
	i = 0
	for {
		if !(i < (N4+int32(1))>>int32(1)) {
			break
		}
		/* We swap real and imag because we're using an FFT instead of an IFFT. */
		re = *(*float32)(unsafe.Pointer(yp0 + 1*4))
		im = *(*float32)(unsafe.Pointer(yp0))
		t0 = *(*float32)(unsafe.Pointer(t1 + uintptr(i)*4))
		t11 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4+i)*4))
		/* We'd scale up by 2 here, but instead it's done when mixing the windows */
		yr1 = float32(re*t0) + float32(im*t11)
		yi1 = float32(re*t11) - float32(im*t0)
		/* We swap real and imag because we're using an FFT instead of an IFFT. */
		re = *(*float32)(unsafe.Pointer(yp1 + 1*4))
		im = *(*float32)(unsafe.Pointer(yp1))
		*(*float32)(unsafe.Pointer(yp0)) = yr1
		*(*float32)(unsafe.Pointer(yp1 + 1*4)) = yi1
		t0 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4-i-libc.Int32FromInt32(1))*4))
		t11 = *(*float32)(unsafe.Pointer(t1 + uintptr(N2-i-libc.Int32FromInt32(1))*4))
		/* We'd scale up by 2 here, but instead it's done when mixing the windows */
		yr1 = float32(re*t0) + float32(im*t11)
		yi1 = float32(re*t11) - float32(im*t0)
		*(*float32)(unsafe.Pointer(yp1)) = yr1
		*(*float32)(unsafe.Pointer(yp0 + 1*4)) = yi1
		yp0 = yp0 + uintptr(2)*4
		yp1 = yp1 - uintptr(2)*4
		goto _4
	_4:
		;
		i = i + 1
	}
	/* Mirror on both sides for TDAC */
	xp11 = out + uintptr(overlap)*4 - uintptr(1)*4
	yp11 = out
	wp1 = window
	wp2 = window + uintptr(overlap)*4 - uintptr(1)*4
	i = 0
	for {
		if !(i < overlap/int32(2)) {
			break
		}
		x11 = *(*float32)(unsafe.Pointer(xp11))
		x21 = *(*float32)(unsafe.Pointer(yp11))
		v3 = yp11
		yp11 += 4
		*(*float32)(unsafe.Pointer(v3)) = float32(x21**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) - float32(x11**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		v3 = xp11
		xp11 -= 4
		*(*float32)(unsafe.Pointer(v3)) = float32(x21**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) + float32(x11**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		wp1 += 4
		wp2 -= 4
		goto _5
	_5:
		;
		i = i + 1
	}
}

const MINI_MAXFACTORS = 32
const mini_kiss_fft_scalar = "float"

type OpusT_mini_kiss_fft_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_mini_kiss_fft_cfg = uintptr

type mini_kiss_fft_state = struct {
	Fnfft     int32
	Finverse  int32
	Ffactors  [64]int32
	Ftwiddles [1]OpusT_mini_kiss_fft_cpx
}

/* e.g. an fft of length 128 has 4 factors
as far as kissfft is concerned
4*4*4*2
*/

type OpusT_mini_kiss_fft_state = struct {
	Fnfft     int32
	Finverse  int32
	Ffactors  [64]int32
	Ftwiddles [1]OpusT_mini_kiss_fft_cpx
}

/*
  Explanation of macros dealing with complex math:

   C_MUL(m,a,b)         : m = a*b
   C_FIXDIV( c , div )  : if a fixed point impl., c /= div. noop otherwise
   C_SUB( res, a,b)     : res = a - b
   C_SUBFROM( res , a)  : res -= a
   C_ADDTO( res , a)    : res += a
 * */

func kf_bfly21(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m int32) {
	var Fout2, tw1 uintptr
	var t OpusT_mini_kiss_fft_cpx
	var v1 int32
	_, _, _, _ = Fout2, t, tw1, v1
	tw1 = st + 264
	Fout2 = Fout + uintptr(m)*8
	for {
		t.Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		t.Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		tw1 = tw1 + uintptr(fstride)*8
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - t.Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - t.Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += t.Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += t.Fi
		Fout2 += 8
		Fout += 8
		goto _2
	_2:
		;
		m = m - 1
		v1 = m
		if !(v1 != 0) {
			break
		}
	}
}

func kf_bfly41(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m OpusT_size_t) {
	var k, m2, m3, v3 OpusT_size_t
	var scratch [6]OpusT_mini_kiss_fft_cpx
	var tw1, tw2, tw3, v1, v2 uintptr
	_, _, _, _, _, _, _, _, _, _ = k, m2, m3, scratch, tw1, tw2, tw3, v1, v2, v3
	k = m
	m2 = uint64(2) * m
	m3 = uint64(3) * m
	v2 = st + 264
	tw1 = v2
	v1 = v2
	tw2 = v1
	tw3 = v1
	for {
		scratch[0].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		scratch[0].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		scratch[int32(1)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi)
		scratch[int32(1)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr)
		scratch[int32(2)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fi)
		scratch[int32(2)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fr)
		scratch[int32(5)].Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(1)].Fr
		scratch[int32(5)].Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(1)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(1)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(1)].Fi
		scratch[int32(3)].Fr = scratch[0].Fr + scratch[int32(2)].Fr
		scratch[int32(3)].Fi = scratch[0].Fi + scratch[int32(2)].Fi
		scratch[int32(4)].Fr = scratch[0].Fr - scratch[int32(2)].Fr
		scratch[int32(4)].Fi = scratch[0].Fi - scratch[int32(2)].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(3)].Fr
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(3)].Fi
		tw1 = tw1 + uintptr(fstride)*8
		tw2 = tw2 + uintptr(fstride*uint64(2))*8
		tw3 = tw3 + uintptr(fstride*uint64(3))*8
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
		if (*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse != 0 {
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
		} else {
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
		}
		Fout += 8
		goto _4
	_4:
		;
		k = k - 1
		v3 = k
		if !(v3 != 0) {
			break
		}
	}
}

func kf_bfly31(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m OpusT_size_t) {
	var epi3 OpusT_mini_kiss_fft_cpx
	var k, m2, v2 OpusT_size_t
	var scratch [5]OpusT_mini_kiss_fft_cpx
	var tw1, tw2, v1 uintptr
	_, _, _, _, _, _, _, _ = epi3, k, m2, scratch, tw1, tw2, v1, v2
	k = m
	m2 = uint64(2) * m
	epi3 = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(fstride*m)*8))
	v1 = st + 264
	tw2 = v1
	tw1 = v1
	for {
		scratch[int32(1)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		scratch[int32(1)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		scratch[int32(2)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi)
		scratch[int32(2)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr)
		scratch[int32(3)].Fr = scratch[int32(1)].Fr + scratch[int32(2)].Fr
		scratch[int32(3)].Fi = scratch[int32(1)].Fi + scratch[int32(2)].Fi
		scratch[0].Fr = scratch[int32(1)].Fr - scratch[int32(2)].Fr
		scratch[0].Fi = scratch[int32(1)].Fi - scratch[int32(2)].Fi
		tw1 = tw1 + uintptr(fstride)*8
		tw2 = tw2 + uintptr(fstride*uint64(2))*8
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - float32(scratch[int32(3)].Fr*libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - float32(scratch[int32(3)].Fi*libc.Float32FromFloat64(0.5))
		scratch[0].Fr *= epi3.Fi
		scratch[0].Fi *= epi3.Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr + scratch[0].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi - scratch[0].Fr
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr -= scratch[0].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi += scratch[0].Fr
		Fout += 8
		goto _3
	_3:
		;
		k = k - 1
		v2 = k
		if !(v2 != 0) {
			break
		}
	}
}

func kf_bfly51(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m int32) {
	var Fout0, Fout1, Fout2, Fout3, Fout4, tw, twiddles uintptr
	var scratch [13]OpusT_mini_kiss_fft_cpx
	var u int32
	var ya, yb OpusT_mini_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _ = Fout0, Fout1, Fout2, Fout3, Fout4, scratch, tw, twiddles, u, ya, yb
	twiddles = st + 264
	ya = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(twiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	yb = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(twiddles + uintptr(fstride*uint64(2)*libc.Uint64FromInt32(m))*8))
	Fout0 = Fout
	Fout1 = Fout0 + uintptr(m)*8
	Fout2 = Fout0 + uintptr(int32(2)*m)*8
	Fout3 = Fout0 + uintptr(int32(3)*m)*8
	Fout4 = Fout0 + uintptr(int32(4)*m)*8
	tw = st + 264
	u = 0
	for {
		if !(u < m) {
			break
		}
		scratch[0] = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout0))
		scratch[int32(1)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi)
		scratch[int32(1)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr)
		scratch[int32(2)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi)
		scratch[int32(2)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr)
		scratch[int32(3)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi)
		scratch[int32(3)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr)
		scratch[int32(4)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi)
		scratch[int32(4)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr)
		scratch[int32(7)].Fr = scratch[int32(1)].Fr + scratch[int32(4)].Fr
		scratch[int32(7)].Fi = scratch[int32(1)].Fi + scratch[int32(4)].Fi
		scratch[int32(10)].Fr = scratch[int32(1)].Fr - scratch[int32(4)].Fr
		scratch[int32(10)].Fi = scratch[int32(1)].Fi - scratch[int32(4)].Fi
		scratch[int32(8)].Fr = scratch[int32(2)].Fr + scratch[int32(3)].Fr
		scratch[int32(8)].Fi = scratch[int32(2)].Fi + scratch[int32(3)].Fi
		scratch[int32(9)].Fr = scratch[int32(2)].Fr - scratch[int32(3)].Fr
		scratch[int32(9)].Fi = scratch[int32(2)].Fi - scratch[int32(3)].Fi
		*(*float32)(unsafe.Pointer(Fout0)) += scratch[int32(7)].Fr + scratch[int32(8)].Fr
		*(*float32)(unsafe.Pointer(Fout0 + 4)) += scratch[int32(7)].Fi + scratch[int32(8)].Fi
		scratch[int32(5)].Fr = scratch[0].Fr + float32(scratch[int32(7)].Fr*ya.Fr) + float32(scratch[int32(8)].Fr*yb.Fr)
		scratch[int32(5)].Fi = scratch[0].Fi + float32(scratch[int32(7)].Fi*ya.Fr) + float32(scratch[int32(8)].Fi*yb.Fr)
		scratch[int32(6)].Fr = float32(scratch[int32(10)].Fi*ya.Fi) + float32(scratch[int32(9)].Fi*yb.Fi)
		scratch[int32(6)].Fi = -float32(scratch[int32(10)].Fr*ya.Fi) - float32(scratch[int32(9)].Fr*yb.Fi)
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr = scratch[int32(5)].Fr - scratch[int32(6)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi = scratch[int32(5)].Fi - scratch[int32(6)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr = scratch[int32(5)].Fr + scratch[int32(6)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi = scratch[int32(5)].Fi + scratch[int32(6)].Fi
		scratch[int32(11)].Fr = scratch[0].Fr + float32(scratch[int32(7)].Fr*yb.Fr) + float32(scratch[int32(8)].Fr*ya.Fr)
		scratch[int32(11)].Fi = scratch[0].Fi + float32(scratch[int32(7)].Fi*yb.Fr) + float32(scratch[int32(8)].Fi*ya.Fr)
		scratch[int32(12)].Fr = -float32(scratch[int32(10)].Fi*yb.Fi) + float32(scratch[int32(9)].Fi*ya.Fi)
		scratch[int32(12)].Fi = float32(scratch[int32(10)].Fr*yb.Fi) - float32(scratch[int32(9)].Fr*ya.Fi)
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = scratch[int32(11)].Fr + scratch[int32(12)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = scratch[int32(11)].Fi + scratch[int32(12)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr = scratch[int32(11)].Fr - scratch[int32(12)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi = scratch[int32(11)].Fi - scratch[int32(12)].Fi
		Fout0 += 8
		Fout1 += 8
		Fout2 += 8
		Fout3 += 8
		Fout4 += 8
		goto _1
	_1:
		;
		u = u + 1
	}
}

func kf_work(tls *libc.TLS, Fout uintptr, f uintptr, fstride OpusT_size_t, in_stride int32, factors uintptr, st OpusT_mini_kiss_fft_cfg) {
	var Fout_beg, Fout_end, v1, v2, v3 uintptr
	var m, p int32
	var v6 bool
	_, _, _, _, _, _, _, _ = Fout_beg, Fout_end, m, p, v1, v2, v3, v6
	Fout_beg = Fout
	v1 = factors
	factors += 4
	p = *(*int32)(unsafe.Pointer(v1))
	v2 = factors
	factors += 4                      /* the radix  */
	m = *(*int32)(unsafe.Pointer(v2)) /* stage's fft length/p */
	Fout_end = Fout + uintptr(p*m)*8
	if m == int32(1) {
		for {
			*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)) = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(f))
			f = f + uintptr(fstride*libc.Uint64FromInt32(in_stride))*8
			goto _4
		_4:
			;
			Fout += 8
			v3 = Fout
			if !(v3 != Fout_end) {
				break
			}
		}
	} else {
		for {
			/* recursive call:
			   DFT of size m*p performed by doing
			   p instances of smaller DFTs of size m,
			   each one takes a decimated version of the input */
			kf_work(tls, Fout, f, fstride*libc.Uint64FromInt32(p), in_stride, factors, st)
			f = f + uintptr(fstride*libc.Uint64FromInt32(in_stride))*8
			goto _5
		_5:
			;
			Fout = Fout + uintptr(m)*8
			if !(Fout != Fout_end) {
				break
			}
		}
	}
	Fout = Fout_beg
	/* recombine the p smaller DFTs*/
	switch p {
	case int32(2):
		kf_bfly21(tls, Fout, fstride, st, m)
	case int32(3):
		kf_bfly31(tls, Fout, fstride, st, libc.Uint64FromInt32(m))
	case int32(4):
		kf_bfly41(tls, Fout, fstride, st, libc.Uint64FromInt32(m))
	case int32(5):
		kf_bfly51(tls, Fout, fstride, st, m)
	default:
		if v6 = libc.Bool(0 != 0); !v6 {
			libc.X__assert_fail(tls, __ccgo_ts+5527, __ccgo_ts+5529, int32(317), uintptr(unsafe.Pointer(&__func__)))
		}
		_ = v6 || libc.Bool(libc.Int32FromInt32(0) != 0)
	}
}

var __func__ = [8]int8{'k', 'f', '_', 'w', 'o', 'r', 'k'}

// C documentation
//
//	/*  facbuf is populated by p1,m1,p2,m2, ...
//	    where
//	    p[i] * m[i] = m[i-1]
//	    m0 = n                  */
func kf_factor(tls *libc.TLS, n int32, facbuf uintptr) {
	var floor_sqrt float64
	var p int32
	var v1 uintptr
	_, _, _ = floor_sqrt, p, v1
	p = int32(4)
	floor_sqrt = libc.Xfloor(tls, libc.Xsqrt(tls, float64(n)))
	/*factor out powers of 4, powers of 2, then any remaining primes */
	for cond := true; cond; cond = n > int32(1) {
		for n%p != 0 {
			switch p {
			case int32(4):
				p = int32(2)
			case int32(2):
				p = int32(3)
			default:
				p = p + int32(2)
				break
			}
			if float64(p) > floor_sqrt {
				p = n
			} /* no more factors, skip to end */
		}
		n = n / p
		v1 = facbuf
		facbuf += 4
		*(*int32)(unsafe.Pointer(v1)) = p
		v1 = facbuf
		facbuf += 4
		*(*int32)(unsafe.Pointer(v1)) = n
	}
}

// C documentation
//
//	/*
//	 *
//	 * User-callable function to allocate all necessary storage space for the fft.
//	 *
//	 * The return value is a contiguous block of memory, allocated with malloc.  As such,
//	 * It can be freed with free(), rather than a kiss_fft-specific function.
//	 * */
func Opus_mini_kiss_fft_alloc(tls *libc.TLS, nfft int32, inverse_fft int32, mem uintptr, lenmem uintptr) (r OpusT_mini_kiss_fft_cfg) {
	var i int32
	var memneeded OpusT_size_t
	var phase, pi float64
	var st OpusT_mini_kiss_fft_cfg
	_, _, _, _, _ = i, memneeded, phase, pi, st
	st = libc.UintptrFromInt32(0)
	memneeded = libc.Uint64FromInt64(272) + libc.Uint64FromInt64(8)*libc.Uint64FromInt32(nfft-libc.Int32FromInt32(1)) /* twiddle factors*/
	if lenmem == libc.UintptrFromInt32(0) {
		st = libc.Xmalloc(tls, memneeded)
	} else {
		if mem != libc.UintptrFromInt32(0) && *(*OpusT_size_t)(unsafe.Pointer(lenmem)) >= memneeded {
			st = mem
		}
		*(*OpusT_size_t)(unsafe.Pointer(lenmem)) = memneeded
	}
	if st != 0 {
		(*mini_kiss_fft_state)(unsafe.Pointer(st)).Fnfft = nfft
		(*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse = inverse_fft
		i = 0
		for {
			if !(i < nfft) {
				break
			}
			pi = float64(3.141592653589793)
			phase = float64(float64(float64(-libc.Int32FromInt32(2))*pi)*float64(i)) / float64(nfft)
			if (*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse != 0 {
				phase = phase * float64(-libc.Int32FromInt32(1))
			}
			(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(i)*8)).Fr = float32(libc.Xcos(tls, phase))
			(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(i)*8)).Fi = float32(libc.Xsin(tls, phase))
			goto _1
		_1:
			;
			i = i + 1
		}
		kf_factor(tls, nfft, st+8)
	}
	return st
}

func Opus_mini_kiss_fft_stride(tls *libc.TLS, st OpusT_mini_kiss_fft_cfg, fin uintptr, fout uintptr, in_stride int32) {
	var v1 bool
	_ = v1
	if v1 = fin != fout; !v1 {
		libc.X__assert_fail(tls, __ccgo_ts+5549, __ccgo_ts+5529, int32(391), uintptr(unsafe.Pointer(&__func__1)))
	}
	_ = v1 || libc.Bool(libc.Int32FromInt32(0) != 0)
	kf_work(tls, fout, fin, uint64(1), in_stride, st+8, st)
}

var __func__1 = [21]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', '_', 's', 't', 'r', 'i', 'd', 'e'}

func Opus_mini_kiss_fft(tls *libc.TLS, cfg OpusT_mini_kiss_fft_cfg, fin uintptr, fout uintptr) {
	Opus_mini_kiss_fft_stride(tls, cfg, fin, fout, int32(1))
}

type OpusT_mini_kiss_fftr_cfg = uintptr

type mini_kiss_fftr_state = struct {
	Fsubstate       OpusT_mini_kiss_fft_cfg
	Ftmpbuf         uintptr
	Fsuper_twiddles uintptr
}

type OpusT_mini_kiss_fftr_state = struct {
	Fsubstate       OpusT_mini_kiss_fft_cfg
	Ftmpbuf         uintptr
	Fsuper_twiddles uintptr
}

func Opus_mini_kiss_fftr_alloc(tls *libc.TLS, nfft int32, inverse_fft int32, mem uintptr, lenmem uintptr) (r OpusT_mini_kiss_fftr_cfg) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i int32
	var memneeded OpusT_size_t
	var phase float64
	var st OpusT_mini_kiss_fftr_cfg
	var v1 bool
	var _ /* subsize at bp+0 */ OpusT_size_t
	_, _, _, _, _ = i, memneeded, phase, st, v1
	st = libc.UintptrFromInt32(0)
	*(*OpusT_size_t)(unsafe.Pointer(bp)) = uint64(0)
	if v1 = nfft&int32(1) == 0; !v1 {
		libc.X__assert_fail(tls, __ccgo_ts+5561, __ccgo_ts+5529, int32(416), uintptr(unsafe.Pointer(&__func__2)))
	}
	_ = v1 || libc.Bool(libc.Int32FromInt32(0) != 0)
	nfft = nfft >> int32(1)
	Opus_mini_kiss_fft_alloc(tls, nfft, inverse_fft, libc.UintptrFromInt32(0), bp)
	memneeded = uint64(24) + *(*OpusT_size_t)(unsafe.Pointer(bp)) + uint64(8)*libc.Uint64FromInt32(nfft*libc.Int32FromInt32(3)/libc.Int32FromInt32(2))
	if lenmem == libc.UintptrFromInt32(0) {
		st = libc.Xmalloc(tls, memneeded)
	} else {
		if *(*OpusT_size_t)(unsafe.Pointer(lenmem)) >= memneeded {
			st = mem
		}
		*(*OpusT_size_t)(unsafe.Pointer(lenmem)) = memneeded
	}
	if !(st != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate = st + libc.UintptrFromInt32(1)*24 /*just beyond kiss_fftr_state struct */
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf = (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate + uintptr(*(*OpusT_size_t)(unsafe.Pointer(bp)))
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles = (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(nfft)*8
	Opus_mini_kiss_fft_alloc(tls, nfft, inverse_fft, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate, bp)
	i = 0
	for {
		if !(i < nfft/int32(2)) {
			break
		}
		phase = float64(-libc.Float64FromFloat64(3.141592653589793) * (float64(i+libc.Int32FromInt32(1))/float64(nfft) + float64(0.5)))
		if inverse_fft != 0 {
			phase = phase * float64(-libc.Int32FromInt32(1))
		}
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(i)*8)).Fr = float32(libc.Xcos(tls, phase))
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(i)*8)).Fi = float32(libc.Xsin(tls, phase))
		goto _2
	_2:
		;
		i = i + 1
	}
	return st
}

var __func__2 = [21]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', 'r', '_', 'a', 'l', 'l', 'o', 'c'}

func Opus_mini_kiss_fftr(tls *libc.TLS, st OpusT_mini_kiss_fftr_cfg, timedata uintptr, freqdata uintptr) {
	var f1k, f2k, fpk, fpnk, tdc, tw OpusT_mini_kiss_fft_cpx
	var k, ncfft int32
	var v1 bool
	var v2 float32
	_, _, _, _, _, _, _, _, _, _ = f1k, f2k, fpk, fpnk, k, ncfft, tdc, tw, v1, v2
	if v1 = !((*mini_kiss_fft_state)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate)).Finverse != 0); !v1 {
		libc.X__assert_fail(tls, __ccgo_ts+5577, __ccgo_ts+5529, int32(453), uintptr(unsafe.Pointer(&__func__3)))
	}
	_ = v1 || libc.Bool(libc.Int32FromInt32(0) != 0)
	ncfft = (*mini_kiss_fft_state)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate)).Fnfft
	/*perform the parallel fft of two real signals packed in real,imag*/
	Opus_mini_kiss_fft(tls, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate, timedata, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf)
	/* The real part of the DC element of the frequency spectrum in st->tmpbuf
	 * contains the sum of the even-numbered elements of the input time sequence
	 * The imag part is the sum of the odd-numbered elements
	 *
	 * The sum of tdc.r and tdc.i is the sum of the input time sequence.
	 *      yielding DC of input time sequence
	 * The difference of tdc.r - tdc.i is the sum of the input (dot product) [1,-1,1,-1...
	 *      yielding Nyquist bin of input time sequence
	 */
	tdc.Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf))).Fr
	tdc.Fi = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf))).Fi
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata))).Fr = tdc.Fr + tdc.Fi
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft)*8))).Fr = tdc.Fr - tdc.Fi
	v2 = libc.Float32FromInt32(0)
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata))).Fi = v2
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft)*8))).Fi = v2
	k = int32(1)
	for {
		if !(k <= ncfft/int32(2)) {
			break
		}
		fpk = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(k)*8))
		fpnk.Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(ncfft-k)*8))).Fr
		fpnk.Fi = -(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(ncfft-k)*8))).Fi
		f1k.Fr = fpk.Fr + fpnk.Fr
		f1k.Fi = fpk.Fi + fpnk.Fi
		f2k.Fr = fpk.Fr - fpnk.Fr
		f2k.Fi = fpk.Fi - fpnk.Fi
		tw.Fr = float32(f2k.Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fr) - float32(f2k.Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fi)
		tw.Fi = float32(f2k.Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fi) + float32(f2k.Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fr)
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(k)*8))).Fr = float32((f1k.Fr + tw.Fr) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(k)*8))).Fi = float32((f1k.Fi + tw.Fi) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft-k)*8))).Fr = float32((f1k.Fr - tw.Fr) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft-k)*8))).Fi = float32((tw.Fi - f1k.Fi) * libc.Float32FromFloat64(0.5))
		goto _3
	_3:
		;
		k = k + 1
	}
}

var __func__3 = [15]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', 'r'}

const LAPLACE_LOG_MINP = 0
const LAPLACE_NMIN = 16

var log2_x_norm_coeff16 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff16 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The minimum probability of an energy delta (out of 32768). */
/* The minimum number of guaranteed representable energy deltas (in one
   direction). */

// C documentation
//
//	/* When called, decay is positive and at most 11456. */
func ec_laplace_get_freq1(tls *libc.TLS, fs0 uint32, decay int32) (r uint32) {
	var ft uint32
	_ = ft
	ft = libc.Uint32FromInt32(libc.Int32FromInt32(32768)-libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)*(libc.Int32FromInt32(2)*libc.Int32FromInt32(LAPLACE_NMIN))) - fs0
	return ft * libc.Uint32FromInt32(libc.Int32FromInt32(16384)-decay) >> int32(15)
}

func Opus_ec_laplace_encode(tls *libc.TLS, enc uintptr, value uintptr, fs uint32, decay int32) {
	var di, i, ndi_max, s, val, v2 int32
	var fl, v3 uint32
	_, _, _, _, _, _, _, _ = di, fl, i, ndi_max, s, val, v2, v3
	val = *(*int32)(unsafe.Pointer(value))
	fl = uint32(0)
	if val != 0 {
		s = -libc.BoolInt32(val < 0)
		val = val + s ^ s
		fl = fs
		fs = ec_laplace_get_freq1(tls, fs, decay)
		/* Search the decaying part of the PDF.*/
		i = int32(1)
		for {
			if !(fs > uint32(0) && i < val) {
				break
			}
			fs = fs * uint32(2)
			fl = fl + (fs + libc.Uint32FromInt32(libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))))
			fs = fs * libc.Uint32FromInt32(decay) >> int32(15)
			goto _1
		_1:
			;
			i = i + 1
		}
		/* Everything beyond that has probability LAPLACE_MINP. */
		if !(fs != 0) {
			ndi_max = libc.Int32FromUint32((uint32(32768) - fl + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) - uint32(1)) >> LAPLACE_LOG_MINP)
			ndi_max = (ndi_max - s) >> int32(1)
			if val-i < ndi_max-int32(1) {
				v2 = val - i
			} else {
				v2 = ndi_max - int32(1)
			}
			di = v2
			fl = fl + libc.Uint32FromInt32((int32(2)*di+int32(1)+s)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))
			if libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) < uint32(32768)-fl {
				v3 = libc.Uint32FromInt32(libc.Int32FromInt32(1) << libc.Int32FromInt32(LAPLACE_LOG_MINP))
			} else {
				v3 = uint32(32768) - fl
			}
			fs = v3
			*(*int32)(unsafe.Pointer(value)) = i + di + s ^ s
		} else {
			fs = fs + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
			fl = fl + fs&libc.Uint32FromInt32(^s)
		}
		if !(fl+fs <= libc.Uint32FromInt32(32768)) {
			Opus_celt_fatal(tls, __ccgo_ts+5600, __ccgo_ts+5631, int32(88))
		}
		if !(fs > libc.Uint32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5649, __ccgo_ts+5631, int32(89))
		}
	}
	Opus_ec_encode_bin(tls, enc, fl, fl+fs, uint32(15))
}

func Opus_ec_laplace_decode(tls *libc.TLS, dec uintptr, fs uint32, decay int32) (r int32) {
	var di, val int32
	var fl, fm, v1 uint32
	_, _, _, _, _ = di, fl, fm, val, v1
	val = 0
	fm = Opus_ec_decode_bin(tls, dec, uint32(15))
	fl = uint32(0)
	if fm >= fs {
		val = val + 1
		fl = fs
		fs = ec_laplace_get_freq1(tls, fs, decay) + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
		/* Search the decaying part of the PDF.*/
		for fs > libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) && fm >= fl+uint32(2)*fs {
			fs = fs * uint32(2)
			fl = fl + fs
			fs = (fs - libc.Uint32FromInt32(libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))) * libc.Uint32FromInt32(decay) >> int32(15)
			fs = fs + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
			val = val + 1
		}
		/* Everything beyond that has probability LAPLACE_MINP. */
		if fs <= libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) {
			di = libc.Int32FromUint32((fm - fl) >> (libc.Int32FromInt32(LAPLACE_LOG_MINP) + libc.Int32FromInt32(1)))
			val = val + di
			fl = fl + libc.Uint32FromInt32(int32(2)*di*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))
		}
		if fm < fl+fs {
			val = -val
		} else {
			fl = fl + fs
		}
	}
	if !(fl < libc.Uint32FromInt32(32768)) {
		Opus_celt_fatal(tls, __ccgo_ts+5672, __ccgo_ts+5631, int32(128))
	}
	if !(fs > libc.Uint32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5649, __ccgo_ts+5631, int32(129))
	}
	if !(fl <= fm) {
		Opus_celt_fatal(tls, __ccgo_ts+5699, __ccgo_ts+5631, int32(130))
	}
	if fl+fs < libc.Uint32FromInt32(libc.Int32FromInt32(32768)) {
		v1 = fl + fs
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(32768))
	}
	if !(fm < v1) {
		Opus_celt_fatal(tls, __ccgo_ts+5724, __ccgo_ts+5631, int32(131))
	}
	if fl+fs < libc.Uint32FromInt32(libc.Int32FromInt32(32768)) {
		v1 = fl + fs
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(32768))
	}
	Opus_ec_dec_update(tls, dec, fl, v1, uint32(32768))
	return val
}

func Opus_ec_laplace_encode_p0(tls *libc.TLS, enc uintptr, value int32, p0 OpusT_opus_uint16, decay OpusT_opus_uint16) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i, s, v1, v2 int32
	var _ /* icdf at bp+6 */ [8]OpusT_opus_uint16
	var _ /* sign_icdf at bp+0 */ [3]OpusT_opus_uint16
	_, _, _, _ = i, s, v1, v2
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0] = libc.Uint16FromInt32(int32(32768) - libc.Int32FromUint16(p0))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(1)] = libc.Uint16FromInt32(libc.Int32FromUint16((*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0]) / int32(2))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(2)] = uint16(0)
	if value == 0 {
		v1 = 0
	} else {
		if value > 0 {
			v2 = int32(1)
		} else {
			v2 = int32(2)
		}
		v1 = v2
	}
	s = v1
	Opus_ec_enc_icdf16(tls, enc, s, bp, uint32(15))
	value = libc.Xabs(tls, value)
	if value != 0 {
		if int32(7) > libc.Int32FromUint16(decay) {
			v1 = int32(7)
		} else {
			v1 = libc.Int32FromUint16(decay)
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[0] = libc.Uint16FromInt32(v1)
		i = int32(1)
		for {
			if !(i < int32(7)) {
				break
			}
			if int32(7)-i > libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)])*libc.Int32FromUint16(decay)>>int32(15) {
				v1 = int32(7) - i
			} else {
				v1 = libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)]) * libc.Int32FromUint16(decay) >> int32(15)
			}
			(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i] = libc.Uint16FromInt32(v1)
			goto _4
		_4:
			;
			i = i + 1
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[int32(7)] = uint16(0)
		value = value - 1
		for cond := true; cond; cond = value >= 0 {
			if value < int32(7) {
				v1 = value
			} else {
				v1 = int32(7)
			}
			Opus_ec_enc_icdf16(tls, enc, v1, bp+6, uint32(15))
			value = value - int32(7)
		}
	}
}

func Opus_ec_laplace_decode_p0(tls *libc.TLS, dec uintptr, p0 OpusT_opus_uint16, decay OpusT_opus_uint16) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i, s, v, value, v1 int32
	var _ /* icdf at bp+6 */ [8]OpusT_opus_uint16
	var _ /* sign_icdf at bp+0 */ [3]OpusT_opus_uint16
	_, _, _, _, _ = i, s, v, value, v1
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0] = libc.Uint16FromInt32(int32(32768) - libc.Int32FromUint16(p0))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(1)] = libc.Uint16FromInt32(libc.Int32FromUint16((*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0]) / int32(2))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(2)] = uint16(0)
	s = Opus_ec_dec_icdf16(tls, dec, bp, uint32(15))
	if s == int32(2) {
		s = -int32(1)
	}
	if s != 0 {
		if int32(7) > libc.Int32FromUint16(decay) {
			v1 = int32(7)
		} else {
			v1 = libc.Int32FromUint16(decay)
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[0] = libc.Uint16FromInt32(v1)
		i = int32(1)
		for {
			if !(i < int32(7)) {
				break
			}
			if int32(7)-i > libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)])*libc.Int32FromUint16(decay)>>int32(15) {
				v1 = int32(7) - i
			} else {
				v1 = libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)]) * libc.Int32FromUint16(decay) >> int32(15)
			}
			(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i] = libc.Uint16FromInt32(v1)
			goto _2
		_2:
			;
			i = i + 1
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[int32(7)] = uint16(0)
		value = int32(1)
		for cond := true; cond; cond = v == int32(7) {
			v = Opus_ec_dec_icdf16(tls, dec, bp+6, uint32(15))
			value = value + v
		}
		return s * value
	} else {
		return 0
	}
	return r
}

const BWE_COEF = 0.99
const LOG2_INV_LPC_GAIN_HIGH_THRES = 3
const LOG2_INV_LPC_GAIN_LOW_THRES = 8
const MAX_PITCH_LAG_MS = 18
const PITCH_DRIFT_FAC_Q16 = 655
const RAND_BUF_SIZE = 128
const SILK_DEBUG = 0
const SILK_TIC_TOC = 0
const V_PITCH_GAIN_START_MAX_Q14 = 15565
const V_PITCH_GAIN_START_MIN_Q14 = 11469
const silk_int16_MAX1 = 32767

// C documentation
//
//	/* Generates excitation for CNG LPC synthesis */
func silk_CNG_exc(tls *libc.TLS, exc_Q14 uintptr, exc_buf_Q14 uintptr, length int32, rand_seed uintptr) {
	var exc_mask, i, idx int32
	var seed OpusT_opus_int32
	_, _, _, _ = exc_mask, i, idx, seed
	exc_mask = int32(CNG_BUF_MASK_MAX)
	for exc_mask > length {
		exc_mask = exc_mask >> int32(1)
	}
	seed = *(*OpusT_opus_int32)(unsafe.Pointer(rand_seed))
	i = 0
	for {
		if !(i < length) {
			break
		}
		seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
		idx = seed >> libc.Int32FromInt32(24) & exc_mask
		_ = idx >= libc.Int32FromInt32(0)
		_ = idx <= libc.Int32FromInt32(CNG_BUF_MASK_MAX)
		*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(exc_buf_Q14 + uintptr(idx)*4))
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(rand_seed)) = seed
}

func Opus_silk_CNG_Reset(tls *libc.TLS, psDec uintptr) {
	var NLSF_acc_Q15, NLSF_step_Q15, i int32
	_, _, _ = NLSF_acc_Q15, NLSF_step_Q15, i
	NLSF_step_Q15 = libc.Int32FromInt32(silk_int16_MAX1) / ((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order + libc.Int32FromInt32(1))
	NLSF_acc_Q15 = 0
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
			break
		}
		NLSF_acc_Q15 = NLSF_acc_Q15 + NLSF_step_Q15
		*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2892 + 1280 + uintptr(i)*2)) = int16(NLSF_acc_Q15)
		goto _1
	_1:
		;
		i = i + 1
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsCNG.FCNG_smth_Gain_Q16 = 0
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsCNG.Frand_seed = int32(3176576)
}

// C documentation
//
//	/* Updates CNG estimate, and applies the CNG when packet was lost   */
func Opus_silk_CNG(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, length int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var CNG_sig_Q14, _saved_stack, psCNG, st, v1, v11, v13, v15, v17, v19, v21, v23, v25, v3, v6, v9 uintptr
	var LPC_pred_Q10, gain_Q10, gain_Q16, lzeros, max_Gain_Q16, y, v33, v34, v36, v37, v38, v41, v43 OpusT_opus_int32
	var i, subfr, v40, v42, v52, v54, v58, v59, v60, v61, v62, v63, v64, v65, v66 int32
	var m, r, x OpusT_opus_uint32
	var _ /* A_Q12 at bp+8 */ [16]OpusT_opus_int16
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = CNG_sig_Q14, LPC_pred_Q10, _saved_stack, gain_Q10, gain_Q16, i, lzeros, m, max_Gain_Q16, psCNG, r, st, subfr, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v25, v3, v33, v34, v36, v37, v38, v40, v41, v42, v43, v52, v54, v58, v59, v6, v60, v61, v62, v63, v64, v65, v66, v9
	psCNG = psDec + 2892
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).Ffs_kHz {
		/* Reset state */
		Opus_silk_CNG_Reset(tls, psDec)
		(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).Ffs_kHz = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz
	}
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt == 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == TYPE_NO_VOICE_ACTIVITY {
		/* Update CNG parameters */
		/* Smoothing of LSF's  */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			v1 = psCNG + 1280 + uintptr(i)*2
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + int32(int64(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(psCNG + 1280 + uintptr(i)*2))))*int64(int16(libc.Int32FromInt32(CNG_NLSF_SMTH_Q16)))>>libc.Int32FromInt32(16)))
			goto _5
		_5:
			;
			i = i + 1
		}
		/* Find the subframe with the highest gain */
		max_Gain_Q16 = 0
		subfr = 0
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			if *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4)) > max_Gain_Q16 {
				max_Gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))
				subfr = i
			}
			goto _7
		_7:
			;
			i = i + 1
		}
		/* Update CNG excitation buffer with excitation from this subframe */
		libc.Xmemmove(tls, psCNG+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, psCNG, libc.Uint64FromInt32(((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-libc.Int32FromInt32(1))*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, psCNG, psDec+4+uintptr(subfr*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(4))
		/* Smooth gains */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(psCNG + 1376)) += int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))-(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16) * int64(int16(libc.Int32FromInt32(CNG_GAIN_SMTH_Q16))) >> libc.Int32FromInt32(16))
			/* If the smoothed gain is 3 dB greater than this subframe's gain, use this subframe's gain to adapt faster. */
			if int32(int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)*int64(libc.Int32FromInt32(CNG_GAIN_SMTH_THRESHOLD_Q16))>>libc.Int32FromInt32(16)) > *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4)) {
				(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))
			}
			goto _8
		_8:
			;
			i = i + 1
		}
	}
	/* Add CNG when packet is lost or during DTX */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _10
		_10:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _12
	_12:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v6 = libc.Xmalloc(tls, uint64(16))
			goto _14
		_14:
			st = v6
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v9 = st
		goto _16
	_16:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _18
		_18:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _20
	_20:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _22
		_22:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _24
	_24:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5763, int32(131))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _26
		_26:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _28
	_28:
		*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v23 = libc.Xmalloc(tls, uint64(16))
			goto _30
		_30:
			st = v23
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v25 = st
		goto _32
	_32:
		CNG_sig_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		/* Generate CNG excitation */
		gain_Q16 = int32(int64((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.FrandScale_Q14) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72 + 1*4))) >> libc.Int32FromInt32(16))
		if gain_Q16 >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(21) || (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(23) {
			gain_Q16 = gain_Q16 >> libc.Int32FromInt32(16) * (gain_Q16 >> libc.Int32FromInt32(16))
			gain_Q16 = (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16>>libc.Int32FromInt32(16)*((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16>>libc.Int32FromInt32(16)) - libc.Int32FromUint32(libc.Uint32FromInt32(gain_Q16)<<libc.Int32FromInt32(5))
			v33 = gain_Q16
			if v33 <= libc.Int32FromInt32(0) {
				v34 = 0
				goto _35
			}
			v36 = v33
			v37 = v36
			if v37 != 0 {
				v40 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v37)))
			} else {
				v40 = int32(32)
			}
			v38 = v40
			goto _39
		_39:
			lzeros = v38
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v41 = v36
			v42 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v41)
			r = libc.Uint32FromInt32(v42)
			m = libc.Uint32FromInt32(-v42)
			if v42 == libc.Int32FromInt32(0) {
				v43 = v41
				goto _44
			} else {
				if v42 < libc.Int32FromInt32(0) {
					v43 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _44
				} else {
					v43 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _44
				}
			}
		_44:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v43 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v34 = y
			goto _35
		_35:
			gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v34) << libc.Int32FromInt32(16))
		} else {
			gain_Q16 = int32(int64(gain_Q16) * int64(gain_Q16) >> libc.Int32FromInt32(16))
			gain_Q16 = int32(int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)*int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)>>libc.Int32FromInt32(16)) - libc.Int32FromUint32(libc.Uint32FromInt32(gain_Q16)<<libc.Int32FromInt32(5))
			v33 = gain_Q16
			if v33 <= libc.Int32FromInt32(0) {
				v34 = 0
				goto _47
			}
			v36 = v33
			v37 = v36
			if v37 != 0 {
				v40 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v37)))
			} else {
				v40 = int32(32)
			}
			v38 = v40
			goto _51
		_51:
			lzeros = v38
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v41 = v36
			v42 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v41)
			r = libc.Uint32FromInt32(v42)
			m = libc.Uint32FromInt32(-v42)
			if v42 == libc.Int32FromInt32(0) {
				v43 = v41
				goto _56
			} else {
				if v42 < libc.Int32FromInt32(0) {
					v43 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _56
				} else {
					v43 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _56
				}
			}
		_56:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v43 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v34 = y
			goto _47
		_47:
			gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v34) << libc.Int32FromInt32(8))
		}
		gain_Q10 = gain_Q16 >> int32(6)
		silk_CNG_exc(tls, CNG_sig_Q14+uintptr(MAX_LPC_ORDER)*4, psCNG, length, psCNG+1380)
		/* Convert CNG NLSF to filter representation */
		Opus_silk_NLSF2A(tls, bp+8, psCNG+1280, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
		/* Generate CNG signal, by synthesis filtering */
		libc.Xmemcpy(tls, CNG_sig_Q14, psCNG+1312, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(10) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16)) {
			Opus_celt_fatal(tls, __ccgo_ts+5777, __ccgo_ts+5763, int32(153))
		}
		i = 0
		for {
			if !(i < length) {
				break
			}
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[0])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(1)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(2)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(3)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(4)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(5)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(6)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(7)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(8)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(9)])>>libc.Int32FromInt32(16))
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16) {
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(11))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(10)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(12))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(11)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(13))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(12)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(14))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(13)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(15))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(14)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(16))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(15)])>>libc.Int32FromInt32(16))
			}
			/* Update states */
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v42 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v52 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v52 = LPC_pred_Q10
				}
				v42 = v52
			}
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v42)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v58 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v59 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v59 = LPC_pred_Q10
					}
					v58 = v59
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v58)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
					v54 = libc.Int32FromUint32(0x80000000)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v60 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v61 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v61 = LPC_pred_Q10
						}
						v60 = v61
					}
					v54 = *(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v60)<<libc.Int32FromInt32(4))
				}
				v40 = v54
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v63 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v64 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v64 = LPC_pred_Q10
					}
					v63 = v64
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v63)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
					v62 = int32(silk_int32_MAX)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v65 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v66 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v66 = LPC_pred_Q10
						}
						v65 = v66
					}
					v62 = *(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v65)<<libc.Int32FromInt32(4))
				}
				v40 = v62
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v40
			/* Scale with Gain and add to input signal */
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
				v42 = int32(silk_int16_MAX1)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v52 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v52 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v42 = v52
			}
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)))+v42 > int32(silk_int16_MAX1) {
				v40 = int32(silk_int16_MAX1)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
					v58 = int32(silk_int16_MAX1)
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
						v59 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v59 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v58 = v59
				}
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)))+v58 < int32(libc.Int16FromInt32(0x8000)) {
					v54 = int32(libc.Int16FromInt32(0x8000))
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
						v60 = int32(silk_int16_MAX1)
					} else {
						if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
							v61 = int32(libc.Int16FromInt32(0x8000))
						} else {
							v61 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
						}
						v60 = v61
					}
					v54 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2))) + v60
				}
				v40 = v54
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(v40)
			goto _57
		_57:
			;
			i = i + 1
		}
		libc.Xmemcpy(tls, psCNG+1312, CNG_sig_Q14+uintptr(length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	} else {
		libc.Xmemset(tls, psCNG+1312, 0, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(4))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _82
_82:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

const silk_int16_MAX2 = 0x7FFF

/*#define silk_enc_map(a)                ((a) > 0 ? 1 : 0)*/
/*#define silk_dec_map(a)                ((a) > 0 ? 1 : -1)*/
/* shifting avoids if-statement */

// C documentation
//
//	/* Encodes signs of excitation */
func Opus_silk_encode_signs(tls *libc.TLS, psRangeEnc uintptr, pulses uintptr, length int32, signalType int32, quantOffsetType int32, sum_pulses uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j, p, v2 int32
	var icdf_ptr, q_ptr uintptr
	var _ /* icdf at bp+0 */ [2]OpusT_opus_uint8
	_, _, _, _, _, _ = i, icdf_ptr, j, p, q_ptr, v2
	(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(0)
	q_ptr = pulses
	i = int32(int16(libc.Int32FromInt32(7))) * int32(int16(quantOffsetType+libc.Int32FromUint32(libc.Uint32FromInt32(signalType)<<libc.Int32FromInt32(1))))
	icdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_sign_iCDF)) + uintptr(i)
	length = (length + libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)/libc.Int32FromInt32(2)) >> int32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	i = 0
	for {
		if !(i < length) {
			break
		}
		p = *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4))
		if p > 0 {
			if p&int32(0x1F) < int32(6) {
				v2 = p & int32(0x1F)
			} else {
				v2 = int32(6)
			}
			(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_uint8)(unsafe.Pointer(icdf_ptr + uintptr(v2)))
			j = 0
			for {
				if !(j < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(q_ptr + uintptr(j)))) != 0 {
					Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(q_ptr + uintptr(j))))>>int32(15)+int32(1), bp, uint32(8))
				}
				goto _3
			_3:
				;
				j = j + 1
			}
		}
		q_ptr = q_ptr + uintptr(SHELL_CODEC_FRAME_LENGTH)
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Decodes signs of excitation */
func Opus_silk_decode_signs(tls *libc.TLS, psRangeDec uintptr, pulses uintptr, length int32, signalType int32, quantOffsetType int32, sum_pulses uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j, p, v2 int32
	var icdf_ptr, q_ptr, v4 uintptr
	var _ /* icdf at bp+0 */ [2]OpusT_opus_uint8
	_, _, _, _, _, _, _ = i, icdf_ptr, j, p, q_ptr, v2, v4
	(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(0)
	q_ptr = pulses
	i = int32(int16(libc.Int32FromInt32(7))) * int32(int16(quantOffsetType+libc.Int32FromUint32(libc.Uint32FromInt32(signalType)<<libc.Int32FromInt32(1))))
	icdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_sign_iCDF)) + uintptr(i)
	length = (length + libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)/libc.Int32FromInt32(2)) >> int32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	i = 0
	for {
		if !(i < length) {
			break
		}
		p = *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4))
		if p > 0 {
			if p&int32(0x1F) < int32(6) {
				v2 = p & int32(0x1F)
			} else {
				v2 = int32(6)
			}
			(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_uint8)(unsafe.Pointer(icdf_ptr + uintptr(v2)))
			j = 0
			for {
				if !(j < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(q_ptr + uintptr(j)*2))) > 0 {
					/* attach sign */
					/* implementation with shift, subtraction, multiplication */
					v4 = q_ptr + uintptr(j)*2
					*(*OpusT_opus_int16)(unsafe.Pointer(v4)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v4))) * (libc.Int32FromUint32(libc.Uint32FromInt32(Opus_ec_dec_icdf(tls, psRangeDec, bp, uint32(8)))<<libc.Int32FromInt32(1)) - libc.Int32FromInt32(1)))
				}
				goto _3
			_3:
				;
				j = j + 1
			}
		}
		q_ptr = q_ptr + uintptr(SHELL_CODEC_FRAME_LENGTH)*2
		goto _1
	_1:
		;
		i = i + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/************************/
//	/* Reset Decoder State  */
//	/************************/
func Opus_silk_reset_decoder(tls *libc.TLS, psDec uintptr) (r int32) {
	var v1 int32
	_ = v1
	/* Clear the entire encoder state, except anything copied */
	libc.Xmemset(tls, psDec, 0, libc.Uint64FromInt64(4392)-libc.Uint64FromInt64(int64(psDec)-int64(psDec)))
	/* Used to deactivate LSF interpolation */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = int32(1)
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 = int32(65536)
	v1 = 0
	goto _2
_2:
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch = v1
	/* Reset CNG state */
	Opus_silk_CNG_Reset(tls, psDec)
	/* Reset PLC state */
	Opus_silk_PLC_Reset(tls, psDec)
	return 0
}

// C documentation
//
//	/************************/
//	/* Init Decoder State   */
//	/************************/
func Opus_silk_init_decoder(tls *libc.TLS, psDec uintptr) (r int32) {
	/* Clear the entire encoder state, except anything copied */
	libc.Xmemset(tls, psDec, 0, libc.Uint64FromInt64(4392))
	Opus_silk_reset_decoder(tls, psDec)
	return 0
}

const silk_int16_MAX3 = 32767

// C documentation
//
//	/**********************************************************/
//	/* Core decoder. Performs inverse NSQ operation LTP + LPC */
//	/**********************************************************/
func Opus_silk_decode_core(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, xq uintptr, pulses uintptr, arch int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var A_Q12, B_Q14, _saved_stack, pexc_Q14, pred_lag_ptr, pres_Q14, pxq, res_Q14, sLPC_Q14, sLTP, sLTP_Q15, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var Gain_Q10, LPC_pred_Q10, LTP_pred_Q13, a32_nrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, err_Q32, gain_adj_Q16, inv_gain_Q31, offset_Q10, rand_seed, result, result1, v103, v106, v107, v110, v117, v118, v121 OpusT_opus_int32
	var NLSF_interpolation_flag, a_headrm, b_headrm, b_headrm1, i, k, lag, lshift, lshift1, sLTP_buf_idx, signalType, start_idx, v104, v105, v109, v112, v113, v114, v115, v116, v119, v120, v124, v125, v129 int32
	var _ /* A_Q12_tmp at bp+0 */ [16]OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = A_Q12, B_Q14, Gain_Q10, LPC_pred_Q10, LTP_pred_Q13, NLSF_interpolation_flag, _saved_stack, a32_nrm, a_headrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, b_headrm, b_headrm1, err_Q32, gain_adj_Q16, i, inv_gain_Q31, k, lag, lshift, lshift1, offset_Q10, pexc_Q14, pred_lag_ptr, pres_Q14, pxq, rand_seed, res_Q14, result, result1, sLPC_Q14, sLTP, sLTP_Q15, sLTP_buf_idx, signalType, st, start_idx, v1, v103, v104, v105, v106, v107, v109, v11, v110, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v124, v125, v129, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	lag = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 != libc.Int32FromInt32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5844, int32(58))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5844, int32(59))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	sLTP_Q15 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5844, int32(60))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	res_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Work around a clang bug (verified with clang 6.0 through clang 20.1.0) that causes the last
	   memset to be flagged as an invalid read by valgrind (not caught by asan). */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _80
_80:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _84
_84:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _88
_88:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _92
_92:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5844, int32(66))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _96
_96:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _100
_100:
	sLPC_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	offset_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)>>int32(1))*4 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType)*2)))
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2) < libc.Int32FromInt32(1)<<libc.Int32FromInt32(2) {
		NLSF_interpolation_flag = int32(1)
	} else {
		NLSF_interpolation_flag = 0
	}
	/* Decode excitation */
	rand_seed = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FSeed)
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			break
		}
		rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(rand_seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
		*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(pulses + uintptr(i)*2)))) << libc.Int32FromInt32(14))
		if *(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) > 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) -= libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10) << libc.Int32FromInt32(4)
		} else {
			if *(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) < 0 {
				*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) += libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10) << libc.Int32FromInt32(4)
			}
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) += offset_Q10 << int32(4)
		if rand_seed < 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4))
		}
		rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(rand_seed) + libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(pulses + uintptr(i)*2))))
		goto _101
	_101:
		;
		i = i + 1
	}
	/* Copy LPC state */
	libc.Xmemcpy(tls, sLPC_Q14, psDec+1284, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	pexc_Q14 = psDec + 4
	pxq = xq
	sLTP_buf_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length
	/* Loop over subframes */
	k = 0
	for {
		if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		pres_Q14 = res_Q14
		A_Q12 = psDecCtrl + 32 + uintptr(k>>int32(1))*32
		/* Preload LPC coefficients to array on stack. Gives small performance gain */
		libc.Xmemcpy(tls, bp, A_Q12, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
		B_Q14 = psDecCtrl + 96 + uintptr(k*int32(LTP_ORDER))*2
		signalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
		Gain_Q10 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4)) >> int32(6)
		v103 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
		v104 = int32(47)
		_ = v103 != libc.Int32FromInt32(0)
		_ = v104 > libc.Int32FromInt32(0)
		if v103 > 0 {
			v105 = v103
		} else {
			v105 = -v103
		}
		v106 = v105
		if v106 != 0 {
			v109 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v106)))
		} else {
			v109 = int32(32)
		}
		v107 = v109
		goto _108
	_108:
		b_headrm1 = v107 - int32(1)
		b32_nrm1 = libc.Int32FromUint32(libc.Uint32FromInt32(v103) << b_headrm1)
		b32_inv1 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm1 >> libc.Int32FromInt32(16))
		result1 = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv1) << libc.Int32FromInt32(16))
		err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm1)*int64(int16(b32_inv1))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
		result1 = int32(int64(result1) + int64(err_Q32)*int64(b32_inv1)>>libc.Int32FromInt32(16))
		lshift1 = int32(61) - b_headrm1 - v104
		if lshift1 <= libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift1 > int32(silk_int32_MAX)>>-lshift1 {
				if result1 > libc.Int32FromUint32(0x80000000)>>-lshift1 {
					v113 = libc.Int32FromUint32(0x80000000) >> -lshift1
				} else {
					if result1 < int32(silk_int32_MAX)>>-lshift1 {
						v114 = int32(silk_int32_MAX) >> -lshift1
					} else {
						v114 = result1
					}
					v113 = v114
				}
				v112 = v113
			} else {
				if result1 > int32(silk_int32_MAX)>>-lshift1 {
					v115 = int32(silk_int32_MAX) >> -lshift1
				} else {
					if result1 < libc.Int32FromUint32(0x80000000)>>-lshift1 {
						v116 = libc.Int32FromUint32(0x80000000) >> -lshift1
					} else {
						v116 = result1
					}
					v115 = v116
				}
				v112 = v115
			}
			v110 = libc.Int32FromUint32(libc.Uint32FromInt32(v112) << -lshift1)
			goto _111
		} else {
			if lshift1 < libc.Int32FromInt32(32) {
				v110 = result1 >> lshift1
				goto _111
			} else {
				v110 = 0
				goto _111
			}
		}
	_111:
		inv_gain_Q31 = v110
		/* Calculate gain adjustment factor */
		if *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4)) != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 {
			v103 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16
			v106 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
			v104 = int32(16)
			_ = v106 != libc.Int32FromInt32(0)
			_ = v104 >= libc.Int32FromInt32(0)
			if v103 > 0 {
				v105 = v103
			} else {
				v105 = -v103
			}
			v107 = v105
			if v107 != 0 {
				v109 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v107)))
			} else {
				v109 = int32(32)
			}
			v110 = v109
			goto _123
		_123:
			a_headrm = v110 - int32(1)
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v103) << a_headrm)
			if v106 > 0 {
				v112 = v106
			} else {
				v112 = -v106
			}
			v117 = v112
			if v117 != 0 {
				v113 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v117)))
			} else {
				v113 = int32(32)
			}
			v118 = v113
			goto _128
		_128:
			b_headrm = v118 - int32(1)
			b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v106) << b_headrm)
			b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
			result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
			result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
			lshift = int32(29) + a_headrm - b_headrm - v104
			if lshift < libc.Int32FromInt32(0) {
				if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
					if result > libc.Int32FromUint32(0x80000000)>>-lshift {
						v115 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						if result < int32(silk_int32_MAX)>>-lshift {
							v116 = int32(silk_int32_MAX) >> -lshift
						} else {
							v116 = result
						}
						v115 = v116
					}
					v114 = v115
				} else {
					if result > int32(silk_int32_MAX)>>-lshift {
						v119 = int32(silk_int32_MAX) >> -lshift
					} else {
						if result < libc.Int32FromUint32(0x80000000)>>-lshift {
							v120 = libc.Int32FromUint32(0x80000000) >> -lshift
						} else {
							v120 = result
						}
						v119 = v120
					}
					v114 = v119
				}
				v121 = libc.Int32FromUint32(libc.Uint32FromInt32(v114) << -lshift)
				goto _131
			} else {
				if lshift < libc.Int32FromInt32(32) {
					v121 = result >> lshift
					goto _131
				} else {
					v121 = 0
					goto _131
				}
			}
		_131:
			gain_adj_Q16 = v121
			/* Scale short term state */
			i = 0
			for {
				if !(i < int32(MAX_LPC_ORDER)) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _137
			_137:
				;
				i = i + 1
			}
		} else {
			gain_adj_Q16 = libc.Int32FromInt32(1) << libc.Int32FromInt32(16)
		}
		/* Save inv_gain */
		_ = inv_gain_Q31 != libc.Int32FromInt32(0)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
		/* Avoid abrupt transition from voiced PLC to unvoiced normal decoding */
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) && int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) != int32(TYPE_VOICED) && k < libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2) {
			libc.Xmemset(tls, B_Q14, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
			*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*2)) = int16(int32(float64(libc.Float64FromFloat64(0.25)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5)))
			signalType = int32(TYPE_VOICED)
			*(*int32)(unsafe.Pointer(psDecCtrl + uintptr(k)*4)) = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev
		}
		if signalType == int32(TYPE_VOICED) {
			/* Voiced */
			lag = *(*int32)(unsafe.Pointer(psDecCtrl + uintptr(k)*4))
			/* Re-whitening */
			if k == 0 || k == int32(2) && NLSF_interpolation_flag != 0 {
				/* Rewhiten with new A coefs */
				start_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - lag - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
				if !(start_idx > libc.Int32FromInt32(0)) {
					Opus_celt_fatal(tls, __ccgo_ts+5866, __ccgo_ts+5844, int32(150))
				}
				if k == int32(2) {
					libc.Xmemcpy(tls, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*2, xq, libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(2))
				}
				Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(start_idx)*2, psDec+1348+uintptr(start_idx+k*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*2, A_Q12, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-start_idx, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, arch)
				/* After rewhitening the LTP state is unscaled */
				if k == 0 {
					/* Do LTP downscaling to reduce inter-packet dependency */
					inv_gain_Q31 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(inv_gain_Q31)*int64(int16((*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
				}
				i = 0
				for {
					if !(i < lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4)) = int32(int64(inv_gain_Q31) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-i-int32(1))*2))) >> libc.Int32FromInt32(16))
					goto _138
				_138:
					;
					i = i + 1
				}
			} else {
				/* Update LTP state when Gain changes */
				if gain_adj_Q16 != libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) {
					i = 0
					for {
						if !(i < lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)) {
							break
						}
						*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4))) >> libc.Int32FromInt32(16))
						goto _139
					_139:
						;
						i = i + 1
					}
				}
			}
		}
		/* Long-term prediction */
		if signalType == int32(TYPE_VOICED) {
			/* Set up pointer */
			pred_lag_ptr = sLTP_Q15 + uintptr(sLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
			i = 0
			for {
				if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
					break
				}
				/* Unrolled loop */
				/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
				LTP_pred_Q13 = int32(2)
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 1*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 2*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 3*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 4*2)))>>libc.Int32FromInt32(16))
				pred_lag_ptr += 4
				/* Generate LPC excitation */
				*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(pexc_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(LTP_pred_Q13)<<libc.Int32FromInt32(1))
				/* Update states */
				*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))) << libc.Int32FromInt32(1))
				sLTP_buf_idx = sLTP_buf_idx + 1
				goto _140
			_140:
				;
				i = i + 1
			}
		} else {
			pres_Q14 = pexc_Q14
		}
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
				break
			}
			/* Short-term prediction */
			if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(10) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16)) {
				Opus_celt_fatal(tls, __ccgo_ts+5777, __ccgo_ts+5844, int32(205))
			}
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[0])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(1)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(2)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(3)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(4)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(5)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(6)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(7)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(8)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(9)])>>libc.Int32FromInt32(16))
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16) {
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(11))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(10)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(12))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(11)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(13))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(12)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(14))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(13)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(15))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(14)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(16))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(15)])>>libc.Int32FromInt32(16))
			}
			/* Add prediction to LPC excitation */
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v105 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v109 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v109 = LPC_pred_Q10
				}
				v105 = v109
			}
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v105)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v113 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v114 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v114 = LPC_pred_Q10
					}
					v113 = v114
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v113)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
					v112 = libc.Int32FromUint32(0x80000000)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v115 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v116 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v116 = LPC_pred_Q10
						}
						v115 = v116
					}
					v112 = *(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v115)<<libc.Int32FromInt32(4))
				}
				v104 = v112
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v120 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v124 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v124 = LPC_pred_Q10
					}
					v120 = v124
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v120)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
					v119 = int32(silk_int32_MAX)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v125 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v129 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v129 = LPC_pred_Q10
						}
						v125 = v129
					}
					v119 = *(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v125)<<libc.Int32FromInt32(4))
				}
				v104 = v119
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v104
			/* Scale with gain */
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX3) {
				v104 = int32(silk_int16_MAX3)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v105 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v105 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v104 = v105
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(pxq + uintptr(i)*2)) = int16(v104)
			goto _141
		_141:
			;
			i = i + 1
		}
		/* Update LPC filter state */
		libc.Xmemcpy(tls, sLPC_Q14, sLPC_Q14+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		pexc_Q14 = pexc_Q14 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4
		pxq = pxq + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*2
		goto _102
	_102:
		;
		k = k + 1
	}
	/* Save LPC state */
	libc.Xmemcpy(tls, psDec+1284, sLPC_Q14, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _158
	_158:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _160
_160:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

const silk_int16_MAX4 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/****************/
//	/* Decode frame */
//	/****************/
func Opus_silk_decode_frame(tls *libc.TLS, psDec uintptr, psRangeDec uintptr, pOut uintptr, pN uintptr, lostFlag int32, condCoding int32, arch int32) (r int32) {
	var L, mv_len, ret int32
	var _saved_stack, psDecCtrl, pulses, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = L, _saved_stack, mv_len, psDecCtrl, pulses, ret, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	ret = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	L = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(140)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5898, int32(64))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(140) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	psDecCtrl = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(140)/libc.Uint64FromInt64(1)))
	(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = 0
	/* Safety checks */
	if !(L > 0 && L <= libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+5921, __ccgo_ts+5898, int32(68))
	}
	if lostFlag == FLAG_DECODE_NORMAL || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(psDec + 2432 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FnFramesDecoded)*4)) == int32(1) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _30
		_30:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _32
	_32:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _34
		_34:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v7 = st
		goto _36
	_36:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v9 = libc.Xmalloc(tls, uint64(16))
			goto _38
		_38:
			st = v9
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v11 = st
		goto _40
	_40:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v13 = libc.Xmalloc(tls, uint64(16))
			goto _42
		_42:
			st = v13
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v15 = st
		goto _44
	_44:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5898, int32(78))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v17 = libc.Xmalloc(tls, uint64(16))
			goto _46
		_46:
			st = v17
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v19 = st
		goto _48
	_48:
		*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v21 = libc.Xmalloc(tls, uint64(16))
			goto _50
		_50:
			st = v21
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v23 = st
		goto _52
	_52:
		pulses = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
		/*********************************************/
		/* Decode quantization indices of side info  */
		/*********************************************/
		Opus_silk_decode_indices(tls, psDec, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FnFramesDecoded, lostFlag, condCoding)
		/*********************************************/
		/* Decode quantization indices of excitation */
		/*********************************************/
		Opus_silk_decode_pulses(tls, psRangeDec, pulses, int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType), int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType), (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)
		/********************************************/
		/* Decode parameters and pulse signal       */
		/********************************************/
		Opus_silk_decode_parameters(tls, psDec, psDecCtrl, condCoding)
		/********************************************************/
		/* Run inverse NSQ                                      */
		/********************************************************/
		Opus_silk_decode_core(tls, psDec, psDecCtrl, pOut, pulses, arch)
		/*************************/
		/* Update output buffer. */
		/*************************/
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length >= (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			Opus_celt_fatal(tls, __ccgo_ts+5970, __ccgo_ts+5898, int32(104))
		}
		mv_len = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
		libc.Xmemmove(tls, psDec+1348, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*2, libc.Uint64FromInt32(mv_len)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+1348+uintptr(mv_len)*2, pOut, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*libc.Uint64FromInt64(2))
		/********************************************************/
		/* Update PLC state                                     */
		/********************************************************/
		Opus_silk_PLC(tls, psDec, psDecCtrl, pOut, 0, arch)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt = 0
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType >= 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType <= int32(2)) {
			Opus_celt_fatal(tls, __ccgo_ts+6033, __ccgo_ts+5898, int32(127))
		}
		/* A frame has been decoded without errors */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = 0
	} else {
		/* Handle packet loss by extrapolation */
		Opus_silk_PLC(tls, psDec, psDecCtrl, pOut, int32(1), arch)
		/*************************/
		/* Update output buffer. */
		/*************************/
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length >= (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			Opus_celt_fatal(tls, __ccgo_ts+5970, __ccgo_ts+5898, int32(145))
		}
		mv_len = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
		libc.Xmemmove(tls, psDec+1348, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*2, libc.Uint64FromInt32(mv_len)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+1348+uintptr(mv_len)*2, pOut, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*libc.Uint64FromInt64(2))
	}
	/************************************************/
	/* Comfort noise generation / estimation        */
	/************************************************/
	Opus_silk_CNG(tls, psDec, psDecCtrl, pOut, L)
	/****************************************************************/
	/* Ensure smooth connection of extrapolated and good frames     */
	/****************************************************************/
	Opus_silk_PLC_glue_frames(tls, psDec, pOut, L)
	/* Update some decoder state variables */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev = *(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1))*4))
	/* Set output frame length */
	*(*OpusT_opus_int32)(unsafe.Pointer(pN)) = L
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/* Decode parameters from payload */
func Opus_silk_decode_parameters(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, condCoding int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var Ix, i, k int32
	var cbk_ptr_Q7 uintptr
	var _ /* pNLSF0_Q15 at bp+32 */ [16]OpusT_opus_int16
	var _ /* pNLSF_Q15 at bp+0 */ [16]OpusT_opus_int16
	_, _, _, _ = Ix, cbk_ptr_Q7, i, k
	/* Dequant Gains */
	Opus_silk_gains_dequant(tls, psDecCtrl+16, psDec+2856, psDec+2312, libc.BoolInt32(condCoding == int32(CODE_CONDITIONALLY)), (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
	/****************/
	/* Decode NLSFs */
	/****************/
	Opus_silk_NLSF_decode(tls, bp, psDec+2856+8, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)
	/* Convert NLSF parameters to AR prediction filter coefficients */
	Opus_silk_NLSF2A(tls, psDecCtrl+32+1*32, bp, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
	/* If just reset, e.g., because internal Fs changed, do not allow interpolation */
	/* improves the case of packet loss in the first frame after a switch           */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset == int32(1) {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(4)
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2) < int32(4) {
		/* Calculation of the interpolated NLSF0 vector from the interpolation factor, */
		/* the previous NLSF1, and the current NLSF1                                   */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			(*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 32)))[i] = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2))) + int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2)*(int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i])-int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2))))>>int32(2))
			goto _1
		_1:
			;
			i = i + 1
		}
		/* Convert NLSF parameters to AR prediction filter coefficients */
		Opus_silk_NLSF2A(tls, psDecCtrl+32, bp+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
	} else {
		/* Copy LPC coefficients for first half from second half */
		libc.Xmemcpy(tls, psDecCtrl+32, psDecCtrl+32+1*32, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	}
	libc.Xmemcpy(tls, psDec+2344, bp, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	/* After a packet loss do BWE of LPC coefs */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		Opus_silk_bwexpander(tls, psDecCtrl+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(BWE_AFTER_LOSS_Q16))
		Opus_silk_bwexpander(tls, psDecCtrl+32+1*32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(BWE_AFTER_LOSS_Q16))
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/*********************/
		/* Decode pitch lags */
		/*********************/
		/* Decode pitch values */
		Opus_silk_decode_pitch(tls, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FcontourIndex, psDecCtrl, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
		/* Decode Codebook Index */
		cbk_ptr_Q7 = Opus_silk_LTP_vq_ptrs_Q7[(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex] /* set pointer to start of codebook */
		k = 0
		for {
			if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			Ix = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 4 + uintptr(k))))
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(psDecCtrl + 96 + uintptr(k*int32(LTP_ORDER)+i)*2)) = int16(libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(cbk_ptr_Q7 + uintptr(Ix*int32(LTP_ORDER)+i)))) << libc.Int32FromInt32(7)))
				goto _3
			_3:
				;
				i = i + 1
			}
			goto _2
		_2:
			;
			k = k + 1
		}
		/**********************/
		/* Decode LTP scaling */
		/**********************/
		Ix = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex)
		(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = int32(Opus_silk_LTPScales_table_Q14[Ix])
	} else {
		libc.Xmemset(tls, psDecCtrl, 0, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)*libc.Uint64FromInt64(4))
		libc.Xmemset(tls, psDecCtrl+96, 0, libc.Uint64FromInt32(libc.Int32FromInt32(LTP_ORDER)*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)*libc.Uint64FromInt64(2))
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex = 0
		(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = 0
	}
}

// C documentation
//
//	/* Decode side-information parameters from payload */
func Opus_silk_decode_indices(tls *libc.TLS, psDec uintptr, psRangeDec uintptr, FrameIndex int32, decode_LBRR int32, condCoding int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var Ix, decode_absolute_lagIndex, delta_lagIndex, i, k int32
	var v1 uintptr
	var _ /* ec_ix at bp+0 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+32 */ [16]OpusT_opus_uint8
	_, _, _, _, _, _ = Ix, decode_absolute_lagIndex, delta_lagIndex, i, k, v1
	/*******************************************/
	/* Decode signal type and quantizer offset */
	/*******************************************/
	if decode_LBRR != 0 || *(*int32)(unsafe.Pointer(psDec + 2416 + uintptr(FrameIndex)*4)) != 0 {
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_type_offset_VAD_iCDF)), uint32(8)) + int32(2)
	} else {
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_type_offset_no_VAD_iCDF)), uint32(8))
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType = int8(Ix >> libc.Int32FromInt32(1))
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType = int8(Ix & libc.Int32FromInt32(1))
	/****************/
	/* Decode gains */
	/****************/
	/* First subframe */
	if condCoding == int32(CODE_CONDITIONALLY) {
		/* Conditional coding */
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856)) = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8)))
	} else {
		/* Independent coding, in two stages: MSB bits followed by 3 LSBs */
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856)) = int8(libc.Int32FromUint32(libc.Uint32FromInt32(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_gain_iCDF))+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)*8, uint32(8))) << libc.Int32FromInt32(3)))
		v1 = psDec + 2856
		*(*OpusT_opus_int8)(unsafe.Pointer(v1)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v1))) + int32(int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF)), uint32(8)))))
	}
	/* Remaining subframes */
	i = int32(1)
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + uintptr(i))) = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8)))
		goto _2
	_2:
		;
		i = i + 1
	}
	/**********************/
	/* Decode LSF Indices */
	/**********************/
	*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8)) = int8(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).FCB1_iCDF+uintptr(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)>>int32(1)*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).FnVectors)), uint32(8)))
	Opus_silk_NLSF_unpack(tls, bp, bp+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8))))
	if !(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Forder) == (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
		Opus_celt_fatal(tls, __ccgo_ts+6108, __ccgo_ts+6170, int32(82))
	}
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Forder)) {
			break
		}
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Fec_iCDF+uintptr((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]), uint32(8))
		if Ix == 0 {
			Ix = Ix - Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
		} else {
			if Ix == libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) {
				Ix = Ix + Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
			}
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8 + uintptr(i+int32(1)))) = int8(Ix - libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE))
		goto _3
	_3:
		;
		i = i + 1
	}
	/* Decode LSF interpolation factor */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_interpolation_factor_iCDF)), uint32(8)))
	} else {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(4)
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/*********************/
		/* Decode pitch lags */
		/*********************/
		/* Get lag index */
		decode_absolute_lagIndex = int32(1)
		if condCoding == int32(CODE_CONDITIONALLY) && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevSignalType == int32(TYPE_VOICED) {
			/* Decode Delta index */
			delta_lagIndex = int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pitch_delta_iCDF)), uint32(8))))
			if delta_lagIndex > 0 {
				delta_lagIndex = delta_lagIndex - int32(9)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex = int16(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevLagIndex) + delta_lagIndex)
				decode_absolute_lagIndex = 0
			}
		}
		if decode_absolute_lagIndex != 0 {
			/* Absolute decoding */
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex = int16(int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pitch_lag_iCDF)), uint32(8)))) * ((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz >> int32(1)))
			v1 = psDec + 2856 + 26
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF, uint32(8)))))
		}
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevLagIndex = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex
		/* Get contour index */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FcontourIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF, uint32(8)))
		/********************/
		/* Decode LTP gains */
		/********************/
		/* Decode PERIndex value */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_LTP_per_index_iCDF)), uint32(8)))
		k = 0
		for {
			if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 4 + uintptr(k))) = int8(Opus_ec_dec_icdf(tls, psRangeDec, Opus_silk_LTP_gain_iCDF_ptrs[(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex], uint32(8)))
			goto _5
		_5:
			;
			k = k + 1
		}
		/**********************/
		/* Decode LTP scaling */
		/**********************/
		if condCoding == CODE_INDEPENDENTLY {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_LTPscale_iCDF)), uint32(8)))
		} else {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex = 0
		}
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
	/***************/
	/* Decode seed */
	/***************/
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FSeed = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF)), uint32(8)))
}

// C documentation
//
//	/*********************************************/
//	/* Decode quantization indices of excitation */
//	/*********************************************/
func Opus_silk_decode_pulses(tls *libc.TLS, psRangeDec uintptr, pulses uintptr, signalType int32, quantOffsetType int32, frame_length int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var RateLevelIndex, abs_q, i, iter, j, k, nLS int32
	var cdf_ptr, pulses_ptr uintptr
	var nLshifts [20]int32
	var _ /* sum_pulses at bp+0 */ [20]int32
	_, _, _, _, _, _, _, _, _, _ = RateLevelIndex, abs_q, cdf_ptr, i, iter, j, k, nLS, nLshifts, pulses_ptr
	/*********************/
	/* Decode rate level */
	/*********************/
	RateLevelIndex = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_rate_levels_iCDF))+uintptr(signalType>>int32(1))*9, uint32(8))
	/* Calculate number of shell blocks */
	_ = libc.Int32FromInt32(1)<<libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH) == libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)
	iter = frame_length >> libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	if iter*int32(SHELL_CODEC_FRAME_LENGTH) < frame_length {
		if !(frame_length == libc.Int32FromInt32(12)*libc.Int32FromInt32(10)) {
			Opus_celt_fatal(tls, __ccgo_ts+6195, __ccgo_ts+6237, int32(59))
		} /* Make sure only happens for 10 ms @ 12 kHz */
		iter = iter + 1
	}
	/***************************************************/
	/* Sum-Weighted-Pulses Decoding                    */
	/***************************************************/
	cdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF)) + uintptr(RateLevelIndex)*18
	i = 0
	for {
		if !(i < iter) {
			break
		}
		nLshifts[i] = 0
		(*(*[20]int32)(unsafe.Pointer(bp)))[i] = Opus_ec_dec_icdf(tls, psRangeDec, cdf_ptr, uint32(8))
		/* LSB indication */
		for (*(*[20]int32)(unsafe.Pointer(bp)))[i] == libc.Int32FromInt32(SILK_MAX_PULSES)+libc.Int32FromInt32(1) {
			nLshifts[i] = nLshifts[i] + 1
			/* When we've already got 10 LSBs, we shift the table to not allow (SILK_MAX_PULSES + 1) */
			(*(*[20]int32)(unsafe.Pointer(bp)))[i] = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF))+uintptr(libc.Int32FromInt32(N_RATE_LEVELS)-libc.Int32FromInt32(1))*18+libc.BoolUintptr(nLshifts[i] == libc.Int32FromInt32(10)), uint32(8))
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	/***************************************************/
	/* Shell decoding                                  */
	/***************************************************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if (*(*[20]int32)(unsafe.Pointer(bp)))[i] > 0 {
			Opus_silk_shell_decoder(tls, pulses+uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2, psRangeDec, (*(*[20]int32)(unsafe.Pointer(bp)))[i])
		} else {
			libc.Xmemset(tls, pulses+uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2, 0, libc.Uint64FromInt32(SHELL_CODEC_FRAME_LENGTH)*libc.Uint64FromInt64(2))
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	/***************************************************/
	/* LSB Decoding                                    */
	/***************************************************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if nLshifts[i] > 0 {
			nLS = nLshifts[i]
			pulses_ptr = pulses + uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2
			k = 0
			for {
				if !(k < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				abs_q = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pulses_ptr + uintptr(k)*2)))
				j = 0
				for {
					if !(j < nLS) {
						break
					}
					abs_q = libc.Int32FromUint32(libc.Uint32FromInt32(abs_q) << libc.Int32FromInt32(1))
					abs_q = abs_q + Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_lsb_iCDF)), uint32(8))
					goto _5
				_5:
					;
					j = j + 1
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(pulses_ptr + uintptr(k)*2)) = int16(abs_q)
				goto _4
			_4:
				;
				k = k + 1
			}
			/* Mark the number of pulses non-zero for sign decoding. */
			*(*int32)(unsafe.Pointer(bp + uintptr(i)*4)) |= nLS << int32(5)
		}
		goto _3
	_3:
		;
		i = i + 1
	}
	/****************************************/
	/* Decode and add signs to pulse signal */
	/****************************************/
	Opus_silk_decode_signs(tls, psRangeDec, pulses, frame_length, signalType, quantOffsetType, bp)
}

// C documentation
//
//	/* Set decoder sampling rate */
func Opus_silk_decoder_set_fs(tls *libc.TLS, psDec uintptr, fs_kHz int32, fs_API_Hz OpusT_opus_int32) (r int32) {
	var frame_length, ret int32
	_, _ = frame_length, ret
	ret = 0
	if !(fs_kHz == int32(8) || fs_kHz == int32(12) || fs_kHz == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+6261, __ccgo_ts+6323, int32(43))
	}
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+6348, __ccgo_ts+6323, int32(44))
	}
	/* New (sub)frame length */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length = int32(int16(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS))) * int32(int16(fs_kHz))
	frame_length = int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)) * int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length))
	/* Initialize resampler when switching internal or external sampling frequency */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_API_hz != fs_API_Hz {
		/* Initialize the resampler for dec_API.c preparing resampling from fs_kHz to API_fs_Hz */
		ret = ret + Opus_silk_resampler_init(tls, psDec+2448, int32(int16(fs_kHz))*int32(int16(libc.Int32FromInt32(1000))), fs_API_Hz, 0)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_API_hz = fs_API_Hz
	}
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz || frame_length != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length {
		if fs_kHz == int32(8) {
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_NB_iCDF))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_NB_iCDF))
			}
		} else {
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_iCDF))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_iCDF))
			}
		}
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length = int32(int16(libc.Int32FromInt32(LTP_MEM_LENGTH_MS))) * int32(int16(fs_kHz))
			if fs_kHz == int32(8) || fs_kHz == int32(12) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order = int32(MIN_LPC_ORDER)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_NB_MB))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order = int32(MAX_LPC_ORDER)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_WB))
			}
			if fs_kHz == int32(16) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF))
			} else {
				if fs_kHz == int32(12) {
					(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform6_iCDF))
				} else {
					if fs_kHz == int32(8) {
						(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF))
					} else {
						/* unsupported sampling rate */
						if !(libc.Int32FromInt32(0) != 0) {
							Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+6323, int32(89))
						}
					}
				}
			}
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = int32(1)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev = int32(100)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLastGainIndex = int8(10)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = TYPE_NO_VOICE_ACTIVITY
			libc.Xmemset(tls, psDec+1348, 0, libc.Uint64FromInt64(960))
			libc.Xmemset(tls, psDec+1284, 0, libc.Uint64FromInt64(64))
		}
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz = fs_kHz
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length = frame_length
	}
	/* Check that settings are valid */
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length > 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length <= libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+6435, __ccgo_ts+6323, int32(104))
	}
	return ret
}

const CELT_SIG_SCALE9 = 32768

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

// C documentation
//
//	/************************/
//	/* Decoder Super Struct */
//	/************************/
type OpusT_silk_decoder = struct {
	Fchannel_state           [2]OpusT_silk_decoder_state
	FsStereo                 OpusT_stereo_dec_state
	FnChannelsAPI            int32
	FnChannelsInternal       int32
	Fprev_decode_only_middle int32
}

/*********************/
/* Decoder functions */
/*********************/
func Opus_silk_LoadOSCEModels(tls *libc.TLS, decState uintptr, data uintptr, len1 int32) (r int32) {
	_ = decState
	_ = data
	_ = len1
	return SILK_NO_ERROR
}

func Opus_silk_Get_Decoder_Size(tls *libc.TLS, decSizeBytes uintptr) (r int32) {
	var ret int32
	_ = ret
	ret = SILK_NO_ERROR
	*(*int32)(unsafe.Pointer(decSizeBytes)) = int32(8808)
	return ret
}

// C documentation
//
//	/* Reset decoder state */
func Opus_silk_ResetDecoder(tls *libc.TLS, decState uintptr) (r int32) {
	var channel_state uintptr
	var n, ret int32
	_, _, _ = channel_state, n, ret
	ret = SILK_NO_ERROR
	channel_state = decState
	n = 0
	for {
		if !(n < int32(DECODER_NUM_CHANNELS)) {
			break
		}
		ret = Opus_silk_reset_decoder(tls, channel_state+uintptr(n)*4392)
		goto _1
	_1:
		;
		n = n + 1
	}
	libc.Xmemset(tls, decState+8784, 0, libc.Uint64FromInt64(12))
	/* Not strictly needed, but it's cleaner that way */
	(*OpusT_silk_decoder)(unsafe.Pointer(decState)).Fprev_decode_only_middle = 0
	return ret
}

func Opus_silk_InitDecoder(tls *libc.TLS, decState uintptr) (r int32) {
	var channel_state uintptr
	var n, ret int32
	_, _, _ = channel_state, n, ret
	ret = SILK_NO_ERROR
	channel_state = decState
	/* load osce models */
	Opus_silk_LoadOSCEModels(tls, decState, libc.UintptrFromInt32(0), 0)
	n = 0
	for {
		if !(n < int32(DECODER_NUM_CHANNELS)) {
			break
		}
		ret = Opus_silk_init_decoder(tls, channel_state+uintptr(n)*4392)
		goto _1
	_1:
		;
		n = n + 1
	}
	libc.Xmemset(tls, decState+8784, 0, libc.Uint64FromInt64(12))
	/* Not strictly needed, but it's cleaner that way */
	(*OpusT_silk_decoder)(unsafe.Pointer(decState)).Fprev_decode_only_middle = 0
	return ret
}

// C documentation
//
//	/* Decode a frame */
func Opus_silk_Decode(tls *libc.TLS, decState uintptr, decControl uintptr, lostFlag int32, newPacketFlag int32, psRangeDec uintptr, samplesOut uintptr, nSamplesOut uintptr, arch int32) (r int32) {
	bp := tls.Alloc(656)
	defer tls.Free(656)
	var FrameIndex, condCoding, condCoding1, fs_kHz_dec, has_side, i, n, ret, stereo_to_mono, v51 int32
	var LBRR_symbol OpusT_opus_int32
	var _saved_stack, channel_state, psDec, resample_out_ptr, samplesOut1_tmp_storage1, samplesOut2_tmp, st, v1, v11, v13, v15, v17, v26, v28, v3, v30, v32, v7, v9 uintptr
	var mult_tab [3]int32
	var samplesOut1_tmp [2]uintptr
	var _ /* MS_pred_Q13 at bp+8 */ [2]OpusT_opus_int32
	var _ /* decode_only_middle at bp+0 */ int32
	var _ /* nSamplesOutDec at bp+4 */ OpusT_opus_int32
	var _ /* pulses at bp+16 */ [320]OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = FrameIndex, LBRR_symbol, _saved_stack, channel_state, condCoding, condCoding1, fs_kHz_dec, has_side, i, mult_tab, n, psDec, resample_out_ptr, ret, samplesOut1_tmp, samplesOut1_tmp_storage1, samplesOut2_tmp, st, stereo_to_mono, v1, v11, v13, v15, v17, v26, v28, v3, v30, v32, v51, v7, v9
	*(*int32)(unsafe.Pointer(bp)) = 0
	ret = SILK_NO_ERROR
	*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 8)) = [2]OpusT_opus_int32{}
	psDec = decState
	channel_state = psDec
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+6520, __ccgo_ts+6611, int32(165))
	}
	/**********************************/
	/* Test if first frame in payload */
	/**********************************/
	if newPacketFlag != 0 {
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded = 0 /* Used to count frames in packet */
			goto _5
		_5:
			;
			n = n + 1
		}
	}
	/* If Mono -> Stereo transition in bitstream: init state of second channel */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal > (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal {
		ret = ret + Opus_silk_init_decoder(tls, channel_state+1*4392)
	}
	stereo_to_mono = libc.BoolInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FinternalSampleRate == int32(1000)*(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz)
	if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded == 0 {
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == 0 {
				/* Assuming packet loss, use 10 ms */
				(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
				(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(2)
			} else {
				if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(10) {
					(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
					(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(2)
				} else {
					if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(20) {
						(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
						(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
					} else {
						if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(40) {
							(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(2)
							(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
						} else {
							if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(60) {
								(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(3)
								(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
							} else {
								if !(libc.Int32FromInt32(0) != 0) {
									Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+6611, int32(204))
								}
								st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
								if !(st != 0) {
									v1 = libc.Xmalloc(tls, uint64(16))
									goto _8
								_8:
									st = v1
									if st != 0 {
										libc.Xmemset(tls, st, 0, uint64(16))
									}
									libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
								}
								v3 = st
								goto _10
							_10:
								(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
								return -int32(203)
							}
						}
					}
				}
			}
			fs_kHz_dec = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FinternalSampleRate>>libc.Int32FromInt32(10) + int32(1)
			if fs_kHz_dec != int32(8) && fs_kHz_dec != int32(12) && fs_kHz_dec != int32(16) {
				if !(libc.Int32FromInt32(0) != 0) {
					Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+6611, int32(210))
				}
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _12
				_12:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _14
			_14:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(200)
			}
			ret = ret + Opus_silk_decoder_set_fs(tls, channel_state+uintptr(n)*4392, fs_kHz_dec, (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate)
			goto _6
		_6:
			;
			n = n + 1
		}
	}
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && ((*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsAPI == int32(1) || (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal == int32(1)) {
		libc.Xmemset(tls, psDec+8784, 0, libc.Uint64FromInt64(4))
		libc.Xmemset(tls, psDec+8784+8, 0, libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, channel_state+1*4392+2448, channel_state+2448, libc.Uint64FromInt64(400))
	}
	(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsAPI = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI
	(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate > libc.Int32FromInt32(MAX_API_FS_KHZ)*libc.Int32FromInt32(1000) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate < int32(8000) {
		ret = -int32(200)
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	if lostFlag != int32(FLAG_PACKET_LOST) && (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded == 0 {
		/* First decoder call for this payload */
		/* Decode VAD flags and LBRR flag */
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			i = 0
			for {
				if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket) {
					break
				}
				*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2416 + uintptr(i)*4)) = Opus_ec_dec_bit_logp(tls, psRangeDec, uint32(1))
				goto _20
			_20:
				;
				i = i + 1
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FLBRR_flag = Opus_ec_dec_bit_logp(tls, psRangeDec, uint32(1))
			goto _19
		_19:
			;
			n = n + 1
		}
		/* Decode LBRR flags */
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			libc.Xmemset(tls, channel_state+uintptr(n)*4392+2432, 0, libc.Uint64FromInt64(12))
			if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FLBRR_flag != 0 {
				if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket == int32(1) {
					*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432)) = int32(1)
				} else {
					LBRR_symbol = Opus_ec_dec_icdf(tls, psRangeDec, Opus_silk_LBRR_flags_iCDF_ptr[(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket-int32(2)], uint32(8)) + int32(1)
					i = 0
					for {
						if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket) {
							break
						}
						*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i)*4)) = LBRR_symbol >> i & int32(1)
						goto _22
					_22:
						;
						i = i + 1
					}
				}
			}
			goto _21
		_21:
			;
			n = n + 1
		}
		if lostFlag == FLAG_DECODE_NORMAL {
			/* Regular decoding: skip all LBRR data */
			i = 0
			for {
				if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesPerPacket) {
					break
				}
				n = 0
				for {
					if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
						break
					}
					if *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i)*4)) != 0 {
						if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && n == 0 {
							Opus_silk_stereo_decode_pred(tls, psRangeDec, bp+8)
							if *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr(i)*4)) == 0 {
								Opus_silk_stereo_decode_mid_only(tls, psRangeDec, bp)
							}
						}
						/* Use conditional coding if previous frame available */
						if i > 0 && *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i-int32(1))*4)) != 0 {
							condCoding = int32(CODE_CONDITIONALLY)
						} else {
							condCoding = CODE_INDEPENDENTLY
						}
						Opus_silk_decode_indices(tls, channel_state+uintptr(n)*4392, psRangeDec, i, int32(1), condCoding)
						Opus_silk_decode_pulses(tls, psRangeDec, bp+16, int32((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Findices.FsignalType), int32((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Findices.FquantOffsetType), (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fframe_length)
					}
					goto _24
				_24:
					;
					n = n + 1
				}
				goto _23
			_23:
				;
				i = i + 1
			}
		}
	}
	/* Get MS predictor index */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) {
		if lostFlag == FLAG_DECODE_NORMAL || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == int32(1) {
			Opus_silk_stereo_decode_pred(tls, psRangeDec, bp+8)
			/* For LBRR data, decode mid-only flag only if side-channel's LBRR flag is false */
			if lostFlag == FLAG_DECODE_NORMAL && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2416 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == 0 || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == 0 {
				Opus_silk_stereo_decode_mid_only(tls, psRangeDec, bp)
			} else {
				*(*int32)(unsafe.Pointer(bp)) = 0
			}
		} else {
			n = 0
			for {
				if !(n < int32(2)) {
					break
				}
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[n] = int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 8784 + uintptr(n)*2)))
				goto _25
			_25:
				;
				n = n + 1
			}
		}
	}
	/* Reset side channel decoder prediction memory for first frame with side coding */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && *(*int32)(unsafe.Pointer(bp)) == 0 && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle == int32(1) {
		libc.Xmemset(tls, psDec+1*4392+1348, 0, libc.Uint64FromInt64(960))
		libc.Xmemset(tls, psDec+1*4392+1284, 0, libc.Uint64FromInt64(64))
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FlagPrev = int32(100)
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FLastGainIndex = int8(10)
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FprevSignalType = TYPE_NO_VOICE_ACTIVITY
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).Ffirst_frame_after_reset = int32(1)
	}
	/* Check if the temp buffer fits into the output PCM buffer. If it fits,
	   we can delay allocating the temp buffer until after the SILK peak stack
	   usage. We need to use a < and not a <= because of the two extra samples. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _29
_29:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _33
_33:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _37
_37:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _41
_41:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6611, int32(319))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v26 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v26
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v28 = st
	goto _45
_45:
	*(*uintptr)(unsafe.Pointer(v28 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v30 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v30
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v32 = st
	goto _49
_49:
	samplesOut1_tmp_storage1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v32)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	samplesOut1_tmp[0] = samplesOut1_tmp_storage1
	samplesOut1_tmp[int32(1)] = samplesOut1_tmp_storage1 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length)*2 + uintptr(2)*2
	if lostFlag == FLAG_DECODE_NORMAL {
		has_side = libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp)) != 0))
	} else {
		has_side = libc.BoolInt32(!((*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle != 0) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + 1*4392))).FnFramesDecoded)*4)) == int32(1))
	}
	(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FsPLC.Fenable_deep_plc = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).Fenable_deep_plc
	/* Call decoder for one frame */
	n = 0
	for {
		if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
			break
		}
		if n == 0 || has_side != 0 {
			FrameIndex = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded - n
			/* Use independent coding if no previous frame available */
			if FrameIndex <= 0 {
				condCoding1 = CODE_INDEPENDENTLY
			} else {
				if lostFlag == int32(FLAG_DECODE_LBRR) {
					if *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(FrameIndex-int32(1))*4)) != 0 {
						v51 = int32(CODE_CONDITIONALLY)
					} else {
						v51 = CODE_INDEPENDENTLY
					}
					condCoding1 = v51
				} else {
					if n > 0 && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle != 0 {
						/* If we skipped a side frame in this packet, we don't
						   need LTP scaling; the LTP state is well-defined. */
						condCoding1 = int32(CODE_INDEPENDENTLY_NO_LTP_SCALING)
					} else {
						condCoding1 = int32(CODE_CONDITIONALLY)
					}
				}
			}
			ret = ret + Opus_silk_decode_frame(tls, channel_state+uintptr(n)*4392, psRangeDec, samplesOut1_tmp[n]+2*2, bp+4, lostFlag, condCoding1, arch)
		} else {
			libc.Xmemset(tls, samplesOut1_tmp[n]+2*2, 0, libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))*libc.Uint64FromInt64(2))
		}
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded + 1
		goto _50
	_50:
		;
		n = n + 1
	}
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) {
		/* Convert Mid/Side to Left/Right */
		Opus_silk_stereo_MS_to_LR(tls, psDec+8784, samplesOut1_tmp[0], samplesOut1_tmp[int32(1)], bp+8, (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
	} else {
		/* Buffering */
		libc.Xmemcpy(tls, samplesOut1_tmp[0], psDec+8784+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+8784+4, samplesOut1_tmp[0]+uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	}
	/* Number of output samples */
	*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) * (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate / (int32(int16((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz)) * int32(int16(libc.Int32FromInt32(1000))))
	/* Set up pointers to temp buffers */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _55
_55:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _59
_59:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _61
	_61:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _63
_63:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _67
_67:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6611, int32(382))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v26 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v26
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v28 = st
	goto _71
_71:
	*(*uintptr)(unsafe.Pointer(v28 + 8)) += uintptr(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v30 = libc.Xmalloc(tls, uint64(16))
		goto _73
	_73:
		st = v30
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v32 = st
	goto _75
_75:
	samplesOut2_tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v32)).Fglobal_stack - uintptr(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	resample_out_ptr = samplesOut2_tmp
	n = 0
	for {
		if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal {
			v51 = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI
		} else {
			v51 = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal
		}
		if !(n < v51) {
			break
		}
		/* Resample decoded signal to API_sampleRate */
		ret = ret + Opus_silk_resampler(tls, channel_state+uintptr(n)*4392+2448, resample_out_ptr, samplesOut1_tmp[n]+1*2, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
		/* Interleave if stereo output and stereo stream */
		if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(n+int32(2)*i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _78
			_78:
				;
				i = i + 1
			}
		} else {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _79
			_79:
				;
				i = i + 1
			}
		}
		goto _76
	_76:
		;
		n = n + 1
	}
	/* Create two channel output from mono stream */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) {
		if stereo_to_mono != 0 {
			/* Resample right channel for newly collapsed stereo just in case
			   we weren't doing collapsing when switching to mono */
			ret = ret + Opus_silk_resampler(tls, channel_state+1*4392+2448, resample_out_ptr, samplesOut1_tmp[0]+1*2, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(int32(1)+int32(2)*i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _80
			_80:
				;
				i = i + 1
			}
		} else {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(int32(1)+int32(2)*i)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(0+int32(2)*i)*4))
				goto _81
			_81:
				;
				i = i + 1
			}
		}
	}
	/* Export pitch lag, measured at 48 kHz sampling rate */
	if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FprevSignalType == int32(TYPE_VOICED) {
		mult_tab = [3]int32{
			0: int32(6),
			1: int32(4),
			2: int32(3),
		}
		(*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FprevPitchLag = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FlagPrev * mult_tab[((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz-int32(8))>>int32(2)]
	} else {
		(*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FprevPitchLag = 0
	}
	if lostFlag == int32(FLAG_PACKET_LOST) {
		/* On packet loss, remove the gain clamping to prevent having the energy "bounce back"
		   if we lose packets when the energy is going down */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + uintptr(i)*4392))).FLastGainIndex = int8(10)
			goto _82
		_82:
			;
			i = i + 1
		}
	} else {
		(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle = *(*int32)(unsafe.Pointer(bp))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _86
_86:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

const CELT_SIG_SCALE10 = "32768.f"

// C documentation
//
//	/* Gain scalar quantization with hysteresis, uniform on log scale */
func Opus_silk_gains_quant(tls *libc.TLS, ind uintptr, gain_Q16 uintptr, prev_ind uintptr, conditional int32, nb_subfr int32) {
	var double_step_size_threshold, k, v2, v3, v4, v5, v6 int32
	var v11 uintptr
	var v19, v20, v21 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = double_step_size_threshold, k, v11, v19, v2, v20, v21, v3, v4, v5, v6
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		/* Convert to log scale, scale, floor() */
		*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(int32(int64(libc.Int32FromInt32(65536)*(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1))/((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))) * int64(int16(Opus_silk_lin2log(tls, *(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)))-(libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6)+libc.Int32FromInt32(16)*libc.Int32FromInt32(128)))) >> libc.Int32FromInt32(16)))
		/* Round towards previous quantized gain (hysteresis) */
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) {
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = *(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) + 1
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
			v2 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
		} else {
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < 0 {
				v3 = 0
			} else {
				v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
			}
			v2 = v3
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
		/* Compute delta indices and limit */
		if k == 0 && conditional == 0 {
			/* Full index */
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) {
					v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) + -int32(4)
				} else {
					if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
						v4 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
					} else {
						v4 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
					}
					v3 = v4
				}
				v2 = v3
			} else {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
					v5 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
				} else {
					if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) {
						v6 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) + -int32(4)
					} else {
						v6 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
					}
					v5 = v6
				}
				v2 = v5
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
			*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = *(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))
		} else {
			/* Delta index */
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) - int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))
			/* Double the quantization step size for large gain increases, so that the max gain level can be reached */
			double_step_size_threshold = libc.Int32FromInt32(2)*libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - libc.Int32FromInt32(N_LEVELS_QGAIN) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > double_step_size_threshold {
				*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(double_step_size_threshold + (int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))-double_step_size_threshold+int32(1))>>int32(1))
			}
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > int32(MAX_DELTA_GAIN_QUANT) {
				v2 = int32(MAX_DELTA_GAIN_QUANT)
			} else {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < -int32(4) {
					v3 = -int32(4)
				} else {
					v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
				}
				v2 = v3
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
			/* Accumulate deltas */
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > double_step_size_threshold {
				v11 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + (libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))<<libc.Int32FromInt32(1)) - double_step_size_threshold))
				v2 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
				v3 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
				if v2 < v3 {
					v5 = v2
				} else {
					v5 = v3
				}
				v4 = v5
				goto _15
			_15:
				*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v4)
			} else {
				v11 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))))
			}
			/* Shift to make non-negative */
			v11 = ind + uintptr(k)
			*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) - -libc.Int32FromInt32(4))
		}
		/* Scale and convert to linear scale */
		v19 = int32(int64(libc.Int32FromInt32(65536)*((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))/(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1)))*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))>>libc.Int32FromInt32(16)) + (libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6) + libc.Int32FromInt32(16)*libc.Int32FromInt32(128))
		v20 = int32(3967)
		if v19 < v20 {
			v2 = v19
		} else {
			v2 = v20
		}
		v21 = v2
		goto _22
	_22:
		*(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)) = Opus_silk_log2lin(tls, v21) /* 3967 = 31 in Q7 */
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* Gains scalar dequantization, uniform on log scale */
func Opus_silk_gains_dequant(tls *libc.TLS, gain_Q16 uintptr, ind uintptr, prev_ind uintptr, conditional int32, nb_subfr int32) {
	var double_step_size_threshold, ind_tmp, k, v2, v3, v4, v6 int32
	var v11, v12, v13 OpusT_opus_int32
	var v7 uintptr
	_, _, _, _, _, _, _, _, _, _, _ = double_step_size_threshold, ind_tmp, k, v11, v12, v13, v2, v3, v4, v6, v7
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		if k == 0 && conditional == 0 {
			/* Gain index is not allowed to go down more than 16 steps (~21.8 dB) */
			v2 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
			v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) - int32(16)
			if v2 > v3 {
				v6 = v2
			} else {
				v6 = v3
			}
			v4 = v6
			goto _5
		_5:
			*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v4)
		} else {
			/* Delta index */
			ind_tmp = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) + -int32(4)
			/* Accumulate deltas */
			double_step_size_threshold = libc.Int32FromInt32(2)*libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - libc.Int32FromInt32(N_LEVELS_QGAIN) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			if ind_tmp > double_step_size_threshold {
				v7 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v7)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v7))) + (libc.Int32FromUint32(libc.Uint32FromInt32(ind_tmp)<<libc.Int32FromInt32(1)) - double_step_size_threshold))
			} else {
				v7 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v7)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v7))) + ind_tmp)
			}
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
			v2 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
		} else {
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) < 0 {
				v3 = 0
			} else {
				v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			}
			v2 = v3
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v2)
		/* Scale and convert to linear scale */
		v11 = int32(int64(libc.Int32FromInt32(65536)*((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))/(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1)))*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))>>libc.Int32FromInt32(16)) + (libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6) + libc.Int32FromInt32(16)*libc.Int32FromInt32(128))
		v12 = int32(3967)
		if v11 < v12 {
			v2 = v11
		} else {
			v2 = v12
		}
		v13 = v2
		goto _14
	_14:
		*(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)) = Opus_silk_log2lin(tls, v13) /* 3967 = 31 in Q7 */
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* Compute unique identifier of gain indices vector */
func Opus_silk_gains_ID(tls *libc.TLS, ind uintptr, nb_subfr int32) (r OpusT_opus_int32) {
	var gainsID OpusT_opus_int32
	var k int32
	_, _ = gainsID, k
	gainsID = 0
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		gainsID = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) + libc.Int32FromUint32(libc.Uint32FromInt32(gainsID)<<libc.Int32FromInt32(8))
		goto _1
	_1:
		;
		k = k + 1
	}
	return gainsID
}

// C documentation
//
//	/* Interpolate two vectors */
func Opus_silk_interpolate(tls *libc.TLS, xi uintptr, x0 uintptr, x1 uintptr, ifact_Q2 int32, d int32) {
	var i int32
	_ = i
	if !(ifact_Q2 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+6629, __ccgo_ts+6661, int32(45))
	}
	if !(ifact_Q2 <= libc.Int32FromInt32(4)) {
		Opus_celt_fatal(tls, __ccgo_ts+6683, __ccgo_ts+6661, int32(46))
	}
	i = 0
	for {
		if !(i < d) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(xi + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x0 + uintptr(i)*2))) + int32(int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(i)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(x0 + uintptr(i)*2)))))*int32(int16(ifact_Q2))>>libc.Int32FromInt32(2))
		goto _1
	_1:
		;
		i = i + 1
	}
}

const silk_int16_MAX5 = 32767

// C documentation
//
//	/* Helper function, interpolates the filter taps */
func silk_LP_interpolate_filter_taps(tls *libc.TLS, B_Q28 uintptr, A_Q28 uintptr, ind int32, fac_Q16 OpusT_opus_int32) {
	var na, nb, v3, v4 int32
	_, _, _, _ = na, nb, v3, v4
	if ind < libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1) {
		if fac_Q16 > 0 {
			if fac_Q16 < int32(32768) { /* fac_Q16 is in range of a 16-bit int */
				/* Piece-wise linear interpolation of B and A */
				nb = 0
				for {
					if !(nb < int32(TRANSITION_NB)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + uintptr(nb)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4)))*int64(int16(fac_Q16))>>libc.Int32FromInt32(16))
					goto _1
				_1:
					;
					nb = nb + 1
				}
				na = 0
				for {
					if !(na < int32(TRANSITION_NA)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + uintptr(na)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4)))*int64(int16(fac_Q16))>>libc.Int32FromInt32(16))
					goto _2
				_2:
					;
					na = na + 1
				}
			} else { /* ( fac_Q16 - ( 1 << 16 ) ) is in range of a 16-bit int */
				if fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) > int32(silk_int16_MAX5) {
					v3 = int32(silk_int16_MAX5)
				} else {
					if fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) < int32(libc.Int16FromInt32(0x8000)) {
						v4 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v4 = fac_Q16 - libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)
					}
					v3 = v4
				}
				_ = fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) == v3
				/* Piece-wise linear interpolation of B and A */
				nb = 0
				for {
					if !(nb < int32(TRANSITION_NB)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + uintptr(nb)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4)))*int64(int16(fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)))>>libc.Int32FromInt32(16))
					goto _5
				_5:
					;
					nb = nb + 1
				}
				na = 0
				for {
					if !(na < int32(TRANSITION_NA)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + uintptr(na)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4)))*int64(int16(fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)))>>libc.Int32FromInt32(16))
					goto _6
				_6:
					;
					na = na + 1
				}
			}
		} else {
			libc.Xmemcpy(tls, B_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28))+uintptr(ind)*12, libc.Uint64FromInt32(TRANSITION_NB)*libc.Uint64FromInt64(4))
			libc.Xmemcpy(tls, A_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28))+uintptr(ind)*8, libc.Uint64FromInt32(TRANSITION_NA)*libc.Uint64FromInt64(4))
		}
	} else {
		libc.Xmemcpy(tls, B_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28))+uintptr(libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1))*12, libc.Uint64FromInt32(TRANSITION_NB)*libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, A_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28))+uintptr(libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1))*8, libc.Uint64FromInt32(TRANSITION_NA)*libc.Uint64FromInt64(4))
	}
}

// C documentation
//
//	/* Low-pass filter with variable cutoff frequency based on  */
//	/* piece-wise linear interpolation between elliptic filters */
//	/* Start by setting psEncC->mode <> 0;                      */
//	/* Deactivate by setting psEncC->mode = 0;                  */
func Opus_silk_LP_variable_cutoff(tls *libc.TLS, psLP uintptr, frame uintptr, frame_length int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var fac_Q16 OpusT_opus_int32
	var ind, v1, v2 int32
	var _ /* A_Q28 at bp+16 */ [2]OpusT_opus_int32
	var _ /* B_Q28 at bp+0 */ [3]OpusT_opus_int32
	_, _, _, _ = fac_Q16, ind, v1, v2
	fac_Q16 = 0
	ind = 0
	_ = (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no >= 0 && (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no <= libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR))
	/* Run filter if needed */
	if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode != 0 {
		/* Calculate index and interpolation factor for interpolation */
		fac_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR))-(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no) << (libc.Int32FromInt32(16) - libc.Int32FromInt32(6)))
		ind = fac_Q16 >> libc.Int32FromInt32(16)
		fac_Q16 = fac_Q16 - libc.Int32FromUint32(libc.Uint32FromInt32(ind)<<libc.Int32FromInt32(16))
		_ = ind >= libc.Int32FromInt32(0)
		_ = ind < libc.Int32FromInt32(TRANSITION_INT_NUM)
		/* Interpolate filter coefficients */
		silk_LP_interpolate_filter_taps(tls, bp, bp+16, ind, fac_Q16)
		/* Update transition frame number for next frame */
		if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no+(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode > libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)) {
			v1 = libc.Int32FromInt32(TRANSITION_TIME_MS) / (libc.Int32FromInt32(SUB_FRAME_LENGTH_MS) * libc.Int32FromInt32(MAX_NB_SUBFR))
		} else {
			if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no+(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode < 0 {
				v2 = 0
			} else {
				v2 = (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no + (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode
			}
			v1 = v2
		}
		(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no = v1
		/* ARMA low-pass filtering */
		_ = libc.Bool(true) && libc.Bool(true)
		Opus_silk_biquad_alt_stride1(tls, frame, bp, bp+16, psLP, frame, frame_length)
	}
}

const silk_int16_MAX6 = 0x7FFF

// C documentation
//
//	/* Predictive dequantizer for NLSF residuals */
func silk_NLSF_residual_dequant(tls *libc.TLS, x_Q10 uintptr, indices uintptr, pred_coef_Q8 uintptr, quant_step_size_Q16 int32, order OpusT_opus_int16) {
	var i, out_Q10, pred_Q10 int32
	_, _, _ = i, out_Q10, pred_Q10
	out_Q10 = 0
	i = int32(order) - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		pred_Q10 = int32(int16(out_Q10)) * int32(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pred_coef_Q8 + uintptr(i))))) >> int32(8)
		out_Q10 = libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(i)))) << libc.Int32FromInt32(10))
		if out_Q10 > 0 {
			out_Q10 = out_Q10 - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5))
		} else {
			if out_Q10 < 0 {
				out_Q10 = out_Q10 + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5))
			}
		}
		out_Q10 = int32(int64(pred_Q10) + int64(out_Q10)*int64(int16(quant_step_size_Q16))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int16)(unsafe.Pointer(x_Q10 + uintptr(i)*2)) = int16(out_Q10)
		goto _1
	_1:
		;
		i = i - 1
	}
}

// C documentation
//
//	/***********************/
//	/* NLSF vector decoder */
//	/***********************/
func Opus_silk_NLSF_decode(tls *libc.TLS, pNLSF_Q15 uintptr, NLSFIndices uintptr, psNLSF_CB uintptr) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var NLSF_Q15_tmp OpusT_opus_int32
	var i, v2, v3 int32
	var pCB_Wght_Q9, pCB_element uintptr
	var _ /* ec_ix at bp+16 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+0 */ [16]OpusT_opus_uint8
	var _ /* res_Q10 at bp+48 */ [16]OpusT_opus_int16
	_, _, _, _, _, _ = NLSF_Q15_tmp, i, pCB_Wght_Q9, pCB_element, v2, v3
	/* Unpack entropy table indices and predictor for current CB1 index */
	Opus_silk_NLSF_unpack(tls, bp+16, bp, psNLSF_CB, int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices))))
	/* Predictive residual dequantizer */
	silk_NLSF_residual_dequant(tls, bp+48, NLSFIndices+1, bp, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FquantStepSize_Q16), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)
	/* Apply inverse square-rooted weights to first stage and add to output */
	pCB_element = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_NLSF_Q8 + uintptr(int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices)))*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
	pCB_Wght_Q9 = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_Wght_Q9 + uintptr(int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices)))*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))*2
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)) {
			break
		}
		NLSF_Q15_tmp = libc.Int32FromUint32(libc.Uint32FromInt32(int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 48)))[i]))<<libc.Int32FromInt32(14))/int32(*(*OpusT_opus_int16)(unsafe.Pointer(pCB_Wght_Q9 + uintptr(i)*2))) + libc.Int32FromUint32(libc.Uint32FromInt16(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pCB_element + uintptr(i)))))<<libc.Int32FromInt32(7))
		if NLSF_Q15_tmp > int32(32767) {
			v2 = int32(32767)
		} else {
			if NLSF_Q15_tmp < 0 {
				v3 = 0
			} else {
				v3 = NLSF_Q15_tmp
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(i)*2)) = int16(v2)
		goto _1
	_1:
		;
		i = i + 1
	}
	/* NLSF stabilization */
	Opus_silk_NLSF_stabilize(tls, pNLSF_Q15, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FdeltaMin_Q15, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
}

const NB_ATT = 2
const silk_int16_MAX7 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

var HARM_ATT_Q15 = [2]OpusT_opus_int16{
	0: int16(32440),
	1: int16(31130),
} /* 0.99, 0.95 */
var PLC_RAND_ATTENUATE_V_Q15 = [2]OpusT_opus_int16{
	0: int16(31130),
	1: int16(26214),
} /* 0.95, 0.8 */
var PLC_RAND_ATTENUATE_UV_Q15 = [2]OpusT_opus_int16{
	0: int16(32440),
	1: int16(29491),
}

func Opus_silk_PLC_Reset(tls *libc.TLS, psDec uintptr) {
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) << (libc.Int32FromInt32(8) - libc.Int32FromInt32(1)))
	*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72)) = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72 + 1*4)) = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Fsubfr_length = int32(20)
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Fnb_subfr = int32(2)
}

func Opus_silk_PLC(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, lost int32, arch int32) {
	/* PLC control function */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Ffs_kHz {
		Opus_silk_PLC_Reset(tls, psDec)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Ffs_kHz = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz
	}
	if lost != 0 {
		/****************************/
		/* Generate Signal          */
		/****************************/
		silk_PLC_conceal(tls, psDec, psDecCtrl, frame, arch)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt + 1
	} else {
		/****************************/
		/* Update state             */
		/****************************/
		silk_PLC_update(tls, psDec, psDecCtrl)
	}
}

// C documentation
//
//	/**************************************************/
//	/* Update state of PLC                            */
//	/**************************************************/
func silk_PLC_update(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr) {
	var LTP_Gain_Q14, temp_LTP_Gain_Q14, tmp, tmp1 OpusT_opus_int32
	var i, j, scale_Q10, scale_Q14, v3 int32
	var psPLC uintptr
	_, _, _, _, _, _, _, _, _, _ = LTP_Gain_Q14, i, j, psPLC, scale_Q10, scale_Q14, temp_LTP_Gain_Q14, tmp, tmp1, v3
	psPLC = psDec + 4292
	/* Update parameters used in case of packet loss */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
	LTP_Gain_Q14 = 0
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Find the parameters for the last subframe which contains a pitch pulse */
		j = 0
		for {
			if !(j*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length < *(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1))*4))) {
				break
			}
			if j == (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr {
				break
			}
			temp_LTP_Gain_Q14 = 0
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				temp_LTP_Gain_Q14 = temp_LTP_Gain_Q14 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDecCtrl + 96 + uintptr(((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1)-j)*int32(LTP_ORDER)+i)*2)))
				goto _2
			_2:
				;
				i = i + 1
			}
			if temp_LTP_Gain_Q14 > LTP_Gain_Q14 {
				LTP_Gain_Q14 = temp_LTP_Gain_Q14
				libc.Xmemcpy(tls, psPLC+4, psDecCtrl+96+uintptr(int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-libc.Int32FromInt32(1)-j))*int32(int16(libc.Int32FromInt32(LTP_ORDER))))*2, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1)-j)*4))) << libc.Int32FromInt32(8))
			}
			goto _1
		_1:
			;
			j = j + 1
		}
		libc.Xmemset(tls, psPLC+4, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
		*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*2)) = int16(LTP_Gain_Q14)
		/* Limit LT coefs */
		if LTP_Gain_Q14 < int32(V_PITCH_GAIN_START_MIN_Q14) {
			tmp = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(V_PITCH_GAIN_START_MIN_Q14)) << libc.Int32FromInt32(10))
			if LTP_Gain_Q14 > int32(1) {
				v3 = LTP_Gain_Q14
			} else {
				v3 = int32(1)
			}
			scale_Q10 = tmp / v3
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2))) * int32(int16(scale_Q10)) >> libc.Int32FromInt32(10))
				goto _4
			_4:
				;
				i = i + 1
			}
		} else {
			if LTP_Gain_Q14 > int32(V_PITCH_GAIN_START_MAX_Q14) {
				tmp1 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(V_PITCH_GAIN_START_MAX_Q14)) << libc.Int32FromInt32(14))
				if LTP_Gain_Q14 > int32(1) {
					v3 = LTP_Gain_Q14
				} else {
					v3 = int32(1)
				}
				scale_Q14 = tmp1 / v3
				i = 0
				for {
					if !(i < int32(LTP_ORDER)) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2))) * int32(int16(scale_Q14)) >> libc.Int32FromInt32(14))
					goto _6
				_6:
					;
					i = i + 1
				}
			}
		}
	} else {
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz))*int32(int16(libc.Int32FromInt32(18)))) << libc.Int32FromInt32(8))
		libc.Xmemset(tls, psPLC+4, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
	}
	/* Save LPC coefficients */
	libc.Xmemcpy(tls, psPLC+14, psDecCtrl+32+1*32, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FprevLTP_scale_Q14 = int16((*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14)
	/* Save last two gains */
	libc.Xmemcpy(tls, psPLC+72, psDecCtrl+16+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(2))*4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(4))
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr
}

func silk_PLC_energy(tls *libc.TLS, energy1 uintptr, shift1 uintptr, energy2 uintptr, shift2 uintptr, exc_Q14 uintptr, prevGain_Q10 uintptr, subfr_length int32, nb_subfr int32) {
	var _saved_stack, exc_buf, exc_buf_ptr, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var i, k, v31, v32 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, exc_buf, exc_buf_ptr, i, k, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v31, v32, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6715, int32(199))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	exc_buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* Find random noise component */
	/* Scale previous excitation signal */
	exc_buf_ptr = exc_buf
	k = 0
	for {
		if !(k < int32(2)) {
			break
		}
		i = 0
		for {
			if !(i < subfr_length) {
				break
			}
			if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(8) > int32(silk_int16_MAX7) {
				v31 = int32(silk_int16_MAX7)
			} else {
				if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(8) < int32(libc.Int16FromInt32(0x8000)) {
					v32 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16)) >> libc.Int32FromInt32(8)
				}
				v31 = v32
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(exc_buf_ptr + uintptr(i)*2)) = int16(v31)
			goto _30
		_30:
			;
			i = i + 1
		}
		exc_buf_ptr = exc_buf_ptr + uintptr(subfr_length)*2
		goto _29
	_29:
		;
		k = k + 1
	}
	/* Find the subframe with lowest energy of the last two and use that as random noise generator */
	Opus_silk_sum_sqr_shift(tls, energy1, shift1, exc_buf, subfr_length)
	Opus_silk_sum_sqr_shift(tls, energy2, shift2, exc_buf+uintptr(subfr_length)*2, subfr_length)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func silk_PLC_conceal(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, arch int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var B_Q14, _saved_stack, pred_lag_ptr, psPLC, rand_ptr, sLPC_Q14_ptr, sLTP, sLTP_Q14, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var LPC_pred_Q10, LTP_pred_Q12, b32_inv, b32_nrm, down_scale_Q30, err_Q32, harm_Gain_Q15, invGain_Q30, inv_gain_Q30, rand_Gain_Q15, rand_seed, result, v84, v85, v86, v89 OpusT_opus_int32
	var b_headrm, i, idx, j, k, lag, lshift, sLTP_buf_idx, v53, v54, v55, v57, v58, v59, v60, v62, v63, v64, v65, v67, v68 int32
	var rand_scale_Q14, v79, v80, v81 OpusT_opus_int16
	var _ /* A_Q12 at bp+16 */ [16]OpusT_opus_int16
	var _ /* energy1 at bp+8 */ OpusT_opus_int32
	var _ /* energy2 at bp+12 */ OpusT_opus_int32
	var _ /* prevGain_Q10 at bp+48 */ [2]OpusT_opus_int32
	var _ /* shift1 at bp+0 */ int32
	var _ /* shift2 at bp+4 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B_Q14, LPC_pred_Q10, LTP_pred_Q12, _saved_stack, b32_inv, b32_nrm, b_headrm, down_scale_Q30, err_Q32, harm_Gain_Q15, i, idx, invGain_Q30, inv_gain_Q30, j, k, lag, lshift, pred_lag_ptr, psPLC, rand_Gain_Q15, rand_ptr, rand_scale_Q14, rand_seed, result, sLPC_Q14_ptr, sLTP, sLTP_Q14, sLTP_buf_idx, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v53, v54, v55, v57, v58, v59, v60, v62, v63, v64, v65, v67, v68, v7, v79, v80, v81, v84, v85, v86, v89, v9
	psPLC = psDec + 4292
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6715, int32(245))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sLTP_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6715, int32(250))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[0] = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72)) >> int32(6)
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)] = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72 + 1*4)) >> int32(6)
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset != 0 {
		libc.Xmemset(tls, psPLC+14, 0, libc.Uint64FromInt64(32))
	}
	silk_PLC_energy(tls, bp+8, bp, bp+12, bp+4, psDec+4, bp+48, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 8))>>*(*int32)(unsafe.Pointer(bp + 4)) < *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12))>>*(*int32)(unsafe.Pointer(bp)) {
		/* First sub-frame has lowest energy */
		v53 = 0
		v54 = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr-int32(1))*(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length - int32(RAND_BUF_SIZE)
		if v53 > v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _56
	_56:
		rand_ptr = psDec + 4 + uintptr(v55)*4
	} else {
		/* Second sub-frame has lowest energy */
		v53 = 0
		v54 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr*(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length - int32(RAND_BUF_SIZE)
		if v53 > v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _61
	_61:
		rand_ptr = psDec + 4 + uintptr(v55)*4
	}
	/* Set up Gain to random noise component */
	B_Q14 = psPLC + 4
	rand_scale_Q14 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FrandScale_Q14
	/* Set up attenuation gains */
	v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
	v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
	if v53 < v54 {
		v57 = v53
	} else {
		v57 = v54
	}
	v55 = v57
	goto _66
_66:
	harm_Gain_Q15 = int32(HARM_ATT_Q15[v55])
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) {
		v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
		v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
		if v53 < v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _71
	_71:
		rand_Gain_Q15 = int32(PLC_RAND_ATTENUATE_V_Q15[v55])
	} else {
		v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
		v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
		if v53 < v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _76
	_76:
		rand_Gain_Q15 = int32(PLC_RAND_ATTENUATE_UV_Q15[v55])
	}
	/* LPC concealment. Apply BWE to previous LPC */
	Opus_silk_bwexpander(tls, psPLC+14, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(float64(libc.Float64FromFloat64(BWE_COEF)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))
	/* Preload LPC coefficients to array on stack. Gives small performance gain */
	libc.Xmemcpy(tls, bp+16, psPLC+14, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	/* First Lost frame */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt == 0 {
		rand_scale_Q14 = int16(libc.Int32FromInt32(1) << libc.Int32FromInt32(14))
		/* Reduce random noise Gain for voiced frames */
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) {
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				rand_scale_Q14 = int16(int32(rand_scale_Q14) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(i)*2))))
				goto _78
			_78:
				;
				i = i + 1
			}
			v79 = int16(3277)
			v80 = rand_scale_Q14
			if int32(v79) > int32(v80) {
				v53 = int32(v79)
			} else {
				v53 = int32(v80)
			}
			v81 = int16(v53)
			goto _82
		_82:
			rand_scale_Q14 = v81 /* 0.2 */
			rand_scale_Q14 = int16(int32(rand_scale_Q14) * int32((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FprevLTP_scale_Q14) >> libc.Int32FromInt32(14))
		} else {
			_ = arch
			invGain_Q30 = Opus_silk_LPC_inverse_pred_gain_c(tls, psPLC+14, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)
			v84 = libc.Int32FromInt32(1) << libc.Int32FromInt32(30) >> libc.Int32FromInt32(LOG2_INV_LPC_GAIN_HIGH_THRES)
			v85 = invGain_Q30
			if v84 < v85 {
				v53 = v84
			} else {
				v53 = v85
			}
			v86 = v53
			goto _87
		_87:
			down_scale_Q30 = v86
			v84 = libc.Int32FromInt32(1) << libc.Int32FromInt32(30) >> libc.Int32FromInt32(LOG2_INV_LPC_GAIN_LOW_THRES)
			v85 = down_scale_Q30
			if v84 > v85 {
				v53 = v84
			} else {
				v53 = v85
			}
			v86 = v53
			goto _92
		_92:
			down_scale_Q30 = v86
			down_scale_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(down_scale_Q30) << libc.Int32FromInt32(LOG2_INV_LPC_GAIN_HIGH_THRES))
			rand_Gain_Q15 = int32(int64(down_scale_Q30)*int64(int16(rand_Gain_Q15))>>libc.Int32FromInt32(16)) >> int32(14)
		}
	}
	rand_seed = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Frand_seed
	lag = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	sLTP_buf_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length
	/* Rewhiten LTP state */
	idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - lag - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
	if !(idx > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+6729, __ccgo_ts+6715, int32(319))
	}
	Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(idx)*2, psDec+1348+uintptr(idx)*2, bp+16, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-idx, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, arch)
	/* Scale LTP state */
	v84 = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72 + 1*4))
	v53 = int32(46)
	_ = v84 != libc.Int32FromInt32(0)
	_ = v53 > libc.Int32FromInt32(0)
	if v84 > 0 {
		v54 = v84
	} else {
		v54 = -v84
	}
	v85 = v54
	if v85 != 0 {
		v55 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v85)))
	} else {
		v55 = int32(32)
	}
	v86 = v55
	goto _99
_99:
	b_headrm = v86 - int32(1)
	b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v84) << b_headrm)
	b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
	result = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv) << libc.Int32FromInt32(16))
	err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
	result = int32(int64(result) + int64(err_Q32)*int64(b32_inv)>>libc.Int32FromInt32(16))
	lshift = int32(61) - b_headrm - v53
	if lshift <= libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
			if result > libc.Int32FromUint32(0x80000000)>>-lshift {
				v58 = libc.Int32FromUint32(0x80000000) >> -lshift
			} else {
				if result < int32(silk_int32_MAX)>>-lshift {
					v59 = int32(silk_int32_MAX) >> -lshift
				} else {
					v59 = result
				}
				v58 = v59
			}
			v57 = v58
		} else {
			if result > int32(silk_int32_MAX)>>-lshift {
				v60 = int32(silk_int32_MAX) >> -lshift
			} else {
				if result < libc.Int32FromUint32(0x80000000)>>-lshift {
					v62 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					v62 = result
				}
				v60 = v62
			}
			v57 = v60
		}
		v89 = libc.Int32FromUint32(libc.Uint32FromInt32(v57) << -lshift)
		goto _102
	} else {
		if lshift < libc.Int32FromInt32(32) {
			v89 = result >> lshift
			goto _102
		} else {
			v89 = 0
			goto _102
		}
	}
_102:
	inv_gain_Q30 = v89
	if inv_gain_Q30 < libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(1) {
		v53 = inv_gain_Q30
	} else {
		v53 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(1)
	}
	inv_gain_Q30 = v53
	i = idx + (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q14 + uintptr(i)*4)) = int32(int64(inv_gain_Q30) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr(i)*2))) >> libc.Int32FromInt32(16))
		goto _109
	_109:
		;
		i = i + 1
	}
	/***************************/
	/* LTP synthesis filtering */
	/***************************/
	k = 0
	for {
		if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		/* Set up pointer */
		pred_lag_ptr = sLTP_Q14 + uintptr(sLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
				break
			}
			/* Unrolled loop */
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LTP_pred_Q12 = int32(2)
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 1*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 2*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 3*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 4*2)))>>libc.Int32FromInt32(16))
			pred_lag_ptr += 4
			/* Generate LPC excitation */
			rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(rand_seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
			idx = rand_seed >> libc.Int32FromInt32(25) & (libc.Int32FromInt32(RAND_BUF_SIZE) - libc.Int32FromInt32(1))
			*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q14 + uintptr(sLTP_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(LTP_pred_Q12)+int64(*(*OpusT_opus_int32)(unsafe.Pointer(rand_ptr + uintptr(idx)*4)))*int64(rand_scale_Q14)>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
			sLTP_buf_idx = sLTP_buf_idx + 1
			goto _111
		_111:
			;
			i = i + 1
		}
		/* Gradually reduce LTP gain */
		j = 0
		for {
			if !(j < int32(LTP_ORDER)) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(j)*2)) = int16(int32(int16(harm_Gain_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(j)*2))) >> libc.Int32FromInt32(15))
			goto _112
		_112:
			;
			j = j + 1
		}
		/* Gradually reduce excitation gain */
		rand_scale_Q14 = int16(int32(rand_scale_Q14) * int32(int16(rand_Gain_Q15)) >> libc.Int32FromInt32(15))
		/* Slowly increase pitch lag */
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = int32(int64((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8) + int64((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8)*int64(int16(libc.Int32FromInt32(PITCH_DRIFT_FAC_Q16)))>>libc.Int32FromInt32(16))
		v84 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8
		v85 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int16(libc.Int32FromInt32(MAX_PITCH_LAG_MS)))*int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz))) << libc.Int32FromInt32(8))
		if v84 < v85 {
			v53 = v84
		} else {
			v53 = v85
		}
		v86 = v53
		goto _116
	_116:
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = v86
		lag = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		goto _110
	_110:
		;
		k = k + 1
	}
	/***************************/
	/* LPC synthesis filtering */
	/***************************/
	sLPC_Q14_ptr = sLTP_Q14 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-int32(MAX_LPC_ORDER))*4
	/* Copy LPC state */
	libc.Xmemcpy(tls, sLPC_Q14_ptr, psDec+1284, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >= libc.Int32FromInt32(10)) {
		Opus_celt_fatal(tls, __ccgo_ts+6755, __ccgo_ts+6715, int32(373))
	} /* check that unrolling works */
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			break
		}
		/* partly unrolled */
		/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
		LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[0])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(1)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(2)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(3)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(4)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(5)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(6)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(7)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(8)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(9)])>>libc.Int32FromInt32(16))
		j = int32(10)
		for {
			if !(j < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-j-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[j])>>libc.Int32FromInt32(16))
			goto _119
		_119:
			;
			j = j + 1
		}
		/* Add prediction to LPC excitation */
		if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
			v54 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
		} else {
			if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
				v55 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
			} else {
				v55 = LPC_pred_Q10
			}
			v54 = v55
		}
		if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v54)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v58 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v59 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v59 = LPC_pred_Q10
				}
				v58 = v59
			}
			if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v58)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
				v57 = libc.Int32FromUint32(0x80000000)
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v60 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v62 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v62 = LPC_pred_Q10
					}
					v60 = v62
				}
				v57 = *(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v60)<<libc.Int32FromInt32(4))
			}
			v53 = v57
		} else {
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v64 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v65 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v65 = LPC_pred_Q10
				}
				v64 = v65
			}
			if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v64)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
				v63 = int32(silk_int32_MAX)
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v67 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v68 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v68 = LPC_pred_Q10
					}
					v67 = v68
				}
				v63 = *(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v67)<<libc.Int32FromInt32(4))
			}
			v53 = v63
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v53
		/* Scale with Gain */
		if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX7) {
			v54 = int32(silk_int16_MAX7)
		} else {
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v55 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v55 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v54 = v55
		}
		if v54 > int32(silk_int16_MAX7) {
			v53 = int32(silk_int16_MAX7)
		} else {
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX7) {
				v58 = int32(silk_int16_MAX7)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v59 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v59 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v58 = v59
			}
			if v58 < int32(libc.Int16FromInt32(0x8000)) {
				v57 = int32(libc.Int16FromInt32(0x8000))
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX7) {
					v60 = int32(silk_int16_MAX7)
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
						v62 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v62 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v60 = v62
				}
				v57 = v60
			}
			v53 = v57
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(v53)
		goto _118
	_118:
		;
		i = i + 1
	}
	/* Save LPC state */
	libc.Xmemcpy(tls, psDec+1284, sLPC_Q14_ptr+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	/**************************************/
	/* Update states                      */
	/**************************************/
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Frand_seed = rand_seed
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FrandScale_Q14 = rand_scale_Q14
	i = 0
	for {
		if !(i < int32(MAX_NB_SUBFR)) {
			break
		}
		*(*int32)(unsafe.Pointer(psDecCtrl + uintptr(i)*4)) = lag
		goto _141
	_141:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _143
	_143:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _145
_145:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

// C documentation
//
//	/* Glues concealed frames with new good received frames */
func Opus_silk_PLC_glue_frames(tls *libc.TLS, psDec uintptr, frame uintptr, length int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var LZ, frac_Q24, gain_Q16, lzeros, slope_Q16, y, v1, v11, v12, v2, v5, v6, v7 OpusT_opus_int32
	var i, v4, v9 int32
	var m, r, x OpusT_opus_uint32
	var psPLC uintptr
	var _ /* energy at bp+12 */ OpusT_opus_int32
	var _ /* energy_shift at bp+8 */ int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = LZ, frac_Q24, gain_Q16, i, lzeros, m, psPLC, r, slope_Q16, x, y, v1, v11, v12, v2, v4, v5, v6, v7, v9
	psPLC = psDec + 4292
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		/* Calculate energy in concealed residual */
		Opus_silk_sum_sqr_shift(tls, psPLC+60, psPLC+64, frame, length)
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Flast_frame_lost = int32(1)
	} else {
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Flast_frame_lost != 0 {
			/* Calculate residual in decoded signal if last frame was lost */
			Opus_silk_sum_sqr_shift(tls, bp+12, bp+8, frame, length)
			/* Normalize energies */
			if *(*int32)(unsafe.Pointer(bp + 8)) > (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift {
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy >> (*(*int32)(unsafe.Pointer(bp + 8)) - (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift)
			} else {
				if *(*int32)(unsafe.Pointer(bp + 8)) < (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift {
					*(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) >> ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift - *(*int32)(unsafe.Pointer(bp + 8)))
				}
			}
			/* Fade in the energy difference */
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) > (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy {
				v1 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy
				if v1 != 0 {
					v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
				} else {
					v4 = int32(32)
				}
				v2 = v4
				goto _3
			_3:
				LZ = v2
				LZ = LZ - int32(1)
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy) << LZ)
				v1 = int32(24) - LZ
				v2 = 0
				if v1 > v2 {
					v4 = v1
				} else {
					v4 = v2
				}
				v5 = v4
				goto _8
			_8:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) >> v5
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) > int32(1) {
					v4 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12))
				} else {
					v4 = int32(1)
				}
				frac_Q24 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy / v4
				v1 = frac_Q24
				if v1 <= libc.Int32FromInt32(0) {
					v2 = 0
					goto _13
				}
				v5 = v1
				v6 = v5
				if v6 != 0 {
					v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v6)))
				} else {
					v4 = int32(32)
				}
				v7 = v4
				goto _17
			_17:
				lzeros = v7
				*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
				v11 = v5
				v9 = int32(24) - lzeros
				x = libc.Uint32FromInt32(v11)
				r = libc.Uint32FromInt32(v9)
				m = libc.Uint32FromInt32(-v9)
				if v9 == libc.Int32FromInt32(0) {
					v12 = v11
					goto _22
				} else {
					if v9 < libc.Int32FromInt32(0) {
						v12 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
						goto _22
					} else {
						v12 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
						goto _22
					}
				}
			_22:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v12 & int32(0x7f)
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
					y = int32(32768)
				} else {
					y = int32(46214)
				}
				y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
				y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
				v2 = y
				goto _13
			_13:
				gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << libc.Int32FromInt32(4))
				slope_Q16 = (libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) - gain_Q16) / length
				/* Make slope 4x steeper to avoid missing onsets after DTX */
				slope_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(slope_Q16) << libc.Int32FromInt32(2))
				i = 0
				for {
					if !(i < length) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(int32(int64(gain_Q16) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2))) >> libc.Int32FromInt32(16)))
					gain_Q16 = gain_Q16 + slope_Q16
					if gain_Q16 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) {
						break
					}
					goto _23
				_23:
					;
					i = i + 1
				}
			}
		}
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Flast_frame_lost = 0
	}
}

const silk_int16_MAX8 = 0x7FFF

/* shell coder; pulse-subframe length is hardcoded */

func combine_pulses(tls *libc.TLS, out uintptr, in uintptr, len1 int32) {
	var k int32
	_ = k
	k = 0
	for {
		if !(k < len1) {
			break
		}
		*(*int32)(unsafe.Pointer(out + uintptr(k)*4)) = *(*int32)(unsafe.Pointer(in + uintptr(int32(2)*k)*4)) + *(*int32)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*4))
		goto _1
	_1:
		;
		k = k + 1
	}
}

func encode_split(tls *libc.TLS, psRangeEnc uintptr, p_child1 int32, p int32, shell_table uintptr) {
	if p > 0 {
		Opus_ec_enc_icdf(tls, psRangeEnc, p_child1, shell_table+uintptr(Opus_silk_shell_code_table_offsets[p]), uint32(8))
	}
}

func decode_split(tls *libc.TLS, p_child1 uintptr, p_child2 uintptr, psRangeDec uintptr, p int32, shell_table uintptr) {
	if p > 0 {
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child1)) = int16(Opus_ec_dec_icdf(tls, psRangeDec, shell_table+uintptr(Opus_silk_shell_code_table_offsets[p]), uint32(8)))
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child2)) = int16(p - int32(*(*OpusT_opus_int16)(unsafe.Pointer(p_child1))))
	} else {
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child1)) = 0
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child2)) = 0
	}
}

// C documentation
//
//	/* Shell encoder, operates on one shell code frame of 16 pulses */
func Opus_silk_shell_encoder(tls *libc.TLS, psRangeEnc uintptr, pulses0 uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* pulses1 at bp+0 */ [8]int32
	var _ /* pulses2 at bp+32 */ [4]int32
	var _ /* pulses3 at bp+48 */ [2]int32
	var _ /* pulses4 at bp+56 */ [1]int32
	/* this function operates on one shell code frame of 16 pulses */
	_ = true
	/* tree representation per pulse-subframe */
	combine_pulses(tls, bp, pulses0, int32(8))
	combine_pulses(tls, bp+32, bp, int32(4))
	combine_pulses(tls, bp+48, bp+32, int32(2))
	combine_pulses(tls, bp+56, bp+48, int32(1))
	encode_split(tls, psRangeEnc, (*(*[2]int32)(unsafe.Pointer(bp + 48)))[0], (*(*[1]int32)(unsafe.Pointer(bp + 56)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table3)))
	encode_split(tls, psRangeEnc, (*(*[4]int32)(unsafe.Pointer(bp + 32)))[0], (*(*[2]int32)(unsafe.Pointer(bp + 48)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[0], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0)), (*(*[8]int32)(unsafe.Pointer(bp)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 2*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 4*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 6*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(3)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(2)], (*(*[2]int32)(unsafe.Pointer(bp + 48)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(2)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 8*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 10*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(5)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(3)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 12*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 14*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(7)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
}

// C documentation
//
//	/* Shell decoder, operates on one shell code frame of 16 pulses */
func Opus_silk_shell_decoder(tls *libc.TLS, pulses0 uintptr, psRangeDec uintptr, pulses4 int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* pulses1 at bp+16 */ [8]OpusT_opus_int16
	var _ /* pulses2 at bp+8 */ [4]OpusT_opus_int16
	var _ /* pulses3 at bp+0 */ [2]OpusT_opus_int16
	/* this function operates on one shell code frame of 16 pulses */
	_ = true
	decode_split(tls, bp, bp+1*2, psRangeDec, pulses4, uintptr(unsafe.Pointer(&Opus_silk_shell_code_table3)))
	decode_split(tls, bp+8, bp+8+1*2, psRangeDec, int32((*(*[2]OpusT_opus_int16)(unsafe.Pointer(bp)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	decode_split(tls, bp+16, bp+16+1*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0, pulses0+1*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+2*2, pulses0+3*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+16+2*2, bp+16+3*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+4*2, pulses0+5*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(2)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+6*2, pulses0+7*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(3)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+8+2*2, bp+8+3*2, psRangeDec, int32((*(*[2]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	decode_split(tls, bp+16+4*2, bp+16+5*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(2)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+8*2, pulses0+9*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(4)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+10*2, pulses0+11*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(5)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+16+6*2, bp+16+7*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(3)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+12*2, pulses0+13*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(6)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+14*2, pulses0+15*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(7)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
}

var silk_LTP_gain_iCDF_0 = [8]OpusT_opus_uint8{
	0: uint8(71),
	1: uint8(56),
	2: uint8(43),
	3: uint8(30),
	4: uint8(21),
	5: uint8(12),
	6: uint8(6),
}

var silk_LTP_gain_iCDF_1 = [16]OpusT_opus_uint8{
	0:  uint8(199),
	1:  uint8(165),
	2:  uint8(144),
	3:  uint8(124),
	4:  uint8(109),
	5:  uint8(96),
	6:  uint8(84),
	7:  uint8(71),
	8:  uint8(61),
	9:  uint8(51),
	10: uint8(42),
	11: uint8(32),
	12: uint8(23),
	13: uint8(15),
	14: uint8(8),
}

var silk_LTP_gain_iCDF_2 = [32]OpusT_opus_uint8{
	0:  uint8(241),
	1:  uint8(225),
	2:  uint8(211),
	3:  uint8(199),
	4:  uint8(187),
	5:  uint8(175),
	6:  uint8(164),
	7:  uint8(153),
	8:  uint8(142),
	9:  uint8(132),
	10: uint8(123),
	11: uint8(114),
	12: uint8(105),
	13: uint8(96),
	14: uint8(88),
	15: uint8(80),
	16: uint8(72),
	17: uint8(64),
	18: uint8(57),
	19: uint8(50),
	20: uint8(44),
	21: uint8(38),
	22: uint8(33),
	23: uint8(29),
	24: uint8(24),
	25: uint8(20),
	26: uint8(16),
	27: uint8(12),
	28: uint8(9),
	29: uint8(5),
	30: uint8(2),
}

var silk_LTP_gain_BITS_Q5_0 = [8]OpusT_opus_uint8{
	0: uint8(15),
	1: uint8(131),
	2: uint8(138),
	3: uint8(138),
	4: uint8(155),
	5: uint8(155),
	6: uint8(173),
	7: uint8(173),
}

var silk_LTP_gain_BITS_Q5_1 = [16]OpusT_opus_uint8{
	0:  uint8(69),
	1:  uint8(93),
	2:  uint8(115),
	3:  uint8(118),
	4:  uint8(131),
	5:  uint8(138),
	6:  uint8(141),
	7:  uint8(138),
	8:  uint8(150),
	9:  uint8(150),
	10: uint8(155),
	11: uint8(150),
	12: uint8(155),
	13: uint8(160),
	14: uint8(166),
	15: uint8(160),
}

var silk_LTP_gain_BITS_Q5_2 = [32]OpusT_opus_uint8{
	0:  uint8(131),
	1:  uint8(128),
	2:  uint8(134),
	3:  uint8(141),
	4:  uint8(141),
	5:  uint8(141),
	6:  uint8(145),
	7:  uint8(145),
	8:  uint8(145),
	9:  uint8(150),
	10: uint8(155),
	11: uint8(155),
	12: uint8(155),
	13: uint8(155),
	14: uint8(160),
	15: uint8(160),
	16: uint8(160),
	17: uint8(160),
	18: uint8(166),
	19: uint8(166),
	20: uint8(173),
	21: uint8(173),
	22: uint8(182),
	23: uint8(192),
	24: uint8(182),
	25: uint8(192),
	26: uint8(192),
	27: uint8(192),
	28: uint8(205),
	29: uint8(192),
	30: uint8(205),
	31: uint8(224),
}

var silk_LTP_gain_vq_0 = [8][5]OpusT_opus_int8{
	0: {
		0: int8(4),
		1: int8(6),
		2: int8(24),
		3: int8(7),
		4: int8(5),
	},
	1: {
		2: int8(2),
	},
	2: {
		0: int8(12),
		1: int8(28),
		2: int8(41),
		3: int8(13),
		4: int8(-int32(4)),
	},
	3: {
		0: int8(-int32(9)),
		1: int8(15),
		2: int8(42),
		3: int8(25),
		4: int8(14),
	},
	4: {
		0: int8(1),
		1: int8(-int32(2)),
		2: int8(62),
		3: int8(41),
		4: int8(-int32(9)),
	},
	5: {
		0: int8(-int32(10)),
		1: int8(37),
		2: int8(65),
		3: int8(-int32(4)),
		4: int8(3),
	},
	6: {
		0: int8(-int32(6)),
		1: int8(4),
		2: int8(66),
		3: int8(7),
		4: int8(-int32(8)),
	},
	7: {
		0: int8(16),
		1: int8(14),
		2: int8(38),
		3: int8(-int32(3)),
		4: int8(33),
	},
}

var silk_LTP_gain_vq_1 = [16][5]OpusT_opus_int8{
	0: {
		0: int8(13),
		1: int8(22),
		2: int8(39),
		3: int8(23),
		4: int8(12),
	},
	1: {
		0: int8(-int32(1)),
		1: int8(36),
		2: int8(64),
		3: int8(27),
		4: int8(-int32(6)),
	},
	2: {
		0: int8(-int32(7)),
		1: int8(10),
		2: int8(55),
		3: int8(43),
		4: int8(17),
	},
	3: {
		0: int8(1),
		1: int8(1),
		2: int8(8),
		3: int8(1),
		4: int8(1),
	},
	4: {
		0: int8(6),
		1: int8(-int32(11)),
		2: int8(74),
		3: int8(53),
		4: int8(-int32(9)),
	},
	5: {
		0: int8(-int32(12)),
		1: int8(55),
		2: int8(76),
		3: int8(-int32(12)),
		4: int8(8),
	},
	6: {
		0: int8(-int32(3)),
		1: int8(3),
		2: int8(93),
		3: int8(27),
		4: int8(-int32(4)),
	},
	7: {
		0: int8(26),
		1: int8(39),
		2: int8(59),
		3: int8(3),
		4: int8(-int32(8)),
	},
	8: {
		0: int8(2),
		2: int8(77),
		3: int8(11),
		4: int8(9),
	},
	9: {
		0: int8(-int32(8)),
		1: int8(22),
		2: int8(44),
		3: int8(-int32(6)),
		4: int8(7),
	},
	10: {
		0: int8(40),
		1: int8(9),
		2: int8(26),
		3: int8(3),
		4: int8(9),
	},
	11: {
		0: int8(-int32(7)),
		1: int8(20),
		2: int8(101),
		3: int8(-int32(7)),
		4: int8(4),
	},
	12: {
		0: int8(3),
		1: int8(-int32(8)),
		2: int8(42),
		3: int8(26),
	},
	13: {
		0: int8(-int32(15)),
		1: int8(33),
		2: int8(68),
		3: int8(2),
		4: int8(23),
	},
	14: {
		0: int8(-int32(2)),
		1: int8(55),
		2: int8(46),
		3: int8(-int32(2)),
		4: int8(15),
	},
	15: {
		0: int8(3),
		1: int8(-int32(1)),
		2: int8(21),
		3: int8(16),
		4: int8(41),
	},
}

var silk_LTP_gain_vq_2 = [32][5]OpusT_opus_int8{
	0: {
		0: int8(-int32(6)),
		1: int8(27),
		2: int8(61),
		3: int8(39),
		4: int8(5),
	},
	1: {
		0: int8(-int32(11)),
		1: int8(42),
		2: int8(88),
		3: int8(4),
		4: int8(1),
	},
	2: {
		0: int8(-int32(2)),
		1: int8(60),
		2: int8(65),
		3: int8(6),
		4: int8(-int32(4)),
	},
	3: {
		0: int8(-int32(1)),
		1: int8(-int32(5)),
		2: int8(73),
		3: int8(56),
		4: int8(1),
	},
	4: {
		0: int8(-int32(9)),
		1: int8(19),
		2: int8(94),
		3: int8(29),
		4: int8(-int32(9)),
	},
	5: {
		1: int8(12),
		2: int8(99),
		3: int8(6),
		4: int8(4),
	},
	6: {
		0: int8(8),
		1: int8(-int32(19)),
		2: int8(102),
		3: int8(46),
		4: int8(-int32(13)),
	},
	7: {
		0: int8(3),
		1: int8(2),
		2: int8(13),
		3: int8(3),
		4: int8(2),
	},
	8: {
		0: int8(9),
		1: int8(-int32(21)),
		2: int8(84),
		3: int8(72),
		4: int8(-int32(18)),
	},
	9: {
		0: int8(-int32(11)),
		1: int8(46),
		2: int8(104),
		3: int8(-int32(22)),
		4: int8(8),
	},
	10: {
		0: int8(18),
		1: int8(38),
		2: int8(48),
		3: int8(23),
	},
	11: {
		0: int8(-int32(16)),
		1: int8(70),
		2: int8(83),
		3: int8(-int32(21)),
		4: int8(11),
	},
	12: {
		0: int8(5),
		1: int8(-int32(11)),
		2: int8(117),
		3: int8(22),
		4: int8(-int32(8)),
	},
	13: {
		0: int8(-int32(6)),
		1: int8(23),
		2: int8(117),
		3: int8(-int32(12)),
		4: int8(3),
	},
	14: {
		0: int8(3),
		1: int8(-int32(8)),
		2: int8(95),
		3: int8(28),
		4: int8(4),
	},
	15: {
		0: int8(-int32(10)),
		1: int8(15),
		2: int8(77),
		3: int8(60),
		4: int8(-int32(15)),
	},
	16: {
		0: int8(-int32(1)),
		1: int8(4),
		2: int8(124),
		3: int8(2),
		4: int8(-int32(4)),
	},
	17: {
		0: int8(3),
		1: int8(38),
		2: int8(84),
		3: int8(24),
		4: int8(-int32(25)),
	},
	18: {
		0: int8(2),
		1: int8(13),
		2: int8(42),
		3: int8(13),
		4: int8(31),
	},
	19: {
		0: int8(21),
		1: int8(-int32(4)),
		2: int8(56),
		3: int8(46),
		4: int8(-int32(1)),
	},
	20: {
		0: int8(-int32(1)),
		1: int8(35),
		2: int8(79),
		3: int8(-int32(13)),
		4: int8(19),
	},
	21: {
		0: int8(-int32(7)),
		1: int8(65),
		2: int8(88),
		3: int8(-int32(9)),
		4: int8(-int32(14)),
	},
	22: {
		0: int8(20),
		1: int8(4),
		2: int8(81),
		3: int8(49),
		4: int8(-int32(29)),
	},
	23: {
		0: int8(20),
		2: int8(75),
		3: int8(3),
		4: int8(-int32(17)),
	},
	24: {
		0: int8(5),
		1: int8(-int32(9)),
		2: int8(44),
		3: int8(92),
		4: int8(-int32(8)),
	},
	25: {
		0: int8(1),
		1: int8(-int32(3)),
		2: int8(22),
		3: int8(69),
		4: int8(31),
	},
	26: {
		0: int8(-int32(6)),
		1: int8(95),
		2: int8(41),
		3: int8(-int32(12)),
		4: int8(5),
	},
	27: {
		0: int8(39),
		1: int8(67),
		2: int8(16),
		3: int8(-int32(4)),
		4: int8(1),
	},
	28: {
		1: int8(-int32(6)),
		2: int8(120),
		3: int8(55),
		4: int8(-int32(36)),
	},
	29: {
		0: int8(-int32(13)),
		1: int8(44),
		2: int8(122),
		3: int8(4),
		4: int8(-int32(24)),
	},
	30: {
		0: int8(81),
		1: int8(5),
		2: int8(11),
		3: int8(3),
		4: int8(7),
	},
	31: {
		0: int8(2),
		2: int8(9),
		3: int8(10),
		4: int8(88),
	},
}

// C documentation
//
//	/* Maximum frequency-dependent response of the pitch taps above,
//	   computed as max(abs(freqz(taps))) */
var silk_LTP_gain_vq_0_gain = [8]OpusT_opus_uint8{
	0: uint8(46),
	1: uint8(2),
	2: uint8(90),
	3: uint8(87),
	4: uint8(93),
	5: uint8(91),
	6: uint8(82),
	7: uint8(98),
}

var silk_LTP_gain_vq_1_gain = [16]OpusT_opus_uint8{
	0:  uint8(109),
	1:  uint8(120),
	2:  uint8(118),
	3:  uint8(12),
	4:  uint8(113),
	5:  uint8(115),
	6:  uint8(117),
	7:  uint8(119),
	8:  uint8(99),
	9:  uint8(59),
	10: uint8(87),
	11: uint8(111),
	12: uint8(63),
	13: uint8(111),
	14: uint8(112),
	15: uint8(80),
}

var silk_LTP_gain_vq_2_gain = [32]OpusT_opus_uint8{
	0:  uint8(126),
	1:  uint8(124),
	2:  uint8(125),
	3:  uint8(124),
	4:  uint8(129),
	5:  uint8(121),
	6:  uint8(126),
	7:  uint8(23),
	8:  uint8(132),
	9:  uint8(127),
	10: uint8(127),
	11: uint8(127),
	12: uint8(126),
	13: uint8(127),
	14: uint8(122),
	15: uint8(133),
	16: uint8(130),
	17: uint8(134),
	18: uint8(101),
	19: uint8(118),
	20: uint8(119),
	21: uint8(145),
	22: uint8(126),
	23: uint8(86),
	24: uint8(124),
	25: uint8(120),
	26: uint8(123),
	27: uint8(119),
	28: uint8(170),
	29: uint8(173),
	30: uint8(107),
	31: uint8(109),
}

var silk_NLSF_CB1_NB_MB_Q8 = [320]OpusT_opus_uint8{
	0:   uint8(12),
	1:   uint8(35),
	2:   uint8(60),
	3:   uint8(83),
	4:   uint8(108),
	5:   uint8(132),
	6:   uint8(157),
	7:   uint8(180),
	8:   uint8(206),
	9:   uint8(228),
	10:  uint8(15),
	11:  uint8(32),
	12:  uint8(55),
	13:  uint8(77),
	14:  uint8(101),
	15:  uint8(125),
	16:  uint8(151),
	17:  uint8(175),
	18:  uint8(201),
	19:  uint8(225),
	20:  uint8(19),
	21:  uint8(42),
	22:  uint8(66),
	23:  uint8(89),
	24:  uint8(114),
	25:  uint8(137),
	26:  uint8(162),
	27:  uint8(184),
	28:  uint8(209),
	29:  uint8(230),
	30:  uint8(12),
	31:  uint8(25),
	32:  uint8(50),
	33:  uint8(72),
	34:  uint8(97),
	35:  uint8(120),
	36:  uint8(147),
	37:  uint8(172),
	38:  uint8(200),
	39:  uint8(223),
	40:  uint8(26),
	41:  uint8(44),
	42:  uint8(69),
	43:  uint8(90),
	44:  uint8(114),
	45:  uint8(135),
	46:  uint8(159),
	47:  uint8(180),
	48:  uint8(205),
	49:  uint8(225),
	50:  uint8(13),
	51:  uint8(22),
	52:  uint8(53),
	53:  uint8(80),
	54:  uint8(106),
	55:  uint8(130),
	56:  uint8(156),
	57:  uint8(180),
	58:  uint8(205),
	59:  uint8(228),
	60:  uint8(15),
	61:  uint8(25),
	62:  uint8(44),
	63:  uint8(64),
	64:  uint8(90),
	65:  uint8(115),
	66:  uint8(142),
	67:  uint8(168),
	68:  uint8(196),
	69:  uint8(222),
	70:  uint8(19),
	71:  uint8(24),
	72:  uint8(62),
	73:  uint8(82),
	74:  uint8(100),
	75:  uint8(120),
	76:  uint8(145),
	77:  uint8(168),
	78:  uint8(190),
	79:  uint8(214),
	80:  uint8(22),
	81:  uint8(31),
	82:  uint8(50),
	83:  uint8(79),
	84:  uint8(103),
	85:  uint8(120),
	86:  uint8(151),
	87:  uint8(170),
	88:  uint8(203),
	89:  uint8(227),
	90:  uint8(21),
	91:  uint8(29),
	92:  uint8(45),
	93:  uint8(65),
	94:  uint8(106),
	95:  uint8(124),
	96:  uint8(150),
	97:  uint8(171),
	98:  uint8(196),
	99:  uint8(224),
	100: uint8(30),
	101: uint8(49),
	102: uint8(75),
	103: uint8(97),
	104: uint8(121),
	105: uint8(142),
	106: uint8(165),
	107: uint8(186),
	108: uint8(209),
	109: uint8(229),
	110: uint8(19),
	111: uint8(25),
	112: uint8(52),
	113: uint8(70),
	114: uint8(93),
	115: uint8(116),
	116: uint8(143),
	117: uint8(166),
	118: uint8(192),
	119: uint8(219),
	120: uint8(26),
	121: uint8(34),
	122: uint8(62),
	123: uint8(75),
	124: uint8(97),
	125: uint8(118),
	126: uint8(145),
	127: uint8(167),
	128: uint8(194),
	129: uint8(217),
	130: uint8(25),
	131: uint8(33),
	132: uint8(56),
	133: uint8(70),
	134: uint8(91),
	135: uint8(113),
	136: uint8(143),
	137: uint8(165),
	138: uint8(196),
	139: uint8(223),
	140: uint8(21),
	141: uint8(34),
	142: uint8(51),
	143: uint8(72),
	144: uint8(97),
	145: uint8(117),
	146: uint8(145),
	147: uint8(171),
	148: uint8(196),
	149: uint8(222),
	150: uint8(20),
	151: uint8(29),
	152: uint8(50),
	153: uint8(67),
	154: uint8(90),
	155: uint8(117),
	156: uint8(144),
	157: uint8(168),
	158: uint8(197),
	159: uint8(221),
	160: uint8(22),
	161: uint8(31),
	162: uint8(48),
	163: uint8(66),
	164: uint8(95),
	165: uint8(117),
	166: uint8(146),
	167: uint8(168),
	168: uint8(196),
	169: uint8(222),
	170: uint8(24),
	171: uint8(33),
	172: uint8(51),
	173: uint8(77),
	174: uint8(116),
	175: uint8(134),
	176: uint8(158),
	177: uint8(180),
	178: uint8(200),
	179: uint8(224),
	180: uint8(21),
	181: uint8(28),
	182: uint8(70),
	183: uint8(87),
	184: uint8(106),
	185: uint8(124),
	186: uint8(149),
	187: uint8(170),
	188: uint8(194),
	189: uint8(217),
	190: uint8(26),
	191: uint8(33),
	192: uint8(53),
	193: uint8(64),
	194: uint8(83),
	195: uint8(117),
	196: uint8(152),
	197: uint8(173),
	198: uint8(204),
	199: uint8(225),
	200: uint8(27),
	201: uint8(34),
	202: uint8(65),
	203: uint8(95),
	204: uint8(108),
	205: uint8(129),
	206: uint8(155),
	207: uint8(174),
	208: uint8(210),
	209: uint8(225),
	210: uint8(20),
	211: uint8(26),
	212: uint8(72),
	213: uint8(99),
	214: uint8(113),
	215: uint8(131),
	216: uint8(154),
	217: uint8(176),
	218: uint8(200),
	219: uint8(219),
	220: uint8(34),
	221: uint8(43),
	222: uint8(61),
	223: uint8(78),
	224: uint8(93),
	225: uint8(114),
	226: uint8(155),
	227: uint8(177),
	228: uint8(205),
	229: uint8(229),
	230: uint8(23),
	231: uint8(29),
	232: uint8(54),
	233: uint8(97),
	234: uint8(124),
	235: uint8(138),
	236: uint8(163),
	237: uint8(179),
	238: uint8(209),
	239: uint8(229),
	240: uint8(30),
	241: uint8(38),
	242: uint8(56),
	243: uint8(89),
	244: uint8(118),
	245: uint8(129),
	246: uint8(158),
	247: uint8(178),
	248: uint8(200),
	249: uint8(231),
	250: uint8(21),
	251: uint8(29),
	252: uint8(49),
	253: uint8(63),
	254: uint8(85),
	255: uint8(111),
	256: uint8(142),
	257: uint8(163),
	258: uint8(193),
	259: uint8(222),
	260: uint8(27),
	261: uint8(48),
	262: uint8(77),
	263: uint8(103),
	264: uint8(133),
	265: uint8(158),
	266: uint8(179),
	267: uint8(196),
	268: uint8(215),
	269: uint8(232),
	270: uint8(29),
	271: uint8(47),
	272: uint8(74),
	273: uint8(99),
	274: uint8(124),
	275: uint8(151),
	276: uint8(176),
	277: uint8(198),
	278: uint8(220),
	279: uint8(237),
	280: uint8(33),
	281: uint8(42),
	282: uint8(61),
	283: uint8(76),
	284: uint8(93),
	285: uint8(121),
	286: uint8(155),
	287: uint8(174),
	288: uint8(207),
	289: uint8(225),
	290: uint8(29),
	291: uint8(53),
	292: uint8(87),
	293: uint8(112),
	294: uint8(136),
	295: uint8(154),
	296: uint8(170),
	297: uint8(188),
	298: uint8(208),
	299: uint8(227),
	300: uint8(24),
	301: uint8(30),
	302: uint8(52),
	303: uint8(84),
	304: uint8(131),
	305: uint8(150),
	306: uint8(166),
	307: uint8(186),
	308: uint8(203),
	309: uint8(229),
	310: uint8(37),
	311: uint8(48),
	312: uint8(64),
	313: uint8(84),
	314: uint8(104),
	315: uint8(118),
	316: uint8(156),
	317: uint8(177),
	318: uint8(201),
	319: uint8(230),
}

var silk_NLSF_CB1_Wght_Q9 = [320]OpusT_opus_int16{
	0:   int16(2897),
	1:   int16(2314),
	2:   int16(2314),
	3:   int16(2314),
	4:   int16(2287),
	5:   int16(2287),
	6:   int16(2314),
	7:   int16(2300),
	8:   int16(2327),
	9:   int16(2287),
	10:  int16(2888),
	11:  int16(2580),
	12:  int16(2394),
	13:  int16(2367),
	14:  int16(2314),
	15:  int16(2274),
	16:  int16(2274),
	17:  int16(2274),
	18:  int16(2274),
	19:  int16(2194),
	20:  int16(2487),
	21:  int16(2340),
	22:  int16(2340),
	23:  int16(2314),
	24:  int16(2314),
	25:  int16(2314),
	26:  int16(2340),
	27:  int16(2340),
	28:  int16(2367),
	29:  int16(2354),
	30:  int16(3216),
	31:  int16(2766),
	32:  int16(2340),
	33:  int16(2340),
	34:  int16(2314),
	35:  int16(2274),
	36:  int16(2221),
	37:  int16(2207),
	38:  int16(2261),
	39:  int16(2194),
	40:  int16(2460),
	41:  int16(2474),
	42:  int16(2367),
	43:  int16(2394),
	44:  int16(2394),
	45:  int16(2394),
	46:  int16(2394),
	47:  int16(2367),
	48:  int16(2407),
	49:  int16(2314),
	50:  int16(3479),
	51:  int16(3056),
	52:  int16(2127),
	53:  int16(2207),
	54:  int16(2274),
	55:  int16(2274),
	56:  int16(2274),
	57:  int16(2287),
	58:  int16(2314),
	59:  int16(2261),
	60:  int16(3282),
	61:  int16(3141),
	62:  int16(2580),
	63:  int16(2394),
	64:  int16(2247),
	65:  int16(2221),
	66:  int16(2207),
	67:  int16(2194),
	68:  int16(2194),
	69:  int16(2114),
	70:  int16(4096),
	71:  int16(3845),
	72:  int16(2221),
	73:  int16(2620),
	74:  int16(2620),
	75:  int16(2407),
	76:  int16(2314),
	77:  int16(2394),
	78:  int16(2367),
	79:  int16(2074),
	80:  int16(3178),
	81:  int16(3244),
	82:  int16(2367),
	83:  int16(2221),
	84:  int16(2553),
	85:  int16(2434),
	86:  int16(2340),
	87:  int16(2314),
	88:  int16(2167),
	89:  int16(2221),
	90:  int16(3338),
	91:  int16(3488),
	92:  int16(2726),
	93:  int16(2194),
	94:  int16(2261),
	95:  int16(2460),
	96:  int16(2354),
	97:  int16(2367),
	98:  int16(2207),
	99:  int16(2101),
	100: int16(2354),
	101: int16(2420),
	102: int16(2327),
	103: int16(2367),
	104: int16(2394),
	105: int16(2420),
	106: int16(2420),
	107: int16(2420),
	108: int16(2460),
	109: int16(2367),
	110: int16(3779),
	111: int16(3629),
	112: int16(2434),
	113: int16(2527),
	114: int16(2367),
	115: int16(2274),
	116: int16(2274),
	117: int16(2300),
	118: int16(2207),
	119: int16(2048),
	120: int16(3254),
	121: int16(3225),
	122: int16(2713),
	123: int16(2846),
	124: int16(2447),
	125: int16(2327),
	126: int16(2300),
	127: int16(2300),
	128: int16(2274),
	129: int16(2127),
	130: int16(3263),
	131: int16(3300),
	132: int16(2753),
	133: int16(2806),
	134: int16(2447),
	135: int16(2261),
	136: int16(2261),
	137: int16(2247),
	138: int16(2127),
	139: int16(2101),
	140: int16(2873),
	141: int16(2981),
	142: int16(2633),
	143: int16(2367),
	144: int16(2407),
	145: int16(2354),
	146: int16(2194),
	147: int16(2247),
	148: int16(2247),
	149: int16(2114),
	150: int16(3225),
	151: int16(3197),
	152: int16(2633),
	153: int16(2580),
	154: int16(2274),
	155: int16(2181),
	156: int16(2247),
	157: int16(2221),
	158: int16(2221),
	159: int16(2141),
	160: int16(3178),
	161: int16(3310),
	162: int16(2740),
	163: int16(2407),
	164: int16(2274),
	165: int16(2274),
	166: int16(2274),
	167: int16(2287),
	168: int16(2194),
	169: int16(2114),
	170: int16(3141),
	171: int16(3272),
	172: int16(2460),
	173: int16(2061),
	174: int16(2287),
	175: int16(2500),
	176: int16(2367),
	177: int16(2487),
	178: int16(2434),
	179: int16(2181),
	180: int16(3507),
	181: int16(3282),
	182: int16(2314),
	183: int16(2700),
	184: int16(2647),
	185: int16(2474),
	186: int16(2367),
	187: int16(2394),
	188: int16(2340),
	189: int16(2127),
	190: int16(3423),
	191: int16(3535),
	192: int16(3038),
	193: int16(3056),
	194: int16(2300),
	195: int16(1950),
	196: int16(2221),
	197: int16(2274),
	198: int16(2274),
	199: int16(2274),
	200: int16(3404),
	201: int16(3366),
	202: int16(2087),
	203: int16(2687),
	204: int16(2873),
	205: int16(2354),
	206: int16(2420),
	207: int16(2274),
	208: int16(2474),
	209: int16(2540),
	210: int16(3760),
	211: int16(3488),
	212: int16(1950),
	213: int16(2660),
	214: int16(2897),
	215: int16(2527),
	216: int16(2394),
	217: int16(2367),
	218: int16(2460),
	219: int16(2261),
	220: int16(3028),
	221: int16(3272),
	222: int16(2740),
	223: int16(2888),
	224: int16(2740),
	225: int16(2154),
	226: int16(2127),
	227: int16(2287),
	228: int16(2234),
	229: int16(2247),
	230: int16(3695),
	231: int16(3657),
	232: int16(2025),
	233: int16(1969),
	234: int16(2660),
	235: int16(2700),
	236: int16(2580),
	237: int16(2500),
	238: int16(2327),
	239: int16(2367),
	240: int16(3207),
	241: int16(3413),
	242: int16(2354),
	243: int16(2074),
	244: int16(2888),
	245: int16(2888),
	246: int16(2340),
	247: int16(2487),
	248: int16(2247),
	249: int16(2167),
	250: int16(3338),
	251: int16(3366),
	252: int16(2846),
	253: int16(2780),
	254: int16(2327),
	255: int16(2154),
	256: int16(2274),
	257: int16(2287),
	258: int16(2114),
	259: int16(2061),
	260: int16(2327),
	261: int16(2300),
	262: int16(2181),
	263: int16(2167),
	264: int16(2181),
	265: int16(2367),
	266: int16(2633),
	267: int16(2700),
	268: int16(2700),
	269: int16(2553),
	270: int16(2407),
	271: int16(2434),
	272: int16(2221),
	273: int16(2261),
	274: int16(2221),
	275: int16(2221),
	276: int16(2340),
	277: int16(2420),
	278: int16(2607),
	279: int16(2700),
	280: int16(3038),
	281: int16(3244),
	282: int16(2806),
	283: int16(2888),
	284: int16(2474),
	285: int16(2074),
	286: int16(2300),
	287: int16(2314),
	288: int16(2354),
	289: int16(2380),
	290: int16(2221),
	291: int16(2154),
	292: int16(2127),
	293: int16(2287),
	294: int16(2500),
	295: int16(2793),
	296: int16(2793),
	297: int16(2620),
	298: int16(2580),
	299: int16(2367),
	300: int16(3676),
	301: int16(3713),
	302: int16(2234),
	303: int16(1838),
	304: int16(2181),
	305: int16(2753),
	306: int16(2726),
	307: int16(2673),
	308: int16(2513),
	309: int16(2207),
	310: int16(2793),
	311: int16(3160),
	312: int16(2726),
	313: int16(2553),
	314: int16(2846),
	315: int16(2513),
	316: int16(2181),
	317: int16(2394),
	318: int16(2221),
	319: int16(2181),
}

var silk_NLSF_CB1_iCDF_NB_MB = [64]OpusT_opus_uint8{
	0:  uint8(212),
	1:  uint8(178),
	2:  uint8(148),
	3:  uint8(129),
	4:  uint8(108),
	5:  uint8(96),
	6:  uint8(85),
	7:  uint8(82),
	8:  uint8(79),
	9:  uint8(77),
	10: uint8(61),
	11: uint8(59),
	12: uint8(57),
	13: uint8(56),
	14: uint8(51),
	15: uint8(49),
	16: uint8(48),
	17: uint8(45),
	18: uint8(42),
	19: uint8(41),
	20: uint8(40),
	21: uint8(38),
	22: uint8(36),
	23: uint8(34),
	24: uint8(31),
	25: uint8(30),
	26: uint8(21),
	27: uint8(12),
	28: uint8(10),
	29: uint8(3),
	30: uint8(1),
	32: uint8(255),
	33: uint8(245),
	34: uint8(244),
	35: uint8(236),
	36: uint8(233),
	37: uint8(225),
	38: uint8(217),
	39: uint8(203),
	40: uint8(190),
	41: uint8(176),
	42: uint8(175),
	43: uint8(161),
	44: uint8(149),
	45: uint8(136),
	46: uint8(125),
	47: uint8(114),
	48: uint8(102),
	49: uint8(91),
	50: uint8(81),
	51: uint8(71),
	52: uint8(60),
	53: uint8(52),
	54: uint8(43),
	55: uint8(35),
	56: uint8(28),
	57: uint8(20),
	58: uint8(19),
	59: uint8(18),
	60: uint8(12),
	61: uint8(11),
	62: uint8(5),
}

var silk_NLSF_CB2_SELECT_NB_MB = [160]OpusT_opus_uint8{
	0:   uint8(16),
	5:   uint8(99),
	6:   uint8(66),
	7:   uint8(36),
	8:   uint8(36),
	9:   uint8(34),
	10:  uint8(36),
	11:  uint8(34),
	12:  uint8(34),
	13:  uint8(34),
	14:  uint8(34),
	15:  uint8(83),
	16:  uint8(69),
	17:  uint8(36),
	18:  uint8(52),
	19:  uint8(34),
	20:  uint8(116),
	21:  uint8(102),
	22:  uint8(70),
	23:  uint8(68),
	24:  uint8(68),
	25:  uint8(176),
	26:  uint8(102),
	27:  uint8(68),
	28:  uint8(68),
	29:  uint8(34),
	30:  uint8(65),
	31:  uint8(85),
	32:  uint8(68),
	33:  uint8(84),
	34:  uint8(36),
	35:  uint8(116),
	36:  uint8(141),
	37:  uint8(152),
	38:  uint8(139),
	39:  uint8(170),
	40:  uint8(132),
	41:  uint8(187),
	42:  uint8(184),
	43:  uint8(216),
	44:  uint8(137),
	45:  uint8(132),
	46:  uint8(249),
	47:  uint8(168),
	48:  uint8(185),
	49:  uint8(139),
	50:  uint8(104),
	51:  uint8(102),
	52:  uint8(100),
	53:  uint8(68),
	54:  uint8(68),
	55:  uint8(178),
	56:  uint8(218),
	57:  uint8(185),
	58:  uint8(185),
	59:  uint8(170),
	60:  uint8(244),
	61:  uint8(216),
	62:  uint8(187),
	63:  uint8(187),
	64:  uint8(170),
	65:  uint8(244),
	66:  uint8(187),
	67:  uint8(187),
	68:  uint8(219),
	69:  uint8(138),
	70:  uint8(103),
	71:  uint8(155),
	72:  uint8(184),
	73:  uint8(185),
	74:  uint8(137),
	75:  uint8(116),
	76:  uint8(183),
	77:  uint8(155),
	78:  uint8(152),
	79:  uint8(136),
	80:  uint8(132),
	81:  uint8(217),
	82:  uint8(184),
	83:  uint8(184),
	84:  uint8(170),
	85:  uint8(164),
	86:  uint8(217),
	87:  uint8(171),
	88:  uint8(155),
	89:  uint8(139),
	90:  uint8(244),
	91:  uint8(169),
	92:  uint8(184),
	93:  uint8(185),
	94:  uint8(170),
	95:  uint8(164),
	96:  uint8(216),
	97:  uint8(223),
	98:  uint8(218),
	99:  uint8(138),
	100: uint8(214),
	101: uint8(143),
	102: uint8(188),
	103: uint8(218),
	104: uint8(168),
	105: uint8(244),
	106: uint8(141),
	107: uint8(136),
	108: uint8(155),
	109: uint8(170),
	110: uint8(168),
	111: uint8(138),
	112: uint8(220),
	113: uint8(219),
	114: uint8(139),
	115: uint8(164),
	116: uint8(219),
	117: uint8(202),
	118: uint8(216),
	119: uint8(137),
	120: uint8(168),
	121: uint8(186),
	122: uint8(246),
	123: uint8(185),
	124: uint8(139),
	125: uint8(116),
	126: uint8(185),
	127: uint8(219),
	128: uint8(185),
	129: uint8(138),
	130: uint8(100),
	131: uint8(100),
	132: uint8(134),
	133: uint8(100),
	134: uint8(102),
	135: uint8(34),
	136: uint8(68),
	137: uint8(68),
	138: uint8(100),
	139: uint8(68),
	140: uint8(168),
	141: uint8(203),
	142: uint8(221),
	143: uint8(218),
	144: uint8(168),
	145: uint8(167),
	146: uint8(154),
	147: uint8(136),
	148: uint8(104),
	149: uint8(70),
	150: uint8(164),
	151: uint8(246),
	152: uint8(171),
	153: uint8(137),
	154: uint8(139),
	155: uint8(137),
	156: uint8(155),
	157: uint8(218),
	158: uint8(219),
	159: uint8(139),
}

var silk_NLSF_CB2_iCDF_NB_MB = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(254),
	2:  uint8(253),
	3:  uint8(238),
	4:  uint8(14),
	5:  uint8(3),
	6:  uint8(2),
	7:  uint8(1),
	9:  uint8(255),
	10: uint8(254),
	11: uint8(252),
	12: uint8(218),
	13: uint8(35),
	14: uint8(3),
	15: uint8(2),
	16: uint8(1),
	18: uint8(255),
	19: uint8(254),
	20: uint8(250),
	21: uint8(208),
	22: uint8(59),
	23: uint8(4),
	24: uint8(2),
	25: uint8(1),
	27: uint8(255),
	28: uint8(254),
	29: uint8(246),
	30: uint8(194),
	31: uint8(71),
	32: uint8(10),
	33: uint8(2),
	34: uint8(1),
	36: uint8(255),
	37: uint8(252),
	38: uint8(236),
	39: uint8(183),
	40: uint8(82),
	41: uint8(8),
	42: uint8(2),
	43: uint8(1),
	45: uint8(255),
	46: uint8(252),
	47: uint8(235),
	48: uint8(180),
	49: uint8(90),
	50: uint8(17),
	51: uint8(2),
	52: uint8(1),
	54: uint8(255),
	55: uint8(248),
	56: uint8(224),
	57: uint8(171),
	58: uint8(97),
	59: uint8(30),
	60: uint8(4),
	61: uint8(1),
	63: uint8(255),
	64: uint8(254),
	65: uint8(236),
	66: uint8(173),
	67: uint8(95),
	68: uint8(37),
	69: uint8(7),
	70: uint8(1),
}

var silk_NLSF_CB2_BITS_NB_MB_Q5 = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(255),
	2:  uint8(255),
	3:  uint8(131),
	4:  uint8(6),
	5:  uint8(145),
	6:  uint8(255),
	7:  uint8(255),
	8:  uint8(255),
	9:  uint8(255),
	10: uint8(255),
	11: uint8(236),
	12: uint8(93),
	13: uint8(15),
	14: uint8(96),
	15: uint8(255),
	16: uint8(255),
	17: uint8(255),
	18: uint8(255),
	19: uint8(255),
	20: uint8(194),
	21: uint8(83),
	22: uint8(25),
	23: uint8(71),
	24: uint8(221),
	25: uint8(255),
	26: uint8(255),
	27: uint8(255),
	28: uint8(255),
	29: uint8(162),
	30: uint8(73),
	31: uint8(34),
	32: uint8(66),
	33: uint8(162),
	34: uint8(255),
	35: uint8(255),
	36: uint8(255),
	37: uint8(210),
	38: uint8(126),
	39: uint8(73),
	40: uint8(43),
	41: uint8(57),
	42: uint8(173),
	43: uint8(255),
	44: uint8(255),
	45: uint8(255),
	46: uint8(201),
	47: uint8(125),
	48: uint8(71),
	49: uint8(48),
	50: uint8(58),
	51: uint8(130),
	52: uint8(255),
	53: uint8(255),
	54: uint8(255),
	55: uint8(166),
	56: uint8(110),
	57: uint8(73),
	58: uint8(57),
	59: uint8(62),
	60: uint8(104),
	61: uint8(210),
	62: uint8(255),
	63: uint8(255),
	64: uint8(251),
	65: uint8(123),
	66: uint8(65),
	67: uint8(55),
	68: uint8(68),
	69: uint8(100),
	70: uint8(171),
	71: uint8(255),
}

var silk_NLSF_PRED_NB_MB_Q8 = [18]OpusT_opus_uint8{
	0:  uint8(179),
	1:  uint8(138),
	2:  uint8(140),
	3:  uint8(148),
	4:  uint8(151),
	5:  uint8(149),
	6:  uint8(153),
	7:  uint8(151),
	8:  uint8(163),
	9:  uint8(116),
	10: uint8(67),
	11: uint8(82),
	12: uint8(59),
	13: uint8(92),
	14: uint8(72),
	15: uint8(100),
	16: uint8(89),
	17: uint8(92),
}

var silk_NLSF_DELTA_MIN_NB_MB_Q15 = [11]OpusT_opus_int16{
	0:  int16(250),
	1:  int16(3),
	2:  int16(6),
	3:  int16(3),
	4:  int16(3),
	5:  int16(3),
	6:  int16(4),
	7:  int16(3),
	8:  int16(3),
	9:  int16(3),
	10: int16(461),
}

var silk_NLSF_CB1_WB_Q8 = [512]OpusT_opus_uint8{
	0:   uint8(7),
	1:   uint8(23),
	2:   uint8(38),
	3:   uint8(54),
	4:   uint8(69),
	5:   uint8(85),
	6:   uint8(100),
	7:   uint8(116),
	8:   uint8(131),
	9:   uint8(147),
	10:  uint8(162),
	11:  uint8(178),
	12:  uint8(193),
	13:  uint8(208),
	14:  uint8(223),
	15:  uint8(239),
	16:  uint8(13),
	17:  uint8(25),
	18:  uint8(41),
	19:  uint8(55),
	20:  uint8(69),
	21:  uint8(83),
	22:  uint8(98),
	23:  uint8(112),
	24:  uint8(127),
	25:  uint8(142),
	26:  uint8(157),
	27:  uint8(171),
	28:  uint8(187),
	29:  uint8(203),
	30:  uint8(220),
	31:  uint8(236),
	32:  uint8(15),
	33:  uint8(21),
	34:  uint8(34),
	35:  uint8(51),
	36:  uint8(61),
	37:  uint8(78),
	38:  uint8(92),
	39:  uint8(106),
	40:  uint8(126),
	41:  uint8(136),
	42:  uint8(152),
	43:  uint8(167),
	44:  uint8(185),
	45:  uint8(205),
	46:  uint8(225),
	47:  uint8(240),
	48:  uint8(10),
	49:  uint8(21),
	50:  uint8(36),
	51:  uint8(50),
	52:  uint8(63),
	53:  uint8(79),
	54:  uint8(95),
	55:  uint8(110),
	56:  uint8(126),
	57:  uint8(141),
	58:  uint8(157),
	59:  uint8(173),
	60:  uint8(189),
	61:  uint8(205),
	62:  uint8(221),
	63:  uint8(237),
	64:  uint8(17),
	65:  uint8(20),
	66:  uint8(37),
	67:  uint8(51),
	68:  uint8(59),
	69:  uint8(78),
	70:  uint8(89),
	71:  uint8(107),
	72:  uint8(123),
	73:  uint8(134),
	74:  uint8(150),
	75:  uint8(164),
	76:  uint8(184),
	77:  uint8(205),
	78:  uint8(224),
	79:  uint8(240),
	80:  uint8(10),
	81:  uint8(15),
	82:  uint8(32),
	83:  uint8(51),
	84:  uint8(67),
	85:  uint8(81),
	86:  uint8(96),
	87:  uint8(112),
	88:  uint8(129),
	89:  uint8(142),
	90:  uint8(158),
	91:  uint8(173),
	92:  uint8(189),
	93:  uint8(204),
	94:  uint8(220),
	95:  uint8(236),
	96:  uint8(8),
	97:  uint8(21),
	98:  uint8(37),
	99:  uint8(51),
	100: uint8(65),
	101: uint8(79),
	102: uint8(98),
	103: uint8(113),
	104: uint8(126),
	105: uint8(138),
	106: uint8(155),
	107: uint8(168),
	108: uint8(179),
	109: uint8(192),
	110: uint8(209),
	111: uint8(218),
	112: uint8(12),
	113: uint8(15),
	114: uint8(34),
	115: uint8(55),
	116: uint8(63),
	117: uint8(78),
	118: uint8(87),
	119: uint8(108),
	120: uint8(118),
	121: uint8(131),
	122: uint8(148),
	123: uint8(167),
	124: uint8(185),
	125: uint8(203),
	126: uint8(219),
	127: uint8(236),
	128: uint8(16),
	129: uint8(19),
	130: uint8(32),
	131: uint8(36),
	132: uint8(56),
	133: uint8(79),
	134: uint8(91),
	135: uint8(108),
	136: uint8(118),
	137: uint8(136),
	138: uint8(154),
	139: uint8(171),
	140: uint8(186),
	141: uint8(204),
	142: uint8(220),
	143: uint8(237),
	144: uint8(11),
	145: uint8(28),
	146: uint8(43),
	147: uint8(58),
	148: uint8(74),
	149: uint8(89),
	150: uint8(105),
	151: uint8(120),
	152: uint8(135),
	153: uint8(150),
	154: uint8(165),
	155: uint8(180),
	156: uint8(196),
	157: uint8(211),
	158: uint8(226),
	159: uint8(241),
	160: uint8(6),
	161: uint8(16),
	162: uint8(33),
	163: uint8(46),
	164: uint8(60),
	165: uint8(75),
	166: uint8(92),
	167: uint8(107),
	168: uint8(123),
	169: uint8(137),
	170: uint8(156),
	171: uint8(169),
	172: uint8(185),
	173: uint8(199),
	174: uint8(214),
	175: uint8(225),
	176: uint8(11),
	177: uint8(19),
	178: uint8(30),
	179: uint8(44),
	180: uint8(57),
	181: uint8(74),
	182: uint8(89),
	183: uint8(105),
	184: uint8(121),
	185: uint8(135),
	186: uint8(152),
	187: uint8(169),
	188: uint8(186),
	189: uint8(202),
	190: uint8(218),
	191: uint8(234),
	192: uint8(12),
	193: uint8(19),
	194: uint8(29),
	195: uint8(46),
	196: uint8(57),
	197: uint8(71),
	198: uint8(88),
	199: uint8(100),
	200: uint8(120),
	201: uint8(132),
	202: uint8(148),
	203: uint8(165),
	204: uint8(182),
	205: uint8(199),
	206: uint8(216),
	207: uint8(233),
	208: uint8(17),
	209: uint8(23),
	210: uint8(35),
	211: uint8(46),
	212: uint8(56),
	213: uint8(77),
	214: uint8(92),
	215: uint8(106),
	216: uint8(123),
	217: uint8(134),
	218: uint8(152),
	219: uint8(167),
	220: uint8(185),
	221: uint8(204),
	222: uint8(222),
	223: uint8(237),
	224: uint8(14),
	225: uint8(17),
	226: uint8(45),
	227: uint8(53),
	228: uint8(63),
	229: uint8(75),
	230: uint8(89),
	231: uint8(107),
	232: uint8(115),
	233: uint8(132),
	234: uint8(151),
	235: uint8(171),
	236: uint8(188),
	237: uint8(206),
	238: uint8(221),
	239: uint8(240),
	240: uint8(9),
	241: uint8(16),
	242: uint8(29),
	243: uint8(40),
	244: uint8(56),
	245: uint8(71),
	246: uint8(88),
	247: uint8(103),
	248: uint8(119),
	249: uint8(137),
	250: uint8(154),
	251: uint8(171),
	252: uint8(189),
	253: uint8(205),
	254: uint8(222),
	255: uint8(237),
	256: uint8(16),
	257: uint8(19),
	258: uint8(36),
	259: uint8(48),
	260: uint8(57),
	261: uint8(76),
	262: uint8(87),
	263: uint8(105),
	264: uint8(118),
	265: uint8(132),
	266: uint8(150),
	267: uint8(167),
	268: uint8(185),
	269: uint8(202),
	270: uint8(218),
	271: uint8(236),
	272: uint8(12),
	273: uint8(17),
	274: uint8(29),
	275: uint8(54),
	276: uint8(71),
	277: uint8(81),
	278: uint8(94),
	279: uint8(104),
	280: uint8(126),
	281: uint8(136),
	282: uint8(149),
	283: uint8(164),
	284: uint8(182),
	285: uint8(201),
	286: uint8(221),
	287: uint8(237),
	288: uint8(15),
	289: uint8(28),
	290: uint8(47),
	291: uint8(62),
	292: uint8(79),
	293: uint8(97),
	294: uint8(115),
	295: uint8(129),
	296: uint8(142),
	297: uint8(155),
	298: uint8(168),
	299: uint8(180),
	300: uint8(194),
	301: uint8(208),
	302: uint8(223),
	303: uint8(238),
	304: uint8(8),
	305: uint8(14),
	306: uint8(30),
	307: uint8(45),
	308: uint8(62),
	309: uint8(78),
	310: uint8(94),
	311: uint8(111),
	312: uint8(127),
	313: uint8(143),
	314: uint8(159),
	315: uint8(175),
	316: uint8(192),
	317: uint8(207),
	318: uint8(223),
	319: uint8(239),
	320: uint8(17),
	321: uint8(30),
	322: uint8(49),
	323: uint8(62),
	324: uint8(79),
	325: uint8(92),
	326: uint8(107),
	327: uint8(119),
	328: uint8(132),
	329: uint8(145),
	330: uint8(160),
	331: uint8(174),
	332: uint8(190),
	333: uint8(204),
	334: uint8(220),
	335: uint8(235),
	336: uint8(14),
	337: uint8(19),
	338: uint8(36),
	339: uint8(45),
	340: uint8(61),
	341: uint8(76),
	342: uint8(91),
	343: uint8(108),
	344: uint8(121),
	345: uint8(138),
	346: uint8(154),
	347: uint8(172),
	348: uint8(189),
	349: uint8(205),
	350: uint8(222),
	351: uint8(238),
	352: uint8(12),
	353: uint8(18),
	354: uint8(31),
	355: uint8(45),
	356: uint8(60),
	357: uint8(76),
	358: uint8(91),
	359: uint8(107),
	360: uint8(123),
	361: uint8(138),
	362: uint8(154),
	363: uint8(171),
	364: uint8(187),
	365: uint8(204),
	366: uint8(221),
	367: uint8(236),
	368: uint8(13),
	369: uint8(17),
	370: uint8(31),
	371: uint8(43),
	372: uint8(53),
	373: uint8(70),
	374: uint8(83),
	375: uint8(103),
	376: uint8(114),
	377: uint8(131),
	378: uint8(149),
	379: uint8(167),
	380: uint8(185),
	381: uint8(203),
	382: uint8(220),
	383: uint8(237),
	384: uint8(17),
	385: uint8(22),
	386: uint8(35),
	387: uint8(42),
	388: uint8(58),
	389: uint8(78),
	390: uint8(93),
	391: uint8(110),
	392: uint8(125),
	393: uint8(139),
	394: uint8(155),
	395: uint8(170),
	396: uint8(188),
	397: uint8(206),
	398: uint8(224),
	399: uint8(240),
	400: uint8(8),
	401: uint8(15),
	402: uint8(34),
	403: uint8(50),
	404: uint8(67),
	405: uint8(83),
	406: uint8(99),
	407: uint8(115),
	408: uint8(131),
	409: uint8(146),
	410: uint8(162),
	411: uint8(178),
	412: uint8(193),
	413: uint8(209),
	414: uint8(224),
	415: uint8(239),
	416: uint8(13),
	417: uint8(16),
	418: uint8(41),
	419: uint8(66),
	420: uint8(73),
	421: uint8(86),
	422: uint8(95),
	423: uint8(111),
	424: uint8(128),
	425: uint8(137),
	426: uint8(150),
	427: uint8(163),
	428: uint8(183),
	429: uint8(206),
	430: uint8(225),
	431: uint8(241),
	432: uint8(17),
	433: uint8(25),
	434: uint8(37),
	435: uint8(52),
	436: uint8(63),
	437: uint8(75),
	438: uint8(92),
	439: uint8(102),
	440: uint8(119),
	441: uint8(132),
	442: uint8(144),
	443: uint8(160),
	444: uint8(175),
	445: uint8(191),
	446: uint8(212),
	447: uint8(231),
	448: uint8(19),
	449: uint8(31),
	450: uint8(49),
	451: uint8(65),
	452: uint8(83),
	453: uint8(100),
	454: uint8(117),
	455: uint8(133),
	456: uint8(147),
	457: uint8(161),
	458: uint8(174),
	459: uint8(187),
	460: uint8(200),
	461: uint8(213),
	462: uint8(227),
	463: uint8(242),
	464: uint8(18),
	465: uint8(31),
	466: uint8(52),
	467: uint8(68),
	468: uint8(88),
	469: uint8(103),
	470: uint8(117),
	471: uint8(126),
	472: uint8(138),
	473: uint8(149),
	474: uint8(163),
	475: uint8(177),
	476: uint8(192),
	477: uint8(207),
	478: uint8(223),
	479: uint8(239),
	480: uint8(16),
	481: uint8(29),
	482: uint8(47),
	483: uint8(61),
	484: uint8(76),
	485: uint8(90),
	486: uint8(106),
	487: uint8(119),
	488: uint8(133),
	489: uint8(147),
	490: uint8(161),
	491: uint8(176),
	492: uint8(193),
	493: uint8(209),
	494: uint8(224),
	495: uint8(240),
	496: uint8(15),
	497: uint8(21),
	498: uint8(35),
	499: uint8(50),
	500: uint8(61),
	501: uint8(73),
	502: uint8(86),
	503: uint8(97),
	504: uint8(110),
	505: uint8(119),
	506: uint8(129),
	507: uint8(141),
	508: uint8(175),
	509: uint8(198),
	510: uint8(218),
	511: uint8(237),
}

var silk_NLSF_CB1_WB_Wght_Q9 = [512]OpusT_opus_int16{
	0:   int16(3657),
	1:   int16(2925),
	2:   int16(2925),
	3:   int16(2925),
	4:   int16(2925),
	5:   int16(2925),
	6:   int16(2925),
	7:   int16(2925),
	8:   int16(2925),
	9:   int16(2925),
	10:  int16(2925),
	11:  int16(2925),
	12:  int16(2963),
	13:  int16(2963),
	14:  int16(2925),
	15:  int16(2846),
	16:  int16(3216),
	17:  int16(3085),
	18:  int16(2972),
	19:  int16(3056),
	20:  int16(3056),
	21:  int16(3010),
	22:  int16(3010),
	23:  int16(3010),
	24:  int16(2963),
	25:  int16(2963),
	26:  int16(3010),
	27:  int16(2972),
	28:  int16(2888),
	29:  int16(2846),
	30:  int16(2846),
	31:  int16(2726),
	32:  int16(3920),
	33:  int16(4014),
	34:  int16(2981),
	35:  int16(3207),
	36:  int16(3207),
	37:  int16(2934),
	38:  int16(3056),
	39:  int16(2846),
	40:  int16(3122),
	41:  int16(3244),
	42:  int16(2925),
	43:  int16(2846),
	44:  int16(2620),
	45:  int16(2553),
	46:  int16(2780),
	47:  int16(2925),
	48:  int16(3516),
	49:  int16(3197),
	50:  int16(3010),
	51:  int16(3103),
	52:  int16(3019),
	53:  int16(2888),
	54:  int16(2925),
	55:  int16(2925),
	56:  int16(2925),
	57:  int16(2925),
	58:  int16(2888),
	59:  int16(2888),
	60:  int16(2888),
	61:  int16(2888),
	62:  int16(2888),
	63:  int16(2753),
	64:  int16(5054),
	65:  int16(5054),
	66:  int16(2934),
	67:  int16(3573),
	68:  int16(3385),
	69:  int16(3056),
	70:  int16(3085),
	71:  int16(2793),
	72:  int16(3160),
	73:  int16(3160),
	74:  int16(2972),
	75:  int16(2846),
	76:  int16(2513),
	77:  int16(2540),
	78:  int16(2753),
	79:  int16(2888),
	80:  int16(4428),
	81:  int16(4149),
	82:  int16(2700),
	83:  int16(2753),
	84:  int16(2972),
	85:  int16(3010),
	86:  int16(2925),
	87:  int16(2846),
	88:  int16(2981),
	89:  int16(3019),
	90:  int16(2925),
	91:  int16(2925),
	92:  int16(2925),
	93:  int16(2925),
	94:  int16(2888),
	95:  int16(2726),
	96:  int16(3620),
	97:  int16(3019),
	98:  int16(2972),
	99:  int16(3056),
	100: int16(3056),
	101: int16(2873),
	102: int16(2806),
	103: int16(3056),
	104: int16(3216),
	105: int16(3047),
	106: int16(2981),
	107: int16(3291),
	108: int16(3291),
	109: int16(2981),
	110: int16(3310),
	111: int16(2991),
	112: int16(5227),
	113: int16(5014),
	114: int16(2540),
	115: int16(3338),
	116: int16(3526),
	117: int16(3385),
	118: int16(3197),
	119: int16(3094),
	120: int16(3376),
	121: int16(2981),
	122: int16(2700),
	123: int16(2647),
	124: int16(2687),
	125: int16(2793),
	126: int16(2846),
	127: int16(2673),
	128: int16(5081),
	129: int16(5174),
	130: int16(4615),
	131: int16(4428),
	132: int16(2460),
	133: int16(2897),
	134: int16(3047),
	135: int16(3207),
	136: int16(3169),
	137: int16(2687),
	138: int16(2740),
	139: int16(2888),
	140: int16(2846),
	141: int16(2793),
	142: int16(2846),
	143: int16(2700),
	144: int16(3122),
	145: int16(2888),
	146: int16(2963),
	147: int16(2925),
	148: int16(2925),
	149: int16(2925),
	150: int16(2925),
	151: int16(2963),
	152: int16(2963),
	153: int16(2963),
	154: int16(2963),
	155: int16(2925),
	156: int16(2925),
	157: int16(2963),
	158: int16(2963),
	159: int16(2963),
	160: int16(4202),
	161: int16(3207),
	162: int16(2981),
	163: int16(3103),
	164: int16(3010),
	165: int16(2888),
	166: int16(2888),
	167: int16(2925),
	168: int16(2972),
	169: int16(2873),
	170: int16(2916),
	171: int16(3019),
	172: int16(2972),
	173: int16(3010),
	174: int16(3197),
	175: int16(2873),
	176: int16(3760),
	177: int16(3760),
	178: int16(3244),
	179: int16(3103),
	180: int16(2981),
	181: int16(2888),
	182: int16(2925),
	183: int16(2888),
	184: int16(2972),
	185: int16(2934),
	186: int16(2793),
	187: int16(2793),
	188: int16(2846),
	189: int16(2888),
	190: int16(2888),
	191: int16(2660),
	192: int16(3854),
	193: int16(4014),
	194: int16(3207),
	195: int16(3122),
	196: int16(3244),
	197: int16(2934),
	198: int16(3047),
	199: int16(2963),
	200: int16(2963),
	201: int16(3085),
	202: int16(2846),
	203: int16(2793),
	204: int16(2793),
	205: int16(2793),
	206: int16(2793),
	207: int16(2580),
	208: int16(3845),
	209: int16(4080),
	210: int16(3357),
	211: int16(3516),
	212: int16(3094),
	213: int16(2740),
	214: int16(3010),
	215: int16(2934),
	216: int16(3122),
	217: int16(3085),
	218: int16(2846),
	219: int16(2846),
	220: int16(2647),
	221: int16(2647),
	222: int16(2846),
	223: int16(2806),
	224: int16(5147),
	225: int16(4894),
	226: int16(3225),
	227: int16(3845),
	228: int16(3441),
	229: int16(3169),
	230: int16(2897),
	231: int16(3413),
	232: int16(3451),
	233: int16(2700),
	234: int16(2580),
	235: int16(2673),
	236: int16(2740),
	237: int16(2846),
	238: int16(2806),
	239: int16(2753),
	240: int16(4109),
	241: int16(3789),
	242: int16(3291),
	243: int16(3160),
	244: int16(2925),
	245: int16(2888),
	246: int16(2888),
	247: int16(2925),
	248: int16(2793),
	249: int16(2740),
	250: int16(2793),
	251: int16(2740),
	252: int16(2793),
	253: int16(2846),
	254: int16(2888),
	255: int16(2806),
	256: int16(5081),
	257: int16(5054),
	258: int16(3047),
	259: int16(3545),
	260: int16(3244),
	261: int16(3056),
	262: int16(3085),
	263: int16(2944),
	264: int16(3103),
	265: int16(2897),
	266: int16(2740),
	267: int16(2740),
	268: int16(2740),
	269: int16(2846),
	270: int16(2793),
	271: int16(2620),
	272: int16(4309),
	273: int16(4309),
	274: int16(2860),
	275: int16(2527),
	276: int16(3207),
	277: int16(3376),
	278: int16(3376),
	279: int16(3075),
	280: int16(3075),
	281: int16(3376),
	282: int16(3056),
	283: int16(2846),
	284: int16(2647),
	285: int16(2580),
	286: int16(2726),
	287: int16(2753),
	288: int16(3056),
	289: int16(2916),
	290: int16(2806),
	291: int16(2888),
	292: int16(2740),
	293: int16(2687),
	294: int16(2897),
	295: int16(3103),
	296: int16(3150),
	297: int16(3150),
	298: int16(3216),
	299: int16(3169),
	300: int16(3056),
	301: int16(3010),
	302: int16(2963),
	303: int16(2846),
	304: int16(4375),
	305: int16(3882),
	306: int16(2925),
	307: int16(2888),
	308: int16(2846),
	309: int16(2888),
	310: int16(2846),
	311: int16(2846),
	312: int16(2888),
	313: int16(2888),
	314: int16(2888),
	315: int16(2846),
	316: int16(2888),
	317: int16(2925),
	318: int16(2888),
	319: int16(2846),
	320: int16(2981),
	321: int16(2916),
	322: int16(2916),
	323: int16(2981),
	324: int16(2981),
	325: int16(3056),
	326: int16(3122),
	327: int16(3216),
	328: int16(3150),
	329: int16(3056),
	330: int16(3010),
	331: int16(2972),
	332: int16(2972),
	333: int16(2972),
	334: int16(2925),
	335: int16(2740),
	336: int16(4229),
	337: int16(4149),
	338: int16(3310),
	339: int16(3347),
	340: int16(2925),
	341: int16(2963),
	342: int16(2888),
	343: int16(2981),
	344: int16(2981),
	345: int16(2846),
	346: int16(2793),
	347: int16(2740),
	348: int16(2846),
	349: int16(2846),
	350: int16(2846),
	351: int16(2793),
	352: int16(4080),
	353: int16(4014),
	354: int16(3103),
	355: int16(3010),
	356: int16(2925),
	357: int16(2925),
	358: int16(2925),
	359: int16(2888),
	360: int16(2925),
	361: int16(2925),
	362: int16(2846),
	363: int16(2846),
	364: int16(2846),
	365: int16(2793),
	366: int16(2888),
	367: int16(2780),
	368: int16(4615),
	369: int16(4575),
	370: int16(3169),
	371: int16(3441),
	372: int16(3207),
	373: int16(2981),
	374: int16(2897),
	375: int16(3038),
	376: int16(3122),
	377: int16(2740),
	378: int16(2687),
	379: int16(2687),
	380: int16(2687),
	381: int16(2740),
	382: int16(2793),
	383: int16(2700),
	384: int16(4149),
	385: int16(4269),
	386: int16(3789),
	387: int16(3657),
	388: int16(2726),
	389: int16(2780),
	390: int16(2888),
	391: int16(2888),
	392: int16(3010),
	393: int16(2972),
	394: int16(2925),
	395: int16(2846),
	396: int16(2687),
	397: int16(2687),
	398: int16(2793),
	399: int16(2888),
	400: int16(4215),
	401: int16(3554),
	402: int16(2753),
	403: int16(2846),
	404: int16(2846),
	405: int16(2888),
	406: int16(2888),
	407: int16(2888),
	408: int16(2925),
	409: int16(2925),
	410: int16(2888),
	411: int16(2925),
	412: int16(2925),
	413: int16(2925),
	414: int16(2963),
	415: int16(2888),
	416: int16(5174),
	417: int16(4921),
	418: int16(2261),
	419: int16(3432),
	420: int16(3789),
	421: int16(3479),
	422: int16(3347),
	423: int16(2846),
	424: int16(3310),
	425: int16(3479),
	426: int16(3150),
	427: int16(2897),
	428: int16(2460),
	429: int16(2487),
	430: int16(2753),
	431: int16(2925),
	432: int16(3451),
	433: int16(3685),
	434: int16(3122),
	435: int16(3197),
	436: int16(3357),
	437: int16(3047),
	438: int16(3207),
	439: int16(3207),
	440: int16(2981),
	441: int16(3216),
	442: int16(3085),
	443: int16(2925),
	444: int16(2925),
	445: int16(2687),
	446: int16(2540),
	447: int16(2434),
	448: int16(2981),
	449: int16(3010),
	450: int16(2793),
	451: int16(2793),
	452: int16(2740),
	453: int16(2793),
	454: int16(2846),
	455: int16(2972),
	456: int16(3056),
	457: int16(3103),
	458: int16(3150),
	459: int16(3150),
	460: int16(3150),
	461: int16(3103),
	462: int16(3010),
	463: int16(3010),
	464: int16(2944),
	465: int16(2873),
	466: int16(2687),
	467: int16(2726),
	468: int16(2780),
	469: int16(3010),
	470: int16(3432),
	471: int16(3545),
	472: int16(3357),
	473: int16(3244),
	474: int16(3056),
	475: int16(3010),
	476: int16(2963),
	477: int16(2925),
	478: int16(2888),
	479: int16(2846),
	480: int16(3019),
	481: int16(2944),
	482: int16(2897),
	483: int16(3010),
	484: int16(3010),
	485: int16(2972),
	486: int16(3019),
	487: int16(3103),
	488: int16(3056),
	489: int16(3056),
	490: int16(3010),
	491: int16(2888),
	492: int16(2846),
	493: int16(2925),
	494: int16(2925),
	495: int16(2888),
	496: int16(3920),
	497: int16(3967),
	498: int16(3010),
	499: int16(3197),
	500: int16(3357),
	501: int16(3216),
	502: int16(3291),
	503: int16(3291),
	504: int16(3479),
	505: int16(3704),
	506: int16(3441),
	507: int16(2726),
	508: int16(2181),
	509: int16(2460),
	510: int16(2580),
	511: int16(2607),
}

var silk_NLSF_CB1_iCDF_WB = [64]OpusT_opus_uint8{
	0:  uint8(225),
	1:  uint8(204),
	2:  uint8(201),
	3:  uint8(184),
	4:  uint8(183),
	5:  uint8(175),
	6:  uint8(158),
	7:  uint8(154),
	8:  uint8(153),
	9:  uint8(135),
	10: uint8(119),
	11: uint8(115),
	12: uint8(113),
	13: uint8(110),
	14: uint8(109),
	15: uint8(99),
	16: uint8(98),
	17: uint8(95),
	18: uint8(79),
	19: uint8(68),
	20: uint8(52),
	21: uint8(50),
	22: uint8(48),
	23: uint8(45),
	24: uint8(43),
	25: uint8(32),
	26: uint8(31),
	27: uint8(27),
	28: uint8(18),
	29: uint8(10),
	30: uint8(3),
	32: uint8(255),
	33: uint8(251),
	34: uint8(235),
	35: uint8(230),
	36: uint8(212),
	37: uint8(201),
	38: uint8(196),
	39: uint8(182),
	40: uint8(167),
	41: uint8(166),
	42: uint8(163),
	43: uint8(151),
	44: uint8(138),
	45: uint8(124),
	46: uint8(110),
	47: uint8(104),
	48: uint8(90),
	49: uint8(78),
	50: uint8(76),
	51: uint8(70),
	52: uint8(69),
	53: uint8(57),
	54: uint8(45),
	55: uint8(34),
	56: uint8(24),
	57: uint8(21),
	58: uint8(11),
	59: uint8(6),
	60: uint8(5),
	61: uint8(4),
	62: uint8(3),
}

var silk_NLSF_CB2_SELECT_WB = [256]OpusT_opus_uint8{
	7:   uint8(1),
	8:   uint8(100),
	9:   uint8(102),
	10:  uint8(102),
	11:  uint8(68),
	12:  uint8(68),
	13:  uint8(36),
	14:  uint8(34),
	15:  uint8(96),
	16:  uint8(164),
	17:  uint8(107),
	18:  uint8(158),
	19:  uint8(185),
	20:  uint8(180),
	21:  uint8(185),
	22:  uint8(139),
	23:  uint8(102),
	24:  uint8(64),
	25:  uint8(66),
	26:  uint8(36),
	27:  uint8(34),
	28:  uint8(34),
	30:  uint8(1),
	31:  uint8(32),
	32:  uint8(208),
	33:  uint8(139),
	34:  uint8(141),
	35:  uint8(191),
	36:  uint8(152),
	37:  uint8(185),
	38:  uint8(155),
	39:  uint8(104),
	40:  uint8(96),
	41:  uint8(171),
	42:  uint8(104),
	43:  uint8(166),
	44:  uint8(102),
	45:  uint8(102),
	46:  uint8(102),
	47:  uint8(132),
	48:  uint8(1),
	53:  uint8(16),
	54:  uint8(16),
	56:  uint8(80),
	57:  uint8(109),
	58:  uint8(78),
	59:  uint8(107),
	60:  uint8(185),
	61:  uint8(139),
	62:  uint8(103),
	63:  uint8(101),
	64:  uint8(208),
	65:  uint8(212),
	66:  uint8(141),
	67:  uint8(139),
	68:  uint8(173),
	69:  uint8(153),
	70:  uint8(123),
	71:  uint8(103),
	72:  uint8(36),
	79:  uint8(1),
	80:  uint8(48),
	87:  uint8(32),
	88:  uint8(68),
	89:  uint8(135),
	90:  uint8(123),
	91:  uint8(119),
	92:  uint8(119),
	93:  uint8(103),
	94:  uint8(69),
	95:  uint8(98),
	96:  uint8(68),
	97:  uint8(103),
	98:  uint8(120),
	99:  uint8(118),
	100: uint8(118),
	101: uint8(102),
	102: uint8(71),
	103: uint8(98),
	104: uint8(134),
	105: uint8(136),
	106: uint8(157),
	107: uint8(184),
	108: uint8(182),
	109: uint8(153),
	110: uint8(139),
	111: uint8(134),
	112: uint8(208),
	113: uint8(168),
	114: uint8(248),
	115: uint8(75),
	116: uint8(189),
	117: uint8(143),
	118: uint8(121),
	119: uint8(107),
	120: uint8(32),
	121: uint8(49),
	122: uint8(34),
	123: uint8(34),
	124: uint8(34),
	126: uint8(17),
	127: uint8(2),
	128: uint8(210),
	129: uint8(235),
	130: uint8(139),
	131: uint8(123),
	132: uint8(185),
	133: uint8(137),
	134: uint8(105),
	135: uint8(134),
	136: uint8(98),
	137: uint8(135),
	138: uint8(104),
	139: uint8(182),
	140: uint8(100),
	141: uint8(183),
	142: uint8(171),
	143: uint8(134),
	144: uint8(100),
	145: uint8(70),
	146: uint8(68),
	147: uint8(70),
	148: uint8(66),
	149: uint8(66),
	150: uint8(34),
	151: uint8(131),
	152: uint8(64),
	153: uint8(166),
	154: uint8(102),
	155: uint8(68),
	156: uint8(36),
	157: uint8(2),
	158: uint8(1),
	160: uint8(134),
	161: uint8(166),
	162: uint8(102),
	163: uint8(68),
	164: uint8(34),
	165: uint8(34),
	166: uint8(66),
	167: uint8(132),
	168: uint8(212),
	169: uint8(246),
	170: uint8(158),
	171: uint8(139),
	172: uint8(107),
	173: uint8(107),
	174: uint8(87),
	175: uint8(102),
	176: uint8(100),
	177: uint8(219),
	178: uint8(125),
	179: uint8(122),
	180: uint8(137),
	181: uint8(118),
	182: uint8(103),
	183: uint8(132),
	184: uint8(114),
	185: uint8(135),
	186: uint8(137),
	187: uint8(105),
	188: uint8(171),
	189: uint8(106),
	190: uint8(50),
	191: uint8(34),
	192: uint8(164),
	193: uint8(214),
	194: uint8(141),
	195: uint8(143),
	196: uint8(185),
	197: uint8(151),
	198: uint8(121),
	199: uint8(103),
	200: uint8(192),
	201: uint8(34),
	207: uint8(1),
	208: uint8(208),
	209: uint8(109),
	210: uint8(74),
	211: uint8(187),
	212: uint8(134),
	213: uint8(249),
	214: uint8(159),
	215: uint8(137),
	216: uint8(102),
	217: uint8(110),
	218: uint8(154),
	219: uint8(118),
	220: uint8(87),
	221: uint8(101),
	222: uint8(119),
	223: uint8(101),
	225: uint8(2),
	227: uint8(36),
	228: uint8(36),
	229: uint8(66),
	230: uint8(68),
	231: uint8(35),
	232: uint8(96),
	233: uint8(164),
	234: uint8(102),
	235: uint8(100),
	236: uint8(36),
	238: uint8(2),
	239: uint8(33),
	240: uint8(167),
	241: uint8(138),
	242: uint8(174),
	243: uint8(102),
	244: uint8(100),
	245: uint8(84),
	246: uint8(2),
	247: uint8(2),
	248: uint8(100),
	249: uint8(107),
	250: uint8(120),
	251: uint8(119),
	252: uint8(36),
	253: uint8(197),
	254: uint8(24),
}

var silk_NLSF_CB2_iCDF_WB = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(254),
	2:  uint8(253),
	3:  uint8(244),
	4:  uint8(12),
	5:  uint8(3),
	6:  uint8(2),
	7:  uint8(1),
	9:  uint8(255),
	10: uint8(254),
	11: uint8(252),
	12: uint8(224),
	13: uint8(38),
	14: uint8(3),
	15: uint8(2),
	16: uint8(1),
	18: uint8(255),
	19: uint8(254),
	20: uint8(251),
	21: uint8(209),
	22: uint8(57),
	23: uint8(4),
	24: uint8(2),
	25: uint8(1),
	27: uint8(255),
	28: uint8(254),
	29: uint8(244),
	30: uint8(195),
	31: uint8(69),
	32: uint8(4),
	33: uint8(2),
	34: uint8(1),
	36: uint8(255),
	37: uint8(251),
	38: uint8(232),
	39: uint8(184),
	40: uint8(84),
	41: uint8(7),
	42: uint8(2),
	43: uint8(1),
	45: uint8(255),
	46: uint8(254),
	47: uint8(240),
	48: uint8(186),
	49: uint8(86),
	50: uint8(14),
	51: uint8(2),
	52: uint8(1),
	54: uint8(255),
	55: uint8(254),
	56: uint8(239),
	57: uint8(178),
	58: uint8(91),
	59: uint8(30),
	60: uint8(5),
	61: uint8(1),
	63: uint8(255),
	64: uint8(248),
	65: uint8(227),
	66: uint8(177),
	67: uint8(100),
	68: uint8(19),
	69: uint8(2),
	70: uint8(1),
}

var silk_NLSF_CB2_BITS_WB_Q5 = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(255),
	2:  uint8(255),
	3:  uint8(156),
	4:  uint8(4),
	5:  uint8(154),
	6:  uint8(255),
	7:  uint8(255),
	8:  uint8(255),
	9:  uint8(255),
	10: uint8(255),
	11: uint8(227),
	12: uint8(102),
	13: uint8(15),
	14: uint8(92),
	15: uint8(255),
	16: uint8(255),
	17: uint8(255),
	18: uint8(255),
	19: uint8(255),
	20: uint8(213),
	21: uint8(83),
	22: uint8(24),
	23: uint8(72),
	24: uint8(236),
	25: uint8(255),
	26: uint8(255),
	27: uint8(255),
	28: uint8(255),
	29: uint8(150),
	30: uint8(76),
	31: uint8(33),
	32: uint8(63),
	33: uint8(214),
	34: uint8(255),
	35: uint8(255),
	36: uint8(255),
	37: uint8(190),
	38: uint8(121),
	39: uint8(77),
	40: uint8(43),
	41: uint8(55),
	42: uint8(185),
	43: uint8(255),
	44: uint8(255),
	45: uint8(255),
	46: uint8(245),
	47: uint8(137),
	48: uint8(71),
	49: uint8(43),
	50: uint8(59),
	51: uint8(139),
	52: uint8(255),
	53: uint8(255),
	54: uint8(255),
	55: uint8(255),
	56: uint8(131),
	57: uint8(66),
	58: uint8(50),
	59: uint8(66),
	60: uint8(107),
	61: uint8(194),
	62: uint8(255),
	63: uint8(255),
	64: uint8(166),
	65: uint8(116),
	66: uint8(76),
	67: uint8(55),
	68: uint8(53),
	69: uint8(125),
	70: uint8(255),
	71: uint8(255),
}

var silk_NLSF_PRED_WB_Q8 = [30]OpusT_opus_uint8{
	0:  uint8(175),
	1:  uint8(148),
	2:  uint8(160),
	3:  uint8(176),
	4:  uint8(178),
	5:  uint8(173),
	6:  uint8(174),
	7:  uint8(164),
	8:  uint8(177),
	9:  uint8(174),
	10: uint8(196),
	11: uint8(182),
	12: uint8(198),
	13: uint8(192),
	14: uint8(182),
	15: uint8(68),
	16: uint8(62),
	17: uint8(66),
	18: uint8(60),
	19: uint8(72),
	20: uint8(117),
	21: uint8(85),
	22: uint8(90),
	23: uint8(118),
	24: uint8(136),
	25: uint8(151),
	26: uint8(142),
	27: uint8(160),
	28: uint8(142),
	29: uint8(155),
}

var silk_NLSF_DELTA_MIN_WB_Q15 = [17]OpusT_opus_int16{
	0:  int16(100),
	1:  int16(3),
	2:  int16(40),
	3:  int16(3),
	4:  int16(3),
	5:  int16(3),
	6:  int16(5),
	7:  int16(14),
	8:  int16(14),
	9:  int16(10),
	10: int16(11),
	11: int16(3),
	12: int16(8),
	13: int16(9),
	14: int16(7),
	15: int16(3),
	16: int16(347),
}

// C documentation
//
//	/* Tables for LBRR flags */
var silk_LBRR_flags_2_iCDF = [3]OpusT_opus_uint8{
	0: uint8(203),
	1: uint8(150),
}
var silk_LBRR_flags_3_iCDF = [7]OpusT_opus_uint8{
	0: uint8(215),
	1: uint8(195),
	2: uint8(166),
	3: uint8(125),
	4: uint8(110),
	5: uint8(82),
}

const silk_int16_MAX9 = 32767
const silk_uint8_MAX1 = 255

// C documentation
//
//	/**********************************/
//	/* Initialization of the Silk VAD */
//	/**********************************/
func Opus_silk_VAD_Init(tls *libc.TLS, psSilk_VAD uintptr) (r int32) {
	var b1, ret, v6 int32
	var v2, v3, v4 OpusT_opus_int32
	_, _, _, _, _, _ = b1, ret, v2, v3, v4, v6
	ret = 0
	/* reset state memory */
	libc.Xmemset(tls, psSilk_VAD, 0, libc.Uint64FromInt64(112))
	/* init noise levels */
	/* Initialize array with approx pink noise levels (psd proportional to inverse of frequency) */
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		v2 = libc.Int32FromInt32(VAD_NOISE_LEVELS_BIAS) / (b1 + libc.Int32FromInt32(1))
		v3 = int32(1)
		if v2 > v3 {
			v6 = v2
		} else {
			v6 = v3
		}
		v4 = v6
		goto _5
	_5:
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(b1)*4)) = v4
		goto _1
	_1:
		;
		b1 = b1 + 1
	}
	/* Initialize state */
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)) = libc.Int32FromInt32(100) * *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(b1)*4))
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(b1)*4)) = libc.Int32FromInt32(silk_int32_MAX) / *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))
		goto _7
	_7:
		;
		b1 = b1 + 1
	}
	(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter = int32(15)
	/* init smoothed energy-to-noise ratio*/
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)) = libc.Int32FromInt32(100) * libc.Int32FromInt32(256) /* 100 * 256 --> 20 dB SNR */
		goto _8
	_8:
		;
		b1 = b1 + 1
	}
	return ret
}

// C documentation
//
//	/* Weighting factors for tilt measure */
var tiltWeights = [4]OpusT_opus_int32{
	0: int32(30000),
	1: int32(6000),
	2: -int32(12000),
	3: -int32(12000),
}

// C documentation
//
//	/***************************************/
//	/* Get the speech activity level in Q8 */
//	/***************************************/
func Opus_silk_VAD_GetSA_Q8_c(tls *libc.TLS, psEncC uintptr, pIn uintptr) (r1 int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var HPstateTmp OpusT_opus_int16
	var NrgToNoiseRatio_Q8 [4]OpusT_opus_int32
	var SA_Q15, SNR_Q7, b1, dec_subframe_length, dec_subframe_offset, decimated_framelength, decimated_framelength1, decimated_framelength2, i, input_tilt, pSNR_dB_Q7, ret, s, v33, v34, v35, v37 int32
	var X, _saved_stack, psSilk_VAD, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var X_offset [4]int32
	var lzeros, smooth_coef_Q16, speech_nrg, sumSquared, x_tmp, y, v43, v44, v46, v47, v48, v51, v53 OpusT_opus_int32
	var m, r, x OpusT_opus_uint32
	var _ /* Xnrg at bp+8 */ [4]OpusT_opus_int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = HPstateTmp, NrgToNoiseRatio_Q8, SA_Q15, SNR_Q7, X, X_offset, _saved_stack, b1, dec_subframe_length, dec_subframe_offset, decimated_framelength, decimated_framelength1, decimated_framelength2, i, input_tilt, lzeros, m, pSNR_dB_Q7, psSilk_VAD, r, ret, s, smooth_coef_Q16, speech_nrg, st, sumSquared, x, x_tmp, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v33, v34, v35, v37, v43, v44, v46, v47, v48, v5, v51, v53, v7, v9
	ret = 0
	psSilk_VAD = psEncC + 36
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Safety checks */
	_ = true
	if !(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ) >= (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) {
		Opus_celt_fatal(tls, __ccgo_ts+6796, __ccgo_ts+6855, int32(104))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length <= libc.Int32FromInt32(512)) {
		Opus_celt_fatal(tls, __ccgo_ts+6869, __ccgo_ts+6855, int32(105))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == libc.Int32FromInt32(8)*((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length>>libc.Int32FromInt32(3))) {
		Opus_celt_fatal(tls, __ccgo_ts+6915, __ccgo_ts+6855, int32(106))
	}
	/***********************/
	/* Filter and Decimate */
	/***********************/
	decimated_framelength1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(1)
	decimated_framelength2 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(2)
	decimated_framelength = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(3)
	/* Decimate into 4 bands:
	   0       L      3L       L              3L                             5L
	           -      --       -              --                             --
	           8       8       2               4                              4
	   [0-1 kHz| temp. |1-2 kHz|    2-4 kHz    |            4-8 kHz           |
	   They're arranged to allow the minimal ( frame_length / 4 ) extra
	   scratch space during the downsampling process */
	X_offset[0] = 0
	X_offset[int32(1)] = decimated_framelength + decimated_framelength2
	X_offset[int32(2)] = X_offset[int32(1)] + decimated_framelength
	X_offset[int32(3)] = X_offset[int32(2)] + decimated_framelength2
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6855, int32(127))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	X = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* 0-8 kHz to 0-4 kHz and 4-8 kHz */
	Opus_silk_ana_filt_bank_1(tls, pIn, psSilk_VAD, X, X+uintptr(X_offset[int32(3)])*2, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)
	/* 0-4 kHz to 0-2 kHz and 2-4 kHz */
	Opus_silk_ana_filt_bank_1(tls, X, psSilk_VAD+8, X, X+uintptr(X_offset[int32(2)])*2, decimated_framelength1)
	/* 0-2 kHz to 0-1 kHz and 1-2 kHz */
	Opus_silk_ana_filt_bank_1(tls, X, psSilk_VAD+16, X, X+uintptr(X_offset[int32(1)])*2, decimated_framelength2)
	/*********************************************/
	/* HP filter on lowest band (differentiator) */
	/*********************************************/
	*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2))) >> libc.Int32FromInt32(1))
	HPstateTmp = *(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2))
	i = decimated_framelength - int32(1)
	for {
		if !(i > 0) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2))) >> libc.Int32FromInt32(1))
		v1 = X + uintptr(i)*2
		*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2))))
		goto _29
	_29:
		;
		i = i - 1
	}
	v1 = X
	*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) - int32((*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).FHPstate))
	(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).FHPstate = HPstateTmp
	/*************************************/
	/* Calculate the energy in each band */
	/*************************************/
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* Find the decimated framelength in the non-uniformly divided bands */
		v33 = int32(VAD_N_BANDS) - b1
		v34 = libc.Int32FromInt32(VAD_N_BANDS) - libc.Int32FromInt32(1)
		if v33 < v34 {
			v37 = v33
		} else {
			v37 = v34
		}
		v35 = v37
		goto _36
	_36:
		decimated_framelength = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> v35
		/* Split length into subframe lengths */
		dec_subframe_length = decimated_framelength >> int32(VAD_INTERNAL_SUBFRAMES_LOG2)
		dec_subframe_offset = 0
		/* Compute energy per sub-frame */
		/* initialize with summed energy of last subframe */
		(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 24 + uintptr(b1)*4))
		s = 0
		for {
			if !(s < libc.Int32FromInt32(1)<<libc.Int32FromInt32(VAD_INTERNAL_SUBFRAMES_LOG2)) {
				break
			}
			sumSquared = 0
			i = 0
			for {
				if !(i < dec_subframe_length) {
					break
				}
				/* The energy will be less than dec_subframe_length * ( silk_int16_MIN / 8 ) ^ 2.            */
				/* Therefore we can accumulate with no risk of overflow (unless dec_subframe_length > 128)  */
				x_tmp = int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(X_offset[b1]+i+dec_subframe_offset)*2))) >> libc.Int32FromInt32(3)
				sumSquared = sumSquared + int32(int16(x_tmp))*int32(int16(x_tmp))
				/* Safety check */
				_ = sumSquared >= libc.Int32FromInt32(0)
				goto _39
			_39:
				;
				i = i + 1
			}
			/* Add/saturate summed energy of current subframe */
			if s < libc.Int32FromInt32(1)<<libc.Int32FromInt32(VAD_INTERNAL_SUBFRAMES_LOG2)-libc.Int32FromInt32(1) {
				if (libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])+libc.Uint32FromInt32(sumSquared))&uint32(0x80000000) != 0 {
					v33 = int32(silk_int32_MAX)
				} else {
					v33 = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] + sumSquared
				}
				(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = v33
			} else {
				/* Look-ahead subframe */
				if (libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])+libc.Uint32FromInt32(sumSquared>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
					v33 = int32(silk_int32_MAX)
				} else {
					v33 = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] + sumSquared>>libc.Int32FromInt32(1)
				}
				(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = v33
			}
			dec_subframe_offset = dec_subframe_offset + dec_subframe_length
			goto _38
		_38:
			;
			s = s + 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 24 + uintptr(b1)*4)) = sumSquared
		goto _32
	_32:
		;
		b1 = b1 + 1
	}
	/********************/
	/* Noise estimation */
	/********************/
	silk_VAD_GetNoiseLevels(tls, bp+8, psSilk_VAD)
	/***********************************************/
	/* Signal-plus-noise to noise ratio estimation */
	/***********************************************/
	sumSquared = 0
	input_tilt = 0
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		speech_nrg = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] - *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))
		if speech_nrg > 0 {
			/* Divide, with sufficient resolution */
			if libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])&uint32(0xFF800000) == uint32(0) {
				NrgToNoiseRatio_Q8[b1] = libc.Int32FromUint32(libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])<<libc.Int32FromInt32(8)) / (*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)) + libc.Int32FromInt32(1))
			} else {
				NrgToNoiseRatio_Q8[b1] = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] / (*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))>>libc.Int32FromInt32(8) + libc.Int32FromInt32(1))
			}
			/* Convert to log domain */
			SNR_Q7 = Opus_silk_lin2log(tls, NrgToNoiseRatio_Q8[b1]) - libc.Int32FromInt32(8)*libc.Int32FromInt32(128)
			/* Sum-of-squares */
			sumSquared = sumSquared + int32(int16(SNR_Q7))*int32(int16(SNR_Q7)) /* Q14 */
			/* Tilt measure */
			if speech_nrg < libc.Int32FromInt32(1)<<libc.Int32FromInt32(20) {
				/* Scale down SNR value for small subband speech energies */
				v43 = speech_nrg
				if v43 <= libc.Int32FromInt32(0) {
					v44 = 0
					goto _45
				}
				v46 = v43
				v47 = v46
				if v47 != 0 {
					v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
				} else {
					v33 = int32(32)
				}
				v48 = v33
				goto _49
			_49:
				lzeros = v48
				*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
				v51 = v46
				v34 = int32(24) - lzeros
				x = libc.Uint32FromInt32(v51)
				r = libc.Uint32FromInt32(v34)
				m = libc.Uint32FromInt32(-v34)
				if v34 == libc.Int32FromInt32(0) {
					v53 = v51
					goto _54
				} else {
					if v34 < libc.Int32FromInt32(0) {
						v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
						goto _54
					} else {
						v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
						goto _54
					}
				}
			_54:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
					y = int32(32768)
				} else {
					y = int32(46214)
				}
				y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
				y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
				v44 = y
				goto _45
			_45:
				SNR_Q7 = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(v44)<<libc.Int32FromInt32(6))) * int64(int16(SNR_Q7)) >> libc.Int32FromInt32(16))
			}
			input_tilt = int32(int64(input_tilt) + int64(tiltWeights[b1])*int64(int16(SNR_Q7))>>libc.Int32FromInt32(16))
		} else {
			NrgToNoiseRatio_Q8[b1] = int32(256)
		}
		goto _42
	_42:
		;
		b1 = b1 + 1
	}
	/* Mean-of-squares */
	sumSquared = sumSquared / libc.Int32FromInt32(VAD_N_BANDS) /* Q14 */
	/* Root-mean-square approximation, scale to dBs, and write to output pointer */
	v43 = sumSquared
	if v43 <= libc.Int32FromInt32(0) {
		v44 = 0
		goto _57
	}
	v46 = v43
	v47 = v46
	if v47 != 0 {
		v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
	} else {
		v33 = int32(32)
	}
	v48 = v33
	goto _61
_61:
	lzeros = v48
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v51 = v46
	v34 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v51)
	r = libc.Uint32FromInt32(v34)
	m = libc.Uint32FromInt32(-v34)
	if v34 == libc.Int32FromInt32(0) {
		v53 = v51
		goto _66
	} else {
		if v34 < libc.Int32FromInt32(0) {
			v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _66
		} else {
			v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _66
		}
	}
_66:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
		y = int32(32768)
	} else {
		y = int32(46214)
	}
	y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
	y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
	v44 = y
	goto _57
_57:
	pSNR_dB_Q7 = int32(int16(libc.Int32FromInt32(3) * v44)) /* Q7 */
	/*********************************/
	/* Speech Probability Estimation */
	/*********************************/
	SA_Q15 = Opus_silk_sigm_Q15(tls, int32(int64(libc.Int32FromInt32(VAD_SNR_FACTOR_Q16))*int64(int16(pSNR_dB_Q7))>>libc.Int32FromInt32(16))-int32(VAD_NEGATIVE_OFFSET_Q5))
	/**************************/
	/* Frequency Tilt Measure */
	/**************************/
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Finput_tilt_Q15 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_sigm_Q15(tls, input_tilt)-libc.Int32FromInt32(16384)) << libc.Int32FromInt32(1))
	/**************************************************/
	/* Scale the sigmoid output based on power levels */
	/**************************************************/
	speech_nrg = 0
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* Accumulate signal-without-noise energies, higher frequency bands have more weight */
		speech_nrg = speech_nrg + (b1+int32(1))*(((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1]-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)))>>int32(4))
		goto _67
	_67:
		;
		b1 = b1 + 1
	}
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == int32(20)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz {
		speech_nrg = speech_nrg >> int32(1)
	}
	/* Power scaling */
	if speech_nrg <= 0 {
		SA_Q15 = SA_Q15 >> int32(1)
	} else {
		if speech_nrg < int32(16384) {
			speech_nrg = libc.Int32FromUint32(libc.Uint32FromInt32(speech_nrg) << libc.Int32FromInt32(16))
			/* square-root */
			v43 = speech_nrg
			if v43 <= libc.Int32FromInt32(0) {
				v44 = 0
				goto _70
			}
			v46 = v43
			v47 = v46
			if v47 != 0 {
				v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
			} else {
				v33 = int32(32)
			}
			v48 = v33
			goto _74
		_74:
			lzeros = v48
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v51 = v46
			v34 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v51)
			r = libc.Uint32FromInt32(v34)
			m = libc.Uint32FromInt32(-v34)
			if v34 == libc.Int32FromInt32(0) {
				v53 = v51
				goto _79
			} else {
				if v34 < libc.Int32FromInt32(0) {
					v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _79
				} else {
					v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _79
				}
			}
		_79:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v44 = y
			goto _70
		_70:
			speech_nrg = v44
			SA_Q15 = int32(int64(libc.Int32FromInt32(32768)+speech_nrg) * int64(int16(SA_Q15)) >> libc.Int32FromInt32(16))
		}
	}
	/* Copy the resulting speech activity in Q8 */
	v33 = SA_Q15 >> int32(7)
	v34 = int32(silk_uint8_MAX1)
	if v33 < v34 {
		v37 = v33
	} else {
		v37 = v34
	}
	v35 = v37
	goto _83
_83:
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fspeech_activity_Q8 = v35
	/***********************************/
	/* Energy Level and SNR estimation */
	/***********************************/
	/* Smoothing coefficient */
	smooth_coef_Q16 = int32(int64(libc.Int32FromInt32(VAD_SNR_SMOOTH_COEF_Q18)) * int64(int16(int32(int64(SA_Q15)*int64(int16(SA_Q15))>>libc.Int32FromInt32(16)))) >> libc.Int32FromInt32(16))
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == int32(10)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz {
		smooth_coef_Q16 = smooth_coef_Q16 >> int32(1)
	}
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* compute smoothed energy-to-noise ratio per band */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4))) + int64(NrgToNoiseRatio_Q8[b1]-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)))*int64(int16(smooth_coef_Q16))>>libc.Int32FromInt32(16))
		/* signal to noise ratio in dB per band */
		SNR_Q7 = int32(3) * (Opus_silk_lin2log(tls, *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4))) - libc.Int32FromInt32(8)*libc.Int32FromInt32(128))
		/* quality = sigmoid( 0.25 * ( SNR_dB - 16 ) ); */
		*(*int32)(unsafe.Pointer(psEncC + 4712 + uintptr(b1)*4)) = Opus_silk_sigm_Q15(tls, (SNR_Q7-libc.Int32FromInt32(16)*libc.Int32FromInt32(128))>>int32(4))
		goto _85
	_85:
		;
		b1 = b1 + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _87
	_87:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _89
_89:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/**************************/
//	/* Noise level estimation */
//	/**************************/
func silk_VAD_GetNoiseLevels(tls *libc.TLS, pX uintptr, psSilk_VAD uintptr) {
	var coef, k, min_coef, v2, v3, v4, v5 int32
	var inv_nrg, nl, nrg OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _ = coef, inv_nrg, k, min_coef, nl, nrg, v2, v3, v4, v5
	/* Initially faster smoothing */
	if (*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter < int32(1000) { /* 1000 = 20 sec */
		min_coef = libc.Int32FromInt32(silk_int16_MAX9) / ((*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter>>libc.Int32FromInt32(4) + libc.Int32FromInt32(1))
		/* Increment frame counter */
		(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter = (*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter + 1
	} else {
		min_coef = 0
	}
	k = 0
	for {
		if !(k < int32(VAD_N_BANDS)) {
			break
		}
		/* Get old noise level estimate for current band */
		nl = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(k)*4))
		_ = nl >= libc.Int32FromInt32(0)
		/* Add bias */
		if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pX + uintptr(k)*4)))+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(k)*4))))&uint32(0x80000000) != 0 {
			v2 = int32(silk_int32_MAX)
		} else {
			v2 = *(*OpusT_opus_int32)(unsafe.Pointer(pX + uintptr(k)*4)) + *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(k)*4))
		}
		nrg = v2
		_ = nrg > libc.Int32FromInt32(0)
		/* Invert energies */
		inv_nrg = libc.Int32FromInt32(silk_int32_MAX) / nrg
		_ = inv_nrg >= libc.Int32FromInt32(0)
		/* Less update when subband energy is high */
		if nrg > libc.Int32FromUint32(libc.Uint32FromInt32(nl)<<libc.Int32FromInt32(3)) {
			coef = libc.Int32FromInt32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16) >> libc.Int32FromInt32(3)
		} else {
			if nrg < nl {
				coef = int32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16)
			} else {
				coef = int32(int64(int32(int64(inv_nrg)*int64(nl)>>libc.Int32FromInt32(16))) * int64(int16(libc.Int32FromInt32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16)<<libc.Int32FromInt32(1))) >> libc.Int32FromInt32(16))
			}
		}
		/* Initially faster smoothing */
		v2 = coef
		v3 = min_coef
		if v2 > v3 {
			v5 = v2
		} else {
			v5 = v3
		}
		v4 = v5
		goto _6
	_6:
		coef = v4
		/* Smooth inverse energies */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4))) + int64(inv_nrg-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)))*int64(int16(coef))>>libc.Int32FromInt32(16))
		_ = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)) >= libc.Int32FromInt32(0)
		/* Compute noise level by inverting again */
		nl = libc.Int32FromInt32(silk_int32_MAX) / *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4))
		_ = nl >= libc.Int32FromInt32(0)
		/* Limit noise levels (guarantee 7 bits of head room) */
		if nl < int32(0x00FFFFFF) {
			v2 = nl
		} else {
			v2 = int32(0x00FFFFFF)
		}
		nl = v2
		/* Store as part of state */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(k)*4)) = nl
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX10 = 0x7FFF
const silk_uint8_MAX2 = 0xFF

// C documentation
//
//	/* Compute quantization errors for an LPC_order element input vector for a VQ codebook */
func Opus_silk_NLSF_VQ(tls *libc.TLS, err_Q24 uintptr, in_Q15 uintptr, pCB_Q8 uintptr, pWght_Q9 uintptr, K int32, LPC_order int32) {
	var cb_Q8_ptr, w_Q9_ptr uintptr
	var diff_Q15, diffw_Q24, pred_Q24, sum_error_Q24 OpusT_opus_int32
	var i, m, v3 int32
	_, _, _, _, _, _, _, _, _ = cb_Q8_ptr, diff_Q15, diffw_Q24, i, m, pred_Q24, sum_error_Q24, w_Q9_ptr, v3
	if !(LPC_order&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7000, __ccgo_ts+7041, int32(49))
	}
	/* Loop over codebook */
	cb_Q8_ptr = pCB_Q8
	w_Q9_ptr = pWght_Q9
	i = 0
	for {
		if !(i < K) {
			break
		}
		sum_error_Q24 = 0
		pred_Q24 = 0
		m = LPC_order - int32(2)
		for {
			if !(m >= 0) {
				break
			}
			/* Compute weighted absolute predictive quantization error for index m + 1 */
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_Q15 + uintptr(m+int32(1))*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(cb_Q8_ptr + uintptr(m+int32(1))))))<<libc.Int32FromInt32(7)) /* range: [ -32767 : 32767 ]*/
			diffw_Q24 = int32(int16(diff_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q9_ptr + uintptr(m+int32(1))*2)))
			if diffw_Q24-pred_Q24>>libc.Int32FromInt32(1) > 0 {
				v3 = diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1)
			} else {
				v3 = -(diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1))
			}
			sum_error_Q24 = sum_error_Q24 + v3
			pred_Q24 = diffw_Q24
			/* Compute weighted absolute predictive quantization error for index m */
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_Q15 + uintptr(m)*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(cb_Q8_ptr + uintptr(m)))))<<libc.Int32FromInt32(7)) /* range: [ -32767 : 32767 ]*/
			diffw_Q24 = int32(int16(diff_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q9_ptr + uintptr(m)*2)))
			if diffw_Q24-pred_Q24>>libc.Int32FromInt32(1) > 0 {
				v3 = diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1)
			} else {
				v3 = -(diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1))
			}
			sum_error_Q24 = sum_error_Q24 + v3
			pred_Q24 = diffw_Q24
			_ = sum_error_Q24 >= libc.Int32FromInt32(0)
			goto _2
		_2:
			;
			m = m - int32(2)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(err_Q24 + uintptr(i)*4)) = sum_error_Q24
		cb_Q8_ptr = cb_Q8_ptr + uintptr(LPC_order)
		w_Q9_ptr = w_Q9_ptr + uintptr(LPC_order)*2
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Unpack predictor values and indices for entropy coding tables */
func Opus_silk_NLSF_unpack(tls *libc.TLS, ec_ix uintptr, pred_Q8 uintptr, psNLSF_CB uintptr, CB1_index int32) {
	var ec_sel_ptr, v2 uintptr
	var entry OpusT_opus_uint8
	var i int32
	_, _, _, _ = ec_sel_ptr, entry, i, v2
	ec_sel_ptr = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fec_sel + uintptr(CB1_index*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)/int32(2))
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)) {
			break
		}
		v2 = ec_sel_ptr
		ec_sel_ptr = ec_sel_ptr + 1
		entry = *(*OpusT_opus_uint8)(unsafe.Pointer(v2))
		*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i)*2)) = int16(int32(int16(libc.Int32FromUint8(entry)>>libc.Int32FromInt32(1)&libc.Int32FromInt32(7))) * int32(int16(libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE)+libc.Int32FromInt32(1))))
		*(*OpusT_opus_uint8)(unsafe.Pointer(pred_Q8 + uintptr(i))) = *(*OpusT_opus_uint8)(unsafe.Pointer((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fpred_Q8 + uintptr(i+libc.Int32FromUint8(entry)&int32(1)*(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)-int32(1)))))
		*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i+int32(1))*2)) = int16(int32(int16(libc.Int32FromUint8(entry)>>libc.Int32FromInt32(5)&libc.Int32FromInt32(7))) * int32(int16(libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE)+libc.Int32FromInt32(1))))
		*(*OpusT_opus_uint8)(unsafe.Pointer(pred_Q8 + uintptr(i+int32(1)))) = *(*OpusT_opus_uint8)(unsafe.Pointer((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fpred_Q8 + uintptr(i+libc.Int32FromUint8(entry)>>int32(4)&int32(1)*(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)-int32(1))+int32(1))))
		goto _1
	_1:
		;
		i = i + int32(2)
	}
}

// C documentation
//
//	/* Delayed-decision quantizer for NLSF residuals */
func Opus_silk_NLSF_del_dec_quant(tls *libc.TLS, indices uintptr, x_Q10 uintptr, w_Q5 uintptr, pred_coef_Q8 uintptr, ec_ix uintptr, ec_rates_Q5 uintptr, quant_step_size_Q16 int32, inv_quant_step_size_Q6 OpusT_opus_int16, mu_Q20 OpusT_opus_int32, order OpusT_opus_int16) (r OpusT_opus_int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var RD_Q25 [8]OpusT_opus_int32
	var RD_max_Q25, RD_min_Q25 [4]OpusT_opus_int32
	var RD_tmp_Q25, max_min_Q25, min_Q25, min_max_Q25 OpusT_opus_int32
	var diff_Q10, i, in_Q10, ind_max_min, ind_min_max, ind_tmp, j, nStates, pred_Q10, rate0_Q5, rate1_Q5, res_Q10, v4, v5 int32
	var ind_sort [4]int32
	var out0_Q10, out1_Q10 OpusT_opus_int16
	var out0_Q10_table, out1_Q10_table [20]int32
	var prev_out_Q10 [8]OpusT_opus_int16
	var rates_Q5, v11 uintptr
	var _ /* ind at bp+0 */ [4][16]OpusT_opus_int8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = RD_Q25, RD_max_Q25, RD_min_Q25, RD_tmp_Q25, diff_Q10, i, in_Q10, ind_max_min, ind_min_max, ind_sort, ind_tmp, j, max_min_Q25, min_Q25, min_max_Q25, nStates, out0_Q10, out0_Q10_table, out1_Q10, out1_Q10_table, pred_Q10, prev_out_Q10, rate0_Q5, rate1_Q5, rates_Q5, res_Q10, v11, v4, v5
	i = -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
	for {
		if !(i <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)-libc.Int32FromInt32(1)) {
			break
		}
		out0_Q10 = int16(libc.Int32FromUint32(libc.Uint32FromInt32(i) << libc.Int32FromInt32(10)))
		out1_Q10 = int16(int32(out0_Q10) + libc.Int32FromInt32(1024))
		if i > 0 {
			out0_Q10 = int16(int32(out0_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
			out1_Q10 = int16(int32(out1_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
		} else {
			if i == 0 {
				out1_Q10 = int16(int32(out1_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
			} else {
				if i == -int32(1) {
					out0_Q10 = int16(int32(out0_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
				} else {
					out0_Q10 = int16(int32(out0_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
					out1_Q10 = int16(int32(out1_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
				}
			}
		}
		out0_Q10_table[i+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)] = int32(out0_Q10) * int32(int16(quant_step_size_Q16)) >> int32(16)
		out1_Q10_table[i+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)] = int32(out1_Q10) * int32(int16(quant_step_size_Q16)) >> int32(16)
		goto _1
	_1:
		;
		i = i + 1
	}
	_ = libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)&(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)-libc.Int32FromInt32(1)) == libc.Int32FromInt32(0) /* must be power of two */
	nStates = int32(1)
	RD_Q25[0] = 0
	prev_out_Q10[0] = 0
	i = int32(order) - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		rates_Q5 = ec_rates_Q5 + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i)*2)))
		in_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x_Q10 + uintptr(i)*2)))
		j = 0
		for {
			if !(j < nStates) {
				break
			}
			pred_Q10 = int32(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pred_coef_Q8 + uintptr(i))))) * int32(prev_out_Q10[j]) >> int32(8)
			res_Q10 = in_Q10 - pred_Q10
			ind_tmp = int32(inv_quant_step_size_Q6) * int32(int16(res_Q10)) >> int32(16)
			if ind_tmp > libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)-libc.Int32FromInt32(1) {
				v4 = libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT) - libc.Int32FromInt32(1)
			} else {
				if ind_tmp < -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT) {
					v5 = -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
				} else {
					v5 = ind_tmp
				}
				v4 = v5
			}
			ind_tmp = v4
			*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i))) = int8(ind_tmp)
			/* compute outputs for ind_tmp and ind_tmp + 1 */
			out0_Q10 = int16(out0_Q10_table[ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)])
			out1_Q10 = int16(out1_Q10_table[ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)])
			out0_Q10 = int16(int32(out0_Q10) + pred_Q10)
			out1_Q10 = int16(int32(out1_Q10) + pred_Q10)
			prev_out_Q10[j] = out0_Q10
			prev_out_Q10[j+nStates] = out1_Q10
			/* compute RD for ind_tmp and ind_tmp + 1 */
			if ind_tmp+int32(1) >= int32(NLSF_QUANT_MAX_AMPLITUDE) {
				if ind_tmp+int32(1) == int32(NLSF_QUANT_MAX_AMPLITUDE) {
					rate0_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					rate1_Q5 = int32(280)
				} else {
					rate0_Q5 = libc.Int32FromInt32(280) - libc.Int32FromInt32(43)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) + int32(int16(libc.Int32FromInt32(43)))*int32(int16(ind_tmp))
					rate1_Q5 = rate0_Q5 + int32(43)
				}
			} else {
				if ind_tmp <= -int32(NLSF_QUANT_MAX_AMPLITUDE) {
					if ind_tmp == -int32(NLSF_QUANT_MAX_AMPLITUDE) {
						rate0_Q5 = int32(280)
						rate1_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(1)+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					} else {
						rate0_Q5 = libc.Int32FromInt32(280) - libc.Int32FromInt32(43)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) + int32(int16(-libc.Int32FromInt32(43)))*int32(int16(ind_tmp))
						rate1_Q5 = rate0_Q5 - int32(43)
					}
				} else {
					rate0_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					rate1_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(1)+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
				}
			}
			RD_tmp_Q25 = RD_Q25[j]
			diff_Q10 = in_Q10 - int32(out0_Q10)
			RD_Q25[j] = RD_tmp_Q25 + int32(int16(diff_Q10))*int32(int16(diff_Q10))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q5 + uintptr(i)*2))) + int32(int16(mu_Q20))*int32(int16(rate0_Q5))
			diff_Q10 = in_Q10 - int32(out1_Q10)
			RD_Q25[j+nStates] = RD_tmp_Q25 + int32(int16(diff_Q10))*int32(int16(diff_Q10))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q5 + uintptr(i)*2))) + int32(int16(mu_Q20))*int32(int16(rate1_Q5))
			goto _3
		_3:
			;
			j = j + 1
		}
		if nStates <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)/libc.Int32FromInt32(2) {
			/* double number of states and copy */
			j = 0
			for {
				if !(j < nStates) {
					break
				}
				*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j+nStates)*16 + uintptr(i))) = int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i)))) + int32(1))
				goto _6
			_6:
				;
				j = j + 1
			}
			nStates = libc.Int32FromUint32(libc.Uint32FromInt32(nStates) << libc.Int32FromInt32(1))
			j = nStates
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i))) = *(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j-nStates)*16 + uintptr(i)))
				goto _7
			_7:
				;
				j = j + 1
			}
		} else {
			/* sort lower and upper half of RD_Q25, pairwise */
			j = 0
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				if RD_Q25[j] > RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] {
					RD_max_Q25[j] = RD_Q25[j]
					RD_min_Q25[j] = RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					RD_Q25[j] = RD_min_Q25[j]
					RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] = RD_max_Q25[j]
					/* swap prev_out values */
					out0_Q10 = prev_out_Q10[j]
					prev_out_Q10[j] = prev_out_Q10[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					prev_out_Q10[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] = out0_Q10
					ind_sort[j] = j + libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)
				} else {
					RD_min_Q25[j] = RD_Q25[j]
					RD_max_Q25[j] = RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					ind_sort[j] = j
				}
				goto _8
			_8:
				;
				j = j + 1
			}
			/* compare the highest RD values of the winning half with the lowest one in the losing half, and copy if necessary */
			/* afterwards ind_sort[] will contain the indices of the NLSF_QUANT_DEL_DEC_STATES winning RD values */
			for int32(1) != 0 {
				min_max_Q25 = int32(silk_int32_MAX)
				max_min_Q25 = 0
				ind_min_max = 0
				ind_max_min = 0
				j = 0
				for {
					if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
						break
					}
					if min_max_Q25 > RD_max_Q25[j] {
						min_max_Q25 = RD_max_Q25[j]
						ind_min_max = j
					}
					if max_min_Q25 < RD_min_Q25[j] {
						max_min_Q25 = RD_min_Q25[j]
						ind_max_min = j
					}
					goto _9
				_9:
					;
					j = j + 1
				}
				if min_max_Q25 >= max_min_Q25 {
					break
				}
				/* copy ind_min_max to ind_max_min */
				ind_sort[ind_max_min] = ind_sort[ind_min_max] ^ libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)
				RD_Q25[ind_max_min] = RD_Q25[ind_min_max+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
				prev_out_Q10[ind_max_min] = prev_out_Q10[ind_min_max+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
				RD_min_Q25[ind_max_min] = 0
				RD_max_Q25[ind_min_max] = int32(silk_int32_MAX)
				libc.Xmemcpy(tls, bp+uintptr(ind_max_min)*16, bp+uintptr(ind_min_max)*16, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(1))
			}
			/* increment index if it comes from the upper half */
			j = 0
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				v11 = bp + uintptr(j)*16 + uintptr(i)
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + ind_sort[j]>>libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))
				goto _10
			_10:
				;
				j = j + 1
			}
		}
		goto _2
	_2:
		;
		i = i - 1
	}
	/* last sample: find winner, copy indices and return RD value */
	ind_tmp = 0
	min_Q25 = int32(silk_int32_MAX)
	j = 0
	for {
		if !(j < libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))) {
			break
		}
		if min_Q25 > RD_Q25[j] {
			min_Q25 = RD_Q25[j]
			ind_tmp = j
		}
		goto _12
	_12:
		;
		j = j + 1
	}
	j = 0
	for {
		if !(j < int32(order)) {
			break
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j))) = *(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(ind_tmp&(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)-libc.Int32FromInt32(1)))*16 + uintptr(j)))
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j)))) >= -libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j)))) <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
		goto _13
	_13:
		;
		j = j + 1
	}
	v11 = indices
	*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + ind_tmp>>libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))
	_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices))) <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
	_ = min_Q25 >= libc.Int32FromInt32(0)
	return min_Q25
}

const silk_int16_MAX11 = 32767

// C documentation
//
//	/* Convert adaptive Mid/Side representation to Left/Right stereo signal */
func Opus_silk_stereo_MS_to_LR(tls *libc.TLS, state uintptr, x1 uintptr, x2 uintptr, pred_Q13 uintptr, fs_kHz int32, frame_length int32) {
	var delta0_Q13, delta1_Q13, denom_Q16, n, v2, v3 int32
	var diff, pred0_Q13, pred1_Q13, sum OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _ = delta0_Q13, delta1_Q13, denom_Q16, diff, n, pred0_Q13, pred1_Q13, sum, v2, v3
	/* Buffering */
	libc.Xmemcpy(tls, x1, state+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, x2, state+8, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+4, x1+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+8, x2+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	/* Interpolate predictors and add prediction to side channel */
	pred0_Q13 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))
	pred1_Q13 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))
	denom_Q16 = libc.Int32FromInt32(1) << libc.Int32FromInt32(16) / (libc.Int32FromInt32(STEREO_INTERP_LEN_MS) * fs_kHz)
	delta0_Q13 = (int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	delta1_Q13 = (int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	n = 0
	for {
		if !(n < int32(STEREO_INTERP_LEN_MS)*fs_kHz) {
			break
		}
		pred0_Q13 = pred0_Q13 + delta0_Q13
		pred1_Q13 = pred1_Q13 + delta1_Q13
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(8))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                           /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                          /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		n = n + 1
	}
	pred0_Q13 = *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13))
	pred1_Q13 = *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))
	n = int32(STEREO_INTERP_LEN_MS) * fs_kHz
	for {
		if !(n < frame_length) {
			break
		}
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(8))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                           /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                          /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _4
	_4:
		;
		n = n + 1
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(state)) = int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13)))
	*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)) = int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4)))
	/* Convert to left/right signals */
	n = 0
	for {
		if !(n < frame_length) {
			break
		}
		sum = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)))
		diff = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)))
		if sum > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if sum < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = sum
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)) = int16(v2)
		if diff > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if diff < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = diff
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _7
	_7:
		;
		n = n + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Coefficients for 2-band filter bank based on first-order allpass filters */
var A_fb1_20 = int16(libc.Int32FromInt32(5394) << libc.Int32FromInt32(1))
var A_fb1_21 = int16(-int32(24290)) /* (opus_int16)(20623 << 1) */

// C documentation
//
//	/* Split signal into two decimated bands using first-order allpass filters */
func Opus_silk_ana_filt_bank_1(tls *libc.TLS, in uintptr, S uintptr, outL uintptr, outH uintptr, N OpusT_opus_int32) {
	var N2, k, v2, v3 int32
	var X, Y, in32, out_1, out_2 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _ = N2, X, Y, in32, k, out_1, out_2, v2, v3
	N2 = N >> libc.Int32FromInt32(1)
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < N2) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k)*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for even input sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) + int64(Y)*int64(A_fb1_21)>>libc.Int32FromInt32(16))
		out_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for odd input sample, and add to output of previous section */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(A_fb1_20) >> libc.Int32FromInt32(16))
		out_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = in32 + X
		/* Add/subtract, convert back to int16 and store to output */
		if ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(outL + uintptr(k)*2)) = int16(v2)
		if ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(outH + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Second order ARMA filter, alternative implementation */
func Opus_silk_biquad_alt_stride1(tls *libc.TLS, in uintptr, B_Q28 uintptr, A_Q28 uintptr, S uintptr, out uintptr, len1 OpusT_opus_int32) {
	var A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, inval, out32_Q14 OpusT_opus_int32
	var k, v2, v3 int32
	_, _, _, _, _, _, _, _, _ = A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, inval, k, out32_Q14, v2, v3
	/* Negate A_Q28 values and split in two parts */
	A0_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) & int32(0x00003FFF)              /* lower part */
	A0_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) >> libc.Int32FromInt32(14)       /* upper part */
	A1_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) & int32(0x00003FFF)        /* lower part */
	A1_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) >> libc.Int32FromInt32(14) /* upper part */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* S[ 0 ], S[ 1 ]: Q12 */
		inval = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2)))
		out32_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(int16(inval))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + (int32(int64(out32_Q14)*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(out32_Q14)*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(int16(inval))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = (int32(int64(out32_Q14)*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32_Q14)*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(int16(inval))>>libc.Int32FromInt32(16))
		/* Scale back to Q0 and saturate */
		if (out32_Q14+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if (out32_Q14+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14 + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

func Opus_silk_biquad_alt_stride2_c(tls *libc.TLS, in uintptr, B_Q28 uintptr, A_Q28 uintptr, S uintptr, out uintptr, len1 OpusT_opus_int32) {
	var A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28 OpusT_opus_int32
	var k, v2, v3 int32
	var out32_Q14 [2]OpusT_opus_int32
	_, _, _, _, _, _, _, _ = A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, k, out32_Q14, v2, v3
	/* Negate A_Q28 values and split in two parts */
	A0_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) & int32(0x00003FFF)              /* lower part */
	A0_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) >> libc.Int32FromInt32(14)       /* upper part */
	A1_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) & int32(0x00003FFF)        /* lower part */
	A1_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) >> libc.Int32FromInt32(14) /* upper part */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* S[ 0 ], S[ 1 ], S[ 2 ], S[ 3 ]: Q12 */
		out32_Q14[0] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		out32_Q14[int32(1)] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + (int32(int64(out32_Q14[0])*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) + (int32(int64(out32_Q14[int32(1)])*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(out32_Q14[0])*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))) + int64(out32_Q14[int32(1)])*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = (int32(int64(out32_Q14[0])*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = (int32(int64(out32_Q14[int32(1)])*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32_Q14[0])*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))) + int64(out32_Q14[int32(1)])*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))
		/* Scale back to Q0 and saturate */
		if (out32_Q14[0]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if (out32_Q14[0]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14[0] + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+0)*2)) = int16(v2)
		if (out32_Q14[int32(1)]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX11) {
			v2 = int32(silk_int16_MAX11)
		} else {
			if (out32_Q14[int32(1)]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14[int32(1)] + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX12 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Chirp (bandwidth expand) LP AR filter.
//	   This logic is reused in _celt_lpc(). Any bug fixes should also be applied there. */
func Opus_silk_bwexpander_32(tls *libc.TLS, ar uintptr, d int32, chirp_Q16 OpusT_opus_int32) {
	var chirp_minus_one_Q16 OpusT_opus_int32
	var i int32
	_, _ = chirp_minus_one_Q16, i
	chirp_minus_one_Q16 = chirp_Q16 - int32(65536)
	i = 0
	for {
		if !(i < d-int32(1)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(i)*4)) = int32(int64(chirp_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(i)*4))) >> libc.Int32FromInt32(16))
		chirp_Q16 = chirp_Q16 + (chirp_Q16*chirp_minus_one_Q16>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(d-int32(1))*4)) = int32(int64(chirp_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(d-int32(1))*4))) >> libc.Int32FromInt32(16))
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Chirp (bandwidth expand) LP AR filter */
func Opus_silk_bwexpander(tls *libc.TLS, ar uintptr, d int32, chirp_Q16 OpusT_opus_int32) {
	var chirp_minus_one_Q16 OpusT_opus_int32
	var i int32
	_, _ = chirp_minus_one_Q16, i
	chirp_minus_one_Q16 = chirp_Q16 - int32(65536)
	/* NB: Dont use silk_SMULWB, instead of silk_RSHIFT_ROUND( silk_MUL(), 16 ), below.  */
	/* Bias in silk_SMULWB can lead to unstable filters                                */
	i = 0
	for {
		if !(i < d-int32(1)) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(i)*2)) = int16((chirp_Q16*int32(*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(i)*2)))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
		chirp_Q16 = chirp_Q16 + (chirp_Q16*chirp_minus_one_Q16>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(d-int32(1))*2)) = int16((chirp_Q16*int32(*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(d-int32(1))*2)))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
}

/* config_ccgo.h
 *
 * ccgo build configuration for producing a pure-Go libopus translation.
 *
 * We include the project's generated config.h, then disable all CPU RTCD and
 * x86 intrinsics so only portable C paths are used.
 */

/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Get CPU Info by asm method */

/* Get CPU Info by c method */
/* #undef CPU_INFO_BY_C */

/* Custom modes */
/* #undef CUSTOM_MODES */

/* Disable DNN debug float */

/* Disable dot product instructions */
/* #undef DISABLE_DOT_PROD */

/* Do not build the float API */
/* #undef DISABLE_FLOAT_API */

/* Disable bitstream fixes from RFC 8251 */
/* #undef DISABLE_UPDATE_DRAFT */

/* Assertions */
/* #undef ENABLE_ASSERTIONS */

/* Deep PLC */
/* #undef ENABLE_DEEP_PLC */

/* DRED */
/* #undef ENABLE_DRED */

/* Hardening */

/* LOSSGEN */
/* #undef ENABLE_LOSSGEN */

/* Opus custom API */
/* #undef ENABLE_OPUS_CUSTOM_API */

/* Enable Opus Speech Coding Enhancement */
/* #undef ENABLE_OSCE */

/* Enable Opus Speech Coding Enhancement Blind BWE */
/* #undef ENABLE_OSCE_BWE */

/* Enable dumping of OSCE training data */
/* #undef ENABLE_OSCE_TRAINING_DATA */

/* Scalable quality extension */
/* #undef ENABLE_QEXT */

/* 24-bit internal resolution for fixed-point */

/* Debug fixed-point implementation */
/* #undef FIXED_DEBUG */

/* Compile as fixed-point (for machines without a fast enough FPU) */
/* #undef FIXED_POINT */

/* Float approximations */

/* Fuzzing */
/* #undef FUZZING */

/* Define to 1 if you have the <alloca.h> header file. */
/* #undef HAVE_ALLOCA_H */

/* NE10 library is installed on host. Make sure it is on target! */
/* #undef HAVE_ARM_NE10 */

/* Define to 1 if you have the <dlfcn.h> header file. */

/* Define to 1 if you have the `elf_aux_info' function. */
/* #undef HAVE_ELF_AUX_INFO */

/* Define to 1 if you have the <inttypes.h> header file. */

/* Define to 1 if you have the `lrint' function. */

/* Define to 1 if you have the `lrintf' function. */

/* Define to 1 if you have the <stdint.h> header file. */

/* Define to 1 if you have the <stdio.h> header file. */

/* Define to 1 if you have the <stdlib.h> header file. */

/* Define to 1 if you have the <strings.h> header file. */

/* Define to 1 if you have the <string.h> header file. */

/* Define to 1 if you have the <sys/stat.h> header file. */

/* Define to 1 if you have the <sys/types.h> header file. */

/* Define to 1 if you have the <unistd.h> header file. */

/* Define to 1 if you have the `__malloc_hook' function. */
/* #undef HAVE___MALLOC_HOOK */

/* Define to the sub-directory where libtool stores uninstalled libraries. */

/* Make use of ARM asm optimization */
/* #undef OPUS_ARM_ASM */

/* Use generic ARMv4 inline asm optimizations */
/* #undef OPUS_ARM_INLINE_ASM */

/* Use ARMv5E inline asm optimizations */
/* #undef OPUS_ARM_INLINE_EDSP */

/* Use ARMv6 inline asm optimizations */
/* #undef OPUS_ARM_INLINE_MEDIA */

/* Use ARM NEON inline asm optimizations */
/* #undef OPUS_ARM_INLINE_NEON */

/* Compiler supports Aarch64 DOTPROD Intrinsics */
/* #undef OPUS_ARM_MAY_HAVE_DOTPROD */

/* Define if assembler supports EDSP instructions */
/* #undef OPUS_ARM_MAY_HAVE_EDSP */

/* Define if assembler supports ARMv6 media instructions */
/* #undef OPUS_ARM_MAY_HAVE_MEDIA */

/* Define if compiler supports NEON instructions */
/* #undef OPUS_ARM_MAY_HAVE_NEON */

/* Compiler supports ARMv7/Aarch64 Neon Intrinsics */
/* #undef OPUS_ARM_MAY_HAVE_NEON_INTR */

/* Define if binary requires Aarch64 Neon Intrinsics */
/* #undef OPUS_ARM_PRESUME_AARCH64_NEON_INTR */

/* Define if binary requires Aarch64 dotprod Intrinsics */
/* #undef OPUS_ARM_PRESUME_DOTPROD */

/* Define if binary requires EDSP instruction support */
/* #undef OPUS_ARM_PRESUME_EDSP */

/* Define if binary requires ARMv6 media instruction support */
/* #undef OPUS_ARM_PRESUME_MEDIA */

/* Define if binary requires NEON instruction support */
/* #undef OPUS_ARM_PRESUME_NEON */

/* Define if binary requires NEON intrinsics support */
/* #undef OPUS_ARM_PRESUME_NEON_INTR */

/* This is a build of OPUS */

/* Run bit-exactness checks between optimized and C implementations */
/* #undef OPUS_CHECK_ASM */

/* Use run-time CPU capabilities detection */

/* Compiler supports X86 AVX2 Intrinsics */

/* Compiler supports X86 SSE Intrinsics */

/* Compiler supports X86 SSE2 Intrinsics */

/* Compiler supports X86 SSE4.1 Intrinsics */

/* Define if binary requires AVX2 intrinsics support */
/* #undef OPUS_X86_PRESUME_AVX2 */

/* Define if binary requires SSE intrinsics support */

/* Define if binary requires SSE2 intrinsics support */

/* Define if binary requires SSE4.1 intrinsics support */
/* #undef OPUS_X86_PRESUME_SSE4_1 */

/* Define to the address where bug reports for this package should be sent. */

/* Define to the full name of this package. */

/* Define to the full name and version of this package. */

/* Define to the one symbol short name of this package. */

/* Define to the home page for this package. */

/* Define to the version of this package. */

/* Define to 1 if all of the C90 standard headers exist (not just the ones
   required in a freestanding environment). This macro is provided for
   backward compatibility; new code need not use it. */

/* Make use of alloca */
/* #undef USE_ALLOCA */

/* Use C99 variable-size arrays */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
/* #undef inline */

/* Define to the equivalent of the C99 'restrict' keyword, or to
   nothing if this is not supported.  Do not define if restrict is
   supported directly.  */
/* Work around a bug in Sun C++: it does not support _Restrict or
   __restrict__, even though the corresponding Sun C compiler ends up with
   "#define restrict _Restrict" or "#define restrict __restrict__" in the
   previous line.  Perhaps some future version of Sun C++ will work with
   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */

/* Enable ccgo-specific concurrency-safe pseudostack plumbing.
 * See celt/stack_alloc.h for details.
 */

/* Temp allocation mode: NONTHREADSAFE_PSEUDOSTACK is fastest, but the upstream
 * implementation uses global variables. We'll patch the generated Go to store
 * the pseudostack state in per-decoder TLS (no shared globals).
 */

/* Disable runtime CPU detection tables and any x86 intrinsic paths.
 *
 * Important: many libopus headers use `#if defined(OPUS_...)` checks, so we
 * must UNDEFINE these macros (not merely set them to 0).
 */

/* Also request that intrinsics are not used even if headers try. */
/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

type OpusT_prevent_empty_translation_unit_warning = int32

const PE_D_SRCH_LENGTH = 24
const PE_FLATCONTOUR_BIAS = "0.05f"
const PE_MAX_FS_KHZ = 16
const PE_MAX_LAG_MS = 18
const PE_MAX_NB_SUBFR = 4
const PE_MIN_LAG_MS = 2
const PE_NB_CBKS_STAGE2 = 3
const PE_NB_CBKS_STAGE2_10MS = 3
const PE_NB_CBKS_STAGE2_EXT = 11
const PE_NB_CBKS_STAGE3_10MS = 12
const PE_NB_CBKS_STAGE3_MAX = 34
const PE_NB_CBKS_STAGE3_MID = 24
const PE_NB_CBKS_STAGE3_MIN = 16
const PE_NB_STAGE3_LAGS = 5
const PE_PREVLAG_BIAS = "0.2f"
const PE_SHORTLAG_BIAS = "0.2f"
const PE_SUBFR_LENGTH_MS = 5
const SILK_PE_MAX_COMPLEX = 2
const SILK_PE_MID_COMPLEX = 1
const SILK_PE_MIN_COMPLEX = 0

func Opus_silk_decode_pitch(tls *libc.TLS, lagIndex OpusT_opus_int16, contourIndex OpusT_opus_int8, pitch_lags uintptr, Fs_kHz int32, nb_subfr int32) {
	var Lag_CB_ptr uintptr
	var cbk_size, k, lag, max_lag, min_lag, v2, v3, v4, v5, v6 int32
	_, _, _, _, _, _, _, _, _, _, _ = Lag_CB_ptr, cbk_size, k, lag, max_lag, min_lag, v2, v3, v4, v5, v6
	if Fs_kHz == int32(8) {
		if nb_subfr == int32(PE_MAX_NB_SUBFR) {
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2))
			cbk_size = int32(PE_NB_CBKS_STAGE2_EXT)
		} else {
			if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
				Opus_celt_fatal(tls, __ccgo_ts+7059, __ccgo_ts+7110, int32(54))
			}
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2_10_ms))
			cbk_size = int32(PE_NB_CBKS_STAGE2_10MS)
		}
	} else {
		if nb_subfr == int32(PE_MAX_NB_SUBFR) {
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3))
			cbk_size = int32(PE_NB_CBKS_STAGE3_MAX)
		} else {
			if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
				Opus_celt_fatal(tls, __ccgo_ts+7059, __ccgo_ts+7110, int32(63))
			}
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3_10_ms))
			cbk_size = int32(PE_NB_CBKS_STAGE3_10MS)
		}
	}
	min_lag = int32(int16(libc.Int32FromInt32(PE_MIN_LAG_MS))) * int32(int16(Fs_kHz))
	max_lag = int32(int16(libc.Int32FromInt32(PE_MAX_LAG_MS))) * int32(int16(Fs_kHz))
	lag = min_lag + int32(lagIndex)
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		*(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) = lag + int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k*cbk_size+int32(contourIndex)))))
		if min_lag > max_lag {
			if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) > min_lag {
				v3 = min_lag
			} else {
				if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) < max_lag {
					v4 = max_lag
				} else {
					v4 = *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4))
				}
				v3 = v4
			}
			v2 = v3
		} else {
			if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) > max_lag {
				v5 = max_lag
			} else {
				if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) < min_lag {
					v6 = min_lag
				} else {
					v6 = *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4))
				}
				v5 = v6
			}
			v2 = v5
		}
		*(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) = v2
		goto _1
	_1:
		;
		k = k + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func Opus_silk_inner_prod_aligned_scale(tls *libc.TLS, inVec1 uintptr, inVec2 uintptr, scale int32, len1 int32) (r OpusT_opus_int32) {
	var i int32
	var sum OpusT_opus_int32
	_, _ = i, sum
	sum = 0
	i = 0
	for {
		if !(i < len1) {
			break
		}
		sum = sum + int32(*(*OpusT_opus_int16)(unsafe.Pointer(inVec1 + uintptr(i)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(inVec2 + uintptr(i)*2)))>>scale
		goto _1
	_1:
		;
		i = i + 1
	}
	return sum
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Approximation of 128 * log2() (very close inverse of silk_log2lin()) */
//	/* Convert input to a log scale    */
func Opus_silk_lin2log(tls *libc.TLS, inLin OpusT_opus_int32) (r1 OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var lzeros, v1, v2, v3, v6, v8 OpusT_opus_int32
	var m, r, x OpusT_opus_uint32
	var v5, v7 int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = lzeros, m, r, x, v1, v2, v3, v5, v6, v7, v8
	v1 = inLin
	v2 = v1
	if v2 != 0 {
		v5 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v2)))
	} else {
		v5 = int32(32)
	}
	v3 = v5
	goto _4
_4:
	lzeros = v3
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v6 = v1
	v7 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v6)
	r = libc.Uint32FromInt32(v7)
	m = libc.Uint32FromInt32(-v7)
	if v7 == libc.Int32FromInt32(0) {
		v8 = v6
		goto _9
	} else {
		if v7 < libc.Int32FromInt32(0) {
			v8 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _9
		} else {
			v8 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _9
		}
	}
_9:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v8 & int32(0x7f)
	/* Piece-wise parabolic approximation */
	return int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))*(libc.Int32FromInt32(128)-*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))*int64(int16(libc.Int32FromInt32(179)))>>libc.Int32FromInt32(16)) + libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(31)-*(*OpusT_opus_int32)(unsafe.Pointer(bp)))<<libc.Int32FromInt32(7))
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Approximation of 2^() (very close inverse of silk_lin2log()) */
//	/* Convert input to a linear scale    */
func Opus_silk_log2lin(tls *libc.TLS, inLog_Q7 OpusT_opus_int32) (r OpusT_opus_int32) {
	var frac_Q7, out OpusT_opus_int32
	_, _ = frac_Q7, out
	if inLog_Q7 < 0 {
		return 0
	} else {
		if inLog_Q7 >= int32(3967) {
			return int32(silk_int32_MAX)
		}
	}
	out = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << (inLog_Q7 >> libc.Int32FromInt32(7)))
	frac_Q7 = inLog_Q7 & int32(0x7F)
	if inLog_Q7 < int32(2048) {
		/* Piece-wise parabolic approximation */
		out = out + out*int32(int64(frac_Q7)+int64(int32(int16(frac_Q7))*int32(int16(libc.Int32FromInt32(128)-frac_Q7)))*int64(int16(-libc.Int32FromInt32(174)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(7)
	} else {
		/* Piece-wise parabolic approximation */
		out = out + out>>libc.Int32FromInt32(7)*int32(int64(frac_Q7)+int64(int32(int16(frac_Q7))*int32(int16(libc.Int32FromInt32(128)-frac_Q7)))*int64(int16(-libc.Int32FromInt32(174)))>>libc.Int32FromInt32(16))
	}
	return out
}

const USE_CELT_FIR = 0
const silk_int16_MAX13 = 32767

/*******************************************/
/* LPC analysis filter                     */
/* NB! State is kept internally and the    */
/* filter always starts with zero state    */
/* first d output samples are set to zero  */
/*******************************************/

/* OPT: Using celt_fir() for this function should be faster, but it may cause
   integer overflows in intermediate values (not final results), which the
   current implementation silences by casting to unsigned. Enabling
   this should be safe in pretty much all cases, even though it is not technically
   C89-compliant. */

func Opus_silk_LPC_analysis_filter(tls *libc.TLS, out uintptr, in uintptr, B uintptr, len1 OpusT_opus_int32, d OpusT_opus_int32, arch int32) {
	var in_ptr uintptr
	var ix, j, v3, v4 int32
	var out32, out32_Q12 OpusT_opus_int32
	_, _, _, _, _, _, _ = in_ptr, ix, j, out32, out32_Q12, v3, v4
	if !(d >= libc.Int32FromInt32(6)) {
		Opus_celt_fatal(tls, __ccgo_ts+7133, __ccgo_ts+7158, int32(67))
	}
	if !(d&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7188, __ccgo_ts+7158, int32(68))
	}
	if !(d <= len1) {
		Opus_celt_fatal(tls, __ccgo_ts+7219, __ccgo_ts+7158, int32(69))
	}
	_ = arch
	ix = d
	for {
		if !(ix < len1) {
			break
		}
		in_ptr = in + uintptr(ix-int32(1))*2
		out32_Q12 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(B)))
		/* Allowing wrap around so that two wraps can cancel each other. The rare
		   cases where the result wraps around can only be triggered by invalid streams*/
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 1*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(2))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 2*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(3))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 3*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(4))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 4*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(5))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 5*2)))))
		j = int32(6)
		for {
			if !(j < d) {
				break
			}
			out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-j)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + uintptr(j)*2)))))
			out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-j-int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + uintptr(j+int32(1))*2)))))
			goto _2
		_2:
			;
			j = j + int32(2)
		}
		/* Subtract prediction */
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + 1*2))))<<libc.Int32FromInt32(12))) - libc.Uint32FromInt32(out32_Q12))
		/* Scale to Q0 */
		out32 = (out32_Q12>>(libc.Int32FromInt32(12)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		/* Saturate output */
		if out32 > int32(silk_int16_MAX13) {
			v3 = int32(silk_int16_MAX13)
		} else {
			if out32 < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = out32
			}
			v3 = v4
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(ix)*2)) = int16(v3)
		goto _1
	_1:
		;
		ix = ix + 1
	}
	/* Set first d output samples to zero */
	libc.Xmemset(tls, out, 0, libc.Uint64FromInt32(d)*libc.Uint64FromInt64(2))
}

const MAX_PREDICTION_POWER_GAIN1 = 10000
const QA = 24
const silk_int16_MAX14 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/******************/
/* Error messages */
/******************/

/**************************/
/* Encoder error messages */
/**************************/

/* Input length is not a multiple of 10 ms, or length is longer than the packet length */

/* Sampling frequency not 8000, 12000 or 16000 Hertz */

/* Packet size not 10, 20, 40, or 60 ms */

/* Allocated payload buffer too short */

/* Loss rate not between 0 and 100 percent */

/* Complexity setting not valid, use 0...10 */

/* Inband FEC setting not valid, use 0 or 1 */

/* DTX setting not valid, use 0 or 1 */

/* CBR setting not valid, use 0 or 1 */

/* Internal encoder error */

/* Internal encoder error */

/**************************/
/* Decoder error messages */
/**************************/

/* Output sampling frequency lower than internal decoded sampling frequency */

/* Payload size exceeded the maximum allowed 1024 bytes */

/* Payload has bit errors */

/* Payload has bit errors */

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Max number of encoder channels (1/2) */
/* Number of decoder channels (1/2) */

/* Limits on bitrate */

/* LBRR thresholds */

/* DTX settings */

/* VAD decision */

/* Maximum sampling frequency */

/* Signal types */

/* Conditional coding types */

/* Settings for stereo processing */

/* Range of pitch lag estimates */

/* Maximum number of subframes */

/* Number of samples per frame */

/* Milliseconds of lookahead for pitch analysis */

/* Order of LPC used in find pitch */

/* Length of LPC window used in find pitch */

/* Milliseconds of lookahead for noise shape analysis */

/* Maximum length of LPC window used in noise shape analysis */

/* dB level of lowest gain quantization level */
/* dB level of highest gain quantization level */
/* Number of gain quantization levels */
/* Max increase in gain quantization index */
/* Max decrease in gain quantization index */

/* Quantization offsets (multiples of 4) */

/* Maximum numbers of iterations used to stabilize an LPC vector */

/* Find Pred Coef defines */

/* LTP quantization settings */

/* Flag to use harmonic noise shaping */

/* Max LPC order of noise shaping filters */

/* Maximum number of delayed decision states */

/* Number of subframes for excitation entropy coding */

/* Number of rate levels, for entropy coding of excitation */

/* Maximum sum of pulses per shell coding frame */

/***************************/
/* Voice activity detector */
/***************************/

/* Sigmoid settings */

/* smoothing for SNR measurement */

/* Size of the piecewise linear cosine approximation table for the LSFs */

/******************/
/* NLSF quantizer */
/******************/

/* Transition filtering for mode switching */

/* BWE factors to apply after packet loss */

/* Defines for CN generation */

// C documentation
//
//	/* Compute inverse of LPC prediction gain, and                          */
//	/* test if LPC coefficients are stable (all poles within unit circle)   */
func LPC_inverse_pred_gain_QA_c(tls *libc.TLS, A_QA uintptr, order int32) (r OpusT_opus_int32) {
	var b32_inv, b32_nrm, err_Q32, invGain_Q30, rc_Q31, rc_mult1_Q30, rc_mult2, result, tmp1, tmp2, v10, v3, v4, v7 OpusT_opus_int32
	var b_headrm, k, lshift, mult2Q, n, v13, v16, v17, v18, v19, v2, v6, v8, v9 int32
	var tmp64 OpusT_opus_int64
	var v22 int64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b32_inv, b32_nrm, b_headrm, err_Q32, invGain_Q30, k, lshift, mult2Q, n, rc_Q31, rc_mult1_Q30, rc_mult2, result, tmp1, tmp2, tmp64, v10, v13, v16, v17, v18, v19, v2, v22, v3, v4, v6, v7, v8, v9
	invGain_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30))) + libc.Float64FromFloat64(0.5))
	k = order - int32(1)
	for {
		if !(k > 0) {
			break
		}
		/* Check for stability */
		if *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) > int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) || *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) < -int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) {
			return 0
		}
		/* Set RC equal to negated AR coef */
		rc_Q31 = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4))) << (libc.Int32FromInt32(31) - libc.Int32FromInt32(QA)))
		/* rc_mult1_Q30 range: [ 1 : 2^30 ] */
		rc_mult1_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) - int32(int64(rc_Q31)*int64(rc_Q31)>>libc.Int32FromInt32(32))
		_ = rc_mult1_Q30 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) /* reduce A_LIMIT if fails */
		_ = rc_mult1_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
		/* Update inverse gain */
		/* invGain_Q30 range: [ 0 : 2^30 ] */
		invGain_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(invGain_Q30)*int64(rc_mult1_Q30)>>libc.Int32FromInt32(32))) << libc.Int32FromInt32(2))
		_ = invGain_Q30 >= libc.Int32FromInt32(0)
		_ = invGain_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
		if invGain_Q30 < int32(float64(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(10000)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) {
			return 0
		}
		/* rc_mult2 range: [ 2^30 : silk_int32_MAX ] */
		if rc_mult1_Q30 > 0 {
			v2 = rc_mult1_Q30
		} else {
			v2 = -rc_mult1_Q30
		}
		v3 = v2
		if v3 != 0 {
			v6 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v3)))
		} else {
			v6 = int32(32)
		}
		v4 = v6
		goto _5
	_5:
		mult2Q = int32(32) - v4
		v3 = rc_mult1_Q30
		v2 = mult2Q + int32(30)
		_ = v3 != libc.Int32FromInt32(0)
		_ = v2 > libc.Int32FromInt32(0)
		if v3 > 0 {
			v6 = v3
		} else {
			v6 = -v3
		}
		v4 = v6
		if v4 != 0 {
			v8 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v4)))
		} else {
			v8 = int32(32)
		}
		v7 = v8
		goto _12
	_12:
		b_headrm = v7 - int32(1)
		b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v3) << b_headrm)
		b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
		result = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv) << libc.Int32FromInt32(16))
		err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
		result = int32(int64(result) + int64(err_Q32)*int64(b32_inv)>>libc.Int32FromInt32(16))
		lshift = int32(61) - b_headrm - v2
		if lshift <= libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
				if result > libc.Int32FromUint32(0x80000000)>>-lshift {
					v13 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					if result < int32(silk_int32_MAX)>>-lshift {
						v16 = int32(silk_int32_MAX) >> -lshift
					} else {
						v16 = result
					}
					v13 = v16
				}
				v9 = v13
			} else {
				if result > int32(silk_int32_MAX)>>-lshift {
					v17 = int32(silk_int32_MAX) >> -lshift
				} else {
					if result < libc.Int32FromUint32(0x80000000)>>-lshift {
						v18 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						v18 = result
					}
					v17 = v18
				}
				v9 = v17
			}
			v10 = libc.Int32FromUint32(libc.Uint32FromInt32(v9) << -lshift)
			goto _15
		} else {
			if lshift < libc.Int32FromInt32(32) {
				v10 = result >> lshift
				goto _15
			} else {
				v10 = 0
				goto _15
			}
		}
	_15:
		rc_mult2 = v10
		/* Update AR coefficient */
		n = 0
		for {
			if !(n < (k+int32(1))>>int32(1)) {
				break
			}
			tmp1 = *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(n)*4))
			tmp2 = *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k-n-int32(1))*4))
			if mult2Q == int32(1) {
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v6 = libc.Int32FromUint32(0x80000000)
					} else {
						v6 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v6
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v8 = int32(silk_int32_MAX)
					} else {
						v8 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v8
				}
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v13 = libc.Int32FromUint32(0x80000000)
					} else {
						v13 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v13
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v16 = int32(silk_int32_MAX)
					} else {
						v16 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v16
				}
				v22 = int64(v2)*int64(rc_mult2)>>int32(1) + int64(v9)*int64(rc_mult2)&int64(1)
			} else {
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v18 = libc.Int32FromUint32(0x80000000)
					} else {
						v18 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v18
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v19 = int32(silk_int32_MAX)
					} else {
						v19 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v19
				}
				v22 = (int64(v17)*int64(rc_mult2)>>(mult2Q-int32(1)) + int64(1)) >> int32(1)
			}
			tmp64 = v22
			if tmp64 > int64(silk_int32_MAX) || tmp64 < int64(libc.Int32FromUint32(0x80000000)) {
				return 0
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(n)*4)) = int32(tmp64)
			if mult2Q == int32(1) {
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v6 = libc.Int32FromUint32(0x80000000)
					} else {
						v6 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v6
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v8 = int32(silk_int32_MAX)
					} else {
						v8 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v8
				}
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v13 = libc.Int32FromUint32(0x80000000)
					} else {
						v13 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v13
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v16 = int32(silk_int32_MAX)
					} else {
						v16 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v16
				}
				v22 = int64(v2)*int64(rc_mult2)>>int32(1) + int64(v9)*int64(rc_mult2)&int64(1)
			} else {
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v18 = libc.Int32FromUint32(0x80000000)
					} else {
						v18 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v18
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v19 = int32(silk_int32_MAX)
					} else {
						v19 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v19
				}
				v22 = (int64(v17)*int64(rc_mult2)>>(mult2Q-int32(1)) + int64(1)) >> int32(1)
			}
			tmp64 = v22
			if tmp64 > int64(silk_int32_MAX) || tmp64 < int64(libc.Int32FromUint32(0x80000000)) {
				return 0
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k-n-int32(1))*4)) = int32(tmp64)
			goto _21
		_21:
			;
			n = n + 1
		}
		goto _1
	_1:
		;
		k = k - 1
	}
	/* Check for stability */
	if *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) > int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) || *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) < -int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) {
		return 0
	}
	/* Set RC equal to negated AR coef */
	rc_Q31 = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(A_QA))) << (libc.Int32FromInt32(31) - libc.Int32FromInt32(QA)))
	/* Range: [ 1 : 2^30 ] */
	rc_mult1_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) - int32(int64(rc_Q31)*int64(rc_Q31)>>libc.Int32FromInt32(32))
	/* Update inverse gain */
	/* Range: [ 0 : 2^30 ] */
	invGain_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(invGain_Q30)*int64(rc_mult1_Q30)>>libc.Int32FromInt32(32))) << libc.Int32FromInt32(2))
	_ = invGain_Q30 >= libc.Int32FromInt32(0)
	_ = invGain_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
	if invGain_Q30 < int32(float64(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(10000)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) {
		return 0
	}
	return invGain_Q30
}

// C documentation
//
//	/* For input in Q12 domain */
func Opus_silk_LPC_inverse_pred_gain_c(tls *libc.TLS, A_Q12 uintptr, order int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var DC_resp OpusT_opus_int32
	var k int32
	var _ /* Atmp_QA at bp+0 */ [24]OpusT_opus_int32
	_, _ = DC_resp, k
	DC_resp = 0
	/* Increase Q domain of the AR coefficients */
	k = 0
	for {
		if !(k < order) {
			break
		}
		DC_resp = DC_resp + int32(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q12 + uintptr(k)*2)))
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp)))[k] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q12 + uintptr(k)*2)))) << (libc.Int32FromInt32(QA) - libc.Int32FromInt32(12)))
		goto _1
	_1:
		;
		k = k + 1
	}
	/* If the DC is unstable, we don't even need to do the full calculations */
	if DC_resp >= int32(4096) {
		return 0
	}
	return LPC_inverse_pred_gain_QA_c(tls, bp, order)
}

const silk_int16_MAX15 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Convert int32 coefficients to int16 coefs and make sure there's no wrap-around.
//	   This logic is reused in _celt_lpc(). Any bug fixes should also be applied there. */
func Opus_silk_LPC_fit(tls *libc.TLS, a_QOUT uintptr, a_QIN uintptr, QOUT int32, QIN int32, d int32) {
	var absval, chirp_Q16, maxabs OpusT_opus_int32
	var i, idx, k, v3, v4, v5, v7, v8 int32
	_, _, _, _, _, _, _, _, _, _, _ = absval, chirp_Q16, i, idx, k, maxabs, v3, v4, v5, v7, v8
	idx = 0
	/* Limit the maximum absolute value of the prediction coefficients, so that they'll fit in int16 */
	i = 0
	for {
		if !(i < int32(10)) {
			break
		}
		/* Find maximum absolute value and its index */
		maxabs = 0
		k = 0
		for {
			if !(k < d) {
				break
			}
			if *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4)) > 0 {
				v3 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))
			} else {
				v3 = -*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))
			}
			absval = v3
			if absval > maxabs {
				maxabs = absval
				idx = k
			}
			goto _2
		_2:
			;
			k = k + 1
		}
		if QIN-QOUT == int32(1) {
			v3 = maxabs>>libc.Int32FromInt32(1) + maxabs&int32(1)
		} else {
			v3 = (maxabs>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		}
		maxabs = v3
		if maxabs > int32(silk_int16_MAX15) {
			/* Reduce magnitude of prediction coefficients */
			if maxabs < int32(163838) {
				v3 = maxabs
			} else {
				v3 = int32(163838)
			}
			maxabs = v3 /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
			chirp_Q16 = int32(float64(libc.Float64FromFloat64(0.999)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)) - libc.Int32FromUint32(libc.Uint32FromInt32(maxabs-libc.Int32FromInt32(silk_int16_MAX15))<<libc.Int32FromInt32(14))/(maxabs*(idx+libc.Int32FromInt32(1))>>libc.Int32FromInt32(2))
			Opus_silk_bwexpander_32(tls, a_QIN, d, chirp_Q16)
		} else {
			break
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if i == int32(10) {
		/* Reached the last iteration, clip the coefficients */
		k = 0
		for {
			if !(k < d) {
				break
			}
			if QIN-QOUT == int32(1) {
				v4 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
			} else {
				v4 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			if v4 > int32(silk_int16_MAX15) {
				v3 = int32(silk_int16_MAX15)
			} else {
				if QIN-QOUT == int32(1) {
					v7 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
				} else {
					v7 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				if v7 < int32(libc.Int16FromInt32(0x8000)) {
					v5 = int32(libc.Int16FromInt32(0x8000))
				} else {
					if QIN-QOUT == int32(1) {
						v8 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
					} else {
						v8 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v5 = v8
				}
				v3 = v5
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)) = int16(v3)
			*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)))) << (QIN - QOUT))
			goto _6
		_6:
			;
			k = k + 1
		}
	} else {
		k = 0
		for {
			if !(k < d) {
				break
			}
			if QIN-QOUT == int32(1) {
				v3 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
			} else {
				v3 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)) = int16(v3)
			goto _12
		_12:
			;
			k = k + 1
		}
	}
}

const MAX_PREDICTION_POWER_GAIN2 = "1e4f"
const silk_int16_MAX16 = 0x7FFF
const QA1 = 16

// C documentation
//
//	/* helper function for NLSF2A(..) */
func silk_NLSF2A_find_poly(tls *libc.TLS, out uintptr, cLSF uintptr, dd int32) {
	var ftmp OpusT_opus_int32
	var k, n int32
	_, _, _ = ftmp, k, n
	*(*OpusT_opus_int32)(unsafe.Pointer(out)) = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << libc.Int32FromInt32(QA1))
	*(*OpusT_opus_int32)(unsafe.Pointer(out + 1*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(cLSF))
	k = int32(1)
	for {
		if !(k < dd) {
			break
		}
		ftmp = *(*OpusT_opus_int32)(unsafe.Pointer(cLSF + uintptr(int32(2)*k)*4)) /* QA*/
		*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k+int32(1))*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k-int32(1))*4)))<<libc.Int32FromInt32(1)) - int32((int64(ftmp)*int64(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k)*4)))>>(libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
		n = k
		for {
			if !(n > int32(1)) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n)*4)) += *(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n-int32(2))*4)) - int32((int64(ftmp)*int64(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n-int32(1))*4)))>>(libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
			goto _2
		_2:
			;
			n = n - 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(out + 1*4)) -= ftmp
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* compute whitening filter coefficients from normalized line spectral frequencies */
func Opus_silk_NLSF2A(tls *libc.TLS, a_Q12 uintptr, NLSF uintptr, d int32, arch int32) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var Ptmp, Qtmp, cos_val, delta, f_frac, f_int OpusT_opus_int32
	var dd, i, k int32
	var ordering, v1 uintptr
	var _ /* P at bp+96 */ [13]OpusT_opus_int32
	var _ /* Q at bp+148 */ [13]OpusT_opus_int32
	var _ /* a32_QA1 at bp+200 */ [24]OpusT_opus_int32
	var _ /* cos_LSF_QA at bp+0 */ [24]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = Ptmp, Qtmp, cos_val, dd, delta, f_frac, f_int, i, k, ordering, v1
	_ = true
	if !(d == int32(10) || d == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+7246, __ccgo_ts+7279, int32(89))
	}
	/* convert LSFs to 2*cos(LSF), using piecewise linear curve from table */
	if d == int32(16) {
		v1 = uintptr(unsafe.Pointer(&ordering16))
	} else {
		v1 = uintptr(unsafe.Pointer(&ordering10))
	}
	ordering = v1
	k = 0
	for {
		if !(k < d) {
			break
		}
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) >= libc.Int32FromInt32(0)
		/* f_int on a scale 0-127 (rounded down) */
		f_int = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) >> (libc.Int32FromInt32(15) - libc.Int32FromInt32(7))
		/* f_frac, range: 0..255 */
		f_frac = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(f_int)<<(libc.Int32FromInt32(15)-libc.Int32FromInt32(7)))
		_ = f_int >= libc.Int32FromInt32(0)
		_ = f_int < libc.Int32FromInt32(LSF_COS_TAB_SZ_FIX)
		/* Read start and end value from table */
		cos_val = int32(Opus_silk_LSFCosTab_FIX_Q12[f_int])                  /* Q12 */
		delta = int32(Opus_silk_LSFCosTab_FIX_Q12[f_int+int32(1)]) - cos_val /* Q12, with a range of 0..200 */
		/* Linear interpolation */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp)))[*(*uint8)(unsafe.Pointer(ordering + uintptr(k)))] = ((libc.Int32FromUint32(libc.Uint32FromInt32(cos_val)<<libc.Int32FromInt32(8))+delta*f_frac)>>(libc.Int32FromInt32(20)-libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1) /* QA */
		goto _2
	_2:
		;
		k = k + 1
	}
	dd = d >> libc.Int32FromInt32(1)
	/* generate even and odd polynomials using convolution */
	silk_NLSF2A_find_poly(tls, bp+96, bp, dd)
	silk_NLSF2A_find_poly(tls, bp+148, bp+1*4, dd)
	/* convert even and odd polynomials to opus_int32 Q12 filter coefs */
	k = 0
	for {
		if !(k < dd) {
			break
		}
		Ptmp = (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 96)))[k+int32(1)] + (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 96)))[k]
		Qtmp = (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 148)))[k+int32(1)] - (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 148)))[k]
		/* the Ptmp and Qtmp values at this stage need to fit in int32 */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[k] = -Qtmp - Ptmp           /* QA+1 */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[d-k-int32(1)] = Qtmp - Ptmp /* QA+1 */
		goto _3
	_3:
		;
		k = k + 1
	}
	/* Convert int32 coefficients to Q12 int16 coefs */
	Opus_silk_LPC_fit(tls, a_Q12, bp+200, int32(12), libc.Int32FromInt32(QA1)+libc.Int32FromInt32(1), d)
	i = 0
	for {
		_ = arch
		if !(Opus_silk_LPC_inverse_pred_gain_c(tls, a_Q12, d) == 0 && i < int32(MAX_LPC_STABILIZE_ITERATIONS)) {
			break
		}
		/* Prediction coefficients are (too close to) unstable; apply bandwidth expansion   */
		/* on the unscaled coefficients, convert to Q12 and measure again                   */
		Opus_silk_bwexpander_32(tls, bp+200, d, int32(65536)-libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(2))<<i))
		k = 0
		for {
			if !(k < d) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_Q12 + uintptr(k)*2)) = int16(((*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[k]>>(libc.Int32FromInt32(QA1)+libc.Int32FromInt32(1)-libc.Int32FromInt32(12)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)) /* QA+1 -> Q12 */
			goto _5
		_5:
			;
			k = k + 1
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

/*
This ordering was found to maximize quality. It improves numerical accuracy of

	silk_NLSF2A_find_poly() compared to "standard" ordering.
*/
var ordering16 = [16]uint8{
	1:  uint8(15),
	2:  uint8(8),
	3:  uint8(7),
	4:  uint8(4),
	5:  uint8(11),
	6:  uint8(12),
	7:  uint8(3),
	8:  uint8(2),
	9:  uint8(13),
	10: uint8(10),
	11: uint8(5),
	12: uint8(6),
	13: uint8(9),
	14: uint8(14),
	15: uint8(1),
}

var ordering10 = [10]uint8{
	1: uint8(9),
	2: uint8(6),
	3: uint8(3),
	4: uint8(4),
	5: uint8(5),
	6: uint8(8),
	7: uint8(1),
	8: uint8(2),
	9: uint8(7),
}

const MAX_LOOPS = 20
const silk_int16_MAX17 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/* Constant Definitions */

// C documentation
//
//	/* NLSF stabilizer, for a single input data vector */
func Opus_silk_NLSF_stabilize(tls *libc.TLS, NLSF_Q15 uintptr, NDeltaMin_Q15 uintptr, L int32) {
	var I, i, k, loops, v10, v5, v6, v7, v8, v9 int32
	var center_freq_Q15 OpusT_opus_int16
	var diff_Q15, max_center_Q15, min_center_Q15, min_diff_Q15 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = I, center_freq_Q15, diff_Q15, i, k, loops, max_center_Q15, min_center_Q15, min_diff_Q15, v10, v5, v6, v7, v8, v9
	I = 0
	/* This is necessary to ensure an output within range of a opus_int16 */
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))) >= libc.Int32FromInt32(1)
	loops = 0
	for {
		if !(loops < int32(MAX_LOOPS)) {
			break
		}
		/**************************/
		/* Find smallest distance */
		/**************************/
		/* First element */
		min_diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15)))
		I = 0
		/* Middle elements */
		i = int32(1)
		for {
			if !(i <= L-int32(1)) {
				break
			}
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2))) - (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))))
			if diff_Q15 < min_diff_Q15 {
				min_diff_Q15 = diff_Q15
				I = i
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		/* Last element */
		diff_Q15 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))))
		if diff_Q15 < min_diff_Q15 {
			min_diff_Q15 = diff_Q15
			I = L
		}
		/***************************************************/
		/* Now check if the smallest distance non-negative */
		/***************************************************/
		if min_diff_Q15 >= 0 {
			return
		}
		if I == 0 {
			/* Move away from lower limit */
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)) = *(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15))
		} else {
			if I == L {
				/* Move away from higher limit */
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)) = int16(libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))))
			} else {
				/* Find the lower extreme for the location of the current center frequency */
				min_center_Q15 = 0
				k = 0
				for {
					if !(k < I) {
						break
					}
					min_center_Q15 = min_center_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(k)*2)))
					goto _3
				_3:
					;
					k = k + 1
				}
				min_center_Q15 = min_center_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1)
				/* Find the upper extreme for the location of the current center frequency */
				max_center_Q15 = libc.Int32FromInt32(1) << libc.Int32FromInt32(15)
				k = L
				for {
					if !(k > I) {
						break
					}
					max_center_Q15 = max_center_Q15 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(k)*2)))
					goto _4
				_4:
					;
					k = k - 1
				}
				max_center_Q15 = max_center_Q15 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1)
				/* Move apart, sorted by value, keeping the same center frequency */
				if min_center_Q15 > max_center_Q15 {
					if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) > min_center_Q15 {
						v6 = min_center_Q15
					} else {
						if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) < max_center_Q15 {
							v7 = max_center_Q15
						} else {
							v7 = (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1) + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1)
						}
						v6 = v7
					}
					v5 = v6
				} else {
					if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) > max_center_Q15 {
						v8 = max_center_Q15
					} else {
						if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) < min_center_Q15 {
							v9 = min_center_Q15
						} else {
							v9 = (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1) + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1)
						}
						v8 = v9
					}
					v5 = v8
				}
				center_freq_Q15 = int16(v5)
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)) = int16(int32(center_freq_Q15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1))
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2))))
			}
		}
		goto _1
	_1:
		;
		loops = loops + 1
	}
	/* Safe and simple fall back method, which is less ideal than the above */
	if loops == int32(MAX_LOOPS) {
		/* Insertion sort (fast for already almost sorted arrays):   */
		/* Best case:  O(n)   for an already sorted array            */
		/* Worst case: O(n^2) for an inversely sorted array          */
		Opus_silk_insertion_sort_increasing_all_values_int16(tls, NLSF_Q15, L)
		/* First NLSF should be no less than NDeltaMin[0] */
		v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)))
		v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15)))
		if v5 > v6 {
			v8 = v5
		} else {
			v8 = v6
		}
		v7 = v8
		goto _13
	_13:
		*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)) = int16(v7)
		/* Keep delta_min distance between the NLSFs */
		i = int32(1)
		for {
			if !(i < L) {
				break
			}
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))) > int32(silk_int16_MAX17) {
				v5 = int32(silk_int16_MAX17)
			} else {
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))) < int32(libc.Int16FromInt32(0x8000)) {
					v6 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2)))
				}
				v5 = v6
			}
			v7 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)))
			v8 = int32(int16(v5))
			if v7 > v8 {
				v10 = v7
			} else {
				v10 = v8
			}
			v9 = v10
			goto _21
		_21:
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)) = int16(v9)
			goto _15
		_15:
			;
			i = i + 1
		}
		/* Last NLSF should be no higher than 1 - NDeltaMin[L] */
		v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)))
		v6 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2)))
		if v5 < v6 {
			v8 = v5
		} else {
			v8 = v6
		}
		v7 = v8
		goto _26
	_26:
		*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)) = int16(v7)
		/* Keep NDeltaMin distance between the NLSFs */
		i = L - int32(2)
		for {
			if !(i >= 0) {
				break
			}
			v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)))
			v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i+int32(1))*2)))
			if v5 < v6 {
				v8 = v5
			} else {
				v8 = v6
			}
			v7 = v8
			goto _32
		_32:
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)) = int16(v7)
			goto _28
		_28:
			;
			i = i - 1
		}
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/*
R. Laroia, N. Phamdo and N. Farvardin, "Robust and Efficient Quantization of Speech LSP
Parameters Using Structured Vector Quantization", Proc. IEEE Int. Conf. Acoust., Speech,
Signal Processing, pp. 641-644, 1991.
*/

// C documentation
//
//	/* Laroia low complexity NLSF weights */
func Opus_silk_NLSF_VQ_weights_laroia(tls *libc.TLS, pNLSFW_Q_OUT uintptr, pNLSF_Q15 uintptr, D int32) {
	var k, v1, v2, v3, v5 int32
	var tmp1_int, tmp2_int OpusT_opus_int32
	_, _, _, _, _, _, _ = k, tmp1_int, tmp2_int, v1, v2, v3, v5
	if !(D > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7296, __ccgo_ts+7320, int32(51))
	}
	if !(D&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7353, __ccgo_ts+7320, int32(52))
	}
	/* First value */
	v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _4
_4:
	tmp1_int = v3
	tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
	v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + 1*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _9
_9:
	tmp2_int = v3
	tmp2_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp2_int
	v1 = tmp1_int + tmp2_int
	v2 = int32(silk_int16_MAX17)
	if v1 < v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _14
_14:
	*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT)) = int16(v3)
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT))) > libc.Int32FromInt32(0)
	/* Main loop */
	k = int32(1)
	for {
		if !(k < D-int32(1)) {
			break
		}
		v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k)*2)))
		v2 = int32(1)
		if v1 > v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _20
	_20:
		tmp1_int = v3
		tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
		v1 = tmp1_int + tmp2_int
		v2 = int32(silk_int16_MAX17)
		if v1 < v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _25
	_25:
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k)*2)) = int16(v3)
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k)*2))) > libc.Int32FromInt32(0)
		v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(2))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(1))*2)))
		v2 = int32(1)
		if v1 > v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _30
	_30:
		tmp2_int = v3
		tmp2_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp2_int
		v1 = tmp1_int + tmp2_int
		v2 = int32(silk_int16_MAX17)
		if v1 < v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _35
	_35:
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k+int32(1))*2)) = int16(v3)
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k+int32(1))*2))) > libc.Int32FromInt32(0)
		goto _16
	_16:
		;
		k = k + int32(2)
	}
	/* Last value */
	v1 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(D-int32(1))*2)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _40
_40:
	tmp1_int = v3
	tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
	v1 = tmp1_int + tmp2_int
	v2 = int32(silk_int16_MAX17)
	if v1 < v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _45
_45:
	*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(D-int32(1))*2)) = int16(v3)
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(D-int32(1))*2))) > libc.Int32FromInt32(0)
}

const silk_int16_MAX18 = 0x7FFF
const RESAMPLER_DOWN_ORDER_FIR0 = 18
const RESAMPLER_DOWN_ORDER_FIR1 = 24
const RESAMPLER_DOWN_ORDER_FIR2 = 36
const RESAMPLER_MAX_BATCH_SIZE_MS = 10
const RESAMPLER_MAX_FS_KHZ = 48
const RESAMPLER_ORDER_FIR_12 = 8
const USE_silk_resampler_copy = 0
const USE_silk_resampler_private_IIR_FIR = 2
const USE_silk_resampler_private_down_FIR = 3
const USE_silk_resampler_private_up2_HQ_wrapper = 1

var silk_resampler_down2_0 = int16(9872)
var silk_resampler_down2_1 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_0 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_1 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Tables with delay compensation values to equalize total delay for different modes */
var delay_matrix_enc = [6][3]OpusT_opus_int8{
	0: {
		0: int8(6),
		2: int8(3),
	},
	1: {
		1: int8(7),
		2: int8(3),
	},
	2: {
		1: int8(1),
		2: int8(10),
	},
	3: {
		1: int8(2),
		2: int8(6),
	},
	4: {
		0: int8(18),
		1: int8(10),
		2: int8(12),
	},
	5: {
		2: int8(44),
	},
}

var delay_matrix_dec = [3][6]OpusT_opus_int8{
	0: {
		0: int8(4),
		2: int8(2),
	},
	1: {
		1: int8(9),
		2: int8(4),
		3: int8(7),
		4: int8(4),
		5: int8(4),
	},
	2: {
		1: int8(3),
		2: int8(12),
		3: int8(7),
		4: int8(7),
		5: int8(7),
	},
}

/* Simple way to make [8000, 12000, 16000, 24000, 48000] to [0, 1, 2, 3, 4] */

// C documentation
//
//	/* Initialize/reset the resampler state for a given pair of input/output sampling rates */
func Opus_silk_resampler_init(tls *libc.TLS, S uintptr, Fs_Hz_in OpusT_opus_int32, Fs_Hz_out OpusT_opus_int32, forEnc int32) (r int32) {
	var up2x, v1, v2 int32
	_, _, _ = up2x, v1, v2
	/* Clear state */
	libc.Xmemset(tls, S, 0, libc.Uint64FromInt64(400))
	/* Input checking */
	if forEnc != 0 {
		if Fs_Hz_in != int32(8000) && Fs_Hz_in != int32(12000) && Fs_Hz_in != int32(16000) && Fs_Hz_in != int32(24000) && Fs_Hz_in != int32(48000) || Fs_Hz_out != int32(8000) && Fs_Hz_out != int32(12000) && Fs_Hz_out != int32(16000) {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7386, int32(99))
			}
			return -int32(1)
		}
		if int32(5) < (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000))-int32(1) {
			v1 = int32(5)
		} else {
			v1 = (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000)) - int32(1)
		}
		if int32(5) < (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000))-int32(1) {
			v2 = int32(5)
		} else {
			v2 = (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000)) - int32(1)
		}
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay = int32(*(*OpusT_opus_int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&delay_matrix_enc)) + uintptr(v1)*3 + uintptr(v2))))
	} else {
		if Fs_Hz_in != int32(8000) && Fs_Hz_in != int32(12000) && Fs_Hz_in != int32(16000) || Fs_Hz_out != int32(8000) && Fs_Hz_out != int32(12000) && Fs_Hz_out != int32(16000) && Fs_Hz_out != int32(24000) && Fs_Hz_out != int32(48000) {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7386, int32(110))
			}
			return -int32(1)
		}
		if int32(5) < (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000))-int32(1) {
			v1 = int32(5)
		} else {
			v1 = (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000)) - int32(1)
		}
		if int32(5) < (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000))-int32(1) {
			v2 = int32(5)
		} else {
			v2 = (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000)) - int32(1)
		}
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay = int32(*(*OpusT_opus_int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&delay_matrix_dec)) + uintptr(v1)*6 + uintptr(v2))))
	}
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz = Fs_Hz_in / libc.Int32FromInt32(1000)
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz = Fs_Hz_out / libc.Int32FromInt32(1000)
	/* Number of samples processed per batch */
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz * int32(RESAMPLER_MAX_BATCH_SIZE_MS)
	/* Find resampler with the right sampling ratio */
	up2x = 0
	if Fs_Hz_out > Fs_Hz_in {
		/* Upsample */
		if Fs_Hz_out == Fs_Hz_in*int32(2) { /* Fs_out : Fs_in = 2 : 1 */
			/* Special case: directly use 2x upsampler */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_up2_HQ_wrapper)
		} else {
			/* Default resampler */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_IIR_FIR)
			up2x = int32(1)
		}
	} else {
		if Fs_Hz_out < Fs_Hz_in {
			/* Downsample */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_down_FIR)
			if Fs_Hz_out*int32(4) == Fs_Hz_in*int32(3) { /* Fs_out : Fs_in = 3 : 4 */
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(3)
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR0)
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_3_4_COEFS))
			} else {
				if Fs_Hz_out*int32(3) == Fs_Hz_in*int32(2) { /* Fs_out : Fs_in = 2 : 3 */
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(2)
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR0)
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_2_3_COEFS))
				} else {
					if Fs_Hz_out*int32(2) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 2 */
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR1)
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_2_COEFS))
					} else {
						if Fs_Hz_out*int32(3) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 3 */
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_3_COEFS))
						} else {
							if Fs_Hz_out*int32(4) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 4 */
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_4_COEFS))
							} else {
								if Fs_Hz_out*int32(6) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 6 */
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_6_COEFS))
								} else {
									/* None available */
									if !(libc.Int32FromInt32(0) != 0) {
										Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7386, int32(163))
									}
									return -int32(1)
								}
							}
						}
					}
				}
			}
		} else {
			/* Input and output sampling rates are equal: copy */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = USE_silk_resampler_copy
		}
	}
	/* Ratio of input/output samples */
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(Fs_Hz_in)<<(libc.Int32FromInt32(14)+up2x))/Fs_Hz_out) << libc.Int32FromInt32(2))
	/* Make sure the ratio is rounded up */
	for int32(int64((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16)*int64(Fs_Hz_out)>>libc.Int32FromInt32(16)) < libc.Int32FromUint32(libc.Uint32FromInt32(Fs_Hz_in)<<up2x) {
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 + 1
	}
	return 0
}

// C documentation
//
//	/* Resampler: convert from one sampling rate to another */
//	/* Input and output sampling rate are at most 48000 Hz  */
func Opus_silk_resampler(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) (r int32) {
	var nSamples int32
	_ = nSamples
	/* Need at least 1 ms of input data */
	if !(inLen >= (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz) {
		Opus_celt_fatal(tls, __ccgo_ts+7406, __ccgo_ts+7386, int32(193))
	}
	/* Delay can't exceed the 1 ms of buffering */
	if !((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay <= (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz) {
		Opus_celt_fatal(tls, __ccgo_ts+7446, __ccgo_ts+7386, int32(195))
	}
	nSamples = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz - (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay
	/* Copy to delay buffer */
	libc.Xmemcpy(tls, S+168+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*2, in, libc.Uint64FromInt32(nSamples)*libc.Uint64FromInt64(2))
	switch (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function {
	case int32(USE_silk_resampler_private_up2_HQ_wrapper):
		Opus_silk_resampler_private_up2_HQ_wrapper(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_up2_HQ_wrapper(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	case int32(USE_silk_resampler_private_IIR_FIR):
		Opus_silk_resampler_private_IIR_FIR(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_IIR_FIR(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	case int32(USE_silk_resampler_private_down_FIR):
		Opus_silk_resampler_private_down_FIR(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_down_FIR(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	default:
		libc.Xmemcpy(tls, out, S+168, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, libc.Uint64FromInt32(inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)*libc.Uint64FromInt64(2))
	}
	/* Copy to delay buffer */
	libc.Xmemcpy(tls, S+168, in+uintptr(inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*2, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*libc.Uint64FromInt64(2))
	return 0
}

const ORDER_FIR = 4
const silk_int16_MAX19 = 32767

var silk_resampler_down2_01 = int16(9872)
var silk_resampler_down2_11 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_01 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_11 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Downsample by a factor 2/3, low quality */
func Opus_silk_resampler_down2_3(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var _saved_stack, buf, buf_ptr, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var counter, nSamplesIn, res_Q6 OpusT_opus_int32
	var v29, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, buf, buf_ptr, counter, nSamplesIn, res_Q6, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v31, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7494, int32(51))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
	/* Iterate over blocks of frameSizeIn input samples */
	for int32(1) != 0 {
		if inLen < libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ) {
			v29 = inLen
		} else {
			v29 = libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS) * libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)
		}
		nSamplesIn = v29
		/* Second-order AR filter (output in Q8) */
		Opus_silk_resampler_private_AR2(tls, S+4*4, buf+4*4, in, uintptr(unsafe.Pointer(&Opus_silk_Resampler_2_3_COEFS_LQ)), nSamplesIn)
		/* Interpolate filtered signal */
		buf_ptr = buf
		counter = nSamplesIn
		for counter > int32(2) {
			/* Inner product */
			res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))) * int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(2)]) >> libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(3)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(5)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(4)])>>libc.Int32FromInt32(16))
			/* Scale down, saturate and store in output array */
			v1 = out
			out += 2
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX19) {
				v29 = int32(silk_int16_MAX19)
			} else {
				if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v31 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v31 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v29 = v31
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = int16(v29)
			res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))) * int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(4)]) >> libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(5)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(3)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(2)])>>libc.Int32FromInt32(16))
			/* Scale down, saturate and store in output array */
			v1 = out
			out += 2
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX19) {
				v29 = int32(silk_int16_MAX19)
			} else {
				if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v31 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v31 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v29 = v31
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = int16(v29)
			buf_ptr = buf_ptr + uintptr(3)*4
			counter = counter - int32(3)
		}
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > 0 {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _39
_39:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_02 = int16(9872)
var silk_resampler_down2_12 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_02 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_12 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Downsample by a factor 2 */
func Opus_silk_resampler_down2(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var X, Y, in32, k, len2, out32 OpusT_opus_int32
	var v2, v3 int32
	_, _, _, _, _, _, _, _ = X, Y, in32, k, len2, out32, v2, v3
	len2 = inLen >> int32(1)
	if !(int32(silk_resampler_down2_02) > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7522, __ccgo_ts+7567, int32(46))
	}
	if !(int32(silk_resampler_down2_12) < libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7593, __ccgo_ts+7567, int32(47))
	}
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < len2) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k)*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for even input sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_down2_12)>>libc.Int32FromInt32(16))
		out32 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for odd input sample, and add to output of previous section */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(silk_resampler_down2_02) >> libc.Int32FromInt32(16))
		out32 = out32 + *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		out32 = out32 + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = in32 + X
		/* Add, convert back to int16 and store to output */
		if (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX19) {
			v2 = int32(silk_int16_MAX19)
		} else {
			if (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX20 = 0x7FFF

var silk_resampler_down2_03 = int16(9872)
var silk_resampler_down2_13 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_03 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_13 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Second order AR filter with single delay elements */
func Opus_silk_resampler_private_AR2(tls *libc.TLS, S uintptr, out_Q8 uintptr, in uintptr, A_Q14 uintptr, len1 OpusT_opus_int32) {
	var k, out32 OpusT_opus_int32
	_, _ = k, out32
	k = 0
	for {
		if !(k < len1) {
			break
		}
		out32 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2))))<<libc.Int32FromInt32(8))
		*(*OpusT_opus_int32)(unsafe.Pointer(out_Q8 + uintptr(k)*4)) = out32
		out32 = libc.Int32FromUint32(libc.Uint32FromInt32(out32) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q14)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(out32) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q14 + 1*2))) >> libc.Int32FromInt32(16))
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX21 = 32767

var silk_resampler_down2_04 = int16(9872)
var silk_resampler_down2_14 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_04 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_14 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

func silk_resampler_private_down_FIR_INTERPOL(tls *libc.TLS, out uintptr, buf uintptr, FIR_Coefs uintptr, FIR_Order int32, FIR_Fracs int32, max_index_Q16 OpusT_opus_int32, index_increment_Q16 OpusT_opus_int32) (r uintptr) {
	var buf_ptr, interpol_ptr, v9 uintptr
	var index_Q16, interpol_ind, res_Q6 OpusT_opus_int32
	var v10, v11 int32
	_, _, _, _, _, _, _, _ = buf_ptr, index_Q16, interpol_ind, interpol_ptr, res_Q6, v10, v11, v9
	switch FIR_Order {
	case int32(RESAMPLER_DOWN_ORDER_FIR0):
		goto _1
	case int32(RESAMPLER_DOWN_ORDER_FIR1):
		goto _2
	case int32(RESAMPLER_DOWN_ORDER_FIR2):
		goto _3
	default:
		goto _4
	}
	goto _5
_1:
	;
	index_Q16 = 0
_8:
	;
	if !(index_Q16 < max_index_Q16) {
		goto _6
	}
	/* Integer part gives pointer to buffered input */
	buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
	/* Fractional part gives interpolation coefficients */
	interpol_ind = int32(int64(index_Q16&libc.Int32FromInt32(0xFFFF)) * int64(int16(FIR_Fracs)) >> libc.Int32FromInt32(16))
	/* Inner product */
	interpol_ptr = FIR_Coefs + uintptr(libc.Int32FromInt32(RESAMPLER_DOWN_ORDER_FIR0)/libc.Int32FromInt32(2)*interpol_ind)*2
	res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr))) >> libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 1*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 2*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 3*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 4*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 5*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 6*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 7*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 8*2)))>>libc.Int32FromInt32(16))
	interpol_ptr = FIR_Coefs + uintptr(libc.Int32FromInt32(RESAMPLER_DOWN_ORDER_FIR0)/libc.Int32FromInt32(2)*(FIR_Fracs-int32(1)-interpol_ind))*2
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 1*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 2*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 3*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 4*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 5*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 6*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 7*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 8*2)))>>libc.Int32FromInt32(16))
	/* Scale down, saturate and store in output array */
	v9 = out
	out += 2
	if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
		v10 = int32(silk_int16_MAX21)
	} else {
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
			v11 = int32(libc.Int16FromInt32(0x8000))
		} else {
			v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		}
		v10 = v11
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
	goto _7
_7:
	;
	index_Q16 = index_Q16 + index_increment_Q16
	goto _8
	goto _6
_6:
	;
	goto _5
_2:
	;
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		/* Integer part gives pointer to buffered input */
		buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
		/* Inner product */
		res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 23*4))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs))) >> libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 22*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 1*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 21*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 2*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 20*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 3*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 19*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 4*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 18*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 5*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 6*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 7*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 8*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 9*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 10*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 11*2)))>>libc.Int32FromInt32(16))
		/* Scale down, saturate and store in output array */
		v9 = out
		out += 2
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
			v10 = int32(silk_int16_MAX21)
		} else {
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v11 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v10 = v11
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
		goto _12
	_12:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	goto _5
_3:
	;
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		/* Integer part gives pointer to buffered input */
		buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
		/* Inner product */
		res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 35*4))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs))) >> libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 34*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 1*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 33*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 2*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 32*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 3*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 31*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 4*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 30*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 5*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 29*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 6*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 28*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 7*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 27*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 8*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 26*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 9*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 25*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 10*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 24*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 11*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 23*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 12*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 22*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 13*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 21*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 14*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 20*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 15*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 19*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 16*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 18*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 17*2)))>>libc.Int32FromInt32(16))
		/* Scale down, saturate and store in output array */
		v9 = out
		out += 2
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
			v10 = int32(silk_int16_MAX21)
		} else {
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v11 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v10 = v11
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
		goto _16
	_16:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	goto _5
_4:
	;
	if !(libc.Int32FromInt32(0) != 0) {
		Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7638, int32(139))
	}
_5:
	;
	return out
}

// C documentation
//
//	/* Resample with a 2nd order AR filter followed by FIR interpolation */
func Opus_silk_resampler_private_down_FIR(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var FIR_Coefs, S, _saved_stack, buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var index_increment_Q16, max_index_Q16, nSamplesIn OpusT_opus_int32
	var v29 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = FIR_Coefs, S, _saved_stack, buf, index_increment_Q16, max_index_Q16, nSamplesIn, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	S = SS
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7638, int32(159))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S+24, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
	FIR_Coefs = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs + 2*2
	/* Iterate over blocks of frameSizeIn input samples */
	index_increment_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16
	for int32(1) != 0 {
		if inLen < (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize {
			v29 = inLen
		} else {
			v29 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize
		}
		nSamplesIn = v29
		/* Second-order AR filter (output in Q8) */
		Opus_silk_resampler_private_AR2(tls, S, buf+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*4, in, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs, nSamplesIn)
		max_index_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(nSamplesIn) << libc.Int32FromInt32(16))
		/* Interpolate filtered signal */
		out = silk_resampler_private_down_FIR_INTERPOL(tls, out, buf, FIR_Coefs, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs, max_index_Q16, index_increment_Q16)
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > int32(1) {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S+24, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_05 = int16(9872)
var silk_resampler_down2_15 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_05 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_15 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

func silk_resampler_private_IIR_FIR_INTERPOL(tls *libc.TLS, out uintptr, buf uintptr, max_index_Q16 OpusT_opus_int32, index_increment_Q16 OpusT_opus_int32) (r uintptr) {
	var buf_ptr, v2 uintptr
	var index_Q16, res_Q15, table_index OpusT_opus_int32
	var v3, v4 int32
	_, _, _, _, _, _, _ = buf_ptr, index_Q16, res_Q15, table_index, v2, v3, v4
	/* Interpolate upsampled signal and store in output array */
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		table_index = int32(int64(index_Q16&libc.Int32FromInt32(0xFFFF)) * int64(int16(libc.Int32FromInt32(12))) >> libc.Int32FromInt32(16))
		buf_ptr = buf + uintptr(index_Q16>>int32(16))*2
		res_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 1*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 1*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 2*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 2*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 3*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 3*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 4*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 3*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 5*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 2*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 6*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 1*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 7*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8)))
		v2 = out
		out += 2
		if (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
			v3 = int32(silk_int16_MAX21)
		} else {
			if (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v3 = v4
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v2)) = int16(v3)
		goto _1
	_1:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	return out
}

// C documentation
//
//	/* Upsample using a combination of allpass-based 2x upsampling and FIR interpolation */
func Opus_silk_resampler_private_IIR_FIR(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var S, _saved_stack, buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var index_increment_Q16, max_index_Q16, nSamplesIn OpusT_opus_int32
	var v29 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = S, _saved_stack, buf, index_increment_Q16, max_index_Q16, nSamplesIn, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	S = SS
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7675, int32(78))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12)) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S+24, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
	/* Iterate over blocks of frameSizeIn input samples */
	index_increment_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16
	for int32(1) != 0 {
		if inLen < (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize {
			v29 = inLen
		} else {
			v29 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize
		}
		nSamplesIn = v29
		/* Upsample 2x */
		Opus_silk_resampler_private_up2_HQ(tls, S, buf+8*2, in, nSamplesIn)
		max_index_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(nSamplesIn) << (libc.Int32FromInt32(16) + libc.Int32FromInt32(1))) /* + 1 because 2x upsampling */
		out = silk_resampler_private_IIR_FIR_INTERPOL(tls, out, buf, max_index_Q16, index_increment_Q16)
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > 0 {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn<<int32(1))*2, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S+24, buf+uintptr(nSamplesIn<<int32(1))*2, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_06 = int16(9872)
var silk_resampler_down2_16 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_06 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_16 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Upsample by a factor 2, high quality */
//	/* Uses 2nd order allpass filters for the 2x upsampling, followed by a      */
//	/* notch filter just above Nyquist.                                         */
func Opus_silk_resampler_private_up2_HQ(tls *libc.TLS, S uintptr, out uintptr, in uintptr, len1 OpusT_opus_int32) {
	var X, Y, in32, k, out32_1, out32_2 OpusT_opus_int32
	var v2, v3 int32
	_, _, _, _, _, _, _, _ = X, Y, in32, k, out32_1, out32_2, v2, v3
	_ = int32(silk_resampler_up2_hq_06[0]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_06[int32(1)]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_06[int32(2)]) < libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[0]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[int32(1)]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[int32(2)]) < libc.Int32FromInt32(0)
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2)))) << libc.Int32FromInt32(10))
		/* First all-pass section for even output sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_06[0]) >> libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Second all-pass section for even output sample */
		Y = out32_1 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_06[int32(1)]) >> libc.Int32FromInt32(16))
		out32_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = out32_1 + X
		/* Third all-pass section for even output sample */
		Y = out32_2 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_up2_hq_06[int32(2)])>>libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = out32_2 + X
		/* Apply gain in Q15, convert back to int16 and store to output */
		if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
			v2 = int32(silk_int16_MAX21)
		} else {
			if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k)*2)) = int16(v2)
		/* First all-pass section for odd output sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_16[0]) >> libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = in32 + X
		/* Second all-pass section for odd output sample */
		Y = out32_1 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_16[int32(1)]) >> libc.Int32FromInt32(16))
		out32_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4)) = out32_1 + X
		/* Third all-pass section for odd output sample */
		Y = out32_2 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_up2_hq_16[int32(2)])>>libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4)) = out32_2 + X
		/* Apply gain in Q15, convert back to int16 and store to output */
		if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX21) {
			v2 = int32(silk_int16_MAX21)
		} else {
			if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

func Opus_silk_resampler_private_up2_HQ_wrapper(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, len1 OpusT_opus_int32) {
	var S uintptr
	_ = S
	S = SS
	Opus_silk_resampler_private_up2_HQ(tls, S, out, in, len1)
}

const silk_int16_MAX22 = 0x7FFF

var silk_resampler_down2_07 = int16(9872)
var silk_resampler_down2_17 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_07 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_17 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* fprintf(1, '%d, ', round(1024 * ([1 ./ (1 + exp(-(1:5))), 1] - 1 ./ (1 + exp(-(0:5)))))); */
var sigm_LUT_slope_Q10 = [6]OpusT_opus_int32{
	0: int32(237),
	1: int32(153),
	2: int32(73),
	3: int32(30),
	4: int32(12),
	5: int32(7),
}

// C documentation
//
//	/* fprintf(1, '%d, ', round(32767 * 1 ./ (1 + exp(-(0:5))))); */
var sigm_LUT_pos_Q15 = [6]OpusT_opus_int32{
	0: int32(16384),
	1: int32(23955),
	2: int32(28861),
	3: int32(31213),
	4: int32(32178),
	5: int32(32548),
}

// C documentation
//
//	/* fprintf(1, '%d, ', round(32767 * 1 ./ (1 + exp((0:5))))); */
var sigm_LUT_neg_Q15 = [6]OpusT_opus_int32{
	0: int32(16384),
	1: int32(8812),
	2: int32(3906),
	3: int32(1554),
	4: int32(589),
	5: int32(219),
}

func Opus_silk_sigm_Q15(tls *libc.TLS, in_Q5 int32) (r int32) {
	var ind int32
	_ = ind
	if in_Q5 < 0 {
		/* Negative input */
		in_Q5 = -in_Q5
		if in_Q5 >= libc.Int32FromInt32(6)*libc.Int32FromInt32(32) {
			return 0 /* Clip */
		} else {
			/* Linear interpolation of look up table */
			ind = in_Q5 >> int32(5)
			return sigm_LUT_neg_Q15[ind] - int32(int16(sigm_LUT_slope_Q10[ind]))*int32(int16(in_Q5&libc.Int32FromInt32(0x1F)))
		}
	} else {
		/* Positive input */
		if in_Q5 >= libc.Int32FromInt32(6)*libc.Int32FromInt32(32) {
			return int32(32767) /* clip */
		} else {
			/* Linear interpolation of look up table */
			ind = in_Q5 >> int32(5)
			return sigm_LUT_pos_Q15[ind] + int32(int16(sigm_LUT_slope_Q10[ind]))*int32(int16(in_Q5&libc.Int32FromInt32(0x1F)))
		}
	}
	return r
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func Opus_silk_insertion_sort_increasing(tls *libc.TLS, a uintptr, idx uintptr, L int32, K int32) {
	var i, j int32
	var value OpusT_opus_int32
	_, _, _ = i, j, value
	/* Safety checks */
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7711, __ccgo_ts+7735, int32(51))
	}
	if !(L > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7750, __ccgo_ts+7735, int32(52))
	}
	if !(L >= K) {
		Opus_celt_fatal(tls, __ccgo_ts+7774, __ccgo_ts+7735, int32(53))
	}
	/* Write start indices in index vector */
	i = 0
	for {
		if !(i < K) {
			break
		}
		*(*int32)(unsafe.Pointer(idx + uintptr(i)*4)) = i
		goto _1
	_1:
		;
		i = i + 1
	}
	/* Sort vector elements by value, increasing order */
	i = int32(1)
	for {
		if !(i < K) {
			break
		}
		value = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(i)*4))
		j = i - int32(1)
		for {
			if !(j >= 0 && value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4))) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4))                   /* Shift index */
			goto _3
		_3:
			;
			j = j - 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
		*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i              /* Write index */
		goto _2
	_2:
		;
		i = i + 1
	}
	/* If less than L values are asked for, check the remaining values, */
	/* but only spend CPU to ensure that the K first values are correct */
	i = K
	for {
		if !(i < L) {
			break
		}
		value = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(i)*4))
		if value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(K-int32(1))*4)) {
			j = K - int32(2)
			for {
				if !(j >= 0 && value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4))) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
				*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4))                   /* Shift index */
				goto _5
			_5:
				;
				j = j - 1
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i              /* Write index */
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

func Opus_silk_insertion_sort_increasing_all_values_int16(tls *libc.TLS, a uintptr, L int32) {
	var i, j, value int32
	_, _, _ = i, j, value
	/* Safety checks */
	if !(L > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+7750, __ccgo_ts+7735, int32(144))
	}
	/* Sort vector elements by value, increasing order */
	i = int32(1)
	for {
		if !(i < L) {
			break
		}
		value = int32(*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(i)*2)))
		j = i - int32(1)
		for {
			if !(j >= 0 && value < int32(*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j)*2)))) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j+int32(1))*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j)*2)) /* Shift value */
			goto _2
		_2:
			;
			j = j - 1
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j+int32(1))*2)) = int16(value) /* Write value */
		goto _1
	_1:
		;
		i = i + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Compute number of bits to right shift the sum of squares of a vector */
//	/* of int16s to make it fit in an int32                                 */
func Opus_silk_sum_sqr_shift(tls *libc.TLS, energy uintptr, shift uintptr, x uintptr, len1 int32) {
	var i, shft, v4, v9 int32
	var nrg, v1, v10, v2, v6, v7 OpusT_opus_int32
	var nrg_tmp OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _ = i, nrg, nrg_tmp, shft, v1, v10, v2, v4, v6, v7, v9
	/* Do a first run with the maximum shift we could have. */
	v1 = len1
	if v1 != 0 {
		v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
	} else {
		v4 = int32(32)
	}
	v2 = v4
	goto _3
_3:
	shft = int32(31) - v2
	/* Let's be conservative with rounding and start with nrg=len. */
	nrg = len1
	i = 0
	for {
		if !(i < len1-int32(1)) {
			break
		}
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg_tmp = libc.Uint32FromInt32(libc.Int32FromUint32(nrg_tmp + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2))))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
		goto _5
	_5:
		;
		i = i + int32(2)
	}
	if i < len1 {
		/* One sample left to process */
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
	}
	_ = nrg >= libc.Int32FromInt32(0)
	/* Make sure the result will fit in a 32-bit signed integer with two bits
	   of headroom. */
	v1 = nrg
	if v1 != 0 {
		v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(CHAR_BIT) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
	} else {
		v4 = int32(32)
	}
	v2 = v4
	goto _8
_8:
	v6 = 0
	v7 = shft + int32(3) - v2
	if v6 > v7 {
		v9 = v6
	} else {
		v9 = v7
	}
	v10 = v9
	goto _13
_13:
	shft = v10
	nrg = 0
	i = 0
	for {
		if !(i < len1-int32(1)) {
			break
		}
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg_tmp = libc.Uint32FromInt32(libc.Int32FromUint32(nrg_tmp + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2))))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
		goto _15
	_15:
		;
		i = i + int32(2)
	}
	if i < len1 {
		/* One sample left to process */
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
	}
	_ = nrg >= libc.Int32FromInt32(0)
	/* Output arguments */
	*(*int32)(unsafe.Pointer(shift)) = shft
	*(*OpusT_opus_int32)(unsafe.Pointer(energy)) = nrg
}

// C documentation
//
//	/* Decode mid/side predictors */
func Opus_silk_stereo_decode_pred(tls *libc.TLS, psRangeDec uintptr, pred_Q13 uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var low_Q13, step_Q13 OpusT_opus_int32
	var n int32
	var _ /* ix at bp+0 */ [2][3]int32
	_, _, _ = low_Q13, n, step_Q13
	/* Entropy decoding */
	n = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_stereo_pred_joint_iCDF)), uint32(8))
	*(*int32)(unsafe.Pointer(bp + 2*4)) = n / libc.Int32FromInt32(5)
	*(*int32)(unsafe.Pointer(bp + 1*12 + 2*4)) = n - int32(5)**(*int32)(unsafe.Pointer(bp + 2*4))
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform3_iCDF)), uint32(8))
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 1*4)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform5_iCDF)), uint32(8))
		goto _1
	_1:
		;
		n = n + 1
	}
	/* Dequantize */
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12)) += int32(3) * *(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 2*4))
		low_Q13 = int32(Opus_silk_stereo_pred_quant_Q13[*(*int32)(unsafe.Pointer(bp + uintptr(n)*12))])
		step_Q13 = int32(int64(int32(Opus_silk_stereo_pred_quant_Q13[*(*int32)(unsafe.Pointer(bp + uintptr(n)*12))+int32(1)])-low_Q13) * int64(int16(int32(float64(libc.Float64FromFloat64(0.5)/libc.Float64FromInt32(STEREO_QUANT_SUB_STEPS)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))) >> libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4)) = low_Q13 + int32(int16(step_Q13))*int32(int16(libc.Int32FromInt32(2)**(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 1*4))+libc.Int32FromInt32(1)))
		goto _2
	_2:
		;
		n = n + 1
	}
	/* Subtract second from first predictor (helps when actually applying these) */
	*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13)) -= *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))
}

// C documentation
//
//	/* Decode mid-only flag */
func Opus_silk_stereo_decode_mid_only(tls *libc.TLS, psRangeDec uintptr, decode_only_mid uintptr) {
	/* Decode flag that only mid channel is coded */
	*(*int32)(unsafe.Pointer(decode_only_mid)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_stereo_only_code_mid_iCDF)), uint32(8))
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

// C documentation
//
//	/* Mean energy in each band quantized in Q4 and converted back to float */
var Opus_eMeans = [25]OpusT_opus_val16{
	0:  libc.Float32FromFloat32(6.4375),
	1:  libc.Float32FromFloat32(6.25),
	2:  libc.Float32FromFloat32(5.75),
	3:  libc.Float32FromFloat32(5.3125),
	4:  libc.Float32FromFloat32(5.0625),
	5:  libc.Float32FromFloat32(4.8125),
	6:  libc.Float32FromFloat32(4.5),
	7:  libc.Float32FromFloat32(4.375),
	8:  libc.Float32FromFloat32(4.875),
	9:  libc.Float32FromFloat32(4.6875),
	10: libc.Float32FromFloat32(4.5625),
	11: libc.Float32FromFloat32(4.4375),
	12: libc.Float32FromFloat32(4.875),
	13: libc.Float32FromFloat32(4.625),
	14: libc.Float32FromFloat32(4.3125),
	15: libc.Float32FromFloat32(4.5),
	16: libc.Float32FromFloat32(4.375),
	17: libc.Float32FromFloat32(4.625),
	18: libc.Float32FromFloat32(4.75),
	19: libc.Float32FromFloat32(4.4375),
	20: libc.Float32FromFloat32(3.75),
	21: libc.Float32FromFloat32(3.75),
	22: libc.Float32FromFloat32(3.75),
	23: libc.Float32FromFloat32(3.75),
	24: libc.Float32FromFloat32(3.75),
}

var Opus_mapping_matrix_fifthoa_demixing = OpusT_MappingMatrix{
	Frows: int32(38),
	Fcols: int32(38),
}

var Opus_mapping_matrix_fifthoa_demixing_data = [1444]OpusT_opus_int16{
	0:    int16(3188),
	1:    int16(3247),
	2:    int16(3268),
	3:    int16(3368),
	4:    int16(3368),
	5:    int16(3138),
	6:    int16(3268),
	7:    int16(3099),
	8:    int16(3211),
	9:    int16(3368),
	10:   int16(3099),
	11:   int16(3247),
	12:   int16(3211),
	13:   int16(3368),
	14:   int16(3368),
	15:   int16(3368),
	16:   int16(3149),
	17:   int16(3268),
	18:   int16(3247),
	19:   int16(3211),
	20:   int16(3099),
	21:   int16(3188),
	22:   int16(3138),
	23:   int16(3149),
	24:   int16(3099),
	25:   int16(3188),
	26:   int16(3368),
	27:   int16(3149),
	28:   int16(3188),
	29:   int16(3247),
	30:   int16(3268),
	31:   int16(3138),
	32:   int16(3211),
	33:   int16(3368),
	34:   int16(3138),
	35:   int16(3149),
	38:   int16(118),
	39:   int16(-int32(47)),
	40:   int16(-int32(5011)),
	41:   int16(282),
	42:   int16(333),
	43:   int16(-int32(1497)),
	44:   int16(-int32(4584)),
	45:   int16(2908),
	46:   int16(3388),
	47:   int16(-int32(3647)),
	48:   int16(-int32(2493)),
	49:   int16(1139),
	50:   int16(-int32(2882)),
	51:   int16(-int32(1719)),
	52:   int16(3604),
	53:   int16(-int32(2543)),
	54:   int16(-int32(4328)),
	55:   int16(5443),
	56:   int16(1286),
	57:   int16(-int32(5498)),
	58:   int16(-int32(4583)),
	59:   int16(2510),
	60:   int16(-int32(1743)),
	61:   int16(-int32(2556)),
	62:   int16(4168),
	63:   int16(1446),
	64:   int16(-int32(290)),
	65:   int16(1812),
	66:   int16(-int32(4074)),
	67:   int16(-int32(2377)),
	68:   int16(4152),
	69:   int16(2847),
	70:   int16(4991),
	71:   int16(3980),
	72:   int16(393),
	73:   int16(5072),
	76:   int16(5489),
	77:   int16(-int32(2235)),
	78:   int16(1507),
	79:   int16(-int32(5326)),
	80:   int16(4609),
	81:   int16(-int32(1096)),
	82:   int16(2926),
	83:   int16(-int32(3427)),
	84:   int16(-int32(3301)),
	85:   int16(-int32(3078)),
	86:   int16(4226),
	87:   int16(1730),
	88:   int16(4627),
	89:   int16(2561),
	90:   int16(2966),
	91:   int16(-int32(592)),
	92:   int16(143),
	93:   int16(-int32(677)),
	94:   int16(4617),
	95:   int16(-int32(755)),
	96:   int16(-int32(956)),
	97:   int16(-int32(433)),
	98:   int16(-int32(5138)),
	99:   int16(3037),
	100:  int16(157),
	101:  int16(-int32(1394)),
	102:  int16(-int32(4498)),
	103:  int16(-int32(4984)),
	104:  int16(-int32(3661)),
	105:  int16(-int32(4112)),
	106:  int16(-int32(3756)),
	107:  int16(4628),
	108:  int16(-int32(570)),
	109:  int16(3356),
	110:  int16(1605),
	111:  int16(1803),
	114:  int16(-int32(162)),
	115:  int16(5162),
	116:  int16(2132),
	117:  int16(2392),
	118:  int16(3556),
	119:  int16(-int32(5141)),
	120:  int16(-int32(1536)),
	121:  int16(2975),
	122:  int16(-int32(3001)),
	123:  int16(-int32(3350)),
	124:  int16(-int32(2231)),
	125:  int16(-int32(5230)),
	126:  int16(1294),
	127:  int16(-int32(4965)),
	128:  int16(3494),
	129:  int16(5230),
	130:  int16(-int32(3292)),
	131:  int16(-int32(1359)),
	132:  int16(-int32(2945)),
	133:  int16(-int32(773)),
	134:  int16(2670),
	135:  int16(4867),
	136:  int16(-int32(660)),
	137:  int16(3720),
	138:  int16(-int32(3415)),
	139:  int16(-int32(5112)),
	140:  int16(-int32(3700)),
	141:  int16(-int32(1211)),
	142:  int16(407),
	143:  int16(3013),
	144:  int16(763),
	145:  int16(591),
	146:  int16(2481),
	147:  int16(-int32(2657)),
	148:  int16(5210),
	149:  int16(784),
	152:  int16(-int32(156)),
	153:  int16(338),
	154:  int16(-int32(4246)),
	155:  int16(510),
	156:  int16(462),
	157:  int16(3296),
	158:  int16(2846),
	159:  int16(3333),
	160:  int16(-int32(4292)),
	161:  int16(4574),
	162:  int16(1940),
	163:  int16(-int32(2986)),
	164:  int16(-int32(1275)),
	165:  int16(3701),
	166:  int16(5022),
	167:  int16(-int32(5250)),
	168:  int16(5780),
	169:  int16(-int32(2676)),
	170:  int16(-int32(1180)),
	171:  int16(1516),
	172:  int16(-int32(4852)),
	173:  int16(4877),
	174:  int16(342),
	175:  int16(-int32(3923)),
	176:  int16(-int32(5703)),
	177:  int16(-int32(2920)),
	178:  int16(379),
	179:  int16(-int32(657)),
	180:  int16(-int32(361)),
	181:  int16(-int32(3346)),
	182:  int16(1044),
	183:  int16(795),
	184:  int16(5257),
	185:  int16(-int32(4004)),
	186:  int16(698),
	187:  int16(1115),
	190:  int16(47),
	191:  int16(-int32(140)),
	192:  int16(-int32(3292)),
	193:  int16(-int32(1097)),
	194:  int16(652),
	195:  int16(855),
	196:  int16(-int32(5260)),
	197:  int16(-int32(3691)),
	198:  int16(-int32(4470)),
	199:  int16(4521),
	200:  int16(-int32(3863)),
	201:  int16(1093),
	202:  int16(-int32(5552)),
	203:  int16(-int32(2016)),
	204:  int16(3831),
	205:  int16(334),
	206:  int16(-int32(456)),
	207:  int16(-int32(1532)),
	208:  int16(2068),
	209:  int16(1788),
	210:  int16(2054),
	211:  int16(-int32(295)),
	212:  int16(3668),
	213:  int16(-int32(2820)),
	214:  int16(328),
	215:  int16(-int32(994)),
	216:  int16(295),
	217:  int16(-int32(3301)),
	218:  int16(5770),
	219:  int16(4282),
	220:  int16(-int32(6353)),
	221:  int16(5632),
	222:  int16(-int32(1371)),
	223:  int16(5005),
	224:  int16(238),
	225:  int16(4041),
	228:  int16(6764),
	229:  int16(-int32(1659)),
	230:  int16(-int32(2730)),
	231:  int16(5726),
	232:  int16(3715),
	233:  int16(-int32(3216)),
	234:  int16(-int32(933)),
	235:  int16(531),
	236:  int16(-int32(52)),
	237:  int16(-int32(345)),
	238:  int16(3022),
	239:  int16(-int32(2818)),
	240:  int16(4005),
	241:  int16(-int32(1617)),
	242:  int16(-int32(1189)),
	243:  int16(-int32(3748)),
	244:  int16(-int32(3403)),
	245:  int16(-int32(3592)),
	246:  int16(4040),
	247:  int16(-int32(3553)),
	248:  int16(-int32(2806)),
	249:  int16(-int32(3444)),
	250:  int16(6023),
	251:  int16(-int32(711)),
	252:  int16(-int32(3298)),
	253:  int16(-int32(2503)),
	254:  int16(2548),
	255:  int16(5564),
	256:  int16(940),
	257:  int16(1848),
	258:  int16(1207),
	259:  int16(4010),
	260:  int16(-int32(3488)),
	261:  int16(-int32(358)),
	262:  int16(-int32(2511)),
	263:  int16(-int32(1966)),
	266:  int16(-int32(64)),
	267:  int16(-int32(5039)),
	268:  int16(1403),
	269:  int16(-int32(4455)),
	270:  int16(6240),
	271:  int16(2189),
	272:  int16(-int32(1716)),
	273:  int16(-int32(4348)),
	274:  int16(4183),
	275:  int16(3951),
	276:  int16(-int32(4042)),
	277:  int16(-int32(3606)),
	278:  int16(2399),
	279:  int16(-int32(4563)),
	280:  int16(4050),
	281:  int16(-int32(612)),
	282:  int16(-int32(395)),
	283:  int16(348),
	284:  int16(-int32(5791)),
	285:  int16(391),
	286:  int16(-int32(1440)),
	287:  int16(-int32(735)),
	288:  int16(1398),
	289:  int16(4359),
	290:  int16(-int32(518)),
	291:  int16(2969),
	292:  int16(6556),
	293:  int16(1951),
	294:  int16(-int32(518)),
	295:  int16(-int32(4993)),
	296:  int16(-int32(925)),
	297:  int16(998),
	298:  int16(-int32(569)),
	299:  int16(-int32(2934)),
	300:  int16(3460),
	301:  int16(420),
	304:  int16(16),
	305:  int16(5482),
	306:  int16(-int32(4122)),
	307:  int16(770),
	308:  int16(2082),
	309:  int16(5020),
	310:  int16(-int32(3961)),
	311:  int16(485),
	312:  int16(-int32(584)),
	313:  int16(-int32(793)),
	314:  int16(3),
	315:  int16(5222),
	316:  int16(-int32(1416)),
	317:  int16(3673),
	318:  int16(78),
	319:  int16(3549),
	320:  int16(-int32(937)),
	321:  int16(-int32(5723)),
	322:  int16(1673),
	323:  int16(-int32(6162)),
	324:  int16(-int32(2540)),
	325:  int16(3082),
	326:  int16(-int32(355)),
	327:  int16(1838),
	328:  int16(-int32(615)),
	329:  int16(4601),
	330:  int16(2832),
	331:  int16(-int32(359)),
	332:  int16(-int32(3346)),
	333:  int16(668),
	334:  int16(-int32(3393)),
	335:  int16(-int32(1583)),
	336:  int16(-int32(3774)),
	337:  int16(-int32(2206)),
	338:  int16(5754),
	339:  int16(-int32(4961)),
	342:  int16(-int32(328)),
	343:  int16(299),
	344:  int16(2470),
	345:  int16(317),
	346:  int16(525),
	347:  int16(-int32(4494)),
	348:  int16(2805),
	349:  int16(2617),
	350:  int16(2383),
	351:  int16(-int32(2363)),
	352:  int16(-int32(1037)),
	353:  int16(4085),
	354:  int16(895),
	355:  int16(-int32(4622)),
	356:  int16(3218),
	357:  int16(-int32(6607)),
	358:  int16(-int32(3381)),
	359:  int16(-int32(5933)),
	360:  int16(1397),
	361:  int16(6394),
	362:  int16(-int32(446)),
	363:  int16(5694),
	364:  int16(14),
	365:  int16(-int32(4510)),
	366:  int16(4329),
	367:  int16(3690),
	368:  int16(-int32(334)),
	370:  int16(2932),
	371:  int16(-int32(2478)),
	372:  int16(-int32(2944)),
	373:  int16(-int32(577)),
	374:  int16(-int32(599)),
	375:  int16(-int32(230)),
	376:  int16(1553),
	377:  int16(-int32(4736)),
	380:  int16(-int32(324)),
	381:  int16(142),
	382:  int16(-int32(3252)),
	383:  int16(-int32(867)),
	384:  int16(1111),
	385:  int16(-int32(1882)),
	386:  int16(3378),
	387:  int16(-int32(6055)),
	388:  int16(6502),
	389:  int16(-int32(6840)),
	390:  int16(4280),
	391:  int16(-int32(2694)),
	392:  int16(-int32(2876)),
	393:  int16(4190),
	394:  int16(6454),
	395:  int16(655),
	396:  int16(1061),
	397:  int16(626),
	398:  int16(-int32(2669)),
	399:  int16(-int32(798)),
	400:  int16(3192),
	401:  int16(-int32(985)),
	402:  int16(-int32(898)),
	403:  int16(-int32(5482)),
	404:  int16(-int32(548)),
	405:  int16(2315),
	406:  int16(-int32(558)),
	407:  int16(1302),
	408:  int16(900),
	409:  int16(5747),
	410:  int16(-int32(1325)),
	411:  int16(1599),
	412:  int16(-int32(1384)),
	413:  int16(-int32(5749)),
	414:  int16(624),
	415:  int16(1110),
	418:  int16(321),
	419:  int16(312),
	420:  int16(2188),
	421:  int16(1322),
	422:  int16(237),
	423:  int16(708),
	424:  int16(-int32(304)),
	425:  int16(2463),
	426:  int16(1500),
	427:  int16(-int32(1094)),
	428:  int16(-int32(5112)),
	429:  int16(-int32(1010)),
	430:  int16(-int32(6799)),
	431:  int16(646),
	432:  int16(992),
	433:  int16(1969),
	434:  int16(3423),
	435:  int16(-int32(3996)),
	436:  int16(2628),
	437:  int16(4451),
	438:  int16(3432),
	439:  int16(-int32(2833)),
	440:  int16(-int32(6101)),
	441:  int16(-int32(330)),
	442:  int16(-int32(3768)),
	443:  int16(-int32(3)),
	444:  int16(-int32(707)),
	445:  int16(5961),
	446:  int16(-int32(4037)),
	447:  int16(-int32(3736)),
	448:  int16(4080),
	449:  int16(7254),
	450:  int16(-int32(4113)),
	451:  int16(2151),
	452:  int16(54),
	453:  int16(-int32(2150)),
	456:  int16(7735),
	457:  int16(4064),
	458:  int16(-int32(3884)),
	459:  int16(-int32(5240)),
	460:  int16(577),
	461:  int16(2229),
	462:  int16(-int32(3947)),
	463:  int16(2914),
	464:  int16(3555),
	465:  int16(4011),
	466:  int16(774),
	467:  int16(-int32(3519)),
	468:  int16(1985),
	469:  int16(-int32(3701)),
	470:  int16(-int32(3824)),
	471:  int16(330),
	472:  int16(-int32(905)),
	473:  int16(2085),
	474:  int16(1155),
	475:  int16(2176),
	476:  int16(3006),
	477:  int16(340),
	478:  int16(-int32(5533)),
	479:  int16(-int32(3264)),
	480:  int16(-int32(902)),
	481:  int16(3114),
	482:  int16(344),
	483:  int16(-int32(5060)),
	484:  int16(1524),
	485:  int16(1805),
	486:  int16(1926),
	487:  int16(2350),
	488:  int16(1905),
	489:  int16(-int32(3203)),
	490:  int16(-int32(2762)),
	491:  int16(-int32(4162)),
	494:  int16(193),
	495:  int16(-int32(151)),
	496:  int16(-int32(1434)),
	497:  int16(6289),
	498:  int16(7354),
	499:  int16(4234),
	500:  int16(169),
	501:  int16(2868),
	502:  int16(-int32(1977)),
	503:  int16(-int32(1375)),
	504:  int16(-int32(4987)),
	505:  int16(2345),
	506:  int16(2742),
	507:  int16(599),
	508:  int16(939),
	509:  int16(-int32(4837)),
	510:  int16(2688),
	511:  int16(991),
	512:  int16(-int32(6907)),
	513:  int16(716),
	514:  int16(-int32(1542)),
	515:  int16(-int32(4346)),
	516:  int16(-int32(1833)),
	517:  int16(1493),
	518:  int16(3134),
	519:  int16(2903),
	520:  int16(-int32(7019)),
	521:  int16(-int32(2835)),
	522:  int16(93),
	523:  int16(4395),
	524:  int16(621),
	525:  int16(870),
	526:  int16(-int32(2357)),
	527:  int16(-int32(975)),
	528:  int16(-int32(2933)),
	529:  int16(-int32(127)),
	532:  int16(-int32(616)),
	533:  int16(-int32(5968)),
	534:  int16(-int32(3479)),
	535:  int16(-int32(1651)),
	536:  int16(4932),
	537:  int16(-int32(2445)),
	538:  int16(-int32(5512)),
	539:  int16(-int32(1451)),
	540:  int16(691),
	541:  int16(739),
	542:  int16(479),
	543:  int16(4227),
	544:  int16(-int32(2886)),
	545:  int16(3853),
	546:  int16(8),
	547:  int16(-int32(501)),
	548:  int16(188),
	549:  int16(1990),
	550:  int16(3842),
	551:  int16(2270),
	552:  int16(1662),
	553:  int16(-int32(174)),
	554:  int16(1290),
	555:  int16(2456),
	556:  int16(67),
	557:  int16(-int32(3267)),
	558:  int16(-int32(5535)),
	559:  int16(483),
	560:  int16(5721),
	561:  int16(-int32(1642)),
	562:  int16(6501),
	563:  int16(-int32(3432)),
	564:  int16(1184),
	565:  int16(-int32(3246)),
	566:  int16(4101),
	567:  int16(-int32(4880)),
	570:  int16(-int32(465)),
	571:  int16(5264),
	572:  int16(-int32(4812)),
	573:  int16(682),
	574:  int16(1683),
	575:  int16(-int32(4539)),
	576:  int16(2916),
	577:  int16(-int32(1985)),
	578:  int16(2899),
	579:  int16(3324),
	580:  int16(1060),
	581:  int16(-int32(4398)),
	582:  int16(-int32(745)),
	583:  int16(-int32(2137)),
	584:  int16(-int32(3827)),
	585:  int16(1044),
	586:  int16(6225),
	587:  int16(3609),
	588:  int16(-int32(532)),
	589:  int16(1980),
	590:  int16(-int32(6001)),
	591:  int16(564),
	592:  int16(-int32(209)),
	593:  int16(-int32(1299)),
	594:  int16(5336),
	595:  int16(-int32(3605)),
	596:  int16(-int32(1484)),
	597:  int16(37),
	598:  int16(19),
	599:  int16(-int32(1295)),
	600:  int16(-int32(665)),
	601:  int16(-int32(385)),
	602:  int16(-int32(6773)),
	603:  int16(3651),
	604:  int16(6153),
	605:  int16(-int32(1291)),
	608:  int16(193),
	609:  int16(-int32(415)),
	610:  int16(5166),
	611:  int16(-int32(110)),
	612:  int16(626),
	613:  int16(6743),
	614:  int16(-int32(2860)),
	615:  int16(1425),
	616:  int16(1101),
	617:  int16(-int32(1341)),
	618:  int16(80),
	619:  int16(-int32(4533)),
	620:  int16(249),
	621:  int16(4231),
	622:  int16(-int32(119)),
	623:  int16(-int32(6009)),
	624:  int16(-int32(2970)),
	625:  int16(5170),
	626:  int16(-int32(822)),
	627:  int16(-int32(2610)),
	628:  int16(4527),
	629:  int16(5948),
	630:  int16(182),
	631:  int16(-int32(2589)),
	632:  int16(837),
	633:  int16(-int32(5471)),
	634:  int16(371),
	635:  int16(-int32(43)),
	636:  int16(373),
	637:  int16(-int32(665)),
	638:  int16(-int32(1233)),
	639:  int16(-int32(626)),
	640:  int16(-int32(7353)),
	641:  int16(2606),
	642:  int16(1339),
	643:  int16(-int32(1398)),
	646:  int16(-int32(533)),
	647:  int16(147),
	648:  int16(2075),
	649:  int16(-int32(672)),
	650:  int16(1043),
	651:  int16(3503),
	652:  int16(4402),
	653:  int16(-int32(4971)),
	654:  int16(-int32(3287)),
	655:  int16(3731),
	656:  int16(-int32(2606)),
	657:  int16(3817),
	658:  int16(1972),
	659:  int16(-int32(5603)),
	660:  int16(5114),
	661:  int16(1185),
	662:  int16(-int32(1318)),
	663:  int16(1906),
	664:  int16(3018),
	665:  int16(-int32(1999)),
	666:  int16(343),
	667:  int16(-int32(1943)),
	668:  int16(207),
	669:  int16(-int32(6744)),
	670:  int16(913),
	671:  int16(-int32(4060)),
	672:  int16(645),
	673:  int16(-int32(349)),
	674:  int16(-int32(5667)),
	675:  int16(4766),
	676:  int16(5575),
	677:  int16(-int32(1733)),
	678:  int16(1116),
	679:  int16(160),
	680:  int16(1534),
	681:  int16(-int32(5690)),
	684:  int16(-int32(137)),
	685:  int16(-int32(36)),
	686:  int16(1556),
	687:  int16(1325),
	688:  int16(1553),
	689:  int16(-int32(2230)),
	690:  int16(1188),
	691:  int16(5296),
	692:  int16(-int32(5104)),
	693:  int16(4673),
	694:  int16(6295),
	695:  int16(498),
	696:  int16(-int32(4723)),
	697:  int16(933),
	698:  int16(2994),
	699:  int16(4067),
	700:  int16(-int32(4700)),
	701:  int16(1758),
	702:  int16(-int32(4116)),
	703:  int16(-int32(1252)),
	704:  int16(2444),
	705:  int16(-int32(4092)),
	706:  int16(1653),
	707:  int16(-int32(2802)),
	708:  int16(5069),
	709:  int16(1133),
	710:  int16(790),
	711:  int16(-int32(2355)),
	712:  int16(-int32(934)),
	713:  int16(-int32(6304)),
	714:  int16(1642),
	715:  int16(2045),
	716:  int16(-int32(4259)),
	717:  int16(-int32(3873)),
	718:  int16(-int32(213)),
	719:  int16(215),
	722:  int16(-int32(364)),
	723:  int16(423),
	724:  int16(4888),
	725:  int16(-int32(1316)),
	726:  int16(118),
	727:  int16(-int32(950)),
	728:  int16(4027),
	729:  int16(114),
	730:  int16(2961),
	731:  int16(-int32(3136)),
	732:  int16(-int32(3012)),
	733:  int16(-int32(883)),
	734:  int16(-int32(6192)),
	735:  int16(1340),
	736:  int16(-int32(3210)),
	737:  int16(-int32(1193)),
	738:  int16(1376),
	739:  int16(3128),
	740:  int16(1596),
	741:  int16(-int32(2994)),
	742:  int16(-int32(3194)),
	743:  int16(533),
	744:  int16(8502),
	745:  int16(2487),
	746:  int16(-int32(1485)),
	747:  int16(1032),
	748:  int16(301),
	749:  int16(-int32(8007)),
	750:  int16(-int32(577)),
	751:  int16(887),
	752:  int16(297),
	753:  int16(7778),
	754:  int16(3121),
	755:  int16(-int32(1901)),
	756:  int16(-int32(94)),
	757:  int16(-int32(6401)),
	760:  int16(9260),
	761:  int16(-int32(1845)),
	762:  int16(668),
	763:  int16(2787),
	764:  int16(-int32(2255)),
	765:  int16(2699),
	766:  int16(-int32(2512)),
	767:  int16(-int32(3737)),
	768:  int16(-int32(3675)),
	769:  int16(-int32(3601)),
	770:  int16(-int32(1803)),
	771:  int16(210),
	772:  int16(-int32(1701)),
	773:  int16(-int32(1442)),
	774:  int16(-int32(2700)),
	775:  int16(3457),
	776:  int16(2868),
	777:  int16(2079),
	778:  int16(-int32(2113)),
	779:  int16(3178),
	780:  int16(1277),
	781:  int16(3578),
	782:  int16(5240),
	783:  int16(-int32(2482)),
	784:  int16(3324),
	785:  int16(1020),
	786:  int16(-int32(4027)),
	787:  int16(3835),
	788:  int16(-int32(3758)),
	789:  int16(-int32(3633)),
	790:  int16(-int32(3170)),
	791:  int16(-int32(1310)),
	792:  int16(2509),
	793:  int16(-int32(3110)),
	794:  int16(713),
	795:  int16(174),
	798:  int16(-int32(399)),
	799:  int16(4969),
	800:  int16(-int32(2321)),
	801:  int16(-int32(7744)),
	802:  int16(6494),
	803:  int16(-int32(3776)),
	804:  int16(1478),
	805:  int16(758),
	806:  int16(-int32(1794)),
	807:  int16(-int32(2233)),
	808:  int16(-int32(4059)),
	809:  int16(4932),
	810:  int16(2770),
	811:  int16(4761),
	812:  int16(-int32(3475)),
	813:  int16(1243),
	814:  int16(829),
	815:  int16(-int32(651)),
	816:  int16(-int32(5358)),
	817:  int16(-int32(436)),
	818:  int16(2381),
	819:  int16(1360),
	820:  int16(2561),
	821:  int16(-int32(3118)),
	822:  int16(858),
	823:  int16(-int32(4366)),
	824:  int16(3933),
	825:  int16(3646),
	826:  int16(-int32(43)),
	827:  int16(-int32(1310)),
	828:  int16(-int32(16)),
	829:  int16(924),
	830:  int16(1197),
	831:  int16(1415),
	832:  int16(-int32(5036)),
	833:  int16(-int32(376)),
	836:  int16(100),
	837:  int16(1410),
	838:  int16(1290),
	839:  int16(3199),
	840:  int16(7091),
	841:  int16(-int32(3638)),
	842:  int16(-int32(2641)),
	843:  int16(1118),
	844:  int16(45),
	845:  int16(-int32(441)),
	846:  int16(794),
	847:  int16(-int32(974)),
	848:  int16(-int32(5033)),
	849:  int16(889),
	850:  int16(438),
	851:  int16(-int32(3102)),
	852:  int16(895),
	853:  int16(3555),
	854:  int16(4672),
	855:  int16(4795),
	856:  int16(1129),
	857:  int16(-int32(2408)),
	858:  int16(-int32(2153)),
	859:  int16(1742),
	860:  int16(159),
	861:  int16(-int32(2040)),
	862:  int16(7578),
	863:  int16(-int32(2006)),
	864:  int16(-int32(5737)),
	865:  int16(1986),
	866:  int16(-int32(5568)),
	867:  int16(-int32(6413)),
	868:  int16(2428),
	869:  int16(-int32(1387)),
	870:  int16(-int32(2441)),
	871:  int16(667),
	874:  int16(-int32(37)),
	875:  int16(-int32(6031)),
	876:  int16(-int32(4434)),
	877:  int16(-int32(904)),
	878:  int16(3290),
	879:  int16(1806),
	880:  int16(4736),
	881:  int16(2516),
	882:  int16(-int32(5905)),
	883:  int16(-int32(5927)),
	884:  int16(1754),
	885:  int16(-int32(4300)),
	886:  int16(-int32(2468)),
	887:  int16(-int32(2203)),
	888:  int16(-int32(4836)),
	889:  int16(-int32(672)),
	890:  int16(1444),
	891:  int16(-int32(1591)),
	892:  int16(-int32(1631)),
	893:  int16(-int32(1789)),
	894:  int16(4311),
	895:  int16(-int32(153)),
	896:  int16(-int32(688)),
	897:  int16(-int32(1222)),
	898:  int16(1058),
	899:  int16(3139),
	900:  int16(4659),
	901:  int16(-int32(353)),
	902:  int16(1543),
	903:  int16(1838),
	904:  int16(2180),
	905:  int16(-int32(1448)),
	906:  int16(2432),
	907:  int16(6277),
	908:  int16(5304),
	909:  int16(-int32(1692)),
	912:  int16(-int32(280)),
	913:  int16(4506),
	914:  int16(807),
	915:  int16(-int32(477)),
	916:  int16(823),
	917:  int16(3550),
	918:  int16(1427),
	919:  int16(-int32(1856)),
	920:  int16(-int32(3003)),
	921:  int16(-int32(3501)),
	922:  int16(-int32(1203)),
	923:  int16(2679),
	924:  int16(933),
	925:  int16(778),
	926:  int16(-int32(4954)),
	927:  int16(-int32(1977)),
	928:  int16(-int32(7458)),
	929:  int16(4687),
	930:  int16(435),
	931:  int16(7045),
	932:  int16(-int32(4053)),
	933:  int16(-int32(3130)),
	934:  int16(257),
	935:  int16(-int32(3917)),
	936:  int16(-int32(6165)),
	937:  int16(1889),
	938:  int16(927),
	939:  int16(235),
	940:  int16(1889),
	941:  int16(-int32(1097)),
	942:  int16(1985),
	943:  int16(630),
	944:  int16(-int32(2172)),
	945:  int16(-int32(2130)),
	946:  int16(7080),
	947:  int16(4810),
	950:  int16(-int32(300)),
	951:  int16(496),
	952:  int16(2808),
	953:  int16(279),
	954:  int16(667),
	955:  int16(-int32(7179)),
	956:  int16(-int32(2661)),
	957:  int16(-int32(526)),
	958:  int16(-int32(2832)),
	959:  int16(1751),
	960:  int16(2849),
	961:  int16(4829),
	962:  int16(-int32(906)),
	963:  int16(-int32(4151)),
	964:  int16(-int32(1124)),
	965:  int16(-int32(3062)),
	966:  int16(8166),
	967:  int16(5361),
	968:  int16(-int32(1656)),
	969:  int16(-int32(6017)),
	970:  int16(3265),
	971:  int16(2551),
	972:  int16(-int32(864)),
	973:  int16(-int32(432)),
	974:  int16(-int32(6966)),
	975:  int16(6295),
	976:  int16(-int32(168)),
	977:  int16(901),
	978:  int16(442),
	979:  int16(-int32(582)),
	980:  int16(269),
	981:  int16(236),
	982:  int16(-int32(3574)),
	983:  int16(799),
	984:  int16(472),
	985:  int16(565),
	988:  int16(805),
	989:  int16(-int32(2466)),
	990:  int16(6208),
	991:  int16(-int32(4592)),
	992:  int16(-int32(170)),
	993:  int16(-int32(6701)),
	994:  int16(-int32(5610)),
	995:  int16(3678),
	996:  int16(-int32(4242)),
	997:  int16(4561),
	998:  int16(-int32(724)),
	999:  int16(-int32(5534)),
	1000: int16(2415),
	1001: int16(7354),
	1002: int16(2761),
	1003: int16(2699),
	1004: int16(-int32(349)),
	1005: int16(3822),
	1006: int16(-int32(2372)),
	1007: int16(1756),
	1008: int16(-int32(5523)),
	1009: int16(-int32(3445)),
	1010: int16(-int32(588)),
	1011: int16(-int32(5749)),
	1012: int16(-int32(3986)),
	1013: int16(9804),
	1014: int16(-int32(3871)),
	1015: int16(5375),
	1016: int16(-int32(2308)),
	1017: int16(5504),
	1018: int16(-int32(2766)),
	1019: int16(-int32(1651)),
	1020: int16(1472),
	1021: int16(6832),
	1022: int16(2705),
	1023: int16(-int32(5104)),
	1026: int16(-int32(700)),
	1027: int16(-int32(1179)),
	1028: int16(4402),
	1029: int16(400),
	1030: int16(1383),
	1031: int16(939),
	1032: int16(-int32(1342)),
	1033: int16(6013),
	1034: int16(2577),
	1035: int16(-int32(3472)),
	1036: int16(472),
	1037: int16(2883),
	1038: int16(1450),
	1039: int16(-int32(3917)),
	1040: int16(2849),
	1041: int16(5084),
	1042: int16(4990),
	1043: int16(5392),
	1044: int16(342),
	1045: int16(-int32(4925)),
	1046: int16(-int32(3329)),
	1047: int16(-int32(5372)),
	1048: int16(-int32(2674)),
	1049: int16(-int32(6035)),
	1050: int16(-int32(5072)),
	1051: int16(-int32(836)),
	1052: int16(179),
	1053: int16(2506),
	1054: int16(7987),
	1055: int16(-int32(3647)),
	1056: int16(-int32(8202)),
	1057: int16(-int32(1437)),
	1058: int16(1891),
	1059: int16(2400),
	1060: int16(1607),
	1061: int16(-int32(3611)),
	1064: int16(-int32(4706)),
	1065: int16(-int32(4003)),
	1066: int16(9928),
	1067: int16(-int32(379)),
	1068: int16(5557),
	1069: int16(3738),
	1070: int16(-int32(8789)),
	1071: int16(685),
	1072: int16(1937),
	1073: int16(-int32(5157)),
	1074: int16(13388),
	1075: int16(7995),
	1076: int16(-int32(4119)),
	1077: int16(-int32(9909)),
	1078: int16(-int32(5079)),
	1079: int16(4804),
	1080: int16(5586),
	1081: int16(774),
	1082: int16(-int32(5430)),
	1083: int16(299),
	1084: int16(-int32(9943)),
	1085: int16(3264),
	1086: int16(-int32(3690)),
	1087: int16(-int32(3901)),
	1088: int16(-int32(1133)),
	1089: int16(-int32(6199)),
	1090: int16(3182),
	1091: int16(1544),
	1092: int16(5467),
	1093: int16(3686),
	1094: int16(-int32(2639)),
	1095: int16(4068),
	1096: int16(1163),
	1097: int16(-int32(185)),
	1098: int16(-int32(1299)),
	1099: int16(-int32(506)),
	1102: int16(843),
	1103: int16(1005),
	1104: int16(-int32(1059)),
	1105: int16(467),
	1106: int16(-int32(1279)),
	1107: int16(-int32(2259)),
	1108: int16(6057),
	1109: int16(-int32(1694)),
	1110: int16(-int32(5885)),
	1111: int16(5342),
	1112: int16(-int32(5160)),
	1113: int16(-int32(3748)),
	1114: int16(-int32(1382)),
	1115: int16(4420),
	1116: int16(-int32(697)),
	1117: int16(-int32(2000)),
	1118: int16(-int32(3808)),
	1119: int16(3100),
	1120: int16(2685),
	1121: int16(-int32(4073)),
	1122: int16(531),
	1123: int16(318),
	1124: int16(-int32(7822)),
	1125: int16(2414),
	1126: int16(2901),
	1127: int16(3399),
	1128: int16(-int32(1340)),
	1129: int16(8449),
	1130: int16(3685),
	1131: int16(463),
	1132: int16(-int32(3341)),
	1133: int16(2423),
	1134: int16(2304),
	1135: int16(-int32(2723)),
	1136: int16(84),
	1137: int16(-int32(2622)),
	1140: int16(12088),
	1141: int16(-int32(265)),
	1142: int16(2562),
	1143: int16(-int32(435)),
	1144: int16(-int32(4348)),
	1145: int16(-int32(2426)),
	1146: int16(3538),
	1147: int16(1552),
	1148: int16(1279),
	1149: int16(883),
	1150: int16(-int32(4166)),
	1151: int16(2634),
	1152: int16(-int32(6130)),
	1153: int16(2994),
	1154: int16(3729),
	1155: int16(-int32(1570)),
	1156: int16(-int32(601)),
	1157: int16(-int32(1753)),
	1158: int16(-int32(5124)),
	1159: int16(-int32(2788)),
	1160: int16(-int32(2096)),
	1161: int16(-int32(1920)),
	1162: int16(-int32(2649)),
	1163: int16(2793),
	1164: int16(-int32(1079)),
	1165: int16(-int32(1952)),
	1166: int16(2983),
	1167: int16(-int32(1530)),
	1168: int16(2499),
	1169: int16(1769),
	1170: int16(1492),
	1171: int16(-int32(6757)),
	1172: int16(-int32(2108)),
	1173: int16(2841),
	1174: int16(1466),
	1175: int16(2597),
	1178: int16(-int32(3830)),
	1179: int16(-int32(4093)),
	1180: int16(2448),
	1181: int16(12720),
	1182: int16(7737),
	1183: int16(-int32(665)),
	1184: int16(-int32(832)),
	1185: int16(-int32(9257)),
	1186: int16(2971),
	1187: int16(-int32(2400)),
	1188: int16(791),
	1189: int16(1873),
	1190: int16(1072),
	1191: int16(-int32(587)),
	1192: int16(-int32(7440)),
	1193: int16(8055),
	1194: int16(1531),
	1195: int16(-int32(4736)),
	1196: int16(616),
	1197: int16(-int32(1782)),
	1198: int16(-int32(2982)),
	1199: int16(9663),
	1200: int16(-int32(5057)),
	1201: int16(-int32(5926)),
	1202: int16(1610),
	1203: int16(-int32(4489)),
	1204: int16(7033),
	1205: int16(-int32(8658)),
	1206: int16(6010),
	1207: int16(-int32(5673)),
	1208: int16(5648),
	1209: int16(812),
	1210: int16(-int32(271)),
	1211: int16(-int32(1802)),
	1212: int16(-int32(4500)),
	1213: int16(4392),
	1216: int16(-int32(888)),
	1217: int16(-int32(327)),
	1218: int16(3373),
	1219: int16(-int32(1084)),
	1220: int16(7959),
	1221: int16(2430),
	1222: int16(1898),
	1223: int16(-int32(2360)),
	1224: int16(-int32(1820)),
	1225: int16(-int32(1377)),
	1226: int16(-int32(1090)),
	1227: int16(-int32(4436)),
	1228: int16(-int32(3422)),
	1229: int16(-int32(1106)),
	1230: int16(-int32(3230)),
	1231: int16(3876),
	1232: int16(-int32(41)),
	1233: int16(-int32(5128)),
	1234: int16(6375),
	1235: int16(-int32(1848)),
	1236: int16(-int32(3824)),
	1237: int16(5844),
	1238: int16(617),
	1239: int16(-int32(1957)),
	1240: int16(4232),
	1241: int16(1345),
	1242: int16(-int32(1439)),
	1243: int16(-int32(83)),
	1244: int16(3046),
	1245: int16(-int32(214)),
	1246: int16(5458),
	1247: int16(-int32(5566)),
	1248: int16(-int32(4387)),
	1249: int16(-int32(3738)),
	1250: int16(-int32(5740)),
	1251: int16(8657),
	1254: int16(6978),
	1255: int16(6239),
	1256: int16(-int32(3686)),
	1257: int16(-int32(981)),
	1258: int16(-int32(2854)),
	1259: int16(78),
	1260: int16(5859),
	1261: int16(-int32(357)),
	1262: int16(4618),
	1263: int16(7391),
	1264: int16(-int32(138)),
	1265: int16(971),
	1266: int16(-int32(5799)),
	1267: int16(2135),
	1268: int16(4478),
	1269: int16(-int32(7004)),
	1270: int16(-int32(5949)),
	1271: int16(1668),
	1272: int16(-int32(6933)),
	1273: int16(-int32(1163)),
	1274: int16(7010),
	1275: int16(-int32(5624)),
	1276: int16(2990),
	1277: int16(6192),
	1278: int16(-int32(8075)),
	1279: int16(3567),
	1280: int16(-int32(8308)),
	1281: int16(2236),
	1282: int16(-int32(5098)),
	1283: int16(-int32(2120)),
	1284: int16(-int32(4355)),
	1285: int16(-int32(4238)),
	1286: int16(4955),
	1287: int16(10230),
	1288: int16(692),
	1289: int16(-int32(5606)),
	1292: int16(-int32(1348)),
	1293: int16(-int32(7069)),
	1294: int16(-int32(12)),
	1295: int16(-int32(4927)),
	1296: int16(1211),
	1297: int16(651),
	1298: int16(1360),
	1299: int16(7744),
	1300: int16(3404),
	1301: int16(5069),
	1302: int16(-int32(2438)),
	1303: int16(-int32(105)),
	1304: int16(2332),
	1305: int16(1494),
	1306: int16(-int32(4686)),
	1307: int16(1336),
	1308: int16(-int32(3628)),
	1309: int16(-int32(881)),
	1310: int16(2474),
	1311: int16(1736),
	1312: int16(-int32(26)),
	1313: int16(-int32(257)),
	1314: int16(2135),
	1315: int16(-int32(4452)),
	1316: int16(446),
	1317: int16(-int32(641)),
	1318: int16(-int32(4704)),
	1319: int16(2605),
	1320: int16(-int32(6436)),
	1321: int16(6662),
	1322: int16(-int32(4939)),
	1323: int16(990),
	1324: int16(-int32(1100)),
	1325: int16(-int32(3782)),
	1326: int16(5028),
	1327: int16(4753),
	1330: int16(-int32(2875)),
	1331: int16(6410),
	1332: int16(3518),
	1333: int16(3950),
	1334: int16(1271),
	1335: int16(869),
	1336: int16(-int32(2842)),
	1337: int16(-int32(5837)),
	1338: int16(1532),
	1339: int16(-int32(2899)),
	1340: int16(1140),
	1341: int16(-int32(597)),
	1342: int16(1712),
	1343: int16(-int32(1988)),
	1344: int16(-int32(4819)),
	1345: int16(-int32(4783)),
	1346: int16(4773),
	1347: int16(-int32(8796)),
	1348: int16(2240),
	1349: int16(-int32(4596)),
	1350: int16(3565),
	1351: int16(-int32(4853)),
	1352: int16(-int32(556)),
	1353: int16(-int32(3974)),
	1354: int16(7366),
	1355: int16(-int32(4370)),
	1356: int16(3113),
	1357: int16(-int32(3548)),
	1358: int16(3552),
	1359: int16(-int32(5450)),
	1360: int16(3869),
	1361: int16(2514),
	1362: int16(6736),
	1363: int16(-int32(4570)),
	1364: int16(6074),
	1365: int16(3151),
	1404: int16(32767),
	1443: int16(32767),
}

var Opus_mapping_matrix_fifthoa_mixing = OpusT_MappingMatrix{
	Frows: int32(38),
	Fcols: int32(38),
}

var Opus_mapping_matrix_fifthoa_mixing_data = [1444]OpusT_opus_int16{
	0:    int16(9243),
	2:    int16(16010),
	6:    int16(20669),
	12:   int16(24456),
	20:   int16(27731),
	30:   int16(30657),
	38:   int16(9243),
	40:   int16(-int32(7023)),
	41:   int16(14387),
	44:   int16(-int32(4369)),
	45:   int16(-int32(14112)),
	46:   int16(14455),
	50:   int16(10931),
	51:   int16(-int32(510)),
	52:   int16(-int32(16777)),
	53:   int16(14031),
	58:   int16(-int32(5118)),
	59:   int16(14286),
	60:   int16(4343),
	61:   int16(-int32(18465)),
	62:   int16(13374),
	68:   int16(-int32(6494)),
	69:   int16(-int32(12221)),
	70:   int16(11761),
	71:   int16(8513),
	72:   int16(-int32(19458)),
	73:   int16(12605),
	76:   int16(9243),
	77:   int16(-int32(14128)),
	78:   int16(5093),
	79:   int16(5547),
	80:   int16(-int32(10946)),
	81:   int16(-int32(10050)),
	82:   int16(-int32(7197)),
	83:   int16(3945),
	84:   int16(-int32(11790)),
	85:   int16(7142),
	86:   int16(-int32(9213)),
	87:   int16(6529),
	88:   int16(-int32(9701)),
	89:   int16(-int32(2563)),
	90:   int16(-int32(9923)),
	91:   int16(-int32(14846)),
	92:   int16(16521),
	93:   int16(6816),
	94:   int16(2764),
	95:   int16(14103),
	96:   int16(1118),
	97:   int16(-int32(5537)),
	98:   int16(2977),
	99:   int16(-int32(14168)),
	100:  int16(1228),
	101:  int16(4866),
	102:  int16(17430),
	103:  int16(-int32(528)),
	104:  int16(10639),
	105:  int16(2641),
	106:  int16(10437),
	107:  int16(-int32(1037)),
	108:  int16(11460),
	109:  int16(1098),
	110:  int16(1296),
	111:  int16(15737),
	114:  int16(9243),
	115:  int16(1128),
	116:  int16(-int32(14775)),
	117:  int16(6062),
	118:  int16(955),
	119:  int16(-int32(2329)),
	120:  int16(16069),
	121:  int16(-int32(12511)),
	122:  int16(2477),
	123:  int16(579),
	124:  int16(-int32(2333)),
	125:  int16(3440),
	126:  int16(-int32(14197)),
	127:  int16(18478),
	128:  int16(-int32(6050)),
	129:  int16(940),
	130:  int16(303),
	131:  int16(-int32(1604)),
	132:  int16(4106),
	133:  int16(-int32(4223)),
	134:  int16(9829),
	135:  int16(-int32(22688)),
	136:  int16(10647),
	137:  int16(-int32(2604)),
	138:  int16(334),
	139:  int16(145),
	140:  int16(-int32(927)),
	141:  int16(3203),
	142:  int16(-int32(6017)),
	143:  int16(4507),
	144:  int16(-int32(3812)),
	145:  int16(24212),
	146:  int16(-int32(15600)),
	147:  int16(5198),
	148:  int16(-int32(1023)),
	149:  int16(110),
	152:  int16(9243),
	153:  int16(1158),
	154:  int16(12997),
	155:  int16(9277),
	156:  int16(1501),
	157:  int16(2103),
	158:  int16(10097),
	159:  int16(16840),
	160:  int16(5916),
	161:  int16(1402),
	162:  int16(3225),
	163:  int16(2488),
	164:  int16(2929),
	165:  int16(19916),
	166:  int16(12706),
	167:  int16(3585),
	168:  int16(1137),
	169:  int16(3415),
	170:  int16(4698),
	171:  int16(2078),
	172:  int16(-int32(5442)),
	173:  int16(16634),
	174:  int16(18511),
	175:  int16(8731),
	176:  int16(2095),
	177:  int16(850),
	178:  int16(3061),
	179:  int16(5733),
	180:  int16(5225),
	181:  int16(960),
	182:  int16(-int32(11728)),
	183:  int16(7689),
	184:  int16(20588),
	185:  int16(14659),
	186:  int16(5642),
	187:  int16(1187),
	190:  int16(9243),
	191:  int16(-int32(4663)),
	192:  int16(-int32(3081)),
	193:  int16(-int32(15003)),
	194:  int16(9771),
	195:  int16(2007),
	196:  int16(-int32(9185)),
	197:  int16(6457),
	198:  int16(14199),
	199:  int16(-int32(14357)),
	200:  int16(-int32(4976)),
	201:  int16(3554),
	202:  int16(6625),
	203:  int16(11434),
	204:  int16(-int32(7231)),
	205:  int16(-int32(11297)),
	206:  int16(17760),
	207:  int16(8291),
	208:  int16(-int32(6267)),
	209:  int16(-int32(3368)),
	210:  int16(6712),
	211:  int16(-int32(10837)),
	212:  int16(-int32(9107)),
	213:  int16(6524),
	214:  int16(6793),
	215:  int16(-int32(19531)),
	216:  int16(-int32(11338)),
	217:  int16(7934),
	218:  int16(7335),
	219:  int16(-int32(2205)),
	220:  int16(-int32(9215)),
	221:  int16(-int32(7094)),
	222:  int16(10659),
	223:  int16(6243),
	224:  int16(-int32(4337)),
	225:  int16(-int32(1250)),
	228:  int16(9243),
	229:  int16(-int32(13515)),
	230:  int16(7679),
	231:  int16(-int32(3831)),
	232:  int16(7232),
	233:  int16(-int32(14496)),
	234:  int16(-int32(3201)),
	235:  int16(-int32(4109)),
	236:  int16(-int32(11731)),
	237:  int16(8828),
	238:  int16(9178),
	239:  int16(-int32(1901)),
	240:  int16(-int32(10848)),
	241:  int16(-int32(539)),
	242:  int16(-int32(14888)),
	243:  int16(9626),
	244:  int16(-int32(10860)),
	245:  int16(12703),
	246:  int16(3824),
	247:  int16(12334),
	248:  int16(-int32(7104)),
	249:  int16(3496),
	250:  int16(-int32(6203)),
	251:  int16(13852),
	252:  int16(5461),
	253:  int16(-int32(2109)),
	254:  int16(-int32(17277)),
	255:  int16(7837),
	256:  int16(-int32(4714)),
	257:  int16(13901),
	258:  int16(4097),
	259:  int16(3940),
	260:  int16(7647),
	261:  int16(8546),
	262:  int16(8688),
	263:  int16(-int32(10986)),
	266:  int16(9243),
	267:  int16(8113),
	268:  int16(-int32(9860)),
	269:  int16(9657),
	270:  int16(10943),
	271:  int16(-int32(11174)),
	272:  int16(1426),
	273:  int16(-int32(13300)),
	274:  int16(1915),
	275:  int16(8178),
	276:  int16(-int32(17833)),
	277:  int16(6805),
	278:  int16(8309),
	279:  int16(8100),
	280:  int16(-int32(3121)),
	281:  int16(-int32(4742)),
	282:  int16(2683),
	283:  int16(-int32(15111)),
	284:  int16(15688),
	285:  int16(2358),
	286:  int16(-int32(11590)),
	287:  int16(2807),
	288:  int16(2746),
	289:  int16(8762),
	290:  int16(-int32(7430)),
	291:  int16(-int32(2251)),
	292:  int16(-int32(5481)),
	293:  int16(16370),
	294:  int16(-int32(4081)),
	295:  int16(-int32(9694)),
	296:  int16(5872),
	297:  int16(-int32(11539)),
	298:  int16(-int32(714)),
	299:  int16(-int32(9492)),
	300:  int16(15177),
	301:  int16(-int32(6126)),
	304:  int16(9243),
	305:  int16(9933),
	306:  int16(-int32(9215)),
	307:  int16(-int32(8528)),
	308:  int16(-int32(11831)),
	309:  int16(-int32(12785)),
	310:  int16(-int32(62)),
	311:  int16(10976),
	312:  int16(-int32(1811)),
	313:  int16(5593),
	314:  int16(18018),
	315:  int16(6100),
	316:  int16(9455),
	317:  int16(-int32(5237)),
	318:  int16(2758),
	319:  int16(8971),
	320:  int16(2743),
	321:  int16(-int32(9659)),
	322:  int16(-int32(13517)),
	323:  int16(5330),
	324:  int16(-int32(10737)),
	325:  int16(-int32(4576)),
	326:  int16(-int32(2069)),
	327:  int16(-int32(15491)),
	328:  int16(-int32(8749)),
	329:  int16(-int32(7226)),
	330:  int16(-int32(5237)),
	331:  int16(9191),
	332:  int16(-int32(181)),
	333:  int16(-int32(12277)),
	334:  int16(2815),
	335:  int16(10540),
	336:  int16(-int32(27)),
	337:  int16(14741),
	338:  int16(16703),
	339:  int16(3103),
	342:  int16(9243),
	343:  int16(-int32(10067)),
	344:  int16(-int32(8881)),
	345:  int16(-int32(8723)),
	346:  int16(12265),
	347:  int16(12487),
	348:  int16(-int32(793)),
	349:  int16(10821),
	350:  int16(-int32(1762)),
	351:  int16(-int32(6021)),
	352:  int16(-int32(18002)),
	353:  int16(-int32(5072)),
	354:  int16(9912),
	355:  int16(-int32(4395)),
	356:  int16(2587),
	357:  int16(9368),
	358:  int16(-int32(2767)),
	359:  int16(10021),
	360:  int16(12259),
	361:  int16(-int32(6468)),
	362:  int16(-int32(10113)),
	363:  int16(-int32(5605)),
	364:  int16(-int32(1761)),
	365:  int16(-int32(15590)),
	366:  int16(-int32(9430)),
	367:  int16(7800),
	368:  int16(5092),
	369:  int16(-int32(8835)),
	370:  int16(2293),
	371:  int16(12314),
	372:  int16(1222),
	373:  int16(10671),
	374:  int16(-int32(329)),
	375:  int16(13745),
	376:  int16(17349),
	377:  int16(3563),
	380:  int16(9243),
	381:  int16(-int32(6485)),
	382:  int16(12991),
	383:  int16(-int32(6743)),
	384:  int16(6108),
	385:  int16(-int32(11768)),
	386:  int16(10080),
	387:  int16(-int32(12236)),
	388:  int16(238),
	389:  int16(-int32(2883)),
	390:  int16(13115),
	391:  int16(-int32(13907)),
	392:  int16(2900),
	393:  int16(-int32(14460)),
	394:  int16(511),
	395:  int16(2564),
	396:  int16(186),
	397:  int16(-int32(7019)),
	398:  int16(19094),
	399:  int16(-int32(11597)),
	400:  int16(-int32(5472)),
	401:  int16(-int32(12058)),
	402:  int16(744),
	403:  int16(6243),
	404:  int16(-int32(2384)),
	405:  int16(930),
	406:  int16(501),
	407:  int16(-int32(11778)),
	408:  int16(21214),
	409:  int16(-int32(5330)),
	410:  int16(-int32(11746)),
	411:  int16(-int32(5542)),
	412:  int16(827),
	413:  int16(10475),
	414:  int16(-int32(6418)),
	415:  int16(1132),
	418:  int16(9243),
	419:  int16(3862),
	420:  int16(5238),
	421:  int16(-int32(14627)),
	422:  int16(-int32(7891)),
	423:  int16(2826),
	424:  int16(-int32(7015)),
	425:  int16(-int32(10701)),
	426:  int16(13900),
	427:  int16(11410),
	428:  int16(-int32(6831)),
	429:  int16(-int32(1679)),
	430:  int16(-int32(9861)),
	431:  int16(6359),
	432:  int16(12032),
	433:  int16(-int32(11660)),
	434:  int16(-int32(14041)),
	435:  int16(11199),
	436:  int16(1713),
	437:  int16(-int32(3895)),
	438:  int16(657),
	439:  int16(14749),
	440:  int16(-int32(3017)),
	441:  int16(-int32(11445)),
	442:  int16(8380),
	443:  int16(15575),
	444:  int16(-int32(15236)),
	445:  int16(-int32(346)),
	446:  int16(7690),
	447:  int16(-int32(923)),
	448:  int16(10317),
	449:  int16(3498),
	450:  int16(-int32(13545)),
	451:  int16(354),
	452:  int16(9093),
	453:  int16(-int32(4476)),
	456:  int16(9243),
	457:  int16(-int32(8417)),
	458:  int16(13183),
	459:  int16(3418),
	460:  int16(-int32(4018)),
	461:  int16(-int32(15498)),
	462:  int16(10685),
	463:  int16(6294),
	464:  int16(-int32(4132)),
	465:  int16(1419),
	466:  int16(-int32(8755)),
	467:  int16(-int32(18818)),
	468:  int16(3926),
	469:  int16(7642),
	470:  int16(-int32(9001)),
	471:  int16(-int32(3235)),
	472:  int16(2125),
	473:  int16(3506),
	474:  int16(-int32(13037)),
	475:  int16(-int32(16570)),
	476:  int16(-int32(4337)),
	477:  int16(6729),
	478:  int16(-int32(13404)),
	479:  int16(-int32(7991)),
	480:  int16(59),
	481:  int16(443),
	482:  int16(5804),
	483:  int16(6005),
	484:  int16(-int32(15011)),
	485:  int16(-int32(9060)),
	486:  int16(-int32(11044)),
	487:  int16(3679),
	488:  int16(-int32(15434)),
	489:  int16(-int32(13685)),
	490:  int16(161),
	491:  int16(1185),
	494:  int16(9243),
	495:  int16(-int32(5288)),
	496:  int16(6773),
	497:  int16(-int32(13508)),
	498:  int16(9977),
	499:  int16(-int32(5002)),
	500:  int16(-int32(4784)),
	501:  int16(-int32(12780)),
	502:  int16(10790),
	503:  int16(-int32(12942)),
	504:  int16(11168),
	505:  int16(519),
	506:  int16(-int32(10890)),
	507:  int16(1326),
	508:  int16(12078),
	509:  int16(-int32(6274)),
	510:  int16(13780),
	511:  int16(-int32(16427)),
	512:  int16(2186),
	513:  int16(5352),
	514:  int16(-int32(4328)),
	515:  int16(13671),
	516:  int16(2364),
	517:  int16(-int32(7963)),
	518:  int16(1080),
	519:  int16(-int32(12568)),
	520:  int16(19336),
	521:  int16(-int32(6557)),
	522:  int16(-int32(8574)),
	523:  int16(4084),
	524:  int16(7277),
	525:  int16(10433),
	526:  int16(-int32(9273)),
	527:  int16(-int32(3178)),
	528:  int16(1516),
	529:  int16(3817),
	532:  int16(9243),
	533:  int16(9660),
	534:  int16(7817),
	535:  int16(10093),
	536:  int16(13619),
	537:  int16(10548),
	538:  int16(-int32(2942)),
	539:  int16(11021),
	540:  int16(597),
	541:  int16(9663),
	542:  int16(17594),
	543:  int16(1736),
	544:  int16(-int32(10794)),
	545:  int16(1814),
	546:  int16(771),
	547:  int16(-int32(8469)),
	548:  int16(1041),
	549:  int16(14155),
	550:  int16(7891),
	551:  int16(-int32(8597)),
	552:  int16(-int32(7498)),
	553:  int16(-int32(8982)),
	554:  int16(346),
	555:  int16(-int32(12407)),
	556:  int16(-int32(11848)),
	557:  int16(-int32(6809)),
	558:  int16(1686),
	559:  int16(9181),
	560:  int16(-int32(8306)),
	561:  int16(-int32(10247)),
	562:  int16(3538),
	563:  int16(-int32(10706)),
	564:  int16(-int32(364)),
	565:  int16(-int32(8047)),
	566:  int16(-int32(19188)),
	567:  int16(-int32(8493)),
	570:  int16(9243),
	571:  int16(-int32(7163)),
	572:  int16(-int32(1020)),
	573:  int16(14282),
	574:  int16(-int32(14289)),
	575:  int16(1021),
	576:  int16(-int32(10208)),
	577:  int16(-int32(2036)),
	578:  int16(10660),
	579:  int16(-int32(18919)),
	580:  int16(2410),
	581:  int16(6564),
	582:  int16(2323),
	583:  int16(-int32(13088)),
	584:  int16(-int32(1798)),
	585:  int16(3365),
	586:  int16(-int32(19498)),
	587:  int16(3619),
	588:  int16(12022),
	589:  int16(-int32(1858)),
	590:  int16(9978),
	591:  int16(3705),
	592:  int16(-int32(8969)),
	593:  int16(-int32(643)),
	594:  int16(-int32(5794)),
	595:  int16(-int32(15523)),
	596:  int16(4123),
	597:  int16(15113),
	598:  int16(-int32(3949)),
	599:  int16(-int32(6265)),
	600:  int16(-int32(3596)),
	601:  int16(12490),
	602:  int16(2946),
	603:  int16(-int32(2688)),
	604:  int16(1225),
	605:  int16(-int32(14570)),
	608:  int16(9243),
	609:  int16(-int32(12187)),
	610:  int16(772),
	611:  int16(-int32(10354)),
	612:  int16(17623),
	613:  int16(-int32(1314)),
	614:  int16(-int32(10262)),
	615:  int16(-int32(1117)),
	616:  int16(-int32(2885)),
	617:  int16(-int32(9937)),
	618:  int16(2249),
	619:  int16(11267),
	620:  int16(-int32(1763)),
	621:  int16(9572),
	622:  int16(-int32(368)),
	623:  int16(16506),
	624:  int16(-int32(6510)),
	625:  int16(-int32(1438)),
	626:  int16(-int32(15014)),
	627:  int16(2402),
	628:  int16(10157),
	629:  int16(2041),
	630:  int16(2458),
	631:  int16(2389),
	632:  int16(-int32(19346)),
	633:  int16(19860),
	634:  int16(-int32(1041)),
	635:  int16(8067),
	636:  int16(-int32(3704)),
	637:  int16(-int32(10931)),
	638:  int16(2743),
	639:  int16(-int32(9286)),
	640:  int16(606),
	641:  int16(-int32(13399)),
	642:  int16(-int32(3095)),
	643:  int16(7924),
	646:  int16(9243),
	647:  int16(15545),
	648:  int16(-int32(2367)),
	649:  int16(-int32(3011)),
	650:  int16(-int32(6538)),
	651:  int16(-int32(5139)),
	652:  int16(-int32(9657)),
	653:  int16(995),
	654:  int16(-int32(16242)),
	655:  int16(-int32(15706)),
	656:  int16(2557),
	657:  int16(-int32(12952)),
	658:  int16(5226),
	659:  int16(2508),
	660:  int16(6353),
	661:  int16(10156),
	662:  int16(13593),
	663:  int16(6966),
	664:  int16(4795),
	665:  int16(8960),
	666:  int16(8183),
	667:  int16(-int32(1735)),
	668:  int16(11914),
	669:  int16(-int32(4504)),
	670:  int16(14149),
	671:  int16(11727),
	672:  int16(-int32(6665)),
	673:  int16(10460),
	674:  int16(-int32(3962)),
	675:  int16(10145),
	676:  int16(-int32(7648)),
	677:  int16(-int32(1965)),
	678:  int16(-int32(9845)),
	679:  int16(-int32(6764)),
	680:  int16(-int32(6938)),
	681:  int16(-int32(16633)),
	684:  int16(9243),
	685:  int16(3098),
	686:  int16(12983),
	687:  int16(-int32(8841)),
	688:  int16(-int32(3826)),
	689:  int16(5618),
	690:  int16(10053),
	691:  int16(-int32(16031)),
	692:  int16(4787),
	693:  int16(3283),
	694:  int16(-int32(8209)),
	695:  int16(6632),
	696:  int16(2856),
	697:  int16(-int32(18922)),
	698:  int16(10272),
	699:  int16(-int32(2055)),
	700:  int16(-int32(2344)),
	701:  int16(7987),
	702:  int16(-int32(11939)),
	703:  int16(5516),
	704:  int16(-int32(5520)),
	705:  int16(-int32(15739)),
	706:  int16(14940),
	707:  int16(-int32(5001)),
	708:  int16(530),
	709:  int16(1465),
	710:  int16(-int32(6306)),
	711:  int16(13388),
	712:  int16(-int32(13243)),
	713:  int16(2513),
	714:  int16(-int32(11772)),
	715:  int16(-int32(7170)),
	716:  int16(16572),
	717:  int16(-int32(8384)),
	718:  int16(1426),
	719:  int16(168),
	722:  int16(9243),
	723:  int16(-int32(15767)),
	724:  int16(-int32(2008)),
	725:  int16(-int32(1916)),
	726:  int16(4220),
	727:  int16(4422),
	728:  int16(-int32(9846)),
	729:  int16(537),
	730:  int16(-int32(17105)),
	731:  int16(17650),
	732:  int16(-int32(1400)),
	733:  int16(13589),
	734:  int16(4481),
	735:  int16(1651),
	736:  int16(5677),
	737:  int16(6701),
	738:  int16(-int32(9241)),
	739:  int16(-int32(6642)),
	740:  int16(-int32(3252)),
	741:  int16(-int32(7827)),
	742:  int16(8792),
	743:  int16(-int32(951)),
	744:  int16(13182),
	745:  int16(-int32(2522)),
	746:  int16(17586),
	747:  int16(-int32(17005)),
	748:  int16(3845),
	749:  int16(-int32(12562)),
	750:  int16(2213),
	751:  int16(-int32(11472)),
	752:  int16(-int32(6688)),
	753:  int16(-int32(1394)),
	754:  int16(-int32(8970)),
	755:  int16(-int32(4769)),
	756:  int16(-int32(7316)),
	757:  int16(-int32(11753)),
	760:  int16(9243),
	761:  int16(-int32(13344)),
	762:  int16(-int32(3829)),
	763:  int16(7975),
	764:  int16(-int32(14863)),
	765:  int16(7136),
	766:  int16(-int32(8561)),
	767:  int16(-int32(4265)),
	768:  int16(-int32(7992)),
	769:  int16(-int32(801)),
	770:  int16(9405),
	771:  int16(8912),
	772:  int16(7937),
	773:  int16(-int32(5326)),
	774:  int16(5057),
	775:  int16(-int32(17681)),
	776:  int16(15207),
	777:  int16(575),
	778:  int16(7717),
	779:  int16(-int32(11360)),
	780:  int16(4847),
	781:  int16(6789),
	782:  int16(4150),
	783:  int16(12686),
	784:  int16(-int32(10050)),
	785:  int16(16730),
	786:  int16(-int32(12063)),
	787:  int16(322),
	788:  int16(-int32(12920)),
	789:  int16(-int32(3313)),
	790:  int16(-int32(10267)),
	791:  int16(1980),
	792:  int16(-int32(6948)),
	793:  int16(7112),
	794:  int16(7972),
	795:  int16(8042),
	798:  int16(9243),
	799:  int16(7791),
	800:  int16(-int32(1021)),
	801:  int16(13949),
	802:  int16(15180),
	803:  int16(-int32(1111)),
	804:  int16(-int32(10208)),
	805:  int16(-int32(1989)),
	806:  int16(9348),
	807:  int16(19199),
	808:  int16(-int32(2561)),
	809:  int16(-int32(7140)),
	810:  int16(2323),
	811:  int16(-int32(12782)),
	812:  int16(-int32(1577)),
	813:  int16(817),
	814:  int16(18164),
	815:  int16(-int32(3673)),
	816:  int16(-int32(12771)),
	817:  int16(2022),
	818:  int16(9978),
	819:  int16(3620),
	820:  int16(-int32(7865)),
	821:  int16(-int32(156)),
	822:  int16(-int32(9155)),
	823:  int16(11924),
	824:  int16(-int32(3842)),
	825:  int16(-int32(15336)),
	826:  int16(4196),
	827:  int16(6814),
	828:  int16(-int32(3596)),
	829:  int16(12199),
	830:  int16(2583),
	831:  int16(-int32(652)),
	832:  int16(1936),
	833:  int16(-int32(17637)),
	836:  int16(9243),
	837:  int16(-int32(4810)),
	838:  int16(-int32(15144)),
	839:  int16(-int32(1958)),
	840:  int16(1315),
	841:  int16(10175),
	842:  int16(17406),
	843:  int16(4142),
	844:  int16(-int32(1348)),
	845:  int16(263),
	846:  int16(-int32(3292)),
	847:  int16(-int32(15632)),
	848:  int16(-int32(17046)),
	849:  int16(-int32(6363)),
	850:  int16(3374),
	851:  int16(605),
	852:  int16(-int32(227)),
	853:  int16(-int32(748)),
	854:  int16(5997),
	855:  int16(20334),
	856:  int16(14481),
	857:  int16(8277),
	858:  int16(-int32(6146)),
	859:  int16(-int32(1717)),
	860:  int16(5),
	861:  int16(27),
	862:  int16(712),
	863:  int16(1542),
	864:  int16(-int32(9197)),
	865:  int16(-int32(23572)),
	866:  int16(-int32(10163)),
	867:  int16(-int32(9595)),
	868:  int16(9425),
	869:  int16(3539),
	870:  int16(-int32(17)),
	871:  int16(-int32(72)),
	874:  int16(9243),
	875:  int16(-int32(7366)),
	876:  int16(8261),
	877:  int16(11568),
	878:  int16(-int32(11901)),
	879:  int16(-int32(8499)),
	880:  int16(-int32(2079)),
	881:  int16(13347),
	882:  int16(5556),
	883:  int16(-int32(12049)),
	884:  int16(-int32(16247)),
	885:  int16(-int32(2282)),
	886:  int16(-int32(10529)),
	887:  int16(3584),
	888:  int16(7585),
	889:  int16(-int32(1577)),
	890:  int16(-int32(8464)),
	891:  int16(-int32(18652)),
	892:  int16(-int32(8902)),
	893:  int16(5913),
	894:  int16(-int32(8688)),
	895:  int16(-int32(9287)),
	896:  int16(4156),
	897:  int16(-int32(2442)),
	898:  int16(-int32(7089)),
	899:  int16(-int32(2993)),
	900:  int16(-int32(14485)),
	901:  int16(-int32(13949)),
	902:  int16(5422),
	903:  int16(8459),
	904:  int16(1638),
	905:  int16(-int32(13285)),
	906:  int16(-int32(2531)),
	907:  int16(-int32(1826)),
	908:  int16(-int32(12132)),
	909:  int16(-int32(9456)),
	912:  int16(9243),
	913:  int16(11716),
	914:  int16(698),
	915:  int16(-int32(10889)),
	916:  int16(-int32(17818)),
	917:  int16(1143),
	918:  int16(-int32(10275)),
	919:  int16(-int32(1062)),
	920:  int16(-int32(1305)),
	921:  int16(12057),
	922:  int16(-int32(2057)),
	923:  int16(-int32(10855)),
	924:  int16(-int32(1595)),
	925:  int16(10088),
	926:  int16(-int32(150)),
	927:  int16(15043),
	928:  int16(2978),
	929:  int16(1578),
	930:  int16(15225),
	931:  int16(-int32(2090)),
	932:  int16(10201),
	933:  int16(1943),
	934:  int16(1115),
	935:  int16(1969),
	936:  int16(-int32(20211)),
	937:  int16(-int32(17636)),
	938:  int16(430),
	939:  int16(-int32(9826)),
	940:  int16(3391),
	941:  int16(10572),
	942:  int16(2485),
	943:  int16(-int32(9826)),
	944:  int16(248),
	945:  int16(-int32(12259)),
	946:  int16(-int32(2924)),
	947:  int16(12131),
	950:  int16(9243),
	951:  int16(4361),
	952:  int16(-int32(4594)),
	953:  int16(-int32(14703)),
	954:  int16(-int32(8956)),
	955:  int16(-int32(2798)),
	956:  int16(-int32(7781)),
	957:  int16(9434),
	958:  int16(13769),
	959:  int16(12936),
	960:  int16(6800),
	961:  int16(-int32(2400)),
	962:  int16(9082),
	963:  int16(8091),
	964:  int16(-int32(10453)),
	965:  int16(-int32(11023)),
	966:  int16(-int32(15786)),
	967:  int16(-int32(11136)),
	968:  int16(3285),
	969:  int16(4153),
	970:  int16(2658),
	971:  int16(-int32(14002)),
	972:  int16(-int32(5051)),
	973:  int16(9489),
	974:  int16(7000),
	975:  int16(17206),
	976:  int16(15024),
	977:  int16(-int32(2777)),
	978:  int16(-int32(8491)),
	979:  int16(-int32(42)),
	980:  int16(-int32(10626)),
	981:  int16(141),
	982:  int16(13053),
	983:  int16(2366),
	984:  int16(-int32(6662)),
	985:  int16(-int32(2231)),
	988:  int16(9243),
	989:  int16(-int32(752)),
	990:  int16(-int32(11933)),
	991:  int16(-int32(10646)),
	992:  int16(1119),
	993:  int16(1254),
	994:  int16(6890),
	995:  int16(17745),
	996:  int16(7875),
	997:  int16(-int32(1203)),
	998:  int16(-int32(2207)),
	999:  int16(-int32(1251)),
	1000: int16(2024),
	1001: int16(-int32(17706)),
	1002: int16(-int32(15532)),
	1003: int16(-int32(5600)),
	1004: int16(1128),
	1005: int16(2691),
	1006: int16(2800),
	1007: int16(683),
	1008: int16(-int32(9927)),
	1009: int16(9661),
	1010: int16(19706),
	1011: int16(12522),
	1012: int16(3889),
	1013: int16(-int32(978)),
	1014: int16(-int32(2789)),
	1015: int16(-int32(3992)),
	1016: int16(-int32(2440)),
	1017: int16(206),
	1018: int16(12695),
	1019: int16(2921),
	1020: int16(-int32(17173)),
	1021: int16(-int32(18575)),
	1022: int16(-int32(9616)),
	1023: int16(-int32(2657)),
	1026: int16(9243),
	1027: int16(4791),
	1028: int16(-int32(15001)),
	1029: int16(-int32(2887)),
	1030: int16(-int32(1931)),
	1031: int16(-int32(10037)),
	1032: int16(16885),
	1033: int16(6048),
	1034: int16(-int32(1020)),
	1035: int16(46),
	1036: int16(4789),
	1037: int16(15191),
	1038: int16(-int32(15922)),
	1039: int16(-int32(9154)),
	1040: int16(2530),
	1041: int16(823),
	1042: int16(252),
	1043: int16(-int32(130)),
	1044: int16(-int32(8608)),
	1045: int16(-int32(19335)),
	1046: int16(12613),
	1047: int16(11651),
	1048: int16(-int32(4549)),
	1049: int16(-int32(2314)),
	1050: int16(-int32(172)),
	1051: int16(-int32(101)),
	1052: int16(-int32(784)),
	1053: int16(265),
	1054: int16(12975),
	1055: int16(21741),
	1056: int16(-int32(7551)),
	1057: int16(-int32(13101)),
	1058: int16(6856),
	1059: int16(4710),
	1060: int16(535),
	1061: int16(-int32(46)),
	1064: int16(9243),
	1065: int16(-int32(12153)),
	1066: int16(-int32(10395)),
	1067: int16(754),
	1068: int16(-int32(1281)),
	1069: int16(17644),
	1070: int16(2735),
	1071: int16(-int32(1095)),
	1072: int16(-int32(10274)),
	1073: int16(8359),
	1074: int16(2200),
	1075: int16(-int32(12593)),
	1076: int16(7083),
	1077: int16(782),
	1078: int16(17650),
	1079: int16(-int32(1573)),
	1080: int16(1685),
	1081: int16(-int32(16282)),
	1082: int16(-int32(2164)),
	1083: int16(-int32(530)),
	1084: int16(-int32(11878)),
	1085: int16(32),
	1086: int16(-int32(17359)),
	1087: int16(3065),
	1088: int16(6651),
	1089: int16(-int32(5212)),
	1090: int16(-int32(3628)),
	1091: int16(19365),
	1092: int16(965),
	1093: int16(13180),
	1094: int16(8243),
	1095: int16(-int32(818)),
	1096: int16(7746),
	1097: int16(-int32(3645)),
	1098: int16(-int32(14323)),
	1099: int16(1670),
	1102: int16(9243),
	1103: int16(-int32(6961)),
	1104: int16(-int32(11198)),
	1105: int16(9081),
	1106: int16(-int32(8829)),
	1107: int16(10887),
	1108: int16(4833),
	1109: int16(-int32(14202)),
	1110: int16(2374),
	1111: int16(-int32(6524)),
	1112: int16(16339),
	1113: int16(-int32(9417)),
	1114: int16(4737),
	1115: int16(12284),
	1116: int16(-int32(4394)),
	1117: int16(-int32(2691)),
	1118: int16(-int32(2683)),
	1119: int16(13690),
	1120: int16(-int32(18539)),
	1121: int16(2830),
	1122: int16(-int32(11438)),
	1123: int16(-int32(3692)),
	1124: int16(4985),
	1125: int16(5648),
	1126: int16(-int32(4628)),
	1127: int16(514),
	1128: int16(6225),
	1129: int16(-int32(18409)),
	1130: int16(12672),
	1131: int16(5311),
	1132: int16(11170),
	1133: int16(-int32(6928)),
	1134: int16(-int32(3407)),
	1135: int16(-int32(7595)),
	1136: int16(10737),
	1137: int16(-int32(3977)),
	1140: int16(9243),
	1141: int16(12099),
	1142: int16(-int32(10405)),
	1143: int16(1294),
	1144: int16(2187),
	1145: int16(-int32(17582)),
	1146: int16(2760),
	1147: int16(-int32(1880)),
	1148: int16(-int32(10105)),
	1149: int16(-int32(8058)),
	1150: int16(-int32(3760)),
	1151: int16(12583),
	1152: int16(7058),
	1153: int16(1346),
	1154: int16(17376),
	1155: int16(-int32(2667)),
	1156: int16(-int32(2829)),
	1157: int16(15710),
	1158: int16(3705),
	1159: int16(468),
	1160: int16(-int32(11880)),
	1161: int16(50),
	1162: int16(-int32(17123)),
	1163: int16(5201),
	1164: int16(6230),
	1165: int16(4698),
	1166: int16(6098),
	1167: int16(-int32(18716)),
	1168: int16(-int32(1665)),
	1169: int16(-int32(13088)),
	1170: int16(8285),
	1171: int16(-int32(1400)),
	1172: int16(7696),
	1173: int16(-int32(6196)),
	1174: int16(-int32(13429)),
	1175: int16(2770),
	1178: int16(9243),
	1179: int16(8602),
	1180: int16(13392),
	1181: int16(1722),
	1182: int16(2070),
	1183: int16(16090),
	1184: int16(11359),
	1185: int16(3222),
	1186: int16(-int32(4960)),
	1187: int16(-int32(2638)),
	1188: int16(4581),
	1189: int16(20106),
	1190: int16(5099),
	1191: int16(4026),
	1192: int16(-int32(10978)),
	1193: int16(-int32(1778)),
	1194: int16(-int32(1314)),
	1195: int16(-int32(6620)),
	1196: int16(6988),
	1197: int16(18701),
	1198: int16(-int32(2965)),
	1199: int16(3745),
	1200: int16(-int32(16745)),
	1201: int16(-int32(4461)),
	1202: int16(1300),
	1203: int16(584),
	1204: int16(-int32(3646)),
	1205: int16(-int32(11588)),
	1206: int16(8350),
	1207: int16(11847),
	1208: int16(-int32(10050)),
	1209: int16(2372),
	1210: int16(-int32(20010)),
	1211: int16(-int32(7809)),
	1212: int16(3608),
	1213: int16(887),
	1216: int16(9243),
	1217: int16(14252),
	1218: int16(-int32(1958)),
	1219: int16(7026),
	1220: int16(13986),
	1221: int16(-int32(3899)),
	1222: int16(-int32(9870)),
	1223: int16(-int32(1922)),
	1224: int16(-int32(10736)),
	1225: int16(-int32(3693)),
	1226: int16(-int32(4527)),
	1227: int16(-int32(12333)),
	1228: int16(4376),
	1229: int16(-int32(6080)),
	1230: int16(3475),
	1231: int16(-int32(18537)),
	1232: int16(-int32(19222)),
	1233: int16(1355),
	1234: int16(-int32(10843)),
	1235: int16(6913),
	1236: int16(8869),
	1237: int16(3408),
	1238: int16(8323),
	1239: int16(6804),
	1240: int16(-int32(5141)),
	1241: int16(-int32(13648)),
	1242: int16(7800),
	1243: int16(2649),
	1244: int16(7171),
	1245: int16(10505),
	1246: int16(-int32(6548)),
	1247: int16(5179),
	1248: int16(-int32(5505)),
	1249: int16(13299),
	1250: int16(2086),
	1251: int16(15579),
	1254: int16(9243),
	1255: int16(11323),
	1256: int16(9021),
	1257: int16(-int32(6835)),
	1258: int16(-int32(10810)),
	1259: int16(14267),
	1260: int16(-int32(489)),
	1261: int16(-int32(8613)),
	1262: int16(-int32(5689)),
	1263: int16(639),
	1264: int16(-int32(16117)),
	1265: int16(6224),
	1266: int16(-int32(9731)),
	1267: int16(-int32(3757)),
	1268: int16(-int32(8482)),
	1269: int16(10882),
	1270: int16(7873),
	1271: int16(1080),
	1272: int16(-int32(11447)),
	1273: int16(-int32(6791)),
	1274: int16(-int32(10388)),
	1275: int16(4099),
	1276: int16(-int32(6025)),
	1277: int16(18396),
	1278: int16(-int32(5407)),
	1279: int16(-int32(7536)),
	1280: int16(14714),
	1281: int16(984),
	1282: int16(1267),
	1283: int16(-int32(13940)),
	1284: int16(-int32(1889)),
	1285: int16(8416),
	1286: int16(666),
	1287: int16(16762),
	1288: int16(-int32(10106)),
	1289: int16(-int32(3418)),
	1292: int16(9243),
	1293: int16(871),
	1294: int16(4833),
	1295: int16(15238),
	1296: int16(1855),
	1297: int16(588),
	1298: int16(-int32(7508)),
	1299: int16(10287),
	1300: int16(16162),
	1301: int16(2857),
	1302: int16(1481),
	1303: int16(-int32(443)),
	1304: int16(-int32(9392)),
	1305: int16(-int32(7758)),
	1306: int16(12910),
	1307: int16(16506),
	1308: int16(3837),
	1309: int16(2588),
	1310: int16(-int32(581)),
	1311: int16(-int32(851)),
	1312: int16(1928),
	1313: int16(-int32(14879)),
	1314: int16(-int32(5066)),
	1315: int16(14950),
	1316: int16(16498),
	1317: int16(4773),
	1318: int16(3842),
	1319: int16(-int32(425)),
	1320: int16(-int32(1785)),
	1321: int16(-int32(82)),
	1322: int16(10578),
	1323: int16(-int32(1435)),
	1324: int16(-int32(15554)),
	1325: int16(-int32(2459)),
	1326: int16(16520),
	1327: int16(16250),
	1330: int16(9243),
	1331: int16(14762),
	1332: int16(5967),
	1333: int16(1673),
	1334: int16(3450),
	1335: int16(12303),
	1336: int16(-int32(6027)),
	1337: int16(1394),
	1338: int16(-int32(15022)),
	1339: int16(-int32(14571)),
	1340: int16(3402),
	1341: int16(-int32(4217)),
	1342: int16(-int32(10507)),
	1343: int16(-int32(478)),
	1344: int16(-int32(14813)),
	1345: int16(-int32(5131)),
	1346: int16(-int32(6634)),
	1347: int16(-int32(16293)),
	1348: int16(-int32(82)),
	1349: int16(-int32(15276)),
	1350: int16(-int32(1705)),
	1351: int16(-int32(1731)),
	1352: int16(358),
	1353: int16(-int32(5738)),
	1354: int16(13681),
	1355: int16(12503),
	1356: int16(-int32(8200)),
	1357: int16(-int32(3023)),
	1358: int16(-int32(3290)),
	1359: int16(-int32(7384)),
	1360: int16(9272),
	1361: int16(-int32(837)),
	1362: int16(14328),
	1363: int16(-int32(1064)),
	1364: int16(16913),
	1365: int16(7915),
	1404: int16(32767),
	1443: int16(32767),
}

var Opus_mapping_matrix_foa_demixing = OpusT_MappingMatrix{
	Frows: int32(6),
	Fcols: int32(6),
}

var Opus_mapping_matrix_foa_demixing_data = [36]OpusT_opus_int16{
	0:  int16(16384),
	1:  int16(16384),
	2:  int16(16384),
	3:  int16(16384),
	7:  int16(23170),
	9:  int16(-int32(23170)),
	12: int16(-int32(16384)),
	13: int16(16384),
	14: int16(-int32(16384)),
	15: int16(16384),
	18: int16(23170),
	20: int16(-int32(23170)),
	28: int16(32767),
	35: int16(32767),
}

var Opus_mapping_matrix_foa_mixing = OpusT_MappingMatrix{
	Frows: int32(6),
	Fcols: int32(6),
}

var Opus_mapping_matrix_foa_mixing_data = [36]OpusT_opus_int16{
	0:  int16(16384),
	2:  int16(-int32(16384)),
	3:  int16(23170),
	6:  int16(16384),
	7:  int16(23170),
	8:  int16(16384),
	12: int16(16384),
	14: int16(-int32(16384)),
	15: int16(-int32(23170)),
	18: int16(16384),
	19: int16(-int32(23170)),
	20: int16(16384),
	28: int16(32767),
	35: int16(32767),
}

var Opus_mapping_matrix_fourthoa_demixing = OpusT_MappingMatrix{
	Frows: int32(27),
	Fcols: int32(27),
}

var Opus_mapping_matrix_fourthoa_demixing_data = [729]OpusT_opus_int16{
	0:   int16(4870),
	1:   int16(4484),
	2:   int16(4870),
	3:   int16(4347),
	4:   int16(4440),
	5:   int16(4726),
	6:   int16(4683),
	7:   int16(4821),
	8:   int16(4883),
	9:   int16(4842),
	10:  int16(4603),
	11:  int16(4484),
	12:  int16(4683),
	13:  int16(4698),
	14:  int16(4234),
	15:  int16(4368),
	16:  int16(4603),
	17:  int16(4783),
	18:  int16(4783),
	19:  int16(4820),
	20:  int16(4821),
	21:  int16(4347),
	22:  int16(4820),
	23:  int16(4440),
	24:  int16(4698),
	27:  int16(101),
	28:  int16(84),
	29:  int16(-int32(7818)),
	30:  int16(4640),
	31:  int16(-int32(7178)),
	32:  int16(-int32(5492)),
	33:  int16(4629),
	34:  int16(8384),
	35:  int16(6547),
	36:  int16(-int32(4966)),
	37:  int16(617),
	38:  int16(-int32(6345)),
	39:  int16(1061),
	40:  int16(-int32(3241)),
	41:  int16(2939),
	42:  int16(5549),
	43:  int16(6390),
	44:  int16(-int32(4434)),
	45:  int16(4994),
	46:  int16(-int32(2610)),
	47:  int16(1993),
	48:  int16(-int32(2873)),
	49:  int16(1547),
	50:  int16(-int32(4356)),
	51:  int16(-int32(164)),
	54:  int16(8797),
	55:  int16(5074),
	56:  int16(-int32(1553)),
	57:  int16(5383),
	58:  int16(1906),
	59:  int16(5297),
	60:  int16(2722),
	61:  int16(1158),
	62:  int16(-int32(5226)),
	63:  int16(1311),
	64:  int16(-int32(7760)),
	65:  int16(-int32(3327)),
	66:  int16(-int32(1940)),
	67:  int16(1586),
	68:  int16(-int32(4093)),
	69:  int16(-int32(2951)),
	70:  int16(-int32(214)),
	71:  int16(-int32(6873)),
	72:  int16(5450),
	73:  int16(-int32(4875)),
	74:  int16(-int32(7193)),
	75:  int16(-int32(4438)),
	76:  int16(558),
	77:  int16(5593),
	78:  int16(5607),
	81:  int16(-int32(26)),
	82:  int16(5761),
	83:  int16(-int32(3723)),
	84:  int16(-int32(1460)),
	85:  int16(1195),
	86:  int16(-int32(3065)),
	87:  int16(-int32(6357)),
	88:  int16(-int32(1175)),
	89:  int16(608),
	90:  int16(6965),
	91:  int16(2310),
	92:  int16(2759),
	93:  int16(-int32(8023)),
	94:  int16(-int32(7138)),
	95:  int16(5162),
	96:  int16(-int32(3624)),
	97:  int16(5006),
	98:  int16(-int32(809)),
	99:  int16(3592),
	100: int16(6209),
	101: int16(-int32(4159)),
	102: int16(-int32(4968)),
	103: int16(8150),
	104: int16(2513),
	105: int16(-int32(5702)),
	108: int16(301),
	109: int16(109),
	110: int16(7161),
	111: int16(-int32(2462)),
	112: int16(-int32(2443)),
	113: int16(5044),
	114: int16(-int32(7125)),
	115: int16(-int32(2256)),
	116: int16(1967),
	117: int16(-int32(9107)),
	118: int16(259),
	119: int16(-int32(4928)),
	120: int16(-int32(2592)),
	121: int16(6514),
	122: int16(4111),
	123: int16(-int32(7236)),
	124: int16(8695),
	125: int16(635),
	126: int16(5009),
	127: int16(-int32(4025)),
	128: int16(-int32(1937)),
	129: int16(4794),
	130: int16(3420),
	131: int16(-int32(3507)),
	132: int16(-int32(400)),
	135: int16(-int32(134)),
	136: int16(85),
	137: int16(2771),
	138: int16(7842),
	139: int16(-int32(3649)),
	140: int16(-int32(8225)),
	141: int16(2866),
	142: int16(2586),
	143: int16(-int32(9200)),
	144: int16(-int32(1945)),
	145: int16(-int32(1563)),
	146: int16(6155),
	147: int16(-int32(720)),
	148: int16(-int32(1061)),
	149: int16(-int32(3494)),
	150: int16(-int32(4513)),
	151: int16(-int32(487)),
	152: int16(8389),
	153: int16(7317),
	154: int16(3348),
	155: int16(-int32(3721)),
	156: int16(3806),
	157: int16(371),
	158: int16(-int32(6896)),
	159: int16(70),
	162: int16(10919),
	163: int16(2072),
	164: int16(-int32(4867)),
	165: int16(3472),
	166: int16(-int32(4429)),
	167: int16(1721),
	168: int16(-int32(4066)),
	169: int16(-int32(5193)),
	170: int16(1032),
	171: int16(-int32(5253)),
	172: int16(9501),
	173: int16(-int32(2017)),
	174: int16(-int32(3971)),
	175: int16(-int32(5261)),
	176: int16(-int32(306)),
	177: int16(-int32(2737)),
	178: int16(-int32(5137)),
	179: int16(5713),
	180: int16(1237),
	181: int16(-int32(8)),
	182: int16(6387),
	183: int16(364),
	184: int16(-int32(5423)),
	185: int16(3364),
	186: int16(2888),
	189: int16(-int32(48)),
	190: int16(8946),
	191: int16(1048),
	192: int16(-int32(2691)),
	193: int16(602),
	194: int16(-int32(4332)),
	195: int16(-int32(4302)),
	196: int16(-int32(514)),
	197: int16(-int32(1730)),
	198: int16(2459),
	199: int16(-int32(4328)),
	200: int16(-int32(2156)),
	201: int16(3335),
	202: int16(-int32(2748)),
	203: int16(-int32(6029)),
	204: int16(4023),
	205: int16(155),
	206: int16(897),
	207: int16(5268),
	208: int16(-int32(8380)),
	209: int16(7625),
	210: int16(7395),
	211: int16(508),
	212: int16(3945),
	213: int16(-int32(8951)),
	216: int16(39),
	217: int16(4151),
	218: int16(-int32(5965)),
	219: int16(-int32(3398)),
	220: int16(-int32(7006)),
	221: int16(-int32(3534)),
	222: int16(2697),
	223: int16(-int32(8989)),
	224: int16(-int32(5237)),
	225: int16(2913),
	226: int16(46),
	227: int16(-int32(5540)),
	228: int16(8196),
	229: int16(5766),
	230: int16(2711),
	231: int16(-int32(2520)),
	232: int16(-int32(3043)),
	233: int16(-int32(2146)),
	234: int16(-int32(948)),
	235: int16(4965),
	236: int16(1806),
	237: int16(2472),
	238: int16(8988),
	239: int16(-int32(1266)),
	240: int16(4840),
	243: int16(-int32(407)),
	244: int16(-int32(189)),
	245: int16(2179),
	246: int16(-int32(1627)),
	247: int16(6516),
	248: int16(259),
	249: int16(7196),
	250: int16(-int32(9449)),
	251: int16(-int32(4905)),
	252: int16(-int32(9766)),
	253: int16(561),
	254: int16(4021),
	255: int16(3371),
	256: int16(-int32(8650)),
	257: int16(5032),
	258: int16(3329),
	259: int16(2534),
	260: int16(641),
	261: int16(2224),
	262: int16(-int32(5747)),
	263: int16(1047),
	264: int16(-int32(4074)),
	265: int16(5252),
	266: int16(-int32(24)),
	267: int16(674),
	270: int16(664),
	271: int16(237),
	272: int16(-int32(2837)),
	273: int16(-int32(4072)),
	274: int16(-int32(1205)),
	275: int16(8252),
	276: int16(-int32(5875)),
	277: int16(-int32(1670)),
	278: int16(-int32(2743)),
	279: int16(-int32(3984)),
	280: int16(381),
	281: int16(5059),
	282: int16(1765),
	283: int16(2666),
	284: int16(-int32(8295)),
	285: int16(7403),
	286: int16(1154),
	287: int16(-int32(2086)),
	288: int16(7622),
	289: int16(7105),
	290: int16(3677),
	291: int16(-int32(6943)),
	292: int16(1050),
	293: int16(-int32(6632)),
	294: int16(-int32(694)),
	297: int16(382),
	298: int16(-int32(133)),
	299: int16(5699),
	300: int16(7650),
	301: int16(5154),
	302: int16(-int32(5713)),
	303: int16(-int32(1645)),
	304: int16(-int32(6902)),
	305: int16(6181),
	306: int16(4450),
	307: int16(1151),
	308: int16(410),
	309: int16(-int32(993)),
	310: int16(3829),
	311: int16(2444),
	312: int16(-int32(2405)),
	313: int16(-int32(6618)),
	314: int16(-int32(9514)),
	315: int16(5366),
	316: int16(-int32(1896)),
	317: int16(5844),
	318: int16(-int32(2886)),
	319: int16(-int32(1524)),
	320: int16(-int32(7321)),
	321: int16(-int32(1007)),
	324: int16(12767),
	325: int16(-int32(2530)),
	326: int16(3183),
	327: int16(-int32(1409)),
	328: int16(-int32(4015)),
	329: int16(-int32(2894)),
	330: int16(-int32(5155)),
	331: int16(-int32(1710)),
	332: int16(3841),
	333: int16(-int32(2107)),
	334: int16(-int32(10274)),
	335: int16(5119),
	336: int16(3979),
	337: int16(-int32(4010)),
	338: int16(5550),
	339: int16(4822),
	340: int16(-int32(746)),
	341: int16(-int32(2507)),
	342: int16(-int32(3080)),
	343: int16(4289),
	344: int16(-int32(3675)),
	345: int16(4333),
	346: int16(-int32(1416)),
	347: int16(-int32(1230)),
	348: int16(-int32(1122)),
	351: int16(17),
	352: int16(8048),
	353: int16(2398),
	354: int16(-int32(2167)),
	355: int16(-int32(73)),
	356: int16(-int32(3606)),
	357: int16(3125),
	358: int16(398),
	359: int16(731),
	360: int16(-int32(5973)),
	361: int16(5705),
	362: int16(-int32(1032)),
	363: int16(4679),
	364: int16(7305),
	365: int16(3134),
	366: int16(1301),
	367: int16(-int32(3858)),
	368: int16(-int32(89)),
	369: int16(2938),
	370: int16(4359),
	371: int16(-int32(9155)),
	372: int16(-int32(4805)),
	373: int16(-int32(8407)),
	374: int16(3673),
	375: int16(-int32(8645)),
	378: int16(187),
	379: int16(7355),
	380: int16(3145),
	381: int16(-int32(6719)),
	382: int16(-int32(4432)),
	383: int16(-int32(5939)),
	384: int16(2541),
	385: int16(-int32(2810)),
	386: int16(9723),
	387: int16(778),
	388: int16(-int32(1105)),
	389: int16(5687),
	390: int16(-int32(4174)),
	391: int16(2534),
	392: int16(-int32(4461)),
	393: int16(1017),
	394: int16(-int32(244)),
	395: int16(5481),
	396: int16(-int32(1655)),
	397: int16(-int32(6765)),
	398: int16(-int32(3350)),
	399: int16(-int32(4894)),
	400: int16(1592),
	401: int16(-int32(2318)),
	402: int16(8827),
	405: int16(196),
	406: int16(3588),
	407: int16(9631),
	408: int16(3063),
	409: int16(-int32(4564)),
	410: int16(6043),
	411: int16(2683),
	412: int16(2595),
	413: int16(-int32(2488)),
	414: int16(-int32(2186)),
	415: int16(173),
	416: int16(-int32(6059)),
	417: int16(-int32(8270)),
	418: int16(-int32(2386)),
	419: int16(409),
	420: int16(7441),
	421: int16(-int32(8608)),
	422: int16(376),
	423: int16(-int32(4364)),
	424: int16(2321),
	425: int16(-int32(280)),
	426: int16(97),
	427: int16(8331),
	428: int16(-int32(3022)),
	429: int16(-int32(4721)),
	432: int16(117),
	433: int16(-int32(748)),
	434: int16(-int32(10833)),
	435: int16(1533),
	436: int16(4200),
	437: int16(-int32(2875)),
	438: int16(-int32(997)),
	439: int16(-int32(109)),
	440: int16(-int32(3661)),
	441: int16(-int32(6119)),
	442: int16(4454),
	443: int16(8808),
	444: int16(-int32(9189)),
	445: int16(8294),
	446: int16(1521),
	447: int16(7265),
	448: int16(-int32(2348)),
	449: int16(-int32(5094)),
	450: int16(-int32(948)),
	451: int16(-int32(5400)),
	452: int16(-int32(3193)),
	453: int16(8914),
	454: int16(5763),
	455: int16(1716),
	456: int16(-int32(1070)),
	459: int16(2497),
	460: int16(399),
	461: int16(-int32(5201)),
	462: int16(-int32(2038)),
	463: int16(7843),
	464: int16(-int32(376)),
	465: int16(7567),
	466: int16(-int32(5073)),
	467: int16(7616),
	468: int16(-int32(5537)),
	469: int16(2086),
	470: int16(-int32(3453)),
	471: int16(-int32(5544)),
	472: int16(-int32(56)),
	473: int16(-int32(11648)),
	474: int16(-int32(1314)),
	475: int16(3546),
	476: int16(-int32(3432)),
	477: int16(-int32(117)),
	478: int16(8694),
	479: int16(-int32(4245)),
	480: int16(9621),
	481: int16(3098),
	482: int16(-int32(2582)),
	483: int16(-int32(2351)),
	486: int16(4386),
	487: int16(-int32(3104)),
	488: int16(-int32(3132)),
	489: int16(-int32(10512)),
	490: int16(566),
	491: int16(5217),
	492: int16(5128),
	493: int16(4967),
	494: int16(1348),
	495: int16(7035),
	496: int16(-int32(1470)),
	497: int16(91),
	498: int16(-int32(125)),
	499: int16(-int32(3548)),
	500: int16(8244),
	501: int16(-int32(3029)),
	502: int16(-int32(10033)),
	503: int16(2186),
	504: int16(9745),
	505: int16(-int32(6440)),
	506: int16(-int32(2074)),
	507: int16(3638),
	508: int16(-int32(1477)),
	509: int16(-int32(7045)),
	510: int16(-int32(562)),
	513: int16(2154),
	514: int16(8116),
	515: int16(-int32(6102)),
	516: int16(6570),
	517: int16(12998),
	518: int16(-int32(712)),
	519: int16(-int32(4126)),
	520: int16(-int32(4996)),
	521: int16(30),
	522: int16(1571),
	523: int16(-int32(6393)),
	524: int16(-int32(12794)),
	525: int16(425),
	526: int16(5036),
	527: int16(1190),
	528: int16(5763),
	529: int16(5653),
	530: int16(12933),
	531: int16(-int32(6671)),
	532: int16(5197),
	533: int16(-int32(2964)),
	534: int16(-int32(3316)),
	535: int16(-int32(6354)),
	536: int16(-int32(10554)),
	537: int16(-int32(2652)),
	540: int16(12618),
	541: int16(-int32(3737)),
	542: int16(93),
	543: int16(-int32(5901)),
	544: int16(4262),
	545: int16(-int32(3364)),
	546: int16(4444),
	547: int16(3103),
	548: int16(-int32(2767)),
	549: int16(3403),
	550: int16(4925),
	551: int16(-int32(2584)),
	552: int16(-int32(989)),
	553: int16(4977),
	554: int16(-int32(3714)),
	555: int16(-int32(1965)),
	556: int16(3076),
	557: int16(326),
	558: int16(-int32(2946)),
	559: int16(-int32(2568)),
	560: int16(1026),
	561: int16(-int32(2980)),
	562: int16(3362),
	563: int16(-int32(6132)),
	564: int16(-int32(5966)),
	567: int16(6001),
	568: int16(48),
	569: int16(-int32(1979)),
	570: int16(-int32(7275)),
	571: int16(3476),
	572: int16(-int32(2096)),
	573: int16(10591),
	574: int16(3793),
	575: int16(2629),
	576: int16(-int32(447)),
	577: int16(-int32(14747)),
	578: int16(-int32(3689)),
	579: int16(-int32(5525)),
	580: int16(8358),
	581: int16(6883),
	582: int16(-int32(9703)),
	583: int16(-int32(4556)),
	584: int16(7471),
	585: int16(2965),
	586: int16(4056),
	587: int16(13221),
	588: int16(-int32(7327)),
	589: int16(-int32(3073)),
	590: int16(-int32(2353)),
	591: int16(-int32(6720)),
	594: int16(621),
	595: int16(11034),
	596: int16(-int32(44)),
	597: int16(-int32(2828)),
	598: int16(5978),
	599: int16(-int32(1850)),
	600: int16(-int32(1772)),
	601: int16(3894),
	602: int16(-int32(7471)),
	603: int16(-int32(1397)),
	604: int16(945),
	605: int16(-int32(2028)),
	606: int16(-int32(2928)),
	607: int16(-int32(2240)),
	608: int16(3172),
	609: int16(2222),
	610: int16(4544),
	611: int16(-int32(4243)),
	612: int16(-int32(5645)),
	613: int16(3745),
	614: int16(2573),
	615: int16(3511),
	616: int16(-int32(8206)),
	617: int16(-int32(7286)),
	618: int16(5700),
	621: int16(321),
	622: int16(10818),
	623: int16(-int32(4982)),
	624: int16(7813),
	625: int16(-int32(749)),
	626: int16(9907),
	627: int16(1360),
	628: int16(-int32(1443)),
	629: int16(568),
	630: int16(-int32(1103)),
	631: int16(2305),
	632: int16(6045),
	633: int16(2270),
	634: int16(-int32(1063)),
	635: int16(-int32(1920)),
	636: int16(-int32(3073)),
	637: int16(5893),
	638: int16(-int32(3476)),
	639: int16(-int32(11346)),
	640: int16(-int32(1657)),
	641: int16(-int32(588)),
	642: int16(2957),
	643: int16(-int32(2287)),
	644: int16(-int32(8527)),
	645: int16(-int32(8041)),
	648: int16(119),
	649: int16(-int32(268)),
	650: int16(2372),
	651: int16(-int32(3040)),
	652: int16(4979),
	653: int16(-int32(3789)),
	654: int16(-int32(5630)),
	655: int16(10619),
	656: int16(5900),
	657: int16(-int32(5109)),
	658: int16(-int32(4585)),
	659: int16(-int32(3862)),
	660: int16(10467),
	661: int16(-int32(3527)),
	662: int16(-int32(385)),
	663: int16(-int32(10034)),
	664: int16(-int32(9991)),
	665: int16(4860),
	666: int16(984),
	667: int16(2362),
	668: int16(2311),
	669: int16(-int32(6804)),
	670: int16(6324),
	671: int16(433),
	672: int16(5291),
	700: int16(32767),
	728: int16(32767),
}

var Opus_mapping_matrix_fourthoa_mixing = OpusT_MappingMatrix{
	Frows: int32(27),
	Fcols: int32(27),
}

var Opus_mapping_matrix_fourthoa_mixing_data = [729]OpusT_opus_int16{
	0:   int16(9243),
	2:   int16(16010),
	6:   int16(20669),
	12:  int16(24456),
	20:  int16(27731),
	27:  int16(9243),
	29:  int16(10884),
	30:  int16(11741),
	33:  int16(3995),
	34:  int16(17849),
	35:  int16(9626),
	39:  int16(-int32(5727)),
	40:  int16(14399),
	41:  int16(17315),
	42:  int16(7625),
	47:  int16(-int32(11747)),
	48:  int16(2574),
	49:  int16(18637),
	50:  int16(15552),
	51:  int16(5930),
	54:  int16(9243),
	55:  int16(-int32(14302)),
	56:  int16(-int32(2682)),
	57:  int16(-int32(6677)),
	58:  int16(13337),
	59:  int16(5357),
	60:  int16(-int32(9464)),
	61:  int16(2501),
	62:  int16(-int32(11170)),
	63:  int16(4770),
	64:  int16(-int32(5911)),
	65:  int16(11501),
	66:  int16(5858),
	67:  int16(5369),
	68:  int16(4951),
	69:  int16(17901),
	70:  int16(-int32(19071)),
	71:  int16(-int32(2397)),
	72:  int16(-int32(9281)),
	73:  int16(-int32(9198)),
	74:  int16(7576),
	75:  int16(-int32(4294)),
	76:  int16(7773),
	77:  int16(-int32(8997)),
	78:  int16(-int32(3399)),
	81:  int16(9243),
	82:  int16(9940),
	83:  int16(11991),
	84:  int16(-int32(3705)),
	85:  int16(-int32(5144)),
	86:  int16(16647),
	87:  int16(7057),
	88:  int16(-int32(6206)),
	89:  int16(-int32(5941)),
	90:  int16(-int32(2698)),
	91:  int16(-int32(10194)),
	92:  int16(16781),
	93:  int16(-int32(1788)),
	94:  int16(-int32(6256)),
	95:  int16(-int32(11772)),
	96:  int16(4935),
	97:  int16(3912),
	98:  int16(-int32(6062)),
	99:  int16(-int32(13039)),
	100: int16(9446),
	101: int16(-int32(9758)),
	102: int16(-int32(3521)),
	103: int16(-int32(15058)),
	104: int16(11089),
	105: int16(565),
	108: int16(9243),
	109: int16(-int32(15376)),
	110: int16(3720),
	111: int16(2461),
	112: int16(-int32(5285)),
	113: int16(-int32(7989)),
	114: int16(-int32(8660)),
	115: int16(1278),
	116: int16(-int32(16087)),
	117: int16(15811),
	118: int16(-int32(3249)),
	119: int16(10500),
	120: int16(-int32(7757)),
	121: int16(-int32(1680)),
	122: int16(-int32(9890)),
	123: int16(-int32(8153)),
	124: int16(10884),
	125: int16(11022),
	126: int16(2847),
	127: int16(12828),
	128: int16(5137),
	129: int16(-int32(2053)),
	130: int16(8666),
	131: int16(-int32(5684)),
	132: int16(14776),
	135: int16(9243),
	136: int16(-int32(10577)),
	137: int16(10304),
	138: int16(-int32(6186)),
	139: int16(9139),
	140: int16(-int32(15222)),
	141: int16(2507),
	142: int16(-int32(8902)),
	143: int16(-int32(5140)),
	144: int16(-int32(145)),
	145: int16(15562),
	146: int16(-int32(10596)),
	147: int16(-int32(7311)),
	148: int16(-int32(6197)),
	149: int16(-int32(8753)),
	150: int16(8667),
	151: int16(-int32(6014)),
	152: int16(-int32(281)),
	153: int16(15033),
	154: int16(938),
	155: int16(-int32(11859)),
	156: int16(548),
	157: int16(-int32(8456)),
	158: int16(16735),
	159: int16(-int32(3654)),
	162: int16(9243),
	163: int16(8974),
	164: int16(4839),
	165: int16(-int32(12343)),
	166: int16(-int32(15472)),
	167: int16(6066),
	168: int16(-int32(7501)),
	169: int16(-int32(8343)),
	170: int16(5015),
	171: int16(15920),
	172: int16(-int32(12374)),
	173: int16(-int32(4559)),
	174: int16(-int32(9400)),
	175: int16(6271),
	176: int16(4011),
	177: int16(5191),
	178: int16(-int32(9932)),
	179: int16(14438),
	180: int16(4828),
	181: int16(-int32(8768)),
	182: int16(1909),
	183: int16(12059),
	184: int16(-int32(1565)),
	185: int16(4707),
	186: int16(-int32(13711)),
	189: int16(9243),
	190: int16(15799),
	191: int16(2085),
	192: int16(-int32(1534)),
	193: int16(-int32(3386)),
	194: int16(4602),
	195: int16(-int32(9808)),
	196: int16(-int32(447)),
	197: int16(-int32(17267)),
	198: int16(-int32(18054)),
	199: int16(-int32(1167)),
	200: int16(-int32(13525)),
	201: int16(-int32(4644)),
	202: int16(1313),
	203: int16(-int32(5951)),
	204: int16(5397),
	205: int16(7485),
	206: int16(-int32(7056)),
	207: int16(2584),
	208: int16(-int32(8120)),
	209: int16(8669),
	210: int16(788),
	211: int16(13177),
	212: int16(2109),
	213: int16(18349),
	216: int16(9243),
	217: int16(12371),
	218: int16(-int32(10036)),
	219: int16(1597),
	220: int16(2760),
	221: int16(-int32(17341)),
	222: int16(1848),
	223: int16(-int32(2239)),
	224: int16(-int32(10509)),
	225: int16(-int32(8474)),
	226: int16(-int32(4577)),
	227: int16(11164),
	228: int16(7935),
	229: int16(1441),
	230: int16(17430),
	231: int16(-int32(3436)),
	232: int16(-int32(3713)),
	233: int16(15936),
	234: int16(4184),
	235: int16(2647),
	236: int16(-int32(11730)),
	237: int16(341),
	238: int16(-int32(15934)),
	239: int16(6462),
	240: int16(6581),
	243: int16(9243),
	244: int16(-int32(8963)),
	245: int16(2184),
	246: int16(13084),
	247: int16(-int32(16381)),
	248: int16(-int32(2734)),
	249: int16(-int32(9757)),
	250: int16(3991),
	251: int16(6345),
	252: int16(-int32(18297)),
	253: int16(-int32(5912)),
	254: int16(7604),
	255: int16(-int32(4849)),
	256: int16(-int32(11100)),
	257: int16(2290),
	258: int16(-int32(4304)),
	259: int16(-int32(13305)),
	260: int16(-int32(7488)),
	261: int16(12338),
	262: int16(4805),
	263: int16(8505),
	264: int16(-int32(7014)),
	265: int16(-int32(4779)),
	266: int16(-int32(1761)),
	267: int16(-int32(14597)),
	270: int16(9243),
	271: int16(1301),
	272: int16(-int32(15498)),
	273: int16(3799),
	274: int16(690),
	275: int16(-int32(2816)),
	276: int16(18718),
	277: int16(-int32(8223)),
	278: int16(889),
	279: int16(255),
	280: int16(-int32(1768)),
	281: int16(4485),
	282: int16(-int32(19951)),
	283: int16(13097),
	284: int16(-int32(2278)),
	285: int16(167),
	286: int16(78),
	287: int16(-int32(740)),
	288: int16(3324),
	289: int16(-int32(6139)),
	290: int16(19488),
	291: int16(-int32(17925)),
	292: int16(4283),
	293: int16(-int32(486)),
	294: int16(20),
	297: int16(9243),
	298: int16(-int32(13470)),
	299: int16(-int32(6719)),
	300: int16(5452),
	301: int16(-int32(10257)),
	302: int16(12641),
	303: int16(-int32(4873)),
	304: int16(-int32(5116)),
	305: int16(-int32(10595)),
	306: int16(5856),
	307: int16(11389),
	308: int16(1502),
	309: int16(10876),
	310: int16(-int32(608)),
	311: int16(11765),
	312: int16(-int32(13218)),
	313: int16(13911),
	314: int16(-int32(7373)),
	315: int16(-int32(2070)),
	316: int16(-int32(13679)),
	317: int16(-int32(4154)),
	318: int16(5536),
	319: int16(-int32(2138)),
	320: int16(16643),
	321: int16(451),
	324: int16(9243),
	325: int16(2455),
	326: int16(-int32(3679)),
	327: int16(-int32(15387)),
	328: int16(-int32(5277)),
	329: int16(-int32(1261)),
	330: int16(-int32(8697)),
	331: int16(7906),
	332: int16(16112),
	333: int16(8147),
	334: int16(3208),
	335: int16(-int32(1690)),
	336: int16(7687),
	337: int16(10593),
	338: int16(-int32(9796)),
	339: int16(-int32(15852)),
	340: int16(-int32(10884)),
	341: int16(-int32(5616)),
	342: int16(2881),
	343: int16(2032),
	344: int16(5246),
	345: int16(-int32(12735)),
	346: int16(-int32(8796)),
	347: int16(10928),
	348: int16(14833),
	351: int16(9243),
	352: int16(-int32(6849)),
	353: int16(2775),
	354: int16(-int32(14202)),
	355: int16(13586),
	356: int16(-int32(2655)),
	357: int16(-int32(9402)),
	358: int16(-int32(5505)),
	359: int16(10809),
	360: int16(-int32(18013)),
	361: int16(6231),
	362: int16(5444),
	363: int16(-int32(6041)),
	364: int16(11288),
	365: int16(4958),
	366: int16(-int32(4078)),
	367: int16(18799),
	368: int16(-int32(9368)),
	369: int16(-int32(9291)),
	370: int16(4535),
	371: int16(7383),
	372: int16(9405),
	373: int16(-int32(7391)),
	374: int16(-int32(2121)),
	375: int16(-int32(4336)),
	378: int16(9243),
	379: int16(6423),
	380: int16(-int32(9040)),
	381: int16(11548),
	382: int16(10359),
	383: int16(-int32(8109)),
	384: int16(-int32(450)),
	385: int16(-int32(14580)),
	386: int16(6431),
	387: int16(10857),
	388: int16(-int32(15475)),
	389: int16(3569),
	390: int16(9707),
	391: int16(6416),
	392: int16(-int32(9607)),
	393: int16(521),
	394: int16(8528),
	395: int16(-int32(18391)),
	396: int16(11049),
	397: int16(3815),
	398: int16(-int32(10423)),
	399: int16(6860),
	400: int16(6860),
	401: int16(-int32(883)),
	402: int16(-int32(4221)),
	405: int16(9243),
	406: int16(11932),
	407: int16(-int32(5968)),
	408: int16(-int32(8850)),
	409: int16(-int32(14749)),
	410: int16(-int32(9946)),
	411: int16(-int32(6026)),
	412: int16(7377),
	413: int16(-int32(4472)),
	414: int16(5206),
	415: int16(14547),
	416: int16(-int32(3406)),
	417: int16(10508),
	418: int16(2526),
	419: int16(4411),
	420: int16(14543),
	421: int16(8444),
	422: int16(-int32(5822)),
	423: int16(347),
	424: int16(12347),
	425: int16(-int32(1709)),
	426: int16(-int32(9158)),
	427: int16(105),
	428: int16(-int32(16265)),
	429: int16(-int32(12642)),
	432: int16(9243),
	433: int16(13044),
	434: int16(-int32(150)),
	435: int16(9282),
	436: int16(16910),
	437: int16(-int32(274)),
	438: int16(-int32(10332)),
	439: int16(-int32(194)),
	440: int16(-int32(5864)),
	441: int16(5428),
	442: int16(-int32(420)),
	443: int16(-int32(12196)),
	444: int16(344),
	445: int16(-int32(8679)),
	446: int16(145),
	447: int16(-int32(18554)),
	448: int16(-int32(12695)),
	449: int16(-int32(152)),
	450: int16(-int32(14635)),
	451: int16(503),
	452: int16(10389),
	453: int16(358),
	454: int16(5076),
	455: int16(522),
	456: int16(-int32(16100)),
	459: int16(9243),
	460: int16(-int32(8374)),
	461: int16(-int32(13590)),
	462: int16(-int32(1221)),
	463: int16(1428),
	464: int16(15896),
	465: int16(12005),
	466: int16(2318),
	467: int16(-int32(4793)),
	468: int16(2590),
	469: int16(-int32(3209)),
	470: int16(-int32(20390)),
	471: int16(-int32(6256)),
	472: int16(-int32(2974)),
	473: int16(10766),
	474: int16(1202),
	475: int16(-int32(876)),
	476: int16(-int32(6597)),
	477: int16(5004),
	478: int16(19896),
	479: int16(-int32(1541)),
	480: int16(2902),
	481: int16(-int32(16788)),
	482: int16(-int32(3062)),
	483: int16(1340),
	486: int16(9243),
	487: int16(9879),
	488: int16(10267),
	489: int16(7300),
	490: int16(10073),
	491: int16(14167),
	492: int16(2416),
	493: int16(10469),
	494: int16(-int32(3094)),
	495: int16(2899),
	496: int16(17092),
	497: int16(9762),
	498: int16(-int32(7400)),
	499: int16(7214),
	500: int16(-int32(5250)),
	501: int16(-int32(8238)),
	502: int16(-int32(3989)),
	503: int16(5578),
	504: int16(16392),
	505: int16(-int32(1050)),
	506: int16(-int32(11848)),
	507: int16(-int32(776)),
	508: int16(-int32(5034)),
	509: int16(-int32(15850)),
	510: int16(-int32(5882)),
	513: int16(9243),
	514: int16(-int32(4974)),
	515: int16(-int32(9068)),
	516: int16(12221),
	517: int16(-int32(8490)),
	518: int16(6299),
	519: int16(-int32(388)),
	520: int16(-int32(15478)),
	521: int16(8702),
	522: int16(-int32(9920)),
	523: int16(12723),
	524: int16(-int32(2810)),
	525: int16(9668),
	526: int16(6905),
	527: int16(-int32(13040)),
	528: int16(4325),
	529: int16(-int32(9456)),
	530: int16(16856),
	531: int16(-int32(9159)),
	532: int16(-int32(2909)),
	533: int16(-int32(10476)),
	534: int16(7149),
	535: int16(9387),
	536: int16(-int32(7350)),
	537: int16(233),
	540: int16(9243),
	541: int16(3627),
	542: int16(-int32(13823)),
	543: int16(-int32(7218)),
	544: int16(-int32(3656)),
	545: int16(-int32(7002)),
	546: int16(12776),
	547: int16(13935),
	548: int16(2719),
	549: int16(2446),
	550: int16(8352),
	551: int16(9252),
	552: int16(-int32(7676)),
	553: int16(-int32(18413)),
	554: int16(-int32(6212)),
	555: int16(-int32(429)),
	556: int16(-int32(1272)),
	557: int16(-int32(6335)),
	558: int16(-int32(13356)),
	559: int16(-int32(9510)),
	560: int16(295),
	561: int16(18926),
	562: int16(9934),
	563: int16(1112),
	564: int16(-int32(382)),
	567: int16(9243),
	568: int16(-int32(6383)),
	569: int16(-int32(9343)),
	570: int16(-int32(11326)),
	571: int16(10097),
	572: int16(8329),
	573: int16(223),
	574: int16(14780),
	575: int16(6114),
	576: int16(-int32(10348)),
	577: int16(-int32(15590)),
	578: int16(-int32(4195)),
	579: int16(9257),
	580: int16(-int32(7445)),
	581: int16(-int32(9439)),
	582: int16(-int32(323)),
	583: int16(7902),
	584: int16(18117),
	585: int16(12101),
	586: int16(-int32(3142)),
	587: int16(-int32(10944)),
	588: int16(-int32(5577)),
	589: int16(7327),
	590: int16(566),
	591: int16(-int32(4133)),
	594: int16(9243),
	595: int16(2626),
	596: int16(865),
	597: int16(15769),
	598: int16(5783),
	599: int16(317),
	600: int16(-int32(10244)),
	601: int16(1905),
	602: int16(16884),
	603: int16(9144),
	604: int16(826),
	605: int16(-int32(2420)),
	606: int16(-int32(1972)),
	607: int16(-int32(14536)),
	608: int16(2413),
	609: int16(16939),
	610: int16(12500),
	611: int16(1482),
	612: int16(-int32(4906)),
	613: int16(-int32(578)),
	614: int16(10096),
	615: int16(-int32(3476)),
	616: int16(-int32(14323)),
	617: int16(2745),
	618: int16(16105),
	621: int16(9243),
	622: int16(-int32(8975)),
	623: int16(12086),
	624: int16(5450),
	625: int16(-int32(6832)),
	626: int16(-int32(15149)),
	627: int16(7333),
	628: int16(9200),
	629: int16(-int32(3550)),
	630: int16(-int32(362)),
	631: int16(-int32(13645)),
	632: int16(-int32(15525)),
	633: int16(-int32(1391)),
	634: int16(9428),
	635: int16(-int32(7091)),
	636: int16(-int32(5442)),
	637: int16(3105),
	638: int16(-int32(820)),
	639: int16(-int32(17685)),
	640: int16(-int32(9175)),
	641: int16(-int32(9462)),
	642: int16(5572),
	643: int16(-int32(9191)),
	644: int16(-int32(12325)),
	645: int16(-int32(2180)),
	648: int16(9243),
	649: int16(-int32(114)),
	650: int16(11576),
	651: int16(-int32(11058)),
	652: int16(177),
	653: int16(-int32(185)),
	654: int16(5875),
	655: int16(-int32(17880)),
	656: int16(8539),
	657: int16(-int32(198)),
	658: int16(339),
	659: int16(-int32(173)),
	660: int16(-int32(3411)),
	661: int16(-int32(16698)),
	662: int16(16336),
	663: int16(-int32(6369)),
	664: int16(193),
	665: int16(-int32(430)),
	666: int16(408),
	667: int16(-int32(75)),
	668: int16(-int32(10806)),
	669: int16(-int32(7225)),
	670: int16(19670),
	671: int16(-int32(13817)),
	672: int16(4665),
	700: int16(32767),
	728: int16(32767),
}

var Opus_mapping_matrix_soa_demixing = OpusT_MappingMatrix{
	Frows: int32(11),
	Fcols: int32(11),
	Fgain: int32(3050),
}

var Opus_mapping_matrix_soa_demixing_data = [121]OpusT_opus_int16{
	0:   int16(2771),
	1:   int16(2771),
	2:   int16(2771),
	3:   int16(2771),
	4:   int16(2771),
	5:   int16(2771),
	6:   int16(2771),
	7:   int16(2771),
	8:   int16(2771),
	11:  int16(10033),
	12:  int16(10033),
	13:  int16(-int32(20066)),
	14:  int16(10033),
	15:  int16(14189),
	16:  int16(14189),
	17:  int16(-int32(28378)),
	18:  int16(10033),
	19:  int16(-int32(20066)),
	22:  int16(3393),
	23:  int16(3393),
	24:  int16(3393),
	25:  int16(-int32(3393)),
	29:  int16(-int32(3393)),
	30:  int16(-int32(3393)),
	33:  int16(-int32(17378)),
	34:  int16(17378),
	36:  int16(-int32(17378)),
	37:  int16(-int32(24576)),
	38:  int16(24576),
	40:  int16(17378),
	44:  int16(-int32(14189)),
	45:  int16(14189),
	47:  int16(-int32(14189)),
	48:  int16(-int32(28378)),
	49:  int16(28378),
	51:  int16(14189),
	55:  int16(2399),
	56:  int16(2399),
	57:  int16(-int32(4799)),
	58:  int16(-int32(2399)),
	62:  int16(-int32(2399)),
	63:  int16(4799),
	66:  int16(1959),
	67:  int16(1959),
	68:  int16(1959),
	69:  int16(1959),
	70:  int16(-int32(3918)),
	71:  int16(-int32(3918)),
	72:  int16(-int32(3918)),
	73:  int16(1959),
	74:  int16(1959),
	77:  int16(-int32(4156)),
	78:  int16(4156),
	80:  int16(4156),
	84:  int16(-int32(4156)),
	88:  int16(8192),
	89:  int16(8192),
	90:  int16(-int32(16384)),
	91:  int16(8192),
	92:  int16(16384),
	93:  int16(16384),
	94:  int16(-int32(32768)),
	95:  int16(8192),
	96:  int16(-int32(16384)),
	108: int16(8312),
	120: int16(8312),
}

var Opus_mapping_matrix_soa_mixing = OpusT_MappingMatrix{
	Frows: int32(11),
	Fcols: int32(11),
}

var Opus_mapping_matrix_soa_mixing_data = [121]OpusT_opus_int16{
	0:   int16(10923),
	1:   int16(7723),
	2:   int16(13377),
	3:   int16(-int32(13377)),
	4:   int16(11585),
	5:   int16(9459),
	6:   int16(7723),
	7:   int16(-int32(16384)),
	8:   int16(-int32(6689)),
	11:  int16(10923),
	12:  int16(7723),
	13:  int16(13377),
	14:  int16(13377),
	15:  int16(-int32(11585)),
	16:  int16(9459),
	17:  int16(7723),
	18:  int16(16384),
	19:  int16(-int32(6689)),
	22:  int16(10923),
	23:  int16(-int32(15447)),
	24:  int16(13377),
	27:  int16(-int32(18919)),
	28:  int16(7723),
	30:  int16(13377),
	33:  int16(10923),
	34:  int16(7723),
	35:  int16(-int32(13377)),
	36:  int16(-int32(13377)),
	37:  int16(11585),
	38:  int16(-int32(9459)),
	39:  int16(7723),
	40:  int16(16384),
	41:  int16(-int32(6689)),
	44:  int16(10923),
	45:  int16(-int32(7723)),
	47:  int16(13377),
	48:  int16(-int32(16384)),
	50:  int16(-int32(15447)),
	52:  int16(9459),
	55:  int16(10923),
	56:  int16(-int32(7723)),
	58:  int16(-int32(13377)),
	59:  int16(16384),
	61:  int16(-int32(15447)),
	63:  int16(9459),
	66:  int16(10923),
	67:  int16(15447),
	72:  int16(-int32(15447)),
	74:  int16(-int32(18919)),
	77:  int16(10923),
	78:  int16(7723),
	79:  int16(-int32(13377)),
	80:  int16(13377),
	81:  int16(-int32(11585)),
	82:  int16(-int32(9459)),
	83:  int16(7723),
	84:  int16(-int32(16384)),
	85:  int16(-int32(6689)),
	88:  int16(10923),
	89:  int16(-int32(15447)),
	90:  int16(-int32(13377)),
	93:  int16(18919),
	94:  int16(7723),
	96:  int16(13377),
	108: int16(32767),
	120: int16(32767),
}

var Opus_mapping_matrix_toa_demixing = OpusT_MappingMatrix{
	Frows: int32(18),
	Fcols: int32(18),
}

var Opus_mapping_matrix_toa_demixing_data = [324]OpusT_opus_int16{
	0:   int16(8192),
	1:   int16(8192),
	2:   int16(8192),
	3:   int16(8192),
	4:   int16(8192),
	5:   int16(8192),
	6:   int16(8192),
	7:   int16(8192),
	8:   int16(8192),
	9:   int16(8192),
	10:  int16(8192),
	11:  int16(8192),
	12:  int16(8192),
	13:  int16(8192),
	14:  int16(8192),
	15:  int16(8192),
	19:  int16(-int32(9779)),
	20:  int16(9779),
	21:  int16(6263),
	22:  int16(8857),
	24:  int16(6263),
	25:  int16(13829),
	26:  int16(9779),
	27:  int16(-int32(13829)),
	29:  int16(-int32(6263)),
	31:  int16(-int32(8857)),
	32:  int16(-int32(6263)),
	33:  int16(-int32(9779)),
	36:  int16(-int32(3413)),
	37:  int16(3413),
	38:  int16(3413),
	39:  int16(-int32(11359)),
	40:  int16(11359),
	41:  int16(11359),
	42:  int16(-int32(11359)),
	43:  int16(-int32(3413)),
	44:  int16(3413),
	45:  int16(-int32(3413)),
	46:  int16(-int32(3413)),
	47:  int16(-int32(11359)),
	48:  int16(11359),
	49:  int16(11359),
	50:  int16(-int32(11359)),
	51:  int16(3413),
	54:  int16(13829),
	55:  int16(9779),
	56:  int16(-int32(9779)),
	57:  int16(6263),
	59:  int16(8857),
	60:  int16(-int32(6263)),
	62:  int16(9779),
	64:  int16(-int32(13829)),
	65:  int16(6263),
	66:  int16(-int32(8857)),
	68:  int16(-int32(6263)),
	69:  int16(-int32(9779)),
	73:  int16(-int32(15617)),
	74:  int16(-int32(15617)),
	75:  int16(6406),
	78:  int16(-int32(6406)),
	80:  int16(15617),
	83:  int16(-int32(6406)),
	86:  int16(6406),
	87:  int16(15617),
	91:  int16(-int32(5003)),
	92:  int16(5003),
	93:  int16(-int32(10664)),
	94:  int16(15081),
	96:  int16(-int32(10664)),
	97:  int16(-int32(7075)),
	98:  int16(5003),
	99:  int16(7075),
	101: int16(10664),
	103: int16(-int32(15081)),
	104: int16(10664),
	105: int16(-int32(5003)),
	108: int16(-int32(8176)),
	109: int16(-int32(8176)),
	110: int16(-int32(8176)),
	111: int16(8208),
	112: int16(8208),
	113: int16(8208),
	114: int16(8208),
	115: int16(-int32(8176)),
	116: int16(-int32(8176)),
	117: int16(-int32(8176)),
	118: int16(-int32(8176)),
	119: int16(8208),
	120: int16(8208),
	121: int16(8208),
	122: int16(8208),
	123: int16(-int32(8176)),
	126: int16(-int32(7075)),
	127: int16(5003),
	128: int16(-int32(5003)),
	129: int16(-int32(10664)),
	131: int16(15081),
	132: int16(10664),
	134: int16(5003),
	136: int16(7075),
	137: int16(-int32(10664)),
	138: int16(-int32(15081)),
	140: int16(10664),
	141: int16(-int32(5003)),
	144: int16(15617),
	148: int16(-int32(6406)),
	149: int16(6406),
	151: int16(-int32(15617)),
	153: int16(-int32(15617)),
	154: int16(15617),
	156: int16(6406),
	157: int16(-int32(6406)),
	163: int16(-int32(11393)),
	164: int16(11393),
	165: int16(2993),
	166: int16(-int32(4233)),
	168: int16(2993),
	169: int16(-int32(16112)),
	170: int16(11393),
	171: int16(16112),
	173: int16(-int32(2993)),
	175: int16(4233),
	176: int16(-int32(2993)),
	177: int16(-int32(11393)),
	181: int16(-int32(9974)),
	182: int16(-int32(9974)),
	183: int16(-int32(13617)),
	186: int16(13617),
	188: int16(9974),
	191: int16(13617),
	194: int16(-int32(13617)),
	195: int16(9974),
	199: int16(5579),
	200: int16(-int32(5579)),
	201: int16(10185),
	202: int16(14403),
	204: int16(10185),
	205: int16(-int32(7890)),
	206: int16(-int32(5579)),
	207: int16(7890),
	209: int16(-int32(10185)),
	211: int16(-int32(14403)),
	212: int16(-int32(10185)),
	213: int16(5579),
	216: int16(11826),
	217: int16(-int32(11826)),
	218: int16(-int32(11826)),
	219: int16(-int32(901)),
	220: int16(901),
	221: int16(901),
	222: int16(-int32(901)),
	223: int16(11826),
	224: int16(-int32(11826)),
	225: int16(11826),
	226: int16(11826),
	227: int16(-int32(901)),
	228: int16(901),
	229: int16(901),
	230: int16(-int32(901)),
	231: int16(-int32(11826)),
	234: int16(-int32(7890)),
	235: int16(-int32(5579)),
	236: int16(5579),
	237: int16(10185),
	239: int16(14403),
	240: int16(-int32(10185)),
	242: int16(-int32(5579)),
	244: int16(7890),
	245: int16(10185),
	246: int16(-int32(14403)),
	248: int16(-int32(10185)),
	249: int16(5579),
	252: int16(-int32(9974)),
	256: int16(-int32(13617)),
	257: int16(13617),
	259: int16(9974),
	261: int16(9974),
	262: int16(-int32(9974)),
	264: int16(13617),
	265: int16(-int32(13617)),
	270: int16(16112),
	271: int16(-int32(11393)),
	272: int16(11393),
	273: int16(-int32(2993)),
	275: int16(4233),
	276: int16(2993),
	278: int16(-int32(11393)),
	280: int16(-int32(16112)),
	281: int16(-int32(2993)),
	282: int16(-int32(4233)),
	284: int16(2993),
	285: int16(11393),
	304: int16(32767),
	323: int16(32767),
}

var Opus_mapping_matrix_toa_mixing = OpusT_MappingMatrix{
	Frows: int32(18),
	Fcols: int32(18),
}

var Opus_mapping_matrix_toa_mixing_data = [324]OpusT_opus_int16{
	0:   int16(8208),
	2:   int16(-int32(881)),
	3:   int16(14369),
	6:   int16(-int32(8192)),
	7:   int16(-int32(4163)),
	8:   int16(13218),
	12:  int16(11095),
	13:  int16(-int32(8836)),
	14:  int16(-int32(6218)),
	15:  int16(14833),
	18:  int16(8208),
	19:  int16(-int32(10161)),
	20:  int16(881),
	21:  int16(10161),
	22:  int16(-int32(13218)),
	23:  int16(-int32(2944)),
	24:  int16(-int32(8192)),
	25:  int16(2944),
	27:  int16(-int32(10488)),
	28:  int16(-int32(6218)),
	29:  int16(6248),
	30:  int16(-int32(11095)),
	31:  int16(-int32(6248)),
	33:  int16(-int32(10488)),
	36:  int16(8208),
	37:  int16(10161),
	38:  int16(881),
	39:  int16(-int32(10161)),
	40:  int16(-int32(13218)),
	41:  int16(2944),
	42:  int16(-int32(8192)),
	43:  int16(-int32(2944)),
	45:  int16(10488),
	46:  int16(-int32(6218)),
	47:  int16(-int32(6248)),
	48:  int16(-int32(11095)),
	49:  int16(6248),
	51:  int16(10488),
	54:  int16(8176),
	55:  int16(5566),
	56:  int16(-int32(11552)),
	57:  int16(5566),
	58:  int16(9681),
	59:  int16(-int32(11205)),
	60:  int16(8192),
	61:  int16(-int32(11205)),
	63:  int16(4920),
	64:  int16(-int32(15158)),
	65:  int16(9756),
	66:  int16(-int32(3334)),
	67:  int16(9756),
	69:  int16(-int32(4920)),
	72:  int16(8176),
	73:  int16(7871),
	74:  int16(11552),
	77:  int16(15846),
	78:  int16(8192),
	80:  int16(-int32(9681)),
	81:  int16(-int32(6958)),
	83:  int16(13797),
	84:  int16(3334),
	86:  int16(-int32(15158)),
	90:  int16(8176),
	92:  int16(11552),
	93:  int16(7871),
	96:  int16(8192),
	97:  int16(15846),
	98:  int16(9681),
	102: int16(3334),
	103: int16(13797),
	104: int16(15158),
	105: int16(6958),
	108: int16(8176),
	109: int16(5566),
	110: int16(-int32(11552)),
	111: int16(-int32(5566)),
	112: int16(-int32(9681)),
	113: int16(-int32(11205)),
	114: int16(8192),
	115: int16(11205),
	117: int16(4920),
	118: int16(15158),
	119: int16(9756),
	120: int16(-int32(3334)),
	121: int16(-int32(9756)),
	123: int16(4920),
	126: int16(8208),
	127: int16(14369),
	128: int16(-int32(881)),
	131: int16(-int32(4163)),
	132: int16(-int32(8192)),
	134: int16(-int32(13218)),
	135: int16(-int32(14833)),
	137: int16(-int32(8836)),
	138: int16(11095),
	140: int16(6218),
	144: int16(8208),
	145: int16(10161),
	146: int16(881),
	147: int16(10161),
	148: int16(13218),
	149: int16(2944),
	150: int16(-int32(8192)),
	151: int16(2944),
	153: int16(10488),
	154: int16(6218),
	155: int16(-int32(6248)),
	156: int16(-int32(11095)),
	157: int16(-int32(6248)),
	159: int16(-int32(10488)),
	162: int16(8208),
	163: int16(-int32(14369)),
	164: int16(-int32(881)),
	167: int16(4163),
	168: int16(-int32(8192)),
	170: int16(-int32(13218)),
	171: int16(14833),
	173: int16(8836),
	174: int16(11095),
	176: int16(6218),
	180: int16(8208),
	182: int16(-int32(881)),
	183: int16(-int32(14369)),
	186: int16(-int32(8192)),
	187: int16(4163),
	188: int16(13218),
	192: int16(11095),
	193: int16(8836),
	194: int16(-int32(6218)),
	195: int16(-int32(14833)),
	198: int16(8176),
	199: int16(-int32(5566)),
	200: int16(-int32(11552)),
	201: int16(5566),
	202: int16(-int32(9681)),
	203: int16(11205),
	204: int16(8192),
	205: int16(-int32(11205)),
	207: int16(-int32(4920)),
	208: int16(15158),
	209: int16(-int32(9756)),
	210: int16(-int32(3334)),
	211: int16(9756),
	213: int16(-int32(4920)),
	216: int16(8176),
	218: int16(11552),
	219: int16(-int32(7871)),
	222: int16(8192),
	223: int16(-int32(15846)),
	224: int16(9681),
	228: int16(3334),
	229: int16(-int32(13797)),
	230: int16(15158),
	231: int16(-int32(6958)),
	234: int16(8176),
	235: int16(-int32(7871)),
	236: int16(11552),
	239: int16(-int32(15846)),
	240: int16(8192),
	242: int16(-int32(9681)),
	243: int16(6958),
	245: int16(-int32(13797)),
	246: int16(3334),
	248: int16(-int32(15158)),
	252: int16(8176),
	253: int16(-int32(5566)),
	254: int16(-int32(11552)),
	255: int16(-int32(5566)),
	256: int16(9681),
	257: int16(11205),
	258: int16(8192),
	259: int16(11205),
	261: int16(-int32(4920)),
	262: int16(-int32(15158)),
	263: int16(-int32(9756)),
	264: int16(-int32(3334)),
	265: int16(-int32(9756)),
	267: int16(4920),
	270: int16(8208),
	271: int16(-int32(10161)),
	272: int16(881),
	273: int16(-int32(10161)),
	274: int16(13218),
	275: int16(-int32(2944)),
	276: int16(-int32(8192)),
	277: int16(-int32(2944)),
	279: int16(-int32(10488)),
	280: int16(6218),
	281: int16(6248),
	282: int16(-int32(11095)),
	283: int16(6248),
	285: int16(10488),
	304: int16(32767),
	323: int16(32767),
}

var Opus_silk_CB_lags_stage2 = [4][11]OpusT_opus_int8{
	0: {
		1:  int8(2),
		2:  int8(-int32(1)),
		3:  int8(-int32(1)),
		4:  int8(-int32(1)),
		7:  int8(1),
		8:  int8(1),
		10: int8(1),
	},
	1: {
		1: int8(1),
		7: int8(1),
	},
	2: {
		2: int8(1),
		6: int8(1),
	},
	3: {
		1:  int8(-int32(1)),
		2:  int8(2),
		3:  int8(1),
		5:  int8(1),
		6:  int8(1),
		9:  int8(-int32(1)),
		10: int8(-int32(1)),
	},
}

var Opus_silk_CB_lags_stage2_10_ms = [2][3]OpusT_opus_int8{
	0: {
		1: int8(1),
	},
	1: {
		2: int8(1),
	},
}

var Opus_silk_CB_lags_stage3 = [4][34]OpusT_opus_int8{
	0: {
		2:  int8(1),
		3:  int8(-int32(1)),
		5:  int8(1),
		6:  int8(-int32(1)),
		8:  int8(-int32(1)),
		9:  int8(1),
		10: int8(-int32(2)),
		11: int8(2),
		12: int8(-int32(2)),
		13: int8(-int32(2)),
		14: int8(2),
		15: int8(-int32(3)),
		16: int8(2),
		17: int8(3),
		18: int8(-int32(3)),
		19: int8(-int32(4)),
		20: int8(3),
		21: int8(-int32(4)),
		22: int8(4),
		23: int8(4),
		24: int8(-int32(5)),
		25: int8(5),
		26: int8(-int32(6)),
		27: int8(-int32(5)),
		28: int8(6),
		29: int8(-int32(7)),
		30: int8(6),
		31: int8(5),
		32: int8(8),
		33: int8(-int32(9)),
	},
	1: {
		2:  int8(1),
		10: int8(-int32(1)),
		11: int8(1),
		14: int8(1),
		15: int8(-int32(1)),
		17: int8(1),
		18: int8(-int32(1)),
		19: int8(-int32(1)),
		20: int8(1),
		21: int8(-int32(1)),
		22: int8(2),
		23: int8(1),
		24: int8(-int32(1)),
		25: int8(2),
		26: int8(-int32(2)),
		27: int8(-int32(2)),
		28: int8(2),
		29: int8(-int32(2)),
		30: int8(2),
		31: int8(2),
		32: int8(3),
		33: int8(-int32(3)),
	},
	2: {
		1:  int8(1),
		8:  int8(1),
		10: int8(1),
		13: int8(1),
		14: int8(-int32(1)),
		15: int8(1),
		18: int8(2),
		19: int8(1),
		20: int8(-int32(1)),
		21: int8(2),
		22: int8(-int32(1)),
		23: int8(-int32(1)),
		24: int8(2),
		25: int8(-int32(1)),
		26: int8(2),
		27: int8(2),
		28: int8(-int32(1)),
		29: int8(3),
		30: int8(-int32(2)),
		31: int8(-int32(2)),
		32: int8(-int32(2)),
		33: int8(3),
	},
	3: {
		1:  int8(1),
		4:  int8(1),
		6:  int8(1),
		7:  int8(-int32(1)),
		8:  int8(2),
		9:  int8(-int32(1)),
		10: int8(2),
		11: int8(-int32(1)),
		12: int8(2),
		13: int8(3),
		14: int8(-int32(2)),
		15: int8(3),
		16: int8(-int32(2)),
		17: int8(-int32(2)),
		18: int8(4),
		19: int8(4),
		20: int8(-int32(3)),
		21: int8(5),
		22: int8(-int32(3)),
		23: int8(-int32(4)),
		24: int8(6),
		25: int8(-int32(4)),
		26: int8(6),
		27: int8(5),
		28: int8(-int32(5)),
		29: int8(8),
		30: int8(-int32(6)),
		31: int8(-int32(5)),
		32: int8(-int32(7)),
		33: int8(9),
	},
}

var Opus_silk_CB_lags_stage3_10_ms = [2][12]OpusT_opus_int8{
	0: {
		2:  int8(1),
		3:  int8(-int32(1)),
		4:  int8(1),
		5:  int8(-int32(1)),
		6:  int8(2),
		7:  int8(-int32(2)),
		8:  int8(2),
		9:  int8(-int32(2)),
		10: int8(3),
		11: int8(-int32(3)),
	},
	1: {
		1:  int8(1),
		3:  int8(1),
		4:  int8(-int32(1)),
		5:  int8(2),
		6:  int8(-int32(1)),
		7:  int8(2),
		8:  int8(-int32(2)),
		9:  int8(3),
		10: int8(-int32(2)),
		11: int8(3),
	},
}

var Opus_silk_LBRR_flags_iCDF_ptr = [2]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LBRR_flags_2_iCDF)),
	1: uintptr(unsafe.Pointer(&silk_LBRR_flags_3_iCDF)),
}

// C documentation
//
//	/* Cosine approximation table for LSF conversion */
//	/* Q12 values (even) */
var Opus_silk_LSFCosTab_FIX_Q12 = [129]OpusT_opus_int16{
	0:   int16(8192),
	1:   int16(8190),
	2:   int16(8182),
	3:   int16(8170),
	4:   int16(8152),
	5:   int16(8130),
	6:   int16(8104),
	7:   int16(8072),
	8:   int16(8034),
	9:   int16(7994),
	10:  int16(7946),
	11:  int16(7896),
	12:  int16(7840),
	13:  int16(7778),
	14:  int16(7714),
	15:  int16(7644),
	16:  int16(7568),
	17:  int16(7490),
	18:  int16(7406),
	19:  int16(7318),
	20:  int16(7226),
	21:  int16(7128),
	22:  int16(7026),
	23:  int16(6922),
	24:  int16(6812),
	25:  int16(6698),
	26:  int16(6580),
	27:  int16(6458),
	28:  int16(6332),
	29:  int16(6204),
	30:  int16(6070),
	31:  int16(5934),
	32:  int16(5792),
	33:  int16(5648),
	34:  int16(5502),
	35:  int16(5352),
	36:  int16(5198),
	37:  int16(5040),
	38:  int16(4880),
	39:  int16(4718),
	40:  int16(4552),
	41:  int16(4382),
	42:  int16(4212),
	43:  int16(4038),
	44:  int16(3862),
	45:  int16(3684),
	46:  int16(3502),
	47:  int16(3320),
	48:  int16(3136),
	49:  int16(2948),
	50:  int16(2760),
	51:  int16(2570),
	52:  int16(2378),
	53:  int16(2186),
	54:  int16(1990),
	55:  int16(1794),
	56:  int16(1598),
	57:  int16(1400),
	58:  int16(1202),
	59:  int16(1002),
	60:  int16(802),
	61:  int16(602),
	62:  int16(402),
	63:  int16(202),
	65:  int16(-int32(202)),
	66:  int16(-int32(402)),
	67:  int16(-int32(602)),
	68:  int16(-int32(802)),
	69:  int16(-int32(1002)),
	70:  int16(-int32(1202)),
	71:  int16(-int32(1400)),
	72:  int16(-int32(1598)),
	73:  int16(-int32(1794)),
	74:  int16(-int32(1990)),
	75:  int16(-int32(2186)),
	76:  int16(-int32(2378)),
	77:  int16(-int32(2570)),
	78:  int16(-int32(2760)),
	79:  int16(-int32(2948)),
	80:  int16(-int32(3136)),
	81:  int16(-int32(3320)),
	82:  int16(-int32(3502)),
	83:  int16(-int32(3684)),
	84:  int16(-int32(3862)),
	85:  int16(-int32(4038)),
	86:  int16(-int32(4212)),
	87:  int16(-int32(4382)),
	88:  int16(-int32(4552)),
	89:  int16(-int32(4718)),
	90:  int16(-int32(4880)),
	91:  int16(-int32(5040)),
	92:  int16(-int32(5198)),
	93:  int16(-int32(5352)),
	94:  int16(-int32(5502)),
	95:  int16(-int32(5648)),
	96:  int16(-int32(5792)),
	97:  int16(-int32(5934)),
	98:  int16(-int32(6070)),
	99:  int16(-int32(6204)),
	100: int16(-int32(6332)),
	101: int16(-int32(6458)),
	102: int16(-int32(6580)),
	103: int16(-int32(6698)),
	104: int16(-int32(6812)),
	105: int16(-int32(6922)),
	106: int16(-int32(7026)),
	107: int16(-int32(7128)),
	108: int16(-int32(7226)),
	109: int16(-int32(7318)),
	110: int16(-int32(7406)),
	111: int16(-int32(7490)),
	112: int16(-int32(7568)),
	113: int16(-int32(7644)),
	114: int16(-int32(7714)),
	115: int16(-int32(7778)),
	116: int16(-int32(7840)),
	117: int16(-int32(7896)),
	118: int16(-int32(7946)),
	119: int16(-int32(7994)),
	120: int16(-int32(8034)),
	121: int16(-int32(8072)),
	122: int16(-int32(8104)),
	123: int16(-int32(8130)),
	124: int16(-int32(8152)),
	125: int16(-int32(8170)),
	126: int16(-int32(8182)),
	127: int16(-int32(8190)),
	128: int16(-int32(8192)),
}

// C documentation
//
//	/* Table for LTPScale */
var Opus_silk_LTPScales_table_Q14 = [3]OpusT_opus_int16{
	0: int16(15565),
	1: int16(12288),
	2: int16(8192),
}

var Opus_silk_LTP_gain_BITS_Q5_ptrs = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_2)),
}

var Opus_silk_LTP_gain_iCDF_ptrs = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_2)),
}

var Opus_silk_LTP_per_index_iCDF = [3]OpusT_opus_uint8{
	0: uint8(179),
	1: uint8(99),
}

var Opus_silk_LTP_vq_gain_ptrs_Q7 = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_0_gain)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_1_gain)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_2_gain)),
}

var Opus_silk_LTP_vq_ptrs_Q7 = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_2)),
}

var Opus_silk_LTP_vq_sizes = [3]OpusT_opus_int8{
	0: int8(8),
	1: int8(16),
	2: int8(32),
}

// C documentation
//
//	/* Tables for LTPScale */
var Opus_silk_LTPscale_iCDF = [3]OpusT_opus_uint8{
	0: uint8(128),
	1: uint8(64),
}

var Opus_silk_Lag_range_stage3 = [3][4][2]OpusT_opus_int8{
	0: {
		0: {
			0: int8(-int32(5)),
			1: int8(8),
		},
		1: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		2: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		3: {
			0: int8(-int32(4)),
			1: int8(10),
		},
	},
	1: {
		0: {
			0: int8(-int32(6)),
			1: int8(10),
		},
		1: {
			0: int8(-int32(2)),
			1: int8(6),
		},
		2: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		3: {
			0: int8(-int32(5)),
			1: int8(10),
		},
	},
	2: {
		0: {
			0: int8(-int32(9)),
			1: int8(12),
		},
		1: {
			0: int8(-int32(3)),
			1: int8(7),
		},
		2: {
			0: int8(-int32(2)),
			1: int8(7),
		},
		3: {
			0: int8(-int32(7)),
			1: int8(13),
		},
	},
}

var Opus_silk_Lag_range_stage3_10_ms = [2][2]OpusT_opus_int8{
	0: {
		0: int8(-int32(3)),
		1: int8(7),
	},
	1: {
		0: int8(-int32(2)),
		1: int8(7),
	},
}

var Opus_silk_NLSF_CB_NB_MB = OpusT_silk_NLSF_CB_struct{
	FnVectors:            int16(32),
	Forder:               int16(10),
	FquantStepSize_Q16:   int16(int32(float64(libc.Float64FromFloat64(0.18)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))),
	FinvQuantStepSize_Q6: int16(int32(float64(libc.Float64FromFloat64(1)/libc.Float64FromFloat64(0.18)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(6))) + libc.Float64FromFloat64(0.5))),
	FCB1_NLSF_Q8:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_NB_MB_Q8)),
	FCB1_Wght_Q9:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_Wght_Q9)),
	FCB1_iCDF:            uintptr(unsafe.Pointer(&silk_NLSF_CB1_iCDF_NB_MB)),
	Fpred_Q8:             uintptr(unsafe.Pointer(&silk_NLSF_PRED_NB_MB_Q8)),
	Fec_sel:              uintptr(unsafe.Pointer(&silk_NLSF_CB2_SELECT_NB_MB)),
	Fec_iCDF:             uintptr(unsafe.Pointer(&silk_NLSF_CB2_iCDF_NB_MB)),
	Fec_Rates_Q5:         uintptr(unsafe.Pointer(&silk_NLSF_CB2_BITS_NB_MB_Q5)),
	FdeltaMin_Q15:        uintptr(unsafe.Pointer(&silk_NLSF_DELTA_MIN_NB_MB_Q15)),
}

var Opus_silk_NLSF_CB_WB = OpusT_silk_NLSF_CB_struct{
	FnVectors:            int16(32),
	Forder:               int16(16),
	FquantStepSize_Q16:   int16(int32(float64(libc.Float64FromFloat64(0.15)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))),
	FinvQuantStepSize_Q6: int16(int32(float64(libc.Float64FromFloat64(1)/libc.Float64FromFloat64(0.15)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(6))) + libc.Float64FromFloat64(0.5))),
	FCB1_NLSF_Q8:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_WB_Q8)),
	FCB1_Wght_Q9:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_WB_Wght_Q9)),
	FCB1_iCDF:            uintptr(unsafe.Pointer(&silk_NLSF_CB1_iCDF_WB)),
	Fpred_Q8:             uintptr(unsafe.Pointer(&silk_NLSF_PRED_WB_Q8)),
	Fec_sel:              uintptr(unsafe.Pointer(&silk_NLSF_CB2_SELECT_WB)),
	Fec_iCDF:             uintptr(unsafe.Pointer(&silk_NLSF_CB2_iCDF_WB)),
	Fec_Rates_Q5:         uintptr(unsafe.Pointer(&silk_NLSF_CB2_BITS_WB_Q5)),
	FdeltaMin_Q15:        uintptr(unsafe.Pointer(&silk_NLSF_DELTA_MIN_WB_Q15)),
}

var Opus_silk_NLSF_EXT_iCDF = [7]OpusT_opus_uint8{
	0: uint8(100),
	1: uint8(40),
	2: uint8(16),
	3: uint8(7),
	4: uint8(3),
	5: uint8(1),
}

// C documentation
//
//	/* Tables for NLSF interpolation factor */
var Opus_silk_NLSF_interpolation_factor_iCDF = [5]OpusT_opus_uint8{
	0: uint8(243),
	1: uint8(221),
	2: uint8(192),
	3: uint8(181),
}

// C documentation
//
//	/* Quantization offsets */
var Opus_silk_Quantization_Offsets_Q10 = [2][2]OpusT_opus_int16{
	0: {
		0: int16(OFFSET_UVL_Q10),
		1: int16(OFFSET_UVH_Q10),
	},
	1: {
		0: int16(OFFSET_VL_Q10),
		1: int16(OFFSET_VH_Q10),
	},
}

var Opus_silk_Resampler_1_2_COEFS = [14]OpusT_opus_int16{
	0:  int16(616),
	1:  int16(-int32(14323)),
	2:  int16(-int32(10)),
	3:  int16(39),
	4:  int16(58),
	5:  int16(-int32(46)),
	6:  int16(-int32(84)),
	7:  int16(120),
	8:  int16(184),
	9:  int16(-int32(315)),
	10: int16(-int32(541)),
	11: int16(1284),
	12: int16(5380),
	13: int16(9024),
}

var Opus_silk_Resampler_1_3_COEFS = [20]OpusT_opus_int16{
	0:  int16(16102),
	1:  int16(-int32(15162)),
	2:  int16(-int32(13)),
	4:  int16(20),
	5:  int16(26),
	6:  int16(5),
	7:  int16(-int32(31)),
	8:  int16(-int32(43)),
	9:  int16(-int32(4)),
	10: int16(65),
	11: int16(90),
	12: int16(7),
	13: int16(-int32(157)),
	14: int16(-int32(248)),
	15: int16(-int32(44)),
	16: int16(593),
	17: int16(1583),
	18: int16(2612),
	19: int16(3271),
}

var Opus_silk_Resampler_1_4_COEFS = [20]OpusT_opus_int16{
	0:  int16(22500),
	1:  int16(-int32(15099)),
	2:  int16(3),
	3:  int16(-int32(14)),
	4:  int16(-int32(20)),
	5:  int16(-int32(15)),
	6:  int16(2),
	7:  int16(25),
	8:  int16(37),
	9:  int16(25),
	10: int16(-int32(16)),
	11: int16(-int32(71)),
	12: int16(-int32(107)),
	13: int16(-int32(79)),
	14: int16(50),
	15: int16(292),
	16: int16(623),
	17: int16(982),
	18: int16(1288),
	19: int16(1464),
}

var Opus_silk_Resampler_1_6_COEFS = [20]OpusT_opus_int16{
	0:  int16(27540),
	1:  int16(-int32(15257)),
	2:  int16(17),
	3:  int16(12),
	4:  int16(8),
	5:  int16(1),
	6:  int16(-int32(10)),
	7:  int16(-int32(22)),
	8:  int16(-int32(30)),
	9:  int16(-int32(32)),
	10: int16(-int32(22)),
	11: int16(3),
	12: int16(44),
	13: int16(100),
	14: int16(168),
	15: int16(243),
	16: int16(317),
	17: int16(381),
	18: int16(429),
	19: int16(455),
}

var Opus_silk_Resampler_2_3_COEFS = [20]OpusT_opus_int16{
	0:  int16(-int32(14457)),
	1:  int16(-int32(14019)),
	2:  int16(64),
	3:  int16(128),
	4:  int16(-int32(122)),
	5:  int16(36),
	6:  int16(310),
	7:  int16(-int32(768)),
	8:  int16(584),
	9:  int16(9267),
	10: int16(17733),
	11: int16(12),
	12: int16(128),
	13: int16(18),
	14: int16(-int32(142)),
	15: int16(288),
	16: int16(-int32(117)),
	17: int16(-int32(865)),
	18: int16(4123),
	19: int16(14459),
}

var Opus_silk_Resampler_2_3_COEFS_LQ = [6]OpusT_opus_int16{
	0: int16(-int32(2797)),
	1: int16(-int32(6507)),
	2: int16(4697),
	3: int16(10739),
	4: int16(1567),
	5: int16(8276),
}

/* Matlab code for the notch filter coefficients: */
/* B = [1, 0.147, 1];  A = [1, 0.107, 0.89]; G = 0.93; freqz(G * B, A, 2^14, 16e3); axis([0, 8000, -10, 1]) */
/* fprintf('\t%6d, %6d, %6d, %6d\n', round(B(2)*2^16), round(-A(2)*2^16), round((1-A(3))*2^16), round(G*2^15)) */
/* const opus_int16 silk_resampler_up2_hq_notch[ 4 ] = { 9634,  -7012,   7209,  30474 }; */

// C documentation
//
//	/* Tables with IIR and FIR coefficients for fractional downsamplers (123 Words) */
var Opus_silk_Resampler_3_4_COEFS = [29]OpusT_opus_int16{
	0:  int16(-int32(20694)),
	1:  int16(-int32(13867)),
	2:  int16(-int32(49)),
	3:  int16(64),
	4:  int16(17),
	5:  int16(-int32(157)),
	6:  int16(353),
	7:  int16(-int32(496)),
	8:  int16(163),
	9:  int16(11047),
	10: int16(22205),
	11: int16(-int32(39)),
	12: int16(6),
	13: int16(91),
	14: int16(-int32(170)),
	15: int16(186),
	16: int16(23),
	17: int16(-int32(896)),
	18: int16(6336),
	19: int16(19928),
	20: int16(-int32(19)),
	21: int16(-int32(36)),
	22: int16(102),
	23: int16(-int32(89)),
	24: int16(-int32(24)),
	25: int16(328),
	26: int16(-int32(951)),
	27: int16(2568),
	28: int16(15909),
}

// C documentation
//
//	/* Interpolation points for filter coefficients used in the bandwidth transition smoother */
var Opus_silk_Transition_LP_A_Q28 = [5][2]OpusT_opus_int32{
	0: {
		0: int32(506393414),
		1: int32(239854379),
	},
	1: {
		0: int32(411067935),
		1: int32(169683996),
	},
	2: {
		0: int32(306733530),
		1: int32(116694253),
	},
	3: {
		0: int32(185807084),
		1: int32(77959395),
	},
	4: {
		0: int32(35497197),
		1: int32(57401098),
	},
}

/*  Elliptic/Cauer filters designed with 0.1 dB passband ripple,
    80 dB minimum stopband attenuation, and
    [0.95 : 0.15 : 0.35] normalized cut off frequencies. */

// C documentation
//
//	/* Interpolation points for filter coefficients used in the bandwidth transition smoother */
var Opus_silk_Transition_LP_B_Q28 = [5][3]OpusT_opus_int32{
	0: {
		0: int32(250767114),
		1: int32(501534038),
		2: int32(250767114),
	},
	1: {
		0: int32(209867381),
		1: int32(419732057),
		2: int32(209867381),
	},
	2: {
		0: int32(170987846),
		1: int32(341967853),
		2: int32(170987846),
	},
	3: {
		0: int32(131531482),
		1: int32(263046905),
		2: int32(131531482),
	},
	4: {
		0: int32(89306658),
		1: int32(178584282),
		2: int32(89306658),
	},
}

var Opus_silk_delta_gain_iCDF = [41]OpusT_opus_uint8{
	0:  uint8(250),
	1:  uint8(245),
	2:  uint8(234),
	3:  uint8(203),
	4:  uint8(71),
	5:  uint8(50),
	6:  uint8(42),
	7:  uint8(38),
	8:  uint8(35),
	9:  uint8(33),
	10: uint8(31),
	11: uint8(29),
	12: uint8(28),
	13: uint8(27),
	14: uint8(26),
	15: uint8(25),
	16: uint8(24),
	17: uint8(23),
	18: uint8(22),
	19: uint8(21),
	20: uint8(20),
	21: uint8(19),
	22: uint8(18),
	23: uint8(17),
	24: uint8(16),
	25: uint8(15),
	26: uint8(14),
	27: uint8(13),
	28: uint8(12),
	29: uint8(11),
	30: uint8(10),
	31: uint8(9),
	32: uint8(8),
	33: uint8(7),
	34: uint8(6),
	35: uint8(5),
	36: uint8(4),
	37: uint8(3),
	38: uint8(2),
	39: uint8(1),
}

var Opus_silk_gain_iCDF = [3][8]OpusT_opus_uint8{
	0: {
		0: uint8(224),
		1: uint8(112),
		2: uint8(44),
		3: uint8(15),
		4: uint8(3),
		5: uint8(2),
		6: uint8(1),
	},
	1: {
		0: uint8(254),
		1: uint8(237),
		2: uint8(192),
		3: uint8(132),
		4: uint8(70),
		5: uint8(23),
		6: uint8(4),
	},
	2: {
		0: uint8(255),
		1: uint8(252),
		2: uint8(226),
		3: uint8(155),
		4: uint8(61),
		5: uint8(11),
		6: uint8(2),
	},
}

// C documentation
//
//	/* Table for LSB coding */
var Opus_silk_lsb_iCDF = [2]OpusT_opus_uint8{
	0: uint8(120),
}

var Opus_silk_max_pulses_table = [4]OpusT_opus_uint8{
	0: uint8(8),
	1: uint8(10),
	2: uint8(12),
	3: uint8(16),
}

var Opus_silk_nb_cbk_searchs_stage3 = [3]OpusT_opus_int8{
	0: int8(PE_NB_CBKS_STAGE3_MIN),
	1: int8(PE_NB_CBKS_STAGE3_MID),
	2: int8(PE_NB_CBKS_STAGE3_MAX),
}

var Opus_silk_pitch_contour_10_ms_NB_iCDF = [3]OpusT_opus_uint8{
	0: uint8(113),
	1: uint8(63),
}

var Opus_silk_pitch_contour_10_ms_iCDF = [12]OpusT_opus_uint8{
	0:  uint8(165),
	1:  uint8(119),
	2:  uint8(80),
	3:  uint8(61),
	4:  uint8(47),
	5:  uint8(35),
	6:  uint8(27),
	7:  uint8(20),
	8:  uint8(14),
	9:  uint8(9),
	10: uint8(4),
}

var Opus_silk_pitch_contour_NB_iCDF = [11]OpusT_opus_uint8{
	0: uint8(188),
	1: uint8(176),
	2: uint8(155),
	3: uint8(138),
	4: uint8(119),
	5: uint8(97),
	6: uint8(67),
	7: uint8(43),
	8: uint8(26),
	9: uint8(10),
}

var Opus_silk_pitch_contour_iCDF = [34]OpusT_opus_uint8{
	0:  uint8(223),
	1:  uint8(201),
	2:  uint8(183),
	3:  uint8(167),
	4:  uint8(152),
	5:  uint8(138),
	6:  uint8(124),
	7:  uint8(111),
	8:  uint8(98),
	9:  uint8(88),
	10: uint8(79),
	11: uint8(70),
	12: uint8(62),
	13: uint8(56),
	14: uint8(50),
	15: uint8(44),
	16: uint8(39),
	17: uint8(35),
	18: uint8(31),
	19: uint8(27),
	20: uint8(24),
	21: uint8(21),
	22: uint8(18),
	23: uint8(16),
	24: uint8(14),
	25: uint8(12),
	26: uint8(10),
	27: uint8(8),
	28: uint8(6),
	29: uint8(4),
	30: uint8(3),
	31: uint8(2),
	32: uint8(1),
}

var Opus_silk_pitch_delta_iCDF = [21]OpusT_opus_uint8{
	0:  uint8(210),
	1:  uint8(208),
	2:  uint8(206),
	3:  uint8(203),
	4:  uint8(199),
	5:  uint8(193),
	6:  uint8(183),
	7:  uint8(168),
	8:  uint8(142),
	9:  uint8(104),
	10: uint8(74),
	11: uint8(52),
	12: uint8(37),
	13: uint8(27),
	14: uint8(20),
	15: uint8(14),
	16: uint8(10),
	17: uint8(6),
	18: uint8(4),
	19: uint8(2),
}

var Opus_silk_pitch_lag_iCDF = [32]OpusT_opus_uint8{
	0:  uint8(253),
	1:  uint8(250),
	2:  uint8(244),
	3:  uint8(233),
	4:  uint8(212),
	5:  uint8(182),
	6:  uint8(150),
	7:  uint8(131),
	8:  uint8(120),
	9:  uint8(110),
	10: uint8(98),
	11: uint8(85),
	12: uint8(72),
	13: uint8(60),
	14: uint8(49),
	15: uint8(40),
	16: uint8(32),
	17: uint8(25),
	18: uint8(19),
	19: uint8(15),
	20: uint8(13),
	21: uint8(11),
	22: uint8(9),
	23: uint8(8),
	24: uint8(7),
	25: uint8(6),
	26: uint8(5),
	27: uint8(4),
	28: uint8(3),
	29: uint8(2),
	30: uint8(1),
}

var Opus_silk_pulses_per_block_BITS_Q5 = [9][18]OpusT_opus_uint8{
	0: {
		0:  uint8(31),
		1:  uint8(57),
		2:  uint8(107),
		3:  uint8(160),
		4:  uint8(205),
		5:  uint8(205),
		6:  uint8(255),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	1: {
		0:  uint8(69),
		1:  uint8(47),
		2:  uint8(67),
		3:  uint8(111),
		4:  uint8(166),
		5:  uint8(205),
		6:  uint8(255),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	2: {
		0:  uint8(82),
		1:  uint8(74),
		2:  uint8(79),
		3:  uint8(95),
		4:  uint8(109),
		5:  uint8(128),
		6:  uint8(145),
		7:  uint8(160),
		8:  uint8(173),
		9:  uint8(205),
		10: uint8(205),
		11: uint8(205),
		12: uint8(224),
		13: uint8(255),
		14: uint8(255),
		15: uint8(224),
		16: uint8(255),
		17: uint8(224),
	},
	3: {
		0:  uint8(125),
		1:  uint8(74),
		2:  uint8(59),
		3:  uint8(69),
		4:  uint8(97),
		5:  uint8(141),
		6:  uint8(182),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	4: {
		0:  uint8(173),
		1:  uint8(115),
		2:  uint8(85),
		3:  uint8(73),
		4:  uint8(76),
		5:  uint8(92),
		6:  uint8(115),
		7:  uint8(145),
		8:  uint8(173),
		9:  uint8(205),
		10: uint8(224),
		11: uint8(224),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	5: {
		0:  uint8(166),
		1:  uint8(134),
		2:  uint8(113),
		3:  uint8(102),
		4:  uint8(101),
		5:  uint8(102),
		6:  uint8(107),
		7:  uint8(118),
		8:  uint8(125),
		9:  uint8(138),
		10: uint8(145),
		11: uint8(155),
		12: uint8(166),
		13: uint8(182),
		14: uint8(192),
		15: uint8(192),
		16: uint8(205),
		17: uint8(150),
	},
	6: {
		0:  uint8(224),
		1:  uint8(182),
		2:  uint8(134),
		3:  uint8(101),
		4:  uint8(83),
		5:  uint8(79),
		6:  uint8(85),
		7:  uint8(97),
		8:  uint8(120),
		9:  uint8(145),
		10: uint8(173),
		11: uint8(205),
		12: uint8(224),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	7: {
		0:  uint8(255),
		1:  uint8(224),
		2:  uint8(192),
		3:  uint8(150),
		4:  uint8(120),
		5:  uint8(101),
		6:  uint8(92),
		7:  uint8(89),
		8:  uint8(93),
		9:  uint8(102),
		10: uint8(118),
		11: uint8(134),
		12: uint8(160),
		13: uint8(182),
		14: uint8(192),
		15: uint8(224),
		16: uint8(224),
		17: uint8(224),
	},
	8: {
		0:  uint8(255),
		1:  uint8(224),
		2:  uint8(224),
		3:  uint8(182),
		4:  uint8(155),
		5:  uint8(134),
		6:  uint8(118),
		7:  uint8(109),
		8:  uint8(104),
		9:  uint8(102),
		10: uint8(106),
		11: uint8(111),
		12: uint8(118),
		13: uint8(131),
		14: uint8(145),
		15: uint8(160),
		16: uint8(173),
		17: uint8(131),
	},
}

var Opus_silk_pulses_per_block_iCDF = [10][18]OpusT_opus_uint8{
	0: {
		0:  uint8(125),
		1:  uint8(51),
		2:  uint8(26),
		3:  uint8(18),
		4:  uint8(15),
		5:  uint8(12),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	1: {
		0:  uint8(198),
		1:  uint8(105),
		2:  uint8(45),
		3:  uint8(22),
		4:  uint8(15),
		5:  uint8(12),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	2: {
		0:  uint8(213),
		1:  uint8(162),
		2:  uint8(116),
		3:  uint8(83),
		4:  uint8(59),
		5:  uint8(43),
		6:  uint8(32),
		7:  uint8(24),
		8:  uint8(18),
		9:  uint8(15),
		10: uint8(12),
		11: uint8(9),
		12: uint8(7),
		13: uint8(6),
		14: uint8(5),
		15: uint8(3),
		16: uint8(2),
	},
	3: {
		0:  uint8(239),
		1:  uint8(187),
		2:  uint8(116),
		3:  uint8(59),
		4:  uint8(28),
		5:  uint8(16),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	4: {
		0:  uint8(250),
		1:  uint8(229),
		2:  uint8(188),
		3:  uint8(135),
		4:  uint8(86),
		5:  uint8(51),
		6:  uint8(30),
		7:  uint8(19),
		8:  uint8(13),
		9:  uint8(10),
		10: uint8(8),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	5: {
		0:  uint8(249),
		1:  uint8(235),
		2:  uint8(213),
		3:  uint8(185),
		4:  uint8(156),
		5:  uint8(128),
		6:  uint8(103),
		7:  uint8(83),
		8:  uint8(66),
		9:  uint8(53),
		10: uint8(42),
		11: uint8(33),
		12: uint8(26),
		13: uint8(21),
		14: uint8(17),
		15: uint8(13),
		16: uint8(10),
	},
	6: {
		0:  uint8(254),
		1:  uint8(249),
		2:  uint8(235),
		3:  uint8(206),
		4:  uint8(164),
		5:  uint8(118),
		6:  uint8(77),
		7:  uint8(46),
		8:  uint8(27),
		9:  uint8(16),
		10: uint8(10),
		11: uint8(7),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	7: {
		0:  uint8(255),
		1:  uint8(253),
		2:  uint8(249),
		3:  uint8(239),
		4:  uint8(220),
		5:  uint8(191),
		6:  uint8(156),
		7:  uint8(119),
		8:  uint8(85),
		9:  uint8(57),
		10: uint8(37),
		11: uint8(23),
		12: uint8(15),
		13: uint8(10),
		14: uint8(6),
		15: uint8(4),
		16: uint8(2),
	},
	8: {
		0:  uint8(255),
		1:  uint8(253),
		2:  uint8(251),
		3:  uint8(246),
		4:  uint8(237),
		5:  uint8(223),
		6:  uint8(203),
		7:  uint8(179),
		8:  uint8(152),
		9:  uint8(124),
		10: uint8(98),
		11: uint8(75),
		12: uint8(55),
		13: uint8(40),
		14: uint8(29),
		15: uint8(21),
		16: uint8(15),
	},
	9: {
		0:  uint8(255),
		1:  uint8(254),
		2:  uint8(253),
		3:  uint8(247),
		4:  uint8(220),
		5:  uint8(162),
		6:  uint8(106),
		7:  uint8(67),
		8:  uint8(42),
		9:  uint8(28),
		10: uint8(18),
		11: uint8(12),
		12: uint8(9),
		13: uint8(6),
		14: uint8(4),
		15: uint8(3),
		16: uint8(2),
	},
}

var Opus_silk_rate_levels_BITS_Q5 = [2][9]OpusT_opus_uint8{
	0: {
		0: uint8(131),
		1: uint8(74),
		2: uint8(141),
		3: uint8(79),
		4: uint8(80),
		5: uint8(138),
		6: uint8(95),
		7: uint8(104),
		8: uint8(134),
	},
	1: {
		0: uint8(95),
		1: uint8(99),
		2: uint8(91),
		3: uint8(125),
		4: uint8(93),
		5: uint8(76),
		6: uint8(123),
		7: uint8(115),
		8: uint8(123),
	},
}

var Opus_silk_rate_levels_iCDF = [2][9]OpusT_opus_uint8{
	0: {
		0: uint8(241),
		1: uint8(190),
		2: uint8(178),
		3: uint8(132),
		4: uint8(87),
		5: uint8(74),
		6: uint8(41),
		7: uint8(14),
	},
	1: {
		0: uint8(223),
		1: uint8(193),
		2: uint8(157),
		3: uint8(140),
		4: uint8(106),
		5: uint8(57),
		6: uint8(39),
		7: uint8(18),
	},
}

// C documentation
//
//	/* Table with interplation fractions of 1/24, 3/24, 5/24, ... , 23/24 : 23/24 (46 Words) */
var Opus_silk_resampler_frac_FIR_12 = [12][4]OpusT_opus_int16{
	0: {
		0: int16(189),
		1: int16(-int32(600)),
		2: int16(617),
		3: int16(30567),
	},
	1: {
		0: int16(117),
		1: int16(-int32(159)),
		2: int16(-int32(1070)),
		3: int16(29704),
	},
	2: {
		0: int16(52),
		1: int16(221),
		2: int16(-int32(2392)),
		3: int16(28276),
	},
	3: {
		0: int16(-int32(4)),
		1: int16(529),
		2: int16(-int32(3350)),
		3: int16(26341),
	},
	4: {
		0: int16(-int32(48)),
		1: int16(758),
		2: int16(-int32(3956)),
		3: int16(23973),
	},
	5: {
		0: int16(-int32(80)),
		1: int16(905),
		2: int16(-int32(4235)),
		3: int16(21254),
	},
	6: {
		0: int16(-int32(99)),
		1: int16(972),
		2: int16(-int32(4222)),
		3: int16(18278),
	},
	7: {
		0: int16(-int32(107)),
		1: int16(967),
		2: int16(-int32(3957)),
		3: int16(15143),
	},
	8: {
		0: int16(-int32(103)),
		1: int16(896),
		2: int16(-int32(3487)),
		3: int16(11950),
	},
	9: {
		0: int16(-int32(91)),
		1: int16(773),
		2: int16(-int32(2865)),
		3: int16(8798),
	},
	10: {
		0: int16(-int32(71)),
		1: int16(611),
		2: int16(-int32(2143)),
		3: int16(5784),
	},
	11: {
		0: int16(-int32(46)),
		1: int16(425),
		2: int16(-int32(1375)),
		3: int16(2996),
	},
}

var Opus_silk_shell_code_table0 = [152]OpusT_opus_uint8{
	0:   uint8(128),
	2:   uint8(214),
	3:   uint8(42),
	5:   uint8(235),
	6:   uint8(128),
	7:   uint8(21),
	9:   uint8(244),
	10:  uint8(184),
	11:  uint8(72),
	12:  uint8(11),
	14:  uint8(248),
	15:  uint8(214),
	16:  uint8(128),
	17:  uint8(42),
	18:  uint8(7),
	20:  uint8(248),
	21:  uint8(225),
	22:  uint8(170),
	23:  uint8(80),
	24:  uint8(25),
	25:  uint8(5),
	27:  uint8(251),
	28:  uint8(236),
	29:  uint8(198),
	30:  uint8(126),
	31:  uint8(54),
	32:  uint8(18),
	33:  uint8(3),
	35:  uint8(250),
	36:  uint8(238),
	37:  uint8(211),
	38:  uint8(159),
	39:  uint8(82),
	40:  uint8(35),
	41:  uint8(15),
	42:  uint8(5),
	44:  uint8(250),
	45:  uint8(231),
	46:  uint8(203),
	47:  uint8(168),
	48:  uint8(128),
	49:  uint8(88),
	50:  uint8(53),
	51:  uint8(25),
	52:  uint8(6),
	54:  uint8(252),
	55:  uint8(238),
	56:  uint8(216),
	57:  uint8(185),
	58:  uint8(148),
	59:  uint8(108),
	60:  uint8(71),
	61:  uint8(40),
	62:  uint8(18),
	63:  uint8(4),
	65:  uint8(253),
	66:  uint8(243),
	67:  uint8(225),
	68:  uint8(199),
	69:  uint8(166),
	70:  uint8(128),
	71:  uint8(90),
	72:  uint8(57),
	73:  uint8(31),
	74:  uint8(13),
	75:  uint8(3),
	77:  uint8(254),
	78:  uint8(246),
	79:  uint8(233),
	80:  uint8(212),
	81:  uint8(183),
	82:  uint8(147),
	83:  uint8(109),
	84:  uint8(73),
	85:  uint8(44),
	86:  uint8(23),
	87:  uint8(10),
	88:  uint8(2),
	90:  uint8(255),
	91:  uint8(250),
	92:  uint8(240),
	93:  uint8(223),
	94:  uint8(198),
	95:  uint8(166),
	96:  uint8(128),
	97:  uint8(90),
	98:  uint8(58),
	99:  uint8(33),
	100: uint8(16),
	101: uint8(6),
	102: uint8(1),
	104: uint8(255),
	105: uint8(251),
	106: uint8(244),
	107: uint8(231),
	108: uint8(210),
	109: uint8(181),
	110: uint8(146),
	111: uint8(110),
	112: uint8(75),
	113: uint8(46),
	114: uint8(25),
	115: uint8(12),
	116: uint8(5),
	117: uint8(1),
	119: uint8(255),
	120: uint8(253),
	121: uint8(248),
	122: uint8(238),
	123: uint8(221),
	124: uint8(196),
	125: uint8(164),
	126: uint8(128),
	127: uint8(92),
	128: uint8(60),
	129: uint8(35),
	130: uint8(18),
	131: uint8(8),
	132: uint8(3),
	133: uint8(1),
	135: uint8(255),
	136: uint8(253),
	137: uint8(249),
	138: uint8(242),
	139: uint8(229),
	140: uint8(208),
	141: uint8(180),
	142: uint8(146),
	143: uint8(110),
	144: uint8(76),
	145: uint8(48),
	146: uint8(27),
	147: uint8(14),
	148: uint8(7),
	149: uint8(3),
	150: uint8(1),
}

var Opus_silk_shell_code_table1 = [152]OpusT_opus_uint8{
	0:   uint8(129),
	2:   uint8(207),
	3:   uint8(50),
	5:   uint8(236),
	6:   uint8(129),
	7:   uint8(20),
	9:   uint8(245),
	10:  uint8(185),
	11:  uint8(72),
	12:  uint8(10),
	14:  uint8(249),
	15:  uint8(213),
	16:  uint8(129),
	17:  uint8(42),
	18:  uint8(6),
	20:  uint8(250),
	21:  uint8(226),
	22:  uint8(169),
	23:  uint8(87),
	24:  uint8(27),
	25:  uint8(4),
	27:  uint8(251),
	28:  uint8(233),
	29:  uint8(194),
	30:  uint8(130),
	31:  uint8(62),
	32:  uint8(20),
	33:  uint8(4),
	35:  uint8(250),
	36:  uint8(236),
	37:  uint8(207),
	38:  uint8(160),
	39:  uint8(99),
	40:  uint8(47),
	41:  uint8(17),
	42:  uint8(3),
	44:  uint8(255),
	45:  uint8(240),
	46:  uint8(217),
	47:  uint8(182),
	48:  uint8(131),
	49:  uint8(81),
	50:  uint8(41),
	51:  uint8(11),
	52:  uint8(1),
	54:  uint8(255),
	55:  uint8(254),
	56:  uint8(233),
	57:  uint8(201),
	58:  uint8(159),
	59:  uint8(107),
	60:  uint8(61),
	61:  uint8(20),
	62:  uint8(2),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(249),
	67:  uint8(233),
	68:  uint8(206),
	69:  uint8(170),
	70:  uint8(128),
	71:  uint8(86),
	72:  uint8(50),
	73:  uint8(23),
	74:  uint8(7),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(250),
	79:  uint8(238),
	80:  uint8(217),
	81:  uint8(186),
	82:  uint8(148),
	83:  uint8(108),
	84:  uint8(70),
	85:  uint8(39),
	86:  uint8(18),
	87:  uint8(6),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(252),
	92:  uint8(243),
	93:  uint8(226),
	94:  uint8(200),
	95:  uint8(166),
	96:  uint8(128),
	97:  uint8(90),
	98:  uint8(56),
	99:  uint8(30),
	100: uint8(13),
	101: uint8(4),
	102: uint8(1),
	104: uint8(255),
	105: uint8(252),
	106: uint8(245),
	107: uint8(231),
	108: uint8(209),
	109: uint8(180),
	110: uint8(146),
	111: uint8(110),
	112: uint8(76),
	113: uint8(47),
	114: uint8(25),
	115: uint8(11),
	116: uint8(4),
	117: uint8(1),
	119: uint8(255),
	120: uint8(253),
	121: uint8(248),
	122: uint8(237),
	123: uint8(219),
	124: uint8(194),
	125: uint8(163),
	126: uint8(128),
	127: uint8(93),
	128: uint8(62),
	129: uint8(37),
	130: uint8(19),
	131: uint8(8),
	132: uint8(3),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(250),
	138: uint8(241),
	139: uint8(226),
	140: uint8(205),
	141: uint8(177),
	142: uint8(145),
	143: uint8(111),
	144: uint8(79),
	145: uint8(51),
	146: uint8(30),
	147: uint8(15),
	148: uint8(6),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table2 = [152]OpusT_opus_uint8{
	0:   uint8(129),
	2:   uint8(203),
	3:   uint8(54),
	5:   uint8(234),
	6:   uint8(129),
	7:   uint8(23),
	9:   uint8(245),
	10:  uint8(184),
	11:  uint8(73),
	12:  uint8(10),
	14:  uint8(250),
	15:  uint8(215),
	16:  uint8(129),
	17:  uint8(41),
	18:  uint8(5),
	20:  uint8(252),
	21:  uint8(232),
	22:  uint8(173),
	23:  uint8(86),
	24:  uint8(24),
	25:  uint8(3),
	27:  uint8(253),
	28:  uint8(240),
	29:  uint8(200),
	30:  uint8(129),
	31:  uint8(56),
	32:  uint8(15),
	33:  uint8(2),
	35:  uint8(253),
	36:  uint8(244),
	37:  uint8(217),
	38:  uint8(164),
	39:  uint8(94),
	40:  uint8(38),
	41:  uint8(10),
	42:  uint8(1),
	44:  uint8(253),
	45:  uint8(245),
	46:  uint8(226),
	47:  uint8(189),
	48:  uint8(132),
	49:  uint8(71),
	50:  uint8(27),
	51:  uint8(7),
	52:  uint8(1),
	54:  uint8(253),
	55:  uint8(246),
	56:  uint8(231),
	57:  uint8(203),
	58:  uint8(159),
	59:  uint8(105),
	60:  uint8(56),
	61:  uint8(23),
	62:  uint8(6),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(248),
	67:  uint8(235),
	68:  uint8(213),
	69:  uint8(179),
	70:  uint8(133),
	71:  uint8(85),
	72:  uint8(47),
	73:  uint8(19),
	74:  uint8(5),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(254),
	79:  uint8(243),
	80:  uint8(221),
	81:  uint8(194),
	82:  uint8(159),
	83:  uint8(117),
	84:  uint8(70),
	85:  uint8(37),
	86:  uint8(12),
	87:  uint8(2),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(254),
	92:  uint8(248),
	93:  uint8(234),
	94:  uint8(208),
	95:  uint8(171),
	96:  uint8(128),
	97:  uint8(85),
	98:  uint8(48),
	99:  uint8(22),
	100: uint8(8),
	101: uint8(2),
	102: uint8(1),
	104: uint8(255),
	105: uint8(254),
	106: uint8(250),
	107: uint8(240),
	108: uint8(220),
	109: uint8(189),
	110: uint8(149),
	111: uint8(107),
	112: uint8(67),
	113: uint8(36),
	114: uint8(16),
	115: uint8(6),
	116: uint8(2),
	117: uint8(1),
	119: uint8(255),
	120: uint8(254),
	121: uint8(251),
	122: uint8(243),
	123: uint8(227),
	124: uint8(201),
	125: uint8(166),
	126: uint8(128),
	127: uint8(90),
	128: uint8(55),
	129: uint8(29),
	130: uint8(13),
	131: uint8(5),
	132: uint8(2),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(252),
	138: uint8(246),
	139: uint8(234),
	140: uint8(213),
	141: uint8(183),
	142: uint8(147),
	143: uint8(109),
	144: uint8(73),
	145: uint8(43),
	146: uint8(22),
	147: uint8(10),
	148: uint8(4),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table3 = [152]OpusT_opus_uint8{
	0:   uint8(130),
	2:   uint8(200),
	3:   uint8(58),
	5:   uint8(231),
	6:   uint8(130),
	7:   uint8(26),
	9:   uint8(244),
	10:  uint8(184),
	11:  uint8(76),
	12:  uint8(12),
	14:  uint8(249),
	15:  uint8(214),
	16:  uint8(130),
	17:  uint8(43),
	18:  uint8(6),
	20:  uint8(252),
	21:  uint8(232),
	22:  uint8(173),
	23:  uint8(87),
	24:  uint8(24),
	25:  uint8(3),
	27:  uint8(253),
	28:  uint8(241),
	29:  uint8(203),
	30:  uint8(131),
	31:  uint8(56),
	32:  uint8(14),
	33:  uint8(2),
	35:  uint8(254),
	36:  uint8(246),
	37:  uint8(221),
	38:  uint8(167),
	39:  uint8(94),
	40:  uint8(35),
	41:  uint8(8),
	42:  uint8(1),
	44:  uint8(254),
	45:  uint8(249),
	46:  uint8(232),
	47:  uint8(193),
	48:  uint8(130),
	49:  uint8(65),
	50:  uint8(23),
	51:  uint8(5),
	52:  uint8(1),
	54:  uint8(255),
	55:  uint8(251),
	56:  uint8(239),
	57:  uint8(211),
	58:  uint8(162),
	59:  uint8(99),
	60:  uint8(45),
	61:  uint8(15),
	62:  uint8(4),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(251),
	67:  uint8(243),
	68:  uint8(223),
	69:  uint8(186),
	70:  uint8(131),
	71:  uint8(74),
	72:  uint8(33),
	73:  uint8(11),
	74:  uint8(3),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(252),
	79:  uint8(245),
	80:  uint8(230),
	81:  uint8(202),
	82:  uint8(158),
	83:  uint8(105),
	84:  uint8(57),
	85:  uint8(24),
	86:  uint8(8),
	87:  uint8(2),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(253),
	92:  uint8(247),
	93:  uint8(235),
	94:  uint8(214),
	95:  uint8(179),
	96:  uint8(132),
	97:  uint8(84),
	98:  uint8(44),
	99:  uint8(19),
	100: uint8(7),
	101: uint8(2),
	102: uint8(1),
	104: uint8(255),
	105: uint8(254),
	106: uint8(250),
	107: uint8(240),
	108: uint8(223),
	109: uint8(196),
	110: uint8(159),
	111: uint8(112),
	112: uint8(69),
	113: uint8(36),
	114: uint8(15),
	115: uint8(6),
	116: uint8(2),
	117: uint8(1),
	119: uint8(255),
	120: uint8(254),
	121: uint8(253),
	122: uint8(245),
	123: uint8(231),
	124: uint8(209),
	125: uint8(176),
	126: uint8(136),
	127: uint8(93),
	128: uint8(55),
	129: uint8(27),
	130: uint8(11),
	131: uint8(3),
	132: uint8(2),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(253),
	138: uint8(252),
	139: uint8(239),
	140: uint8(221),
	141: uint8(194),
	142: uint8(158),
	143: uint8(117),
	144: uint8(76),
	145: uint8(42),
	146: uint8(18),
	147: uint8(4),
	148: uint8(3),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table_offsets = [17]OpusT_opus_uint8{
	2:  uint8(2),
	3:  uint8(5),
	4:  uint8(9),
	5:  uint8(14),
	6:  uint8(20),
	7:  uint8(27),
	8:  uint8(35),
	9:  uint8(44),
	10: uint8(54),
	11: uint8(65),
	12: uint8(77),
	13: uint8(90),
	14: uint8(104),
	15: uint8(119),
	16: uint8(135),
}

var Opus_silk_sign_iCDF = [42]OpusT_opus_uint8{
	0:  uint8(254),
	1:  uint8(49),
	2:  uint8(67),
	3:  uint8(77),
	4:  uint8(82),
	5:  uint8(93),
	6:  uint8(99),
	7:  uint8(198),
	8:  uint8(11),
	9:  uint8(18),
	10: uint8(24),
	11: uint8(31),
	12: uint8(36),
	13: uint8(45),
	14: uint8(255),
	15: uint8(46),
	16: uint8(66),
	17: uint8(78),
	18: uint8(87),
	19: uint8(94),
	20: uint8(104),
	21: uint8(208),
	22: uint8(14),
	23: uint8(21),
	24: uint8(32),
	25: uint8(42),
	26: uint8(51),
	27: uint8(66),
	28: uint8(255),
	29: uint8(94),
	30: uint8(104),
	31: uint8(109),
	32: uint8(112),
	33: uint8(115),
	34: uint8(118),
	35: uint8(248),
	36: uint8(53),
	37: uint8(69),
	38: uint8(80),
	39: uint8(88),
	40: uint8(95),
	41: uint8(102),
}

var Opus_silk_stereo_only_code_mid_iCDF = [2]OpusT_opus_uint8{
	0: uint8(64),
}

var Opus_silk_stereo_pred_joint_iCDF = [25]OpusT_opus_uint8{
	0:  uint8(249),
	1:  uint8(247),
	2:  uint8(246),
	3:  uint8(245),
	4:  uint8(244),
	5:  uint8(234),
	6:  uint8(210),
	7:  uint8(202),
	8:  uint8(201),
	9:  uint8(200),
	10: uint8(197),
	11: uint8(174),
	12: uint8(82),
	13: uint8(59),
	14: uint8(56),
	15: uint8(55),
	16: uint8(54),
	17: uint8(46),
	18: uint8(22),
	19: uint8(12),
	20: uint8(11),
	21: uint8(10),
	22: uint8(9),
	23: uint8(7),
}

// C documentation
//
//	/* Tables for stereo predictor coding */
var Opus_silk_stereo_pred_quant_Q13 = [16]OpusT_opus_int16{
	0:  int16(-int32(13732)),
	1:  int16(-int32(10050)),
	2:  int16(-int32(8266)),
	3:  int16(-int32(7526)),
	4:  int16(-int32(6500)),
	5:  int16(-int32(5000)),
	6:  int16(-int32(2950)),
	7:  int16(-int32(820)),
	8:  int16(820),
	9:  int16(2950),
	10: int16(5000),
	11: int16(6500),
	12: int16(7526),
	13: int16(8266),
	14: int16(10050),
	15: int16(13732),
}

// C documentation
//
//	/* Tables for signal type and offset coding */
var Opus_silk_type_offset_VAD_iCDF = [4]OpusT_opus_uint8{
	0: uint8(232),
	1: uint8(158),
	2: uint8(10),
}

var Opus_silk_type_offset_no_VAD_iCDF = [2]OpusT_opus_uint8{
	0: uint8(230),
}

// C documentation
//
//	/* Uniform entropy tables */
var Opus_silk_uniform3_iCDF = [3]OpusT_opus_uint8{
	0: uint8(171),
	1: uint8(85),
}

var Opus_silk_uniform4_iCDF = [4]OpusT_opus_uint8{
	0: uint8(192),
	1: uint8(128),
	2: uint8(64),
}

var Opus_silk_uniform5_iCDF = [5]OpusT_opus_uint8{
	0: uint8(205),
	1: uint8(154),
	2: uint8(102),
	3: uint8(51),
}

var Opus_silk_uniform6_iCDF = [6]OpusT_opus_uint8{
	0: uint8(213),
	1: uint8(171),
	2: uint8(128),
	3: uint8(85),
	4: uint8(43),
}

var Opus_silk_uniform8_iCDF = [8]OpusT_opus_uint8{
	0: uint8(224),
	1: uint8(192),
	2: uint8(160),
	3: uint8(128),
	4: uint8(96),
	5: uint8(64),
	6: uint8(32),
}

// C documentation
//
//	/* TF change table. Positive values mean better frequency resolution (longer
//	   effective window), whereas negative values mean better time resolution
//	   (shorter effective window). The second index is computed as:
//	   4*isTransient + 2*tf_select + per_band_flag */
var Opus_tf_select_table = [4][8]int8{
	0: {
		1: int8(-int32(1)),
		3: int8(-int32(1)),
		5: int8(-int32(1)),
		7: int8(-int32(1)),
	},
	1: {
		1: int8(-int32(1)),
		3: int8(-int32(2)),
		4: int8(1),
		6: int8(1),
		7: int8(-int32(1)),
	},
	2: {
		1: int8(-int32(2)),
		3: int8(-int32(3)),
		4: int8(2),
		6: int8(1),
		7: int8(-int32(1)),
	},
	3: {
		1: int8(-int32(2)),
		3: int8(-int32(3)),
		4: int8(3),
		6: int8(1),
		7: int8(-int32(1)),
	},
}

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = "assertion failed: st->channels == 1 || st->channels == 2\x00../src/opus_decoder.c\x00assertion failed: st->Fs == 48000 || st->Fs == 24000 || st->Fs == 16000 || st->Fs == 12000 || st->Fs == 8000\x00assertion failed: st->DecControl.API_sampleRate == st->Fs\x00assertion failed: st->DecControl.internalSampleRate == 0 || st->DecControl.internalSampleRate == 16000 || st->DecControl.internalSampleRate == 12000 || st->DecControl.internalSampleRate == 8000\x00assertion failed: st->DecControl.nChannelsAPI == st->channels\x00assertion failed: st->DecControl.nChannelsInternal == 0 || st->DecControl.nChannelsInternal == 1 || st->DecControl.nChannelsInternal == 2\x00assertion failed: st->DecControl.payloadSize_ms == 0 || st->DecControl.payloadSize_ms == 10 || st->DecControl.payloadSize_ms == 20 || st->DecControl.payloadSize_ms == 40 || st->DecControl.payloadSize_ms == 60\x00assertion failed: st->arch >= 0\x00assertion failed: st->arch <= OPUS_ARCHMASK\x00assertion failed: st->stream_channels == 1 || st->stream_channels == 2\x00pseudostack overflow\x00assertion failed: 0\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10012, (((void)((endband) == (opus_int32)0)), (opus_int32)(endband)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10008, (((void)((st->stream_channels) == (opus_int32)0)), (opus_int32)(st->stream_channels)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10010, (((void)((0) == (opus_int32)0)), (opus_int32)(0)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 4031, ((&redundant_rng) + ((&redundant_rng) - (opus_uint32*)(&redundant_rng))))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10010, (((void)((start_band) == (opus_int32)0)), (opus_int32)(start_band)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 4028)) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10015, ((&celt_mode) + ((&celt_mode) - (const OpusCustomMode**)(&celt_mode))))) == OPUS_OK\x00assertion failed: pcm_count == frame_size\x00assertion failed: ret==frame_size-packet_frame_size\x00assertion failed: ret==packet_frame_size\x00assertion failed: (opus_multistream_decoder_ctl(st, 4029, ((&Fs) + ((&Fs) - (opus_int32*)(&Fs))))) == OPUS_OK\x00../src/opus_multistream_decoder.c\x00assertion failed: align(data_size) == align(rows * cols * sizeof(opus_int16))\x00../src/mapping_matrix.c\x00assertion failed: input_rows <= matrix->cols && output_rows <= matrix->rows\x00../src/opus_projection_decoder.c\x00assertion failed: len >= 0\x00../src/extensions.c\x00assertion failed: data != NULL || len == 0\x00assertion failed: nb_frames >= 0 && nb_frames <= 48\x00assertion failed: iter->repeat_frame > 0\x00assertion failed: iter->src_len >= 0\x00assertion failed: iter->curr_data - iter->data == iter->len - iter->curr_len\x00assertion failed: nb_extensions != NULL\x00assertion failed: extensions != NULL || *nb_extensions == 0\x00assertion failed: nb_frames <= 48\x00assertion failed: idx < nb_frames_cum[ext.frame + 1]\x00assertion failed: ext->id >= 3 && ext->id <= 127\x00assertion failed: extensions[frame_repeat_idx[g]].frame == g\x00assertion failed: written == nb_extensions\x00Fatal (internal) error in %s, line %d: %s\n\x00../celt/celt.c\x00success\x00invalid argument\x00buffer too small\x00internal error\x00corrupted stream\x00request not implemented\x00invalid state\x00memory allocation failed\x00unknown error\x00libopus 1.6.1\x00assertion failed: x != y\x00../celt/celt_lpc.c\x00assertion failed: len>=3\x00../celt/pitch.h\x00assertion failed: (ord&3)==0\x00assertion failed: n>0\x00assertion failed: overlap>=0\x00assertion failed: m==4\x00../celt/kiss_fft.c\x00assertion failed: fin != fout\nIn-place FFT not supported\x00assertion failed: _ft>1\x00../celt/entdec.c\x00assertion failed: _n>=2\x00../celt/cwrs.c\x00assertion failed: _k>0\x00assertion failed: _n>1\x00assertion failed: st->mode == opus_custom_mode_create(48000, 960, NULL)\x00../celt/celt_decoder.c\x00assertion failed: st->overlap == 120\x00assertion failed: st->end <= 21\x00assertion failed: st->downsample > 0\x00assertion failed: st->start == 0 || st->start == 17\x00assertion failed: st->start < st->end\x00assertion failed: st->last_pitch_index <= PLC_PITCH_LAG_MAX\x00assertion failed: st->last_pitch_index >= PLC_PITCH_LAG_MIN || st->last_pitch_index == 0\x00assertion failed: st->postfilter_period < MAX_PERIOD\x00assertion failed: st->postfilter_period >= COMBFILTER_MINPERIOD || st->postfilter_period == 0\x00assertion failed: st->postfilter_period_old < MAX_PERIOD\x00assertion failed: st->postfilter_period_old >= COMBFILTER_MINPERIOD || st->postfilter_period_old == 0\x00assertion failed: st->postfilter_tapset <= 2\x00assertion failed: st->postfilter_tapset >= 0\x00assertion failed: st->postfilter_tapset_old <= 2\x00assertion failed: st->postfilter_tapset_old >= 0\x00assertion failed: max_pitch>0\x00../celt/pitch.c\x00assertion failed: len>0\x00../celt/entenc.c\x00assertion failed: _bits>0\x00assertion failed: _nbits<=EC_SYM_BITS\x00assertion failed: _this->offs+_this->end_offs<=_size\x00../celt/quant_bands.c\x00../celt/vq.c\x00assertion failed: K>0\nalg_quant() needs at least one pulse\x00assertion failed: N>1\nalg_quant() needs at least two dimensions\x00assertion failed: K>0\nalg_unquant() needs at least one pulse\x00assertion failed: N>1\nalg_unquant() needs at least two dimensions\x00assertion failed: codedBands > start\x00../celt/rate.c\x00assertion failed: bits[j] >= 0\x00assertion failed: ebits[j] >= 0\x00assertion failed: C*ebits[j]<<BITRES == bits[j]\x00assertion failed: start <= end\x00../celt/bands.c\x00assertion failed: end>0\x00assertion failed: nbBands>0\x00assertion failed: sum>=0\x00assertion failed: stride>0\x00assertion failed: qn <= 256\x00assertion failed: itheta>=0\x00assertion failed: N > 0\x00../celt/mdct.c\x000\x00../celt/mini_kfft.c\x00fin != fout\x00(nfft & 1) == 0\x00!st->substate->inverse\x00assertion failed: fl+fs<=32768\x00../celt/laplace.c\x00assertion failed: fs>0\x00assertion failed: fl<32768\x00assertion failed: fl<=fm\x00assertion failed: fm<IMIN(fl+fs,32768)\x00../silk/CNG.c\x00assertion failed: psDec->LPC_order == 10 || psDec->LPC_order == 16\x00../silk/decode_core.c\x00assertion failed: start_idx > 0\x00../silk/decode_frame.c\x00assertion failed: L > 0 && L <= MAX_FRAME_LENGTH\x00assertion failed: psDec->ltp_mem_length >= psDec->frame_length\x00assertion failed: psDec->prevSignalType >= 0 && psDec->prevSignalType <= 2\x00assertion failed: psDec->psNLSF_CB->order == psDec->LPC_order\x00../silk/decode_indices.c\x00assertion failed: frame_length == 12 * 10\x00../silk/decode_pulses.c\x00assertion failed: fs_kHz == 8 || fs_kHz == 12 || fs_kHz == 16\x00../silk/decoder_set_fs.c\x00assertion failed: psDec->nb_subfr == MAX_NB_SUBFR || psDec->nb_subfr == MAX_NB_SUBFR/2\x00assertion failed: psDec->frame_length > 0 && psDec->frame_length <= MAX_FRAME_LENGTH\x00assertion failed: decControl->nChannelsInternal == 1 || decControl->nChannelsInternal == 2\x00../silk/dec_API.c\x00assertion failed: ifact_Q2 >= 0\x00../silk/interpolate.c\x00assertion failed: ifact_Q2 <= 4\x00../silk/PLC.c\x00assertion failed: idx > 0\x00assertion failed: psDec->LPC_order >= 10\x00assertion failed: MAX_FRAME_LENGTH >= psEncC->frame_length\x00../silk/VAD.c\x00assertion failed: psEncC->frame_length <= 512\x00assertion failed: psEncC->frame_length == 8 * silk_RSHIFT( psEncC->frame_length, 3 )\x00assertion failed: ( LPC_order & 1 ) == 0\x00../silk/NLSF_VQ.c\x00assertion failed: nb_subfr == PE_MAX_NB_SUBFR >> 1\x00../silk/decode_pitch.c\x00assertion failed: d >= 6\x00../silk/LPC_analysis_filter.c\x00assertion failed: (d & 1) == 0\x00assertion failed: d <= len\x00assertion failed: d==10 || d==16\x00../silk/NLSF2A.c\x00assertion failed: D > 0\x00../silk/NLSF_VQ_weights_laroia.c\x00assertion failed: ( D & 1 ) == 0\x00../silk/resampler.c\x00assertion failed: inLen >= S->Fs_in_kHz\x00assertion failed: S->inputDelay <= S->Fs_in_kHz\x00../silk/resampler_down2_3.c\x00assertion failed: silk_resampler_down2_0 > 0\x00../silk/resampler_down2.c\x00assertion failed: silk_resampler_down2_1 < 0\x00../silk/resampler_private_down_FIR.c\x00../silk/resampler_private_IIR_FIR.c\x00assertion failed: K > 0\x00../silk/sort.c\x00assertion failed: L > 0\x00assertion failed: L >= K\x00"
