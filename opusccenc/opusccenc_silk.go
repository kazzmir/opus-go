// Code generated for linux/amd64 by 'ccgo --package-name opusccenc --prefix-external Opus_ --prefix-typename OpusT_ -o opusccenc/libopus_enc.go -I .. -I ../include -I ../src -I ../celt -I ../silk -I ../silk/float -include config_ccgo.h -DOPUS_BUILD -DOPUS_DISABLE_INTRINSICS -DNONTHREADSAFE_PSEUDOSTACK -UVAR_ARRAYS -UUSE_ALLOCA -U__SSE__ -U__SSE2__ -U__SSE3__ -U__SSSE3__ -U__AVX__ -U__AVX2__ -std=c99 -O2 -fno-builtin -ignore-asm-errors -ignore-vector-functions ccgo_support/math_lrint.c ../src/opus.c ../src/opus_decoder.c ../src/opus_encoder.c ../src/extensions.c ../src/opus_multistream.c ../src/opus_multistream_encoder.c ../src/opus_multistream_decoder.c ../src/repacketizer.c ../src/opus_projection_encoder.c ../src/opus_projection_decoder.c ../src/mapping_matrix.c ../src/analysis.c ../src/mlp.c ../src/mlp_data.c ../celt/bands.c ../celt/celt.c ../celt/celt_encoder.c ../celt/celt_decoder.c ../celt/cwrs.c ../celt/entcode.c ../celt/entdec.c ../celt/entenc.c ../celt/kiss_fft.c ../celt/laplace.c ../celt/mathops.c ../celt/mdct.c ../celt/modes.c ../celt/pitch.c ../celt/celt_lpc.c ../celt/quant_bands.c ../celt/rate.c ../celt/vq.c ../celt/mini_kfft.c ../silk/CNG.c ../silk/code_signs.c ../silk/init_decoder.c ../silk/decode_core.c ../silk/decode_frame.c ../silk/decode_parameters.c ../silk/decode_indices.c ../silk/decode_pulses.c ../silk/decoder_set_fs.c ../silk/dec_API.c ../silk/enc_API.c ../silk/encode_indices.c ../silk/encode_pulses.c ../silk/gain_quant.c ../silk/interpolate.c ../silk/LP_variable_cutoff.c ../silk/NLSF_decode.c ../silk/NSQ.c ../silk/NSQ_del_dec.c ../silk/PLC.c ../silk/shell_coder.c ../silk/tables_gain.c ../silk/tables_LTP.c ../silk/tables_NLSF_CB_NB_MB.c ../silk/tables_NLSF_CB_WB.c ../silk/tables_other.c ../silk/tables_pitch_lag.c ../silk/tables_pulses_per_block.c ../silk/VAD.c ../silk/control_audio_bandwidth.c ../silk/quant_LTP_gains.c ../silk/VQ_WMat_EC.c ../silk/HP_variable_cutoff.c ../silk/NLSF_encode.c ../silk/NLSF_VQ.c ../silk/NLSF_unpack.c ../silk/NLSF_del_dec_quant.c ../silk/process_NLSFs.c ../silk/stereo_LR_to_MS.c ../silk/stereo_MS_to_LR.c ../silk/check_control_input.c ../silk/control_SNR.c ../silk/init_encoder.c ../silk/control_codec.c ../silk/A2NLSF.c ../silk/ana_filt_bank_1.c ../silk/biquad_alt.c ../silk/bwexpander_32.c ../silk/bwexpander.c ../silk/debug.c ../silk/decode_pitch.c ../silk/inner_prod_aligned.c ../silk/lin2log.c ../silk/log2lin.c ../silk/LPC_analysis_filter.c ../silk/LPC_inv_pred_gain.c ../silk/table_LSF_cos.c ../silk/NLSF2A.c ../silk/NLSF_stabilize.c ../silk/NLSF_VQ_weights_laroia.c ../silk/pitch_est_tables.c ../silk/resampler.c ../silk/resampler_down2_3.c ../silk/resampler_down2.c ../silk/resampler_private_AR2.c ../silk/resampler_private_down_FIR.c ../silk/resampler_private_IIR_FIR.c ../silk/resampler_private_up2_HQ.c ../silk/resampler_rom.c ../silk/sigm_Q15.c ../silk/sort.c ../silk/sum_sqr_shift.c ../silk/stereo_decode_pred.c ../silk/stereo_encode_pred.c ../silk/stereo_find_predictor.c ../silk/stereo_quant_pred.c ../silk/LPC_fit.c ../silk/float/apply_sine_window_FLP.c ../silk/float/corrMatrix_FLP.c ../silk/float/encode_frame_FLP.c ../silk/float/find_LPC_FLP.c ../silk/float/find_LTP_FLP.c ../silk/float/find_pitch_lags_FLP.c ../silk/float/find_pred_coefs_FLP.c ../silk/float/LPC_analysis_filter_FLP.c ../silk/float/LTP_analysis_filter_FLP.c ../silk/float/LTP_scale_ctrl_FLP.c ../silk/float/noise_shape_analysis_FLP.c ../silk/float/process_gains_FLP.c ../silk/float/regularize_correlations_FLP.c ../silk/float/residual_energy_FLP.c ../silk/float/warped_autocorrelation_FLP.c ../silk/float/wrappers_FLP.c ../silk/float/autocorrelation_FLP.c ../silk/float/burg_modified_FLP.c ../silk/float/bwexpander_FLP.c ../silk/float/energy_FLP.c ../silk/float/inner_product_FLP.c ../silk/float/k2a_FLP.c ../silk/float/LPC_inv_pred_gain_FLP.c ../silk/float/pitch_analysis_core_FLP.c ../silk/float/scale_copy_vector_FLP.c ../silk/float/scale_vector_FLP.c ../silk/float/schur_FLP.c ../silk/float/sort_FLP.c', DO NOT EDIT.

//go:build linux && (amd64 || arm64)

package opusccenc

import (
	"reflect"
	"unsafe"

	libc "github.com/kazzmir/opus-go/libcshim"
)

var _ reflect.Type
var _ unsafe.Pointer

func Opus_silk_A2NLSF(tls *libc.TLS, NLSF uintptr, a_Q16 uintptr, d int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var PQ [2]uintptr
	var dd, ffrac, i, k, m, root_ix, v2 int32
	var den, nom, thr, xhi, xlo, xmid, yhi, ylo, ymid, v3, v4, v5 OpusT_opus_int32
	var p uintptr
	var _ /* P at bp+0 */ [13]OpusT_opus_int32
	var _ /* Q at bp+52 */ [13]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = PQ, dd, den, ffrac, i, k, m, nom, p, root_ix, thr, xhi, xlo, xmid, yhi, ylo, ymid, v2, v3, v4, v5
	/* Store pointers to array */
	PQ[0] = bp
	PQ[int32(1)] = bp + 52
	dd = d >> libc.Int32FromInt32(1)
	silk_A2NLSF_init(tls, a_Q16, bp, bp+52, dd)
	/* Find roots, alternating between P and Q */
	p = bp                                      /* Pointer to polynomial */
	xlo = int32(Opus_silk_LSFCosTab_FIX_Q12[0]) /* Q12*/
	ylo = silk_A2NLSF_eval_poly(tls, p, xlo, dd)
	if ylo < 0 {
		/* Set the first NLSF to zero and move on to the next */
		*(*OpusT_opus_int16)(unsafe.Pointer(NLSF)) = 0
		p = bp + 52 /* Pointer to polynomial */
		ylo = silk_A2NLSF_eval_poly(tls, p, xlo, dd)
		root_ix = int32(1) /* Index of current root */
	} else {
		root_ix = 0 /* Index of current root */
	}
	k = int32(1) /* Loop counter */
	i = 0        /* Counter for bandwidth expansions applied */
	thr = 0
	for int32(1) != 0 {
		/* Evaluate polynomial */
		xhi = int32(Opus_silk_LSFCosTab_FIX_Q12[k]) /* Q12 */
		yhi = silk_A2NLSF_eval_poly(tls, p, xhi, dd)
		/* Detect zero crossing */
		if ylo <= 0 && yhi >= thr || ylo >= 0 && yhi <= -thr {
			if yhi == 0 {
				/* If the root lies exactly at the end of the current       */
				/* interval, look for the next root in the next interval    */
				thr = int32(1)
			} else {
				thr = 0
			}
			/* Binary division */
			ffrac = -int32(256)
			m = 0
			for {
				if !(m < int32(BIN_DIV_STEPS_A2NLSF_FIX)) {
					break
				}
				/* Evaluate polynomial */
				xmid = (xlo+xhi)>>libc.Int32FromInt32(1) + (xlo+xhi)&libc.Int32FromInt32(1)
				ymid = silk_A2NLSF_eval_poly(tls, p, xmid, dd)
				/* Detect zero crossing */
				if ylo <= 0 && ymid >= 0 || ylo >= 0 && ymid <= 0 {
					/* Reduce frequency */
					xhi = xmid
					yhi = ymid
				} else {
					/* Increase frequency */
					xlo = xmid
					ylo = ymid
					ffrac = ffrac + int32(128)>>m
				}
				goto _1
			_1:
				;
				m = m + 1
			}
			/* Interpolate */
			if ylo > 0 {
				v2 = ylo
			} else {
				v2 = -ylo
			}
			if v2 < int32(65536) {
				/* Avoid dividing by zero */
				den = ylo - yhi
				nom = libc.Int32FromUint32(libc.Uint32FromInt32(ylo)<<(libc.Int32FromInt32(8)-libc.Int32FromInt32(BIN_DIV_STEPS_A2NLSF_FIX))) + den>>libc.Int32FromInt32(1)
				if den != 0 {
					ffrac = ffrac + nom/den
				}
			} else {
				/* No risk of dividing by zero because abs(ylo - yhi) >= abs(ylo) >= 65536 */
				ffrac = ffrac + ylo/((ylo-yhi)>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(BIN_DIV_STEPS_A2NLSF_FIX)))
			}
			v3 = libc.Int32FromUint32(libc.Uint32FromInt32(k)<<libc.Int32FromInt32(8)) + ffrac
			v4 = int32(silk_int16_MAX17)
			if v3 < v4 {
				v2 = v3
			} else {
				v2 = v4
			}
			v5 = v2
			goto _6
		_6:
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(root_ix)*2)) = int16(v5)
			_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(root_ix)*2))) >= libc.Int32FromInt32(0)
			root_ix = root_ix + 1 /* Next root */
			if root_ix >= d {
				/* Found all roots */
				break
			}
			/* Alternate pointer to polynomial */
			p = PQ[root_ix&int32(1)]
			/* Evaluate polynomial */
			xlo = int32(Opus_silk_LSFCosTab_FIX_Q12[k-int32(1)]) /* Q12*/
			ylo = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)-root_ix&libc.Int32FromInt32(2)) << libc.Int32FromInt32(12))
		} else {
			/* Increment loop counter */
			k = k + 1
			xlo = xhi
			ylo = yhi
			thr = 0
			if k > int32(LSF_COS_TAB_SZ_FIX) {
				i = i + 1
				if i > int32(MAX_ITERATIONS_A2NLSF_FIX) {
					/* Set NLSFs to white spectrum and exit */
					*(*OpusT_opus_int16)(unsafe.Pointer(NLSF)) = int16(libc.Int32FromInt32(1) << libc.Int32FromInt32(15) / (d + libc.Int32FromInt32(1)))
					k = int32(1)
					for {
						if !(k < d) {
							break
						}
						*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF))))
						goto _8
					_8:
						;
						k = k + 1
					}
					return
				}
				/* Error: Apply progressively more bandwidth expansion and run again */
				Opus_silk_bwexpander_32(tls, a_Q16, d, int32(65536)-libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1))<<i))
				silk_A2NLSF_init(tls, a_Q16, bp, bp+52, dd)
				p = bp                                      /* Pointer to polynomial */
				xlo = int32(Opus_silk_LSFCosTab_FIX_Q12[0]) /* Q12*/
				ylo = silk_A2NLSF_eval_poly(tls, p, xlo, dd)
				if ylo < 0 {
					/* Set the first NLSF to zero and move on to the next */
					*(*OpusT_opus_int16)(unsafe.Pointer(NLSF)) = 0
					p = bp + 52 /* Pointer to polynomial */
					ylo = silk_A2NLSF_eval_poly(tls, p, xlo, dd)
					root_ix = int32(1) /* Index of current root */
				} else {
					root_ix = 0 /* Index of current root */
				}
				k = int32(1) /* Reset loop counter */
			}
		}
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Coefficients for 2-band filter bank based on first-order allpass filters */
var A_fb1_20 = int16(libc.Int32FromInt32(5394) << libc.Int32FromInt32(1))
var A_fb1_21 = int16(-int32(24290)) /* (opus_int16)(20623 << 1) */

// C documentation
//
//	/* Split signal into two decimated bands using first-order allpass filters */

func Opus_silk_A2NLSF_FLP(tls *libc.TLS, NLSF_Q15 uintptr, pAR uintptr, LPC_order int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var i int32
	var v2 OpusT_opus_int32
	var _ /* a_fix_Q16 at bp+0 */ [16]OpusT_opus_int32
	_, _ = i, v2
	i = 0
	for {
		if !(i < LPC_order) {
			break
		}
		v2 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(pAR + uintptr(i)*4))*libc.Float32FromFloat32(65536))))
		goto _3
	_3:
		(*(*[16]OpusT_opus_int32)(unsafe.Pointer(bp)))[i] = v2
		goto _1
	_1:
		;
		i = i + 1
	}
	Opus_silk_A2NLSF(tls, NLSF_Q15, bp, LPC_order)
}

// C documentation
//
//	/* Convert LSF parameters to AR prediction filter coefficients */

func Opus_silk_CNG(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, length int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var CNG_sig_Q14, _saved_stack, psCNG, st, v1, v11, v13, v15, v17, v19, v21, v23, v25, v3, v6, v9 uintptr
	var LPC_pred_Q10, gain_Q10, gain_Q16, lzeros, max_Gain_Q16, y, v33, v34, v36, v37, v38, v41, v43 OpusT_opus_int32
	var i, subfr, v40, v42, v52, v54, v58, v59, v60, v61, v62, v63, v64, v65, v66 int32
	var m, r, x OpusT_opus_uint32
	var _ /* A_Q12 at bp+8 */ [16]OpusT_opus_int16
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = CNG_sig_Q14, LPC_pred_Q10, _saved_stack, gain_Q10, gain_Q16, i, lzeros, m, max_Gain_Q16, psCNG, r, st, subfr, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v25, v3, v33, v34, v36, v37, v38, v40, v41, v42, v43, v52, v54, v58, v59, v6, v60, v61, v62, v63, v64, v65, v66, v9
	psCNG = psDec + 2892
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).Ffs_kHz {
		/* Reset state */
		Opus_silk_CNG_Reset(tls, psDec)
		(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).Ffs_kHz = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz
	}
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt == 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == TYPE_NO_VOICE_ACTIVITY {
		/* Update CNG parameters */
		/* Smoothing of LSF's  */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			v1 = psCNG + 1280 + uintptr(i)*2
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + int32(int64(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(psCNG + 1280 + uintptr(i)*2))))*int64(int16(libc.Int32FromInt32(CNG_NLSF_SMTH_Q16)))>>libc.Int32FromInt32(16)))
			goto _5
		_5:
			;
			i = i + 1
		}
		/* Find the subframe with the highest gain */
		max_Gain_Q16 = 0
		subfr = 0
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			if *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4)) > max_Gain_Q16 {
				max_Gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))
				subfr = i
			}
			goto _7
		_7:
			;
			i = i + 1
		}
		/* Update CNG excitation buffer with excitation from this subframe */
		libc.Xmemmove(tls, psCNG+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, psCNG, libc.Uint64FromInt32(((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-libc.Int32FromInt32(1))*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, psCNG, psDec+4+uintptr(subfr*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(4))
		/* Smooth gains */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(psCNG + 1376)) += int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))-(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16) * int64(int16(libc.Int32FromInt32(CNG_GAIN_SMTH_Q16))) >> libc.Int32FromInt32(16))
			/* If the smoothed gain is 3 dB greater than this subframe's gain, use this subframe's gain to adapt faster. */
			if int32(int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)*int64(libc.Int32FromInt32(CNG_GAIN_SMTH_THRESHOLD_Q16))>>libc.Int32FromInt32(16)) > *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4)) {
				(*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(i)*4))
			}
			goto _8
		_8:
			;
			i = i + 1
		}
	}
	/* Add CNG when packet is lost or during DTX */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _10
		_10:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _12
	_12:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v6 = libc.Xmalloc(tls, uint64(16))
			goto _14
		_14:
			st = v6
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v9 = st
		goto _16
	_16:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _18
		_18:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _20
	_20:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _22
		_22:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _24
	_24:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6575, int32(131))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _26
		_26:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _28
	_28:
		*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v23 = libc.Xmalloc(tls, uint64(16))
			goto _30
		_30:
			st = v23
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v25 = st
		goto _32
	_32:
		CNG_sig_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		/* Generate CNG excitation */
		gain_Q16 = int32(int64((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.FrandScale_Q14) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72 + 1*4))) >> libc.Int32FromInt32(16))
		if gain_Q16 >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(21) || (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(23) {
			gain_Q16 = gain_Q16 >> libc.Int32FromInt32(16) * (gain_Q16 >> libc.Int32FromInt32(16))
			gain_Q16 = (*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16>>libc.Int32FromInt32(16)*((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16>>libc.Int32FromInt32(16)) - libc.Int32FromUint32(libc.Uint32FromInt32(gain_Q16)<<libc.Int32FromInt32(5))
			v33 = gain_Q16
			if v33 <= libc.Int32FromInt32(0) {
				v34 = 0
				goto _35
			}
			v36 = v33
			v37 = v36
			if v37 != 0 {
				v40 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v37)))
			} else {
				v40 = int32(32)
			}
			v38 = v40
			goto _39
		_39:
			lzeros = v38
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v41 = v36
			v42 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v41)
			r = libc.Uint32FromInt32(v42)
			m = libc.Uint32FromInt32(-v42)
			if v42 == libc.Int32FromInt32(0) {
				v43 = v41
				goto _44
			} else {
				if v42 < libc.Int32FromInt32(0) {
					v43 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _44
				} else {
					v43 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _44
				}
			}
		_44:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v43 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v34 = y
			goto _35
		_35:
			gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v34) << libc.Int32FromInt32(16))
		} else {
			gain_Q16 = int32(int64(gain_Q16) * int64(gain_Q16) >> libc.Int32FromInt32(16))
			gain_Q16 = int32(int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)*int64((*OpusT_silk_CNG_struct)(unsafe.Pointer(psCNG)).FCNG_smth_Gain_Q16)>>libc.Int32FromInt32(16)) - libc.Int32FromUint32(libc.Uint32FromInt32(gain_Q16)<<libc.Int32FromInt32(5))
			v33 = gain_Q16
			if v33 <= libc.Int32FromInt32(0) {
				v34 = 0
				goto _47
			}
			v36 = v33
			v37 = v36
			if v37 != 0 {
				v40 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v37)))
			} else {
				v40 = int32(32)
			}
			v38 = v40
			goto _51
		_51:
			lzeros = v38
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v41 = v36
			v42 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v41)
			r = libc.Uint32FromInt32(v42)
			m = libc.Uint32FromInt32(-v42)
			if v42 == libc.Int32FromInt32(0) {
				v43 = v41
				goto _56
			} else {
				if v42 < libc.Int32FromInt32(0) {
					v43 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _56
				} else {
					v43 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _56
				}
			}
		_56:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v43 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v34 = y
			goto _47
		_47:
			gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v34) << libc.Int32FromInt32(8))
		}
		gain_Q10 = gain_Q16 >> int32(6)
		silk_CNG_exc(tls, CNG_sig_Q14+uintptr(MAX_LPC_ORDER)*4, psCNG, length, psCNG+1380)
		/* Convert CNG NLSF to filter representation */
		Opus_silk_NLSF2A(tls, bp+8, psCNG+1280, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
		/* Generate CNG signal, by synthesis filtering */
		libc.Xmemcpy(tls, CNG_sig_Q14, psCNG+1312, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(10) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16)) {
			Opus_celt_fatal(tls, __ccgo_ts+6589, __ccgo_ts+6575, int32(153))
		}
		i = 0
		for {
			if !(i < length) {
				break
			}
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[0])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(1)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(2)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(3)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(4)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(5)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(6)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(7)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(8)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(9)])>>libc.Int32FromInt32(16))
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16) {
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(11))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(10)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(12))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(11)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(13))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(12)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(14))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(13)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(15))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(14)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(16))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(15)])>>libc.Int32FromInt32(16))
			}
			/* Update states */
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v42 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v52 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v52 = LPC_pred_Q10
				}
				v42 = v52
			}
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v42)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v58 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v59 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v59 = LPC_pred_Q10
					}
					v58 = v59
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v58)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
					v54 = libc.Int32FromUint32(0x80000000)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v60 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v61 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v61 = LPC_pred_Q10
						}
						v60 = v61
					}
					v54 = *(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v60)<<libc.Int32FromInt32(4))
				}
				v40 = v54
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v63 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v64 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v64 = LPC_pred_Q10
					}
					v63 = v64
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v63)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
					v62 = int32(silk_int32_MAX)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v65 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v66 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v66 = LPC_pred_Q10
						}
						v65 = v66
					}
					v62 = *(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v65)<<libc.Int32FromInt32(4))
				}
				v40 = v62
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v40
			/* Scale with Gain and add to input signal */
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
				v42 = int32(silk_int16_MAX1)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v52 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v52 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v42 = v52
			}
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)))+v42 > int32(silk_int16_MAX1) {
				v40 = int32(silk_int16_MAX1)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
					v58 = int32(silk_int16_MAX1)
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
						v59 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v59 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v58 = v59
				}
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)))+v58 < int32(libc.Int16FromInt32(0x8000)) {
					v54 = int32(libc.Int16FromInt32(0x8000))
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX1) {
						v60 = int32(silk_int16_MAX1)
					} else {
						if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
							v61 = int32(libc.Int16FromInt32(0x8000))
						} else {
							v61 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(CNG_sig_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
						}
						v60 = v61
					}
					v54 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2))) + v60
				}
				v40 = v54
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(v40)
			goto _57
		_57:
			;
			i = i + 1
		}
		libc.Xmemcpy(tls, psCNG+1312, CNG_sig_Q14+uintptr(length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	} else {
		libc.Xmemset(tls, psCNG+1312, 0, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(4))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _82
_82:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

const silk_int16_MAX2 = 0x7FFF

/*#define silk_enc_map(a)                ((a) > 0 ? 1 : 0)*/
/*#define silk_dec_map(a)                ((a) > 0 ? 1 : -1)*/
/* shifting avoids if-statement */

// C documentation
//
//	/* Encodes signs of excitation */

func Opus_silk_CNG_Reset(tls *libc.TLS, psDec uintptr) {
	var NLSF_acc_Q15, NLSF_step_Q15, i int32
	_, _, _ = NLSF_acc_Q15, NLSF_step_Q15, i
	NLSF_step_Q15 = libc.Int32FromInt32(silk_int16_MAX1) / ((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order + libc.Int32FromInt32(1))
	NLSF_acc_Q15 = 0
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
			break
		}
		NLSF_acc_Q15 = NLSF_acc_Q15 + NLSF_step_Q15
		*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2892 + 1280 + uintptr(i)*2)) = int16(NLSF_acc_Q15)
		goto _1
	_1:
		;
		i = i + 1
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsCNG.FCNG_smth_Gain_Q16 = 0
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsCNG.Frand_seed = int32(3176576)
}

// C documentation
//
//	/* Updates CNG estimate, and applies the CNG when packet was lost   */

func Opus_silk_Decode(tls *libc.TLS, decState uintptr, decControl uintptr, lostFlag int32, newPacketFlag int32, psRangeDec uintptr, samplesOut uintptr, nSamplesOut uintptr, arch int32) (r int32) {
	bp := tls.Alloc(656)
	defer tls.Free(656)
	var FrameIndex, condCoding, condCoding1, fs_kHz_dec, has_side, i, n, ret, stereo_to_mono, v51 int32
	var LBRR_symbol OpusT_opus_int32
	var _saved_stack, channel_state, psDec, resample_out_ptr, samplesOut1_tmp_storage1, samplesOut2_tmp, st, v1, v11, v13, v15, v17, v26, v28, v3, v30, v32, v7, v9 uintptr
	var mult_tab [3]int32
	var samplesOut1_tmp [2]uintptr
	var _ /* MS_pred_Q13 at bp+8 */ [2]OpusT_opus_int32
	var _ /* decode_only_middle at bp+0 */ int32
	var _ /* nSamplesOutDec at bp+4 */ OpusT_opus_int32
	var _ /* pulses at bp+16 */ [320]OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = FrameIndex, LBRR_symbol, _saved_stack, channel_state, condCoding, condCoding1, fs_kHz_dec, has_side, i, mult_tab, n, psDec, resample_out_ptr, ret, samplesOut1_tmp, samplesOut1_tmp_storage1, samplesOut2_tmp, st, stereo_to_mono, v1, v11, v13, v15, v17, v26, v28, v3, v30, v32, v51, v7, v9
	*(*int32)(unsafe.Pointer(bp)) = 0
	ret = SILK_NO_ERROR
	*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 8)) = [2]OpusT_opus_int32{}
	psDec = decState
	channel_state = psDec
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+7332, __ccgo_ts+7423, int32(165))
	}
	/**********************************/
	/* Test if first frame in payload */
	/**********************************/
	if newPacketFlag != 0 {
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded = 0 /* Used to count frames in packet */
			goto _5
		_5:
			;
			n = n + 1
		}
	}
	/* If Mono -> Stereo transition in bitstream: init state of second channel */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal > (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal {
		ret = ret + Opus_silk_init_decoder(tls, channel_state+1*4392)
	}
	stereo_to_mono = libc.BoolInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FinternalSampleRate == int32(1000)*(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz)
	if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded == 0 {
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == 0 {
				/* Assuming packet loss, use 10 ms */
				(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
				(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(2)
			} else {
				if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(10) {
					(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
					(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(2)
				} else {
					if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(20) {
						(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(1)
						(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
					} else {
						if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(40) {
							(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(2)
							(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
						} else {
							if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FpayloadSize_ms == int32(60) {
								(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket = int32(3)
								(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fnb_subfr = int32(4)
							} else {
								if !(libc.Int32FromInt32(0) != 0) {
									Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7423, int32(204))
								}
								st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
								if !(st != 0) {
									v1 = libc.Xmalloc(tls, uint64(16))
									goto _8
								_8:
									st = v1
									if st != 0 {
										libc.Xmemset(tls, st, 0, uint64(16))
									}
									libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
								}
								v3 = st
								goto _10
							_10:
								(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
								return -int32(203)
							}
						}
					}
				}
			}
			fs_kHz_dec = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FinternalSampleRate>>libc.Int32FromInt32(10) + int32(1)
			if fs_kHz_dec != int32(8) && fs_kHz_dec != int32(12) && fs_kHz_dec != int32(16) {
				if !(libc.Int32FromInt32(0) != 0) {
					Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7423, int32(210))
				}
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _12
				_12:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _14
			_14:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(200)
			}
			ret = ret + Opus_silk_decoder_set_fs(tls, channel_state+uintptr(n)*4392, fs_kHz_dec, (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate)
			goto _6
		_6:
			;
			n = n + 1
		}
	}
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && ((*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsAPI == int32(1) || (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal == int32(1)) {
		libc.Xmemset(tls, psDec+8784, 0, libc.Uint64FromInt64(4))
		libc.Xmemset(tls, psDec+8784+8, 0, libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, channel_state+1*4392+2448, channel_state+2448, libc.Uint64FromInt64(400))
	}
	(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsAPI = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI
	(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate > libc.Int32FromInt32(MAX_API_FS_KHZ)*libc.Int32FromInt32(1000) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate < int32(8000) {
		ret = -int32(200)
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	if lostFlag != int32(FLAG_PACKET_LOST) && (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded == 0 {
		/* First decoder call for this payload */
		/* Decode VAD flags and LBRR flag */
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			i = 0
			for {
				if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket) {
					break
				}
				*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2416 + uintptr(i)*4)) = Opus_ec_dec_bit_logp(tls, psRangeDec, uint32(1))
				goto _20
			_20:
				;
				i = i + 1
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FLBRR_flag = Opus_ec_dec_bit_logp(tls, psRangeDec, uint32(1))
			goto _19
		_19:
			;
			n = n + 1
		}
		/* Decode LBRR flags */
		n = 0
		for {
			if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
				break
			}
			libc.Xmemset(tls, channel_state+uintptr(n)*4392+2432, 0, libc.Uint64FromInt64(12))
			if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FLBRR_flag != 0 {
				if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket == int32(1) {
					*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432)) = int32(1)
				} else {
					LBRR_symbol = Opus_ec_dec_icdf(tls, psRangeDec, Opus_silk_LBRR_flags_iCDF_ptr[(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket-int32(2)], uint32(8)) + int32(1)
					i = 0
					for {
						if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesPerPacket) {
							break
						}
						*(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i)*4)) = LBRR_symbol >> i & int32(1)
						goto _22
					_22:
						;
						i = i + 1
					}
				}
			}
			goto _21
		_21:
			;
			n = n + 1
		}
		if lostFlag == FLAG_DECODE_NORMAL {
			/* Regular decoding: skip all LBRR data */
			i = 0
			for {
				if !(i < (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesPerPacket) {
					break
				}
				n = 0
				for {
					if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
						break
					}
					if *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i)*4)) != 0 {
						if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && n == 0 {
							Opus_silk_stereo_decode_pred(tls, psRangeDec, bp+8)
							if *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr(i)*4)) == 0 {
								Opus_silk_stereo_decode_mid_only(tls, psRangeDec, bp)
							}
						}
						/* Use conditional coding if previous frame available */
						if i > 0 && *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(i-int32(1))*4)) != 0 {
							condCoding = int32(CODE_CONDITIONALLY)
						} else {
							condCoding = CODE_INDEPENDENTLY
						}
						Opus_silk_decode_indices(tls, channel_state+uintptr(n)*4392, psRangeDec, i, int32(1), condCoding)
						Opus_silk_decode_pulses(tls, psRangeDec, bp+16, int32((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Findices.FsignalType), int32((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Findices.FquantOffsetType), (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).Fframe_length)
					}
					goto _24
				_24:
					;
					n = n + 1
				}
				goto _23
			_23:
				;
				i = i + 1
			}
		}
	}
	/* Get MS predictor index */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) {
		if lostFlag == FLAG_DECODE_NORMAL || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == int32(1) {
			Opus_silk_stereo_decode_pred(tls, psRangeDec, bp+8)
			/* For LBRR data, decode mid-only flag only if side-channel's LBRR flag is false */
			if lostFlag == FLAG_DECODE_NORMAL && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2416 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == 0 || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded)*4)) == 0 {
				Opus_silk_stereo_decode_mid_only(tls, psRangeDec, bp)
			} else {
				*(*int32)(unsafe.Pointer(bp)) = 0
			}
		} else {
			n = 0
			for {
				if !(n < int32(2)) {
					break
				}
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[n] = int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 8784 + uintptr(n)*2)))
				goto _25
			_25:
				;
				n = n + 1
			}
		}
	}
	/* Reset side channel decoder prediction memory for first frame with side coding */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && *(*int32)(unsafe.Pointer(bp)) == 0 && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle == int32(1) {
		libc.Xmemset(tls, psDec+1*4392+1348, 0, libc.Uint64FromInt64(960))
		libc.Xmemset(tls, psDec+1*4392+1284, 0, libc.Uint64FromInt64(64))
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FlagPrev = int32(100)
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FLastGainIndex = int8(10)
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).FprevSignalType = TYPE_NO_VOICE_ACTIVITY
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + 1*4392))).Ffirst_frame_after_reset = int32(1)
	}
	/* Check if the temp buffer fits into the output PCM buffer. If it fits,
	   we can delay allocating the temp buffer until after the SILK peak stack
	   usage. We need to use a < and not a <= because of the two extra samples. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _29
_29:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _33
_33:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _37
_37:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _41
_41:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7423, int32(319))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v26 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v26
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v28 = st
	goto _45
_45:
	*(*uintptr)(unsafe.Pointer(v28 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v30 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v30
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v32 = st
	goto _49
_49:
	samplesOut1_tmp_storage1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v32)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal*((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length+libc.Int32FromInt32(2)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	samplesOut1_tmp[0] = samplesOut1_tmp_storage1
	samplesOut1_tmp[int32(1)] = samplesOut1_tmp_storage1 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Fframe_length)*2 + uintptr(2)*2
	if lostFlag == FLAG_DECODE_NORMAL {
		has_side = libc.BoolInt32(!(*(*int32)(unsafe.Pointer(bp)) != 0))
	} else {
		has_side = libc.BoolInt32(!((*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle != 0) || (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) && lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(channel_state + 1*4392 + 2432 + uintptr((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + 1*4392))).FnFramesDecoded)*4)) == int32(1))
	}
	(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FsPLC.Fenable_deep_plc = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).Fenable_deep_plc
	/* Call decoder for one frame */
	n = 0
	for {
		if !(n < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal) {
			break
		}
		if n == 0 || has_side != 0 {
			FrameIndex = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FnFramesDecoded - n
			/* Use independent coding if no previous frame available */
			if FrameIndex <= 0 {
				condCoding1 = CODE_INDEPENDENTLY
			} else {
				if lostFlag == int32(FLAG_DECODE_LBRR) {
					if *(*int32)(unsafe.Pointer(channel_state + uintptr(n)*4392 + 2432 + uintptr(FrameIndex-int32(1))*4)) != 0 {
						v51 = int32(CODE_CONDITIONALLY)
					} else {
						v51 = CODE_INDEPENDENTLY
					}
					condCoding1 = v51
				} else {
					if n > 0 && (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle != 0 {
						/* If we skipped a side frame in this packet, we don't
						   need LTP scaling; the LTP state is well-defined. */
						condCoding1 = int32(CODE_INDEPENDENTLY_NO_LTP_SCALING)
					} else {
						condCoding1 = int32(CODE_CONDITIONALLY)
					}
				}
			}
			ret = ret + Opus_silk_decode_frame(tls, channel_state+uintptr(n)*4392, psRangeDec, samplesOut1_tmp[n]+2*2, bp+4, lostFlag, condCoding1, arch)
		} else {
			libc.Xmemset(tls, samplesOut1_tmp[n]+2*2, 0, libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))*libc.Uint64FromInt64(2))
		}
		(*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state + uintptr(n)*4392))).FnFramesDecoded + 1
		goto _50
	_50:
		;
		n = n + 1
	}
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(2) {
		/* Convert Mid/Side to Left/Right */
		Opus_silk_stereo_MS_to_LR(tls, psDec+8784, samplesOut1_tmp[0], samplesOut1_tmp[int32(1)], bp+8, (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
	} else {
		/* Buffering */
		libc.Xmemcpy(tls, samplesOut1_tmp[0], psDec+8784+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+8784+4, samplesOut1_tmp[0]+uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	}
	/* Number of output samples */
	*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) * (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FAPI_sampleRate / (int32(int16((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz)) * int32(int16(libc.Int32FromInt32(1000))))
	/* Set up pointers to temp buffers */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _55
_55:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _59
_59:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _61
	_61:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _63
_63:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _67
_67:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7423, int32(382))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v26 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v26
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v28 = st
	goto _71
_71:
	*(*uintptr)(unsafe.Pointer(v28 + 8)) += uintptr(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v30 = libc.Xmalloc(tls, uint64(16))
		goto _73
	_73:
		st = v30
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v32 = st
	goto _75
_75:
	samplesOut2_tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v32)).Fglobal_stack - uintptr(libc.Uint64FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	resample_out_ptr = samplesOut2_tmp
	n = 0
	for {
		if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI < (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal {
			v51 = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI
		} else {
			v51 = (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal
		}
		if !(n < v51) {
			break
		}
		/* Resample decoded signal to API_sampleRate */
		ret = ret + Opus_silk_resampler(tls, channel_state+uintptr(n)*4392+2448, resample_out_ptr, samplesOut1_tmp[n]+1*2, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
		/* Interleave if stereo output and stereo stream */
		if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(n+int32(2)*i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _78
			_78:
				;
				i = i + 1
			}
		} else {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _79
			_79:
				;
				i = i + 1
			}
		}
		goto _76
	_76:
		;
		n = n + 1
	}
	/* Create two channel output from mono stream */
	if (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FnChannelsInternal == int32(1) {
		if stereo_to_mono != 0 {
			/* Resample right channel for newly collapsed stereo just in case
			   we weren't doing collapsing when switching to mono */
			ret = ret + Opus_silk_resampler(tls, channel_state+1*4392+2448, resample_out_ptr, samplesOut1_tmp[0]+1*2, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(int32(1)+int32(2)*i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(resample_out_ptr + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
				goto _80
			_80:
				;
				i = i + 1
			}
		} else {
			i = 0
			for {
				if !(i < *(*OpusT_opus_int32)(unsafe.Pointer(nSamplesOut))) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(int32(1)+int32(2)*i)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(samplesOut + uintptr(0+int32(2)*i)*4))
				goto _81
			_81:
				;
				i = i + 1
			}
		}
	}
	/* Export pitch lag, measured at 48 kHz sampling rate */
	if (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FprevSignalType == int32(TYPE_VOICED) {
		mult_tab = [3]int32{
			0: int32(6),
			1: int32(4),
			2: int32(3),
		}
		(*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FprevPitchLag = (*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).FlagPrev * mult_tab[((*(*OpusT_silk_decoder_state)(unsafe.Pointer(channel_state))).Ffs_kHz-int32(8))>>int32(2)]
	} else {
		(*OpusT_silk_DecControlStruct)(unsafe.Pointer(decControl)).FprevPitchLag = 0
	}
	if lostFlag == int32(FLAG_PACKET_LOST) {
		/* On packet loss, remove the gain clamping to prevent having the energy "bounce back"
		   if we lose packets when the energy is going down */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder)(unsafe.Pointer(psDec)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec + uintptr(i)*4392))).FLastGainIndex = int8(10)
			goto _82
		_82:
			;
			i = i + 1
		}
	} else {
		(*OpusT_silk_decoder)(unsafe.Pointer(psDec)).Fprev_decode_only_middle = *(*int32)(unsafe.Pointer(bp))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _86
_86:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

const PI1 = "3.1415926536f"
const SPEECH_ACTIVITY_DTX_THRES1 = 0.05
const VARIABLE_HP_SMTH_COEF21 = "0.015f"
const silk_encode_do_VAD_Fxx = "silk_encode_do_VAD_FLP"
const silk_encode_frame_Fxx = "silk_encode_frame_FLP"
const silk_encoder_state_Fxx = "silk_encoder_state_FLP"
const silk_int16_MAX5 = 32767

/****************************************/
/* Encoder functions                    */
/****************************************/

func Opus_silk_Encode(tls *libc.TLS, encState uintptr, encControl uintptr, samplesIn uintptr, nSamplesIn int32, psRangeEnc uintptr, nBytesOut uintptr, prefillFlag int32, activity int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var LBRR_symbol, TargetRate_bps, bitsBalance, channelRate_bps, sum OpusT_opus_int32
	var _saved_stack, buf, psEnc, st, v1, v10, v13, v15, v19, v21, v23, v25, v3, v30, v32, v8 uintptr
	var condCoding, condCoding1, curr_block, curr_nBitsUsedLBRR, flags, force_fs_kHz, i, id, maxBits, n, nBits, nBlocksOf10ms, nSamplesFromInput, nSamplesFromInputMax, nSamplesToBuffer, nSamplesToBufferMax, ret, speech_act_thr_for_switch_Q8, tmp_complexity, tmp_payloadSize_ms, tot_blocks, transition, useCBR, v12, v28, v29, v59, v7 int32
	var save_LP OpusT_silk_LP_state
	var v61, v62, v63 float32
	var v64 OpusT_opus_int16
	var _ /* MStargetRates_bps at bp+0 */ [2]OpusT_opus_int32
	var _ /* iCDF at bp+8 */ [2]OpusT_opus_uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = LBRR_symbol, TargetRate_bps, _saved_stack, bitsBalance, buf, channelRate_bps, condCoding, condCoding1, curr_block, curr_nBitsUsedLBRR, flags, force_fs_kHz, i, id, maxBits, n, nBits, nBlocksOf10ms, nSamplesFromInput, nSamplesFromInputMax, nSamplesToBuffer, nSamplesToBufferMax, psEnc, ret, save_LP, speech_act_thr_for_switch_Q8, st, sum, tmp_complexity, tmp_payloadSize_ms, tot_blocks, transition, useCBR, v1, v10, v12, v13, v15, v19, v21, v23, v25, v28, v29, v3, v30, v32, v59, v61, v62, v63, v64, v7, v8
	tmp_payloadSize_ms = 0
	tmp_complexity = 0
	ret = 0
	nSamplesFromInput = 0
	psEnc = encState
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI >= (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI >= (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal) {
		Opus_celt_fatal(tls, __ccgo_ts+7459, __ccgo_ts+7441, int32(171))
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FreducedDependency != 0 {
		n = 0
		for {
			if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI) {
				break
			}
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Ffirst_frame_after_reset = int32(1)
			goto _5
		_5:
			;
			n = n + 1
		}
	}
	n = 0
	for {
		if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI) {
			break
		}
		(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesEncoded = 0
		goto _6
	_6:
		;
		n = n + 1
	}
	/* Check values in encoder control structure */
	v7 = Opus_check_control_input(tls, encControl)
	ret = v7
	if v7 != 0 {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(183))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _9
		_9:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _11
	_11:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FswitchReady = 0
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal > (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal {
		/* Mono -> Stereo transition: init state of second channel and stereo state */
		ret = ret + Opus_silk_init_encoder(tls, psEnc+88+1*10184, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Farch)
		libc.Xmemset(tls, psEnc, 0, libc.Uint64FromInt64(4))
		libc.Xmemset(tls, psEnc+8, 0, libc.Uint64FromInt64(4))
		*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 12)) = 0
		*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 12 + 1*4)) = int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 12 + 2*4)) = 0
		*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 12 + 3*4)) = int32(1)
		(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FsStereo.Fwidth_prev_Q14 = 0
		(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FsStereo.Fsmth_width_Q14 = int16(int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5)))
		if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsAPI == int32(2) {
			libc.Xmemcpy(tls, psEnc+88+1*10184+5792, psEnc+88+5792, libc.Uint64FromInt64(400))
			libc.Xmemcpy(tls, psEnc+88+1*10184, psEnc+88, libc.Uint64FromInt64(8))
		}
	}
	transition = libc.BoolInt32((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms != (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FPacketSize_ms || (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal != (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal)
	(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsAPI = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI
	(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal
	nBlocksOf10ms = libc.Int32FromInt32(100) * nSamplesIn / (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate
	if nBlocksOf10ms > int32(1) {
		v7 = nBlocksOf10ms >> int32(1)
	} else {
		v7 = int32(1)
	}
	tot_blocks = v7
	curr_block = 0
	if prefillFlag != 0 {
		/* Only accept input length of 10 ms */
		if nBlocksOf10ms != int32(1) {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(219))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _14
			_14:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _16
		_16:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(101)
		}
		if prefillFlag == int32(2) {
			save_LP = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FsLP
			/* Save the sampling rate so the bandwidth switching code can keep handling transitions. */
			save_LP.Fsaved_fs_kHz = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz
		}
		/* Reset Encoder */
		n = 0
		for {
			if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
				break
			}
			ret = Opus_silk_init_encoder(tls, psEnc+88+uintptr(n)*10184, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Farch)
			/* Restore the variable LP state. */
			if prefillFlag == int32(2) {
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FsLP = save_LP
			}
			if !!(ret != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+7591, __ccgo_ts+7441, int32(235))
			}
			goto _17
		_17:
			;
			n = n + 1
		}
		tmp_payloadSize_ms = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms
		(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms = int32(10)
		tmp_complexity = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity
		(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity = 0
		n = 0
		for {
			if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Fcontrolled_since_last_payload = 0
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FprefillFlag = int32(1)
			goto _18
		_18:
			;
			n = n + 1
		}
	} else {
		/* Only accept input lengths that are a multiple of 10 ms */
		if nBlocksOf10ms*(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(100)*nSamplesIn || nSamplesIn < 0 {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(248))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _20
			_20:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _22
		_22:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(101)
		}
		/* Make sure no more than one packet can be produced */
		if int32(1000)*nSamplesIn > (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms*(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(254))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _24
			_24:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _26
		_26:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(101)
		}
	}
	n = 0
	for {
		if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
			break
		}
		if n == int32(1) {
			v7 = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz
		} else {
			v7 = 0
		}
		/* Force the side channel to the same rate as the mid */
		force_fs_kHz = v7
		v12 = Opus_silk_control_encoder(tls, psEnc+88+uintptr(n)*10184, encControl, (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FallowBandwidthSwitch, n, force_fs_kHz)
		ret = v12
		if v12 != 0 {
			_ = libc.Int32FromInt32(0)
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _31
			_31:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _33
		_33:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return ret
		}
		if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Ffirst_frame_after_reset != 0 || transition != 0 {
			i = 0
			for {
				if !(i < (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket) {
					break
				}
				*(*int32)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 4740 + uintptr(i)*4)) = 0
				goto _34
			_34:
				;
				i = i + 1
			}
		}
		(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FinDTX = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FuseDTX
		goto _27
	_27:
		;
		n = n + 1
	}
	if !((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1) || (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz == (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Ffs_kHz) {
		Opus_celt_fatal(tls, __ccgo_ts+7614, __ccgo_ts+7441, int32(275))
	}
	/* Input buffering/resampling and encoding */
	nSamplesToBufferMax = int32(10) * nBlocksOf10ms * (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz
	nSamplesFromInputMax = nSamplesToBufferMax * (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FAPI_fs_Hz / ((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz * libc.Int32FromInt32(1000))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _38
_38:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _42
_42:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _46
_46:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _50
_50:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nSamplesFromInputMax)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+7441, int32(284))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _54
_54:
	*(*uintptr)(unsafe.Pointer(v25 + 8)) += uintptr(libc.Uint64FromInt32(nSamplesFromInputMax) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v30 = libc.Xmalloc(tls, uint64(16))
		goto _56
	_56:
		st = v30
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v32 = st
	goto _58
_58:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v32)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nSamplesFromInputMax)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	for int32(1) != 0 {
		curr_nBitsUsedLBRR = 0
		nSamplesToBuffer = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length - (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx
		if nSamplesToBuffer < nSamplesToBufferMax {
			v7 = nSamplesToBuffer
		} else {
			v7 = nSamplesToBufferMax
		}
		nSamplesToBuffer = v7
		nSamplesFromInput = nSamplesToBuffer * (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FAPI_fs_Hz / ((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz * libc.Int32FromInt32(1000))
		/* Resample and write to buffer */
		if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(2) {
			id = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded
			n = 0
			for {
				if !(n < nSamplesFromInput) {
					break
				}
				v61 = *(*OpusT_opus_res)(unsafe.Pointer(samplesIn + uintptr(int32(2)*n)*4))
				v61 = float32(v61 * libc.Float32FromFloat32(32768))
				if v61 > float32(-libc.Int32FromInt32(32768)) {
					v62 = v61
				} else {
					v62 = float32(-libc.Int32FromInt32(32768))
				}
				v61 = v62
				if v61 < float32(libc.Int32FromInt32(32767)) {
					v63 = v61
				} else {
					v63 = float32(libc.Int32FromInt32(32767))
				}
				v61 = v63
				v64 = int16(Opus_lrintf(tls, v61))
				goto _65
			_65:
				*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(n)*2)) = v64
				goto _60
			_60:
				;
				n = n + 1
			}
			/* Making sure to start both resamplers from the same state when switching from mono to stereo */
			if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnPrevChannelsInternal == int32(1) && id == 0 {
				libc.Xmemcpy(tls, psEnc+88+1*10184+5792, psEnc+88+5792, libc.Uint64FromInt64(400))
			}
			ret = ret + Opus_silk_resampler(tls, psEnc+88+5792, psEnc+88+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx+int32(2))*2, buf, nSamplesFromInput)
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx += nSamplesToBuffer
			nSamplesToBuffer = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Fframe_length - (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx
			if nSamplesToBuffer < int32(10)*nBlocksOf10ms*(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Ffs_kHz {
				v7 = nSamplesToBuffer
			} else {
				v7 = int32(10) * nBlocksOf10ms * (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Ffs_kHz
			}
			nSamplesToBuffer = v7
			n = 0
			for {
				if !(n < nSamplesFromInput) {
					break
				}
				v61 = *(*OpusT_opus_res)(unsafe.Pointer(samplesIn + uintptr(int32(2)*n+int32(1))*4))
				v61 = float32(v61 * libc.Float32FromFloat32(32768))
				if v61 > float32(-libc.Int32FromInt32(32768)) {
					v62 = v61
				} else {
					v62 = float32(-libc.Int32FromInt32(32768))
				}
				v61 = v62
				if v61 < float32(libc.Int32FromInt32(32767)) {
					v63 = v61
				} else {
					v63 = float32(libc.Int32FromInt32(32767))
				}
				v61 = v63
				v64 = int16(Opus_lrintf(tls, v61))
				goto _72
			_72:
				*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(n)*2)) = v64
				goto _67
			_67:
				;
				n = n + 1
			}
			ret = ret + Opus_silk_resampler(tls, psEnc+88+1*10184+5792, psEnc+88+1*10184+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx+int32(2))*2, buf, nSamplesFromInput)
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx += nSamplesToBuffer
		} else {
			if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI == int32(2) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1) {
				/* Combine left and right channels before resampling */
				n = 0
				for {
					if !(n < nSamplesFromInput) {
						break
					}
					v61 = *(*OpusT_opus_res)(unsafe.Pointer(samplesIn + uintptr(int32(2)*n)*4)) + *(*OpusT_opus_res)(unsafe.Pointer(samplesIn + uintptr(int32(2)*n+int32(1))*4))
					v61 = float32(v61 * libc.Float32FromFloat32(32768))
					if v61 > float32(-libc.Int32FromInt32(32768)) {
						v62 = v61
					} else {
						v62 = float32(-libc.Int32FromInt32(32768))
					}
					v61 = v62
					if v61 < float32(libc.Int32FromInt32(32767)) {
						v63 = v61
					} else {
						v63 = float32(libc.Int32FromInt32(32767))
					}
					v61 = v63
					v64 = int16(Opus_lrintf(tls, v61))
					goto _78
				_78:
					sum = int32(v64)
					*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(n)*2)) = int16(sum>>libc.Int32FromInt32(1) + sum&libc.Int32FromInt32(1))
					goto _73
				_73:
					;
					n = n + 1
				}
				ret = ret + Opus_silk_resampler(tls, psEnc+88+5792, psEnc+88+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx+int32(2))*2, buf, nSamplesFromInput)
				/* On the first mono frame, average the results for the two resampler states  */
				if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnPrevChannelsInternal == int32(2) && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded == 0 {
					ret = ret + Opus_silk_resampler(tls, psEnc+88+1*10184+5792, psEnc+88+1*10184+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx+int32(2))*2, buf, nSamplesFromInput)
					n = 0
					for {
						if !(n < (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length) {
							break
						}
						*(*OpusT_opus_int16)(unsafe.Pointer(psEnc + 88 + 5112 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx+n+int32(2))*2)) = int16((int32(*(*OpusT_opus_int16)(unsafe.Pointer(psEnc + 88 + 5112 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx+n+int32(2))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(psEnc + 88 + 1*10184 + 5112 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx+n+int32(2))*2)))) >> libc.Int32FromInt32(1))
						goto _79
					_79:
						;
						n = n + 1
					}
				}
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx += nSamplesToBuffer
			} else {
				if !((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI == int32(1) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1)) {
					Opus_celt_fatal(tls, __ccgo_ts+7741, __ccgo_ts+7441, int32(334))
				}
				n = 0
				for {
					if !(n < nSamplesFromInput) {
						break
					}
					v61 = *(*OpusT_opus_res)(unsafe.Pointer(samplesIn + uintptr(n)*4))
					v61 = float32(v61 * libc.Float32FromFloat32(32768))
					if v61 > float32(-libc.Int32FromInt32(32768)) {
						v62 = v61
					} else {
						v62 = float32(-libc.Int32FromInt32(32768))
					}
					v61 = v62
					if v61 < float32(libc.Int32FromInt32(32767)) {
						v63 = v61
					} else {
						v63 = float32(libc.Int32FromInt32(32767))
					}
					v61 = v63
					v64 = int16(Opus_lrintf(tls, v61))
					goto _85
				_85:
					*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(n)*2)) = v64
					goto _80
				_80:
					;
					n = n + 1
				}
				ret = ret + Opus_silk_resampler(tls, psEnc+88+5792, psEnc+88+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx+int32(2))*2, buf, nSamplesFromInput)
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx += nSamplesToBuffer
			}
		}
		samplesIn = samplesIn + uintptr(nSamplesFromInput*(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI)*4
		nSamplesIn = nSamplesIn - nSamplesFromInput
		/* Default */
		(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FallowBandwidthSwitch = 0
		/* Silk encoder */
		if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx >= (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length {
			/* Enough data in input buffer, so encode */
			if !((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinputBufIx == (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length) {
				Opus_celt_fatal(tls, __ccgo_ts+7827, __ccgo_ts+7441, int32(352))
			}
			if !((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1) || (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinputBufIx == (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Fframe_length) {
				Opus_celt_fatal(tls, __ccgo_ts+7926, __ccgo_ts+7441, int32(353))
			}
			/* Deal with LBRR data */
			if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded == 0 && !(prefillFlag != 0) {
				/* Create space at start of payload for VAD and FEC flags */
				*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp + 8)) = [2]OpusT_opus_uint8{}
				(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp + 8)))[0] = libc.Uint8FromInt32(int32(256) - int32(256)>>(((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket+int32(1))*(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal))
				Opus_ec_enc_icdf(tls, psRangeEnc, 0, bp+8, uint32(8))
				v1 = psRangeEnc
				v7 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _88
			_88:
				curr_nBitsUsedLBRR = v7
				/* Encode any LBRR data from previous packet */
				/* Encode LBRR flags */
				n = 0
				for {
					if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
						break
					}
					LBRR_symbol = 0
					i = 0
					for {
						if !(i < (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesPerPacket) {
							break
						}
						LBRR_symbol = LBRR_symbol | libc.Int32FromUint32(libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 4740 + uintptr(i)*4)))<<i)
						goto _90
					_90:
						;
						i = i + 1
					}
					if LBRR_symbol > 0 {
						v7 = int32(1)
					} else {
						v7 = 0
					}
					(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FLBRR_flag = int8(v7)
					if LBRR_symbol != 0 && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesPerPacket > int32(1) {
						Opus_ec_enc_icdf(tls, psRangeEnc, LBRR_symbol-int32(1), Opus_silk_LBRR_flags_iCDF_ptr[(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesPerPacket-int32(2)], uint32(8))
					}
					goto _89
				_89:
					;
					n = n + 1
				}
				/* Code LBRR indices and excitation signals */
				i = 0
				for {
					if !(i < (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket) {
						break
					}
					n = 0
					for {
						if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
							break
						}
						if *(*int32)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 4740 + uintptr(i)*4)) != 0 {
							if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(2) && n == 0 {
								Opus_silk_stereo_encode_pred(tls, psRangeEnc, psEnc+34+uintptr(i)*6)
								/* For LBRR data there's no need to code the mid-only flag if the side-channel LBRR flag is set */
								if *(*int32)(unsafe.Pointer(psEnc + 88 + 1*10184 + 4740 + uintptr(i)*4)) == 0 {
									Opus_silk_stereo_encode_mid_only(tls, psRangeEnc, *(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 52 + uintptr(i))))
								}
							}
							/* Use conditional coding if previous frame available */
							if i > 0 && *(*int32)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 4740 + uintptr(i-int32(1))*4)) != 0 {
								condCoding = int32(CODE_CONDITIONALLY)
							} else {
								condCoding = CODE_INDEPENDENTLY
							}
							Opus_silk_encode_indices(tls, psEnc+88+uintptr(n)*10184, psRangeEnc, i, int32(1), condCoding)
							Opus_silk_encode_pulses(tls, psRangeEnc, int32((*(*OpusT_SideInfoIndices)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 6216 + uintptr(i)*36))).FsignalType), int32((*(*OpusT_SideInfoIndices)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 6216 + uintptr(i)*36))).FquantOffsetType), psEnc+88+uintptr(n)*10184+6324+uintptr(i)*320, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Fframe_length)
						}
						goto _93
					_93:
						;
						n = n + 1
					}
					goto _92
				_92:
					;
					i = i + 1
				}
				/* Reset LBRR flags */
				n = 0
				for {
					if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
						break
					}
					libc.Xmemset(tls, psEnc+88+uintptr(n)*10184+4740, 0, libc.Uint64FromInt64(12))
					goto _94
				_94:
					;
					n = n + 1
				}
				v1 = psRangeEnc
				v7 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _97
			_97:
				curr_nBitsUsedLBRR = v7 - curr_nBitsUsedLBRR
			}
			Opus_silk_HP_variable_cutoff(tls, psEnc+88)
			/* Total target bits for packet */
			nBits = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate * (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms / libc.Int32FromInt32(1000)
			/* Subtract bits used for LBRR */
			if !(prefillFlag != 0) {
				/* psEnc->nBitsUsedLBRR is an exponential moving average of the LBRR usage,
				   except that for the first LBRR frame it does no averaging and for the first
				   frame after after LBRR, it goes back to zero immediately. */
				if curr_nBitsUsedLBRR < int32(10) {
					(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR = 0
				} else {
					if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR < int32(10) {
						(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR = curr_nBitsUsedLBRR
					} else {
						(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR = ((*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR + curr_nBitsUsedLBRR) / int32(2)
					}
				}
				nBits = nBits - (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR
			}
			/* Divide by number of uncoded frames left in packet */
			nBits = nBits / (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket
			/* Convert to bits/second */
			if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms == int32(10) {
				TargetRate_bps = int32(int16(nBits)) * int32(int16(libc.Int32FromInt32(100)))
			} else {
				TargetRate_bps = int32(int16(nBits)) * int32(int16(libc.Int32FromInt32(50)))
			}
			/* Subtract fraction of bits in excess of target in previous frames and packets */
			TargetRate_bps = TargetRate_bps - (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsExceeded*libc.Int32FromInt32(1000)/libc.Int32FromInt32(BITRESERVOIR_DECAY_TIME_MS)
			if !(prefillFlag != 0) && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded > 0 {
				v1 = psRangeEnc
				v7 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _100
			_100:
				/* Compare actual vs target bits so far in this packet */
				bitsBalance = v7 - (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsUsedLBRR - nBits*(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded
				TargetRate_bps = TargetRate_bps - bitsBalance*libc.Int32FromInt32(1000)/libc.Int32FromInt32(BITRESERVOIR_DECAY_TIME_MS)
			}
			/* Never exceed input bitrate */
			if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate > int32(5000) {
				if TargetRate_bps > (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate {
					v12 = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate
				} else {
					if TargetRate_bps < int32(5000) {
						v28 = int32(5000)
					} else {
						v28 = TargetRate_bps
					}
					v12 = v28
				}
				v7 = v12
			} else {
				if TargetRate_bps > int32(5000) {
					v29 = int32(5000)
				} else {
					if TargetRate_bps < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate {
						v59 = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate
					} else {
						v59 = TargetRate_bps
					}
					v29 = v59
				}
				v7 = v29
			}
			TargetRate_bps = v7
			/* Convert Left/Right to Mid/Side */
			if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(2) {
				Opus_silk_stereo_LR_to_MS(tls, psEnc, psEnc+88+5112+2*2, psEnc+88+1*10184+5112+2*2, psEnc+34+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded)*6, psEnc+52+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded), bp, TargetRate_bps, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fspeech_activity_Q8, (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FtoMono, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz, (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length)
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 52 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded)))) == 0 {
					/* Reset side channel encoder memory for first frame with side coding */
					if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).Fprev_decode_only_middle == int32(1) {
						libc.Xmemset(tls, psEnc+88+1*10184+7288, 0, libc.Uint64FromInt64(12))
						libc.Xmemset(tls, psEnc+88+1*10184+148, 0, libc.Uint64FromInt64(4352))
						libc.Xmemset(tls, psEnc+88+1*10184+4500, 0, libc.Uint64FromInt64(32))
						libc.Xmemset(tls, psEnc+88+1*10184+16, 0, libc.Uint64FromInt64(8))
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FprevLag = int32(100)
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FsNSQ.FlagPrev = int32(100)
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsShape.FLastGainIndex = int8(10)
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FprevSignalType = TYPE_NO_VOICE_ACTIVITY
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FsNSQ.Fprev_gain_Q16 = int32(65536)
						(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.Ffirst_frame_after_reset = int32(1)
					}
					Opus_silk_encode_do_VAD_FLP(tls, psEnc+88+1*10184, activity)
				} else {
					*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 88 + 1*10184 + 4736 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded))) = 0
				}
				if !(prefillFlag != 0) {
					Opus_silk_stereo_encode_pred(tls, psRangeEnc, psEnc+34+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded)*6)
					if int32(*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 88 + 1*10184 + 4736 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded)))) == 0 {
						Opus_silk_stereo_encode_mid_only(tls, psRangeEnc, *(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 52 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded))))
					}
				}
			} else {
				/* Buffering */
				libc.Xmemcpy(tls, psEnc+88+5112, psEnc+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
				libc.Xmemcpy(tls, psEnc+4, psEnc+88+5112+uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fframe_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
			}
			Opus_silk_encode_do_VAD_FLP(tls, psEnc+88, activity)
			/* Encode */
			n = 0
			for {
				if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
					break
				}
				/* Handling rate constraints */
				maxBits = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxBits
				if tot_blocks == int32(2) && curr_block == 0 {
					maxBits = maxBits * int32(3) / int32(5)
				} else {
					if tot_blocks == int32(3) {
						if curr_block == 0 {
							maxBits = maxBits * int32(2) / int32(5)
						} else {
							if curr_block == int32(1) {
								maxBits = maxBits * int32(3) / int32(4)
							}
						}
					}
				}
				useCBR = libc.BoolInt32((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseCBR != 0 && curr_block == tot_blocks-int32(1))
				if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1) {
					channelRate_bps = TargetRate_bps
				} else {
					channelRate_bps = (*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[n]
					if n == 0 && (*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] > 0 {
						useCBR = 0
						/* Give mid up to 1/2 of the max bits for that frame */
						maxBits = maxBits - (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxBits/(tot_blocks*int32(2))
					}
				}
				if channelRate_bps > 0 {
					Opus_silk_control_SNR(tls, psEnc+88+uintptr(n)*10184, channelRate_bps)
					/* Use independent coding if no previous frame available */
					if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded-n <= 0 {
						condCoding1 = CODE_INDEPENDENTLY
					} else {
						if n > 0 && (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).Fprev_decode_only_middle != 0 {
							/* If we skipped a side frame in this packet, we don't
							   need LTP scaling; the LTP state is well-defined. */
							condCoding1 = int32(CODE_INDEPENDENTLY_NO_LTP_SCALING)
						} else {
							condCoding1 = int32(CODE_CONDITIONALLY)
						}
					}
					v7 = Opus_silk_encode_frame_FLP(tls, psEnc+88+uintptr(n)*10184, nBytesOut, psRangeEnc, condCoding1, maxBits, useCBR)
					ret = v7
					if v7 != 0 {
						_ = libc.Int32FromInt32(0)
					}
				}
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Fcontrolled_since_last_payload = 0
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FinputBufIx = 0
				(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesEncoded = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesEncoded + 1
				goto _106
			_106:
				;
				n = n + 1
			}
			(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).Fprev_decode_only_middle = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 52 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded-int32(1)))))
			/* Insert VAD and FEC flags at beginning of bitstream */
			if *(*OpusT_opus_int32)(unsafe.Pointer(nBytesOut)) > 0 && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesEncoded == (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket {
				flags = 0
				n = 0
				for {
					if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
						break
					}
					i = 0
					for {
						if !(i < (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FnFramesPerPacket) {
							break
						}
						flags = libc.Int32FromUint32(libc.Uint32FromInt32(flags) << libc.Int32FromInt32(1))
						flags = flags | int32(*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184 + 4736 + uintptr(i))))
						goto _109
					_109:
						;
						i = i + 1
					}
					flags = libc.Int32FromUint32(libc.Uint32FromInt32(flags) << libc.Int32FromInt32(1))
					flags = flags | int32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FLBRR_flag)
					goto _108
				_108:
					;
					n = n + 1
				}
				if !(prefillFlag != 0) {
					Opus_ec_enc_patch_initial_bits(tls, psRangeEnc, libc.Uint32FromInt32(flags), libc.Uint32FromInt32(((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FnFramesPerPacket+int32(1))*(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal))
				}
				/* Return zero bytes if all channels DTXed */
				if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FinDTX != 0 && ((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal == int32(1) || (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + 1*10184))).FsCmn.FinDTX != 0) {
					*(*OpusT_opus_int32)(unsafe.Pointer(nBytesOut)) = 0
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 60)) += *(*OpusT_opus_int32)(unsafe.Pointer(nBytesOut)) * int32(8)
				*(*OpusT_opus_int32)(unsafe.Pointer(psEnc + 60)) -= (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FbitRate * (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms / libc.Int32FromInt32(1000)
				if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsExceeded > int32(10000) {
					v7 = int32(10000)
				} else {
					if (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsExceeded < 0 {
						v12 = 0
					} else {
						v12 = (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsExceeded
					}
					v7 = v12
				}
				(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnBitsExceeded = v7
				/* Update flag indicating if bandwidth switching is allowed */
				speech_act_thr_for_switch_Q8 = int32(int64(int32(float64(libc.Float32FromFloat32(0.05)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(8)))+libc.Float64FromFloat64(0.5))) + int64(int32(float64((libc.Float32FromInt32(1)-libc.Float32FromFloat32(0.05))/libc.Float32FromInt32(MAX_BANDWIDTH_SWITCH_DELAY_MS)*float32(libc.Int64FromInt32(1)<<(libc.Int32FromInt32(16)+libc.Int32FromInt32(8))))+libc.Float64FromFloat64(0.5)))*int64(int16((*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FtimeSinceSwitchAllowed_ms))>>libc.Int32FromInt32(16))
				if (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Fspeech_activity_Q8 < speech_act_thr_for_switch_Q8 {
					(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FallowBandwidthSwitch = int32(1)
					(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FtimeSinceSwitchAllowed_ms = 0
				} else {
					(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FallowBandwidthSwitch = 0
					*(*int32)(unsafe.Pointer(psEnc + 76)) += (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms
				}
			}
			if nSamplesIn == 0 {
				break
			}
		} else {
			break
		}
		curr_block = curr_block + 1
	}
	(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnPrevChannelsInternal = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FallowBandwidthSwitch = (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FallowBandwidthSwitch
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FinWBmodeWithoutVariableLP = libc.BoolInt32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz == int32(16) && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.FsLP.Fmode == 0)
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FinternalSampleRate = int32(int16((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Ffs_kHz)) * int32(int16(libc.Int32FromInt32(1000)))
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FtoMono != 0 {
		v7 = 0
	} else {
		v7 = int32((*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FsStereo.Fsmth_width_Q14)
	}
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FstereoWidth_Q14 = v7
	if prefillFlag != 0 {
		(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms = tmp_payloadSize_ms
		(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity = tmp_complexity
		n = 0
		for {
			if !(n < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal) {
				break
			}
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.Fcontrolled_since_last_payload = 0
			(*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88 + uintptr(n)*10184))).FsCmn.FprefillFlag = 0
			goto _113
		_113:
			;
			n = n + 1
		}
	}
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FsignalType = int32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Findices.FsignalType)
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Foffset = int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Findices.FsignalType)>>int32(1))*4 + uintptr((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc + 88))).FsCmn.Findices.FquantOffsetType)*2)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _115
	_115:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _117
_117:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

const CELT_SIG_SCALE12 = "32768.f"
const silk_int16_MAX6 = 0x7FFF

// C documentation
//
//	/* Encode side-information parameters to payload */

func Opus_silk_Get_Decoder_Size(tls *libc.TLS, decSizeBytes uintptr) (r int32) {
	var ret int32
	_ = ret
	ret = SILK_NO_ERROR
	*(*int32)(unsafe.Pointer(decSizeBytes)) = int32(8808)
	return ret
}

// C documentation
//
//	/* Reset decoder state */

func Opus_silk_Get_Encoder_Size(tls *libc.TLS, encSizeBytes uintptr, channels int32) (r int32) {
	var ret int32
	var v1 uintptr
	_, _ = ret, v1
	ret = SILK_NO_ERROR
	*(*int32)(unsafe.Pointer(encSizeBytes)) = int32(20456)
	/* Skip second encoder state for mono. */
	if channels == int32(1) {
		v1 = encSizeBytes
		*(*int32)(unsafe.Pointer(v1)) = int32(uint64(*(*int32)(unsafe.Pointer(v1))) - libc.Uint64FromInt64(10184))
	}
	return ret
}

// C documentation
//
//	/*************************/
//	/* Init or Reset encoder */
//	/*************************/

func Opus_silk_HP_variable_cutoff(tls *libc.TLS, state_Fxx uintptr) {
	var delta_freq_Q7, pitch_freq_Hz_Q16, pitch_freq_log_Q7 OpusT_opus_int32
	var psEncC1 uintptr
	var quality_Q15, v1, v2, v3, v4, v5 int32
	_, _, _, _, _, _, _, _, _, _ = delta_freq_Q7, pitch_freq_Hz_Q16, pitch_freq_log_Q7, psEncC1, quality_Q15, v1, v2, v3, v4, v5
	psEncC1 = state_Fxx
	/* Adaptive cutoff frequency: estimate low end of pitch frequency range */
	if int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).FprevSignalType) == int32(TYPE_VOICED) {
		/* difference, in log domain */
		pitch_freq_Hz_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Ffs_kHz*libc.Int32FromInt32(1000))<<libc.Int32FromInt32(16)) / (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).FprevLag
		pitch_freq_log_Q7 = Opus_silk_lin2log(tls, pitch_freq_Hz_Q16) - libc.Int32FromInt32(16)<<libc.Int32FromInt32(7)
		/* adjustment based on quality */
		quality_Q15 = *(*int32)(unsafe.Pointer(psEncC1 + 4712))
		pitch_freq_log_Q7 = int32(int64(pitch_freq_log_Q7) + int64(int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(-quality_Q15)<<libc.Int32FromInt32(2)))*int64(int16(quality_Q15))>>libc.Int32FromInt32(16)))*int64(int16(pitch_freq_log_Q7-(Opus_silk_lin2log(tls, int32(float64(int64(libc.Int32FromInt32(VARIABLE_HP_MIN_CUTOFF_HZ))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))-libc.Int32FromInt32(16)<<libc.Int32FromInt32(7))))>>libc.Int32FromInt32(16))
		/* delta_freq = pitch_freq_log - psEnc->variable_HP_smth1; */
		delta_freq_Q7 = pitch_freq_log_Q7 - (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15>>libc.Int32FromInt32(8)
		if delta_freq_Q7 < 0 {
			/* less smoothing for decreasing pitch frequency, to track something close to the minimum */
			delta_freq_Q7 = delta_freq_Q7 * libc.Int32FromInt32(3)
		}
		/* limit delta, to reduce impact of outliers in pitch estimation */
		if -int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) > int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
			if delta_freq_Q7 > -int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
				v2 = -int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7))) + libc.Float64FromFloat64(0.5))
			} else {
				if delta_freq_Q7 < int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
					v3 = int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7))) + libc.Float64FromFloat64(0.5))
				} else {
					v3 = delta_freq_Q7
				}
				v2 = v3
			}
			v1 = v2
		} else {
			if delta_freq_Q7 > int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
				v4 = int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7))) + libc.Float64FromFloat64(0.5))
			} else {
				if delta_freq_Q7 < -int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
					v5 = -int32(float64(libc.Float32FromFloat32(0.4)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7))) + libc.Float64FromFloat64(0.5))
				} else {
					v5 = delta_freq_Q7
				}
				v4 = v5
			}
			v1 = v4
		}
		delta_freq_Q7 = v1
		/* update smoother */
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 = int32(int64((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15) + int64(int32(int16((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fspeech_activity_Q8))*int32(int16(delta_freq_Q7)))*int64(int16(int32(float64(libc.Float32FromFloat32(0.1)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))))>>libc.Int32FromInt32(16))
		/* limit frequency range */
		if libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) > libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MAX_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) {
			if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 > libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) {
				v2 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ))) << libc.Int32FromInt32(8))
			} else {
				if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 < libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MAX_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) {
					v3 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MAX_CUTOFF_HZ))) << libc.Int32FromInt32(8))
				} else {
					v3 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15
				}
				v2 = v3
			}
			v1 = v2
		} else {
			if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 > libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MAX_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) {
				v4 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MAX_CUTOFF_HZ))) << libc.Int32FromInt32(8))
			} else {
				if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 < libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ)))<<libc.Int32FromInt32(8)) {
					v5 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ))) << libc.Int32FromInt32(8))
				} else {
					v5 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15
				}
				v4 = v5
			}
			v1 = v4
		}
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC1)).Fvariable_HP_smth1_Q15 = v1
	}
}

const CELT_SIG_SCALE14 = "32768.f"
const silk_int16_MAX14 = 0x7FFF

// C documentation
//
//	/***********************/
//	/* NLSF vector encoder */
//	/***********************/

func Opus_silk_InitDecoder(tls *libc.TLS, decState uintptr) (r int32) {
	var channel_state uintptr
	var n, ret int32
	_, _, _ = channel_state, n, ret
	ret = SILK_NO_ERROR
	channel_state = decState
	/* load osce models */
	Opus_silk_LoadOSCEModels(tls, decState, libc.UintptrFromInt32(0), 0)
	n = 0
	for {
		if !(n < int32(DECODER_NUM_CHANNELS)) {
			break
		}
		ret = Opus_silk_init_decoder(tls, channel_state+uintptr(n)*4392)
		goto _1
	_1:
		;
		n = n + 1
	}
	libc.Xmemset(tls, decState+8784, 0, libc.Uint64FromInt64(12))
	/* Not strictly needed, but it's cleaner that way */
	(*OpusT_silk_decoder)(unsafe.Pointer(decState)).Fprev_decode_only_middle = 0
	return ret
}

// C documentation
//
//	/* Decode a frame */

func Opus_silk_InitEncoder(tls *libc.TLS, encState uintptr, channels int32, arch int32, encStatus uintptr) (r int32) {
	var n, ret int32
	var psEnc uintptr
	_, _, _ = n, psEnc, ret
	ret = SILK_NO_ERROR
	psEnc = encState
	/* Reset encoder. Skip second encoder state for mono. */
	libc.Xmemset(tls, psEnc, 0, libc.Uint64FromInt64(20456)-libc.BoolUint64(channels == libc.Int32FromInt32(1))*libc.Uint64FromInt64(10184))
	n = 0
	for {
		if !(n < channels) {
			break
		}
		ret = ret + Opus_silk_init_encoder(tls, psEnc+88+uintptr(n)*10184, arch)
		if ret != 0 {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(95))
			}
		}
		goto _1
	_1:
		;
		n = n + 1
	}
	(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsAPI = int32(1)
	(*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal = int32(1)
	/* Read control structure */
	ret = ret + silk_QueryEncoder(tls, encState, encStatus)
	if ret != 0 {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7441, int32(104))
		}
	}
	return ret
}

// C documentation
//
//	/***************************************/
//	/* Read control structure from encoder */
//	/***************************************/

func Opus_silk_LPC_analysis_filter(tls *libc.TLS, out uintptr, in uintptr, B uintptr, len1 OpusT_opus_int32, d OpusT_opus_int32, arch int32) {
	var in_ptr uintptr
	var ix, j, v3, v4 int32
	var out32, out32_Q12 OpusT_opus_int32
	_, _, _, _, _, _, _ = in_ptr, ix, j, out32, out32_Q12, v3, v4
	if !(d >= libc.Int32FromInt32(6)) {
		Opus_celt_fatal(tls, __ccgo_ts+9986, __ccgo_ts+10011, int32(67))
	}
	if !(d&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10041, __ccgo_ts+10011, int32(68))
	}
	if !(d <= len1) {
		Opus_celt_fatal(tls, __ccgo_ts+10072, __ccgo_ts+10011, int32(69))
	}
	_ = arch
	ix = d
	for {
		if !(ix < len1) {
			break
		}
		in_ptr = in + uintptr(ix-int32(1))*2
		out32_Q12 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(B)))
		/* Allowing wrap around so that two wraps can cancel each other. The rare
		   cases where the result wraps around can only be triggered by invalid streams*/
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 1*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(2))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 2*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(3))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 3*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(4))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 4*2)))))
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-libc.Int32FromInt32(5))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + 5*2)))))
		j = int32(6)
		for {
			if !(j < d) {
				break
			}
			out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-j)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + uintptr(j)*2)))))
			out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(out32_Q12) + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + uintptr(-j-int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(B + uintptr(j+int32(1))*2)))))
			goto _2
		_2:
			;
			j = j + int32(2)
		}
		/* Subtract prediction */
		out32_Q12 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_ptr + 1*2))))<<libc.Int32FromInt32(12))) - libc.Uint32FromInt32(out32_Q12))
		/* Scale to Q0 */
		out32 = (out32_Q12>>(libc.Int32FromInt32(12)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		/* Saturate output */
		if out32 > int32(silk_int16_MAX19) {
			v3 = int32(silk_int16_MAX19)
		} else {
			if out32 < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = out32
			}
			v3 = v4
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(ix)*2)) = int16(v3)
		goto _1
	_1:
		;
		ix = ix + 1
	}
	/* Set first d output samples to zero */
	libc.Xmemset(tls, out, 0, libc.Uint64FromInt32(d)*libc.Uint64FromInt64(2))
}

const MAX_PREDICTION_POWER_GAIN1 = 10000
const QA = 24
const silk_int16_MAX20 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/******************/
/* Error messages */
/******************/

/**************************/
/* Encoder error messages */
/**************************/

/* Input length is not a multiple of 10 ms, or length is longer than the packet length */

/* Sampling frequency not 8000, 12000 or 16000 Hertz */

/* Packet size not 10, 20, 40, or 60 ms */

/* Allocated payload buffer too short */

/* Loss rate not between 0 and 100 percent */

/* Complexity setting not valid, use 0...10 */

/* Inband FEC setting not valid, use 0 or 1 */

/* DTX setting not valid, use 0 or 1 */

/* CBR setting not valid, use 0 or 1 */

/* Internal encoder error */

/* Internal encoder error */

/**************************/
/* Decoder error messages */
/**************************/

/* Output sampling frequency lower than internal decoded sampling frequency */

/* Payload size exceeded the maximum allowed 1024 bytes */

/* Payload has bit errors */

/* Payload has bit errors */

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Max number of encoder channels (1/2) */
/* Number of decoder channels (1/2) */

/* Limits on bitrate */

/* LBRR thresholds */

/* DTX settings */

/* VAD decision */

/* Maximum sampling frequency */

/* Signal types */

/* Conditional coding types */

/* Settings for stereo processing */

/* Range of pitch lag estimates */

/* Maximum number of subframes */

/* Number of samples per frame */

/* Milliseconds of lookahead for pitch analysis */

/* Order of LPC used in find pitch */

/* Length of LPC window used in find pitch */

/* Milliseconds of lookahead for noise shape analysis */

/* Maximum length of LPC window used in noise shape analysis */

/* dB level of lowest gain quantization level */
/* dB level of highest gain quantization level */
/* Number of gain quantization levels */
/* Max increase in gain quantization index */
/* Max decrease in gain quantization index */

/* Quantization offsets (multiples of 4) */

/* Maximum numbers of iterations used to stabilize an LPC vector */

/* Find Pred Coef defines */

/* LTP quantization settings */

/* Flag to use harmonic noise shaping */

/* Max LPC order of noise shaping filters */

/* Maximum number of delayed decision states */

/* Number of subframes for excitation entropy coding */

/* Number of rate levels, for entropy coding of excitation */

/* Maximum sum of pulses per shell coding frame */

/***************************/
/* Voice activity detector */
/***************************/

/* Sigmoid settings */

/* smoothing for SNR measurement */

/* Size of the piecewise linear cosine approximation table for the LSFs */

/******************/
/* NLSF quantizer */
/******************/

/* Transition filtering for mode switching */

/* BWE factors to apply after packet loss */

/* Defines for CN generation */

// C documentation
//
//	/* Compute inverse of LPC prediction gain, and                          */
//	/* test if LPC coefficients are stable (all poles within unit circle)   */

func Opus_silk_LPC_analysis_filter_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32, Order int32) {
	if !(Order <= length) {
		Opus_celt_fatal(tls, __ccgo_ts+11490, __ccgo_ts+11524, int32(218))
	}
	switch Order {
	case int32(6):
		silk_LPC_analysis_filter6_FLP(tls, r_LPC, PredCoef, s, length)
	case int32(8):
		silk_LPC_analysis_filter8_FLP(tls, r_LPC, PredCoef, s, length)
	case int32(10):
		silk_LPC_analysis_filter10_FLP(tls, r_LPC, PredCoef, s, length)
	case int32(12):
		silk_LPC_analysis_filter12_FLP(tls, r_LPC, PredCoef, s, length)
	case int32(16):
		silk_LPC_analysis_filter16_FLP(tls, r_LPC, PredCoef, s, length)
	default:
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+11524, int32(242))
		}
		break
	}
	/* Set first Order output samples to zero */
	libc.Xmemset(tls, r_LPC, 0, libc.Uint64FromInt32(Order)*libc.Uint64FromInt64(4))
}

func Opus_silk_LPC_fit(tls *libc.TLS, a_QOUT uintptr, a_QIN uintptr, QOUT int32, QIN int32, d int32) {
	var absval, chirp_Q16, maxabs OpusT_opus_int32
	var i, idx, k, v3, v4, v5, v7, v8 int32
	_, _, _, _, _, _, _, _, _, _, _ = absval, chirp_Q16, i, idx, k, maxabs, v3, v4, v5, v7, v8
	idx = 0
	/* Limit the maximum absolute value of the prediction coefficients, so that they'll fit in int16 */
	i = 0
	for {
		if !(i < int32(10)) {
			break
		}
		/* Find maximum absolute value and its index */
		maxabs = 0
		k = 0
		for {
			if !(k < d) {
				break
			}
			if *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4)) > 0 {
				v3 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))
			} else {
				v3 = -*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))
			}
			absval = v3
			if absval > maxabs {
				maxabs = absval
				idx = k
			}
			goto _2
		_2:
			;
			k = k + 1
		}
		if QIN-QOUT == int32(1) {
			v3 = maxabs>>libc.Int32FromInt32(1) + maxabs&int32(1)
		} else {
			v3 = (maxabs>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		}
		maxabs = v3
		if maxabs > int32(silk_int16_MAX27) {
			/* Reduce magnitude of prediction coefficients */
			if maxabs < int32(163838) {
				v3 = maxabs
			} else {
				v3 = int32(163838)
			}
			maxabs = v3 /* ( silk_int32_MAX >> 14 ) + silk_int16_MAX = 163838 */
			chirp_Q16 = int32(float64(libc.Float64FromFloat64(0.999)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)) - libc.Int32FromUint32(libc.Uint32FromInt32(maxabs-libc.Int32FromInt32(silk_int16_MAX27))<<libc.Int32FromInt32(14))/(maxabs*(idx+libc.Int32FromInt32(1))>>libc.Int32FromInt32(2))
			Opus_silk_bwexpander_32(tls, a_QIN, d, chirp_Q16)
		} else {
			break
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if i == int32(10) {
		/* Reached the last iteration, clip the coefficients */
		k = 0
		for {
			if !(k < d) {
				break
			}
			if QIN-QOUT == int32(1) {
				v4 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
			} else {
				v4 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			if v4 > int32(silk_int16_MAX27) {
				v3 = int32(silk_int16_MAX27)
			} else {
				if QIN-QOUT == int32(1) {
					v7 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
				} else {
					v7 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				if v7 < int32(libc.Int16FromInt32(0x8000)) {
					v5 = int32(libc.Int16FromInt32(0x8000))
				} else {
					if QIN-QOUT == int32(1) {
						v8 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
					} else {
						v8 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v5 = v8
				}
				v3 = v5
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)) = int16(v3)
			*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)))) << (QIN - QOUT))
			goto _6
		_6:
			;
			k = k + 1
		}
	} else {
		k = 0
		for {
			if !(k < d) {
				break
			}
			if QIN-QOUT == int32(1) {
				v3 = *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>libc.Int32FromInt32(1) + *(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))&int32(1)
			} else {
				v3 = (*(*OpusT_opus_int32)(unsafe.Pointer(a_QIN + uintptr(k)*4))>>(QIN-QOUT-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_QOUT + uintptr(k)*2)) = int16(v3)
			goto _12
		_12:
			;
			k = k + 1
		}
	}
}

const CELT_SIG_SCALE17 = 32768
const PI2 = 3.1415926536

// C documentation
//
//	/* Apply sine window to signal vector   */
//	/* Window types:                        */
//	/*  1 -> sine window from 0 to pi/2     */
//	/*  2 -> sine window from pi/2 to pi    */

func Opus_silk_LPC_inverse_pred_gain_FLP(tls *libc.TLS, A uintptr, order OpusT_opus_int32) (r float32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var invGain, rc, rc_mult1, rc_mult2, tmp1, tmp2 float64
	var k, n int32
	var _ /* Atmp at bp+0 */ [24]float32
	_, _, _, _, _, _, _, _ = invGain, k, n, rc, rc_mult1, rc_mult2, tmp1, tmp2
	libc.Xmemcpy(tls, bp, A, libc.Uint64FromInt32(order)*libc.Uint64FromInt64(4))
	invGain = float64(1)
	k = order - int32(1)
	for {
		if !(k > 0) {
			break
		}
		rc = float64(-(*(*[24]float32)(unsafe.Pointer(bp)))[k])
		rc_mult1 = libc.Float64FromFloat32(1) - float64(rc*rc)
		invGain = invGain * rc_mult1
		if float64(invGain*libc.Float64FromFloat32(10000)) < libc.Float64FromFloat32(1) {
			return libc.Float32FromFloat32(0)
		}
		rc_mult2 = libc.Float64FromFloat32(1) / rc_mult1
		n = 0
		for {
			if !(n < (k+int32(1))>>int32(1)) {
				break
			}
			tmp1 = float64((*(*[24]float32)(unsafe.Pointer(bp)))[n])
			tmp2 = float64((*(*[24]float32)(unsafe.Pointer(bp)))[k-n-int32(1)])
			(*(*[24]float32)(unsafe.Pointer(bp)))[n] = float32(float64((tmp1 - float64(tmp2*rc)) * rc_mult2))
			(*(*[24]float32)(unsafe.Pointer(bp)))[k-n-int32(1)] = float32(float64((tmp2 - float64(tmp1*rc)) * rc_mult2))
			goto _2
		_2:
			;
			n = n + 1
		}
		goto _1
	_1:
		;
		k = k - 1
	}
	rc = float64(-(*(*[24]float32)(unsafe.Pointer(bp)))[0])
	rc_mult1 = libc.Float64FromFloat32(1) - float64(rc*rc)
	invGain = invGain * rc_mult1
	if float64(invGain*libc.Float64FromFloat32(10000)) < libc.Float64FromFloat32(1) {
		return libc.Float32FromFloat32(0)
	}
	return float32(invGain)
}

const MAX_PREDICTION_POWER_GAIN6 = "1e4f"
const PE_FLATCONTOUR_BIAS1 = 0.05
const PE_PREVLAG_BIAS1 = 0.2
const PE_SHORTLAG_BIAS1 = 0.2
const SCRATCH_SIZE = 22

var trim_icdf22 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf22 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf22 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

// C documentation
//
//	/************************************************************/
//	/* CORE PITCH ANALYSIS FUNCTION                             */
//	/************************************************************/

func Opus_silk_LPC_inverse_pred_gain_c(tls *libc.TLS, A_Q12 uintptr, order int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var DC_resp OpusT_opus_int32
	var k int32
	var _ /* Atmp_QA at bp+0 */ [24]OpusT_opus_int32
	_, _ = DC_resp, k
	DC_resp = 0
	/* Increase Q domain of the AR coefficients */
	k = 0
	for {
		if !(k < order) {
			break
		}
		DC_resp = DC_resp + int32(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q12 + uintptr(k)*2)))
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp)))[k] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q12 + uintptr(k)*2)))) << (libc.Int32FromInt32(QA) - libc.Int32FromInt32(12)))
		goto _1
	_1:
		;
		k = k + 1
	}
	/* If the DC is unstable, we don't even need to do the full calculations */
	if DC_resp >= int32(4096) {
		return 0
	}
	return LPC_inverse_pred_gain_QA_c(tls, bp, order)
}

const MAX_PREDICTION_POWER_GAIN2 = "1e4f"
const QA1 = 16

// C documentation
//
//	/* helper function for NLSF2A(..) */

func Opus_silk_LP_variable_cutoff(tls *libc.TLS, psLP uintptr, frame uintptr, frame_length int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var fac_Q16 OpusT_opus_int32
	var ind, v1, v2 int32
	var _ /* A_Q28 at bp+16 */ [2]OpusT_opus_int32
	var _ /* B_Q28 at bp+0 */ [3]OpusT_opus_int32
	_, _, _, _ = fac_Q16, ind, v1, v2
	fac_Q16 = 0
	ind = 0
	_ = (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no >= 0 && (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no <= libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR))
	/* Run filter if needed */
	if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode != 0 {
		/* Calculate index and interpolation factor for interpolation */
		fac_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR))-(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no) << (libc.Int32FromInt32(16) - libc.Int32FromInt32(6)))
		ind = fac_Q16 >> libc.Int32FromInt32(16)
		fac_Q16 = fac_Q16 - libc.Int32FromUint32(libc.Uint32FromInt32(ind)<<libc.Int32FromInt32(16))
		_ = ind >= libc.Int32FromInt32(0)
		_ = ind < libc.Int32FromInt32(TRANSITION_INT_NUM)
		/* Interpolate filter coefficients */
		silk_LP_interpolate_filter_taps(tls, bp, bp+16, ind, fac_Q16)
		/* Update transition frame number for next frame */
		if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no+(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode > libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)) {
			v1 = libc.Int32FromInt32(TRANSITION_TIME_MS) / (libc.Int32FromInt32(SUB_FRAME_LENGTH_MS) * libc.Int32FromInt32(MAX_NB_SUBFR))
		} else {
			if (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no+(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode < 0 {
				v2 = 0
			} else {
				v2 = (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no + (*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Fmode
			}
			v1 = v2
		}
		(*OpusT_silk_LP_state)(unsafe.Pointer(psLP)).Ftransition_frame_no = v1
		/* ARMA low-pass filtering */
		_ = libc.Bool(true) && libc.Bool(true)
		Opus_silk_biquad_alt_stride1(tls, frame, bp, bp+16, psLP, frame, frame_length)
	}
}

const silk_int16_MAX8 = 0x7FFF

// C documentation
//
//	/* Predictive dequantizer for NLSF residuals */

func Opus_silk_LTP_analysis_filter_FLP(tls *libc.TLS, LTP_res uintptr, x uintptr, B uintptr, pitchL uintptr, invGains uintptr, subfr_length int32, nb_subfr int32, pre_length int32) {
	var Btmp [5]float32
	var LTP_res_ptr, x_lag_ptr, x_ptr uintptr
	var i, j, k int32
	var inv_gain float32
	_, _, _, _, _, _, _, _ = Btmp, LTP_res_ptr, i, inv_gain, j, k, x_lag_ptr, x_ptr
	x_ptr = x
	LTP_res_ptr = LTP_res
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		x_lag_ptr = x_ptr - uintptr(*(*int32)(unsafe.Pointer(pitchL + uintptr(k)*4)))*4
		inv_gain = *(*float32)(unsafe.Pointer(invGains + uintptr(k)*4))
		i = 0
		for {
			if !(i < int32(LTP_ORDER)) {
				break
			}
			Btmp[i] = *(*float32)(unsafe.Pointer(B + uintptr(k*int32(LTP_ORDER)+i)*4))
			goto _2
		_2:
			;
			i = i + 1
		}
		/* LTP analysis FIR filter */
		i = 0
		for {
			if !(i < subfr_length+pre_length) {
				break
			}
			*(*float32)(unsafe.Pointer(LTP_res_ptr + uintptr(i)*4)) = *(*float32)(unsafe.Pointer(x_ptr + uintptr(i)*4))
			/* Subtract long-term prediction */
			j = 0
			for {
				if !(j < int32(LTP_ORDER)) {
					break
				}
				*(*float32)(unsafe.Pointer(LTP_res_ptr + uintptr(i)*4)) -= float32(Btmp[j] * *(*float32)(unsafe.Pointer(x_lag_ptr + uintptr(libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)-j)*4)))
				goto _4
			_4:
				;
				j = j + 1
			}
			*(*float32)(unsafe.Pointer(LTP_res_ptr + uintptr(i)*4)) *= inv_gain
			x_lag_ptr += 4
			goto _3
		_3:
			;
			i = i + 1
		}
		/* Update pointers */
		LTP_res_ptr = LTP_res_ptr + uintptr(subfr_length+pre_length)*4
		x_ptr = x_ptr + uintptr(subfr_length)*4
		goto _1
	_1:
		;
		k = k + 1
	}
}

func Opus_silk_LTP_scale_ctrl_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, condCoding int32) {
	var round_loss int32
	var v1 uintptr
	_, _ = round_loss, v1
	if condCoding == CODE_INDEPENDENTLY {
		/* Only scale if first frame in packet */
		round_loss = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FPacketLoss_perc * (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesPerPacket
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FLBRR_flag != 0 {
			/* LBRR reduces the effective loss. In practice, it does not square the loss because
			   losses aren't independent, but that still seems to work best. We also never go below 2%. */
			round_loss = int32(2) + int32(int16(round_loss))*int32(int16(round_loss))/int32(100)
		}
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FLTP_scaleIndex = libc.BoolInt8(int32(int16((*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain))*int32(int16(round_loss)) > Opus_silk_log2lin(tls, int32(2900)-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FSNR_dB_Q7))
		v1 = psEnc + 4752 + 33
		*(*OpusT_opus_int8)(unsafe.Pointer(v1)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v1))) + libc.BoolInt32(int32(int16((*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain))*int32(int16(round_loss)) > Opus_silk_log2lin(tls, int32(3900)-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FSNR_dB_Q7)))
	} else {
		/* Default is minimum scaling */
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FLTP_scaleIndex = 0
	}
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTP_scale = float32(Opus_silk_LTPScales_table_Q14[(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FLTP_scaleIndex]) / libc.Float32FromFloat32(16384)
}

const BANDWIDTH_EXPANSION1 = 0.94
const BG_SNR_DECR_dB1 = 2
const ENERGY_VARIATION_THRESHOLD_QNT_OFFSET1 = 0.6
const FIND_PITCH_BANDWIDTH_EXPANSION2 = "0.99f"
const HARMONIC_SHAPING1 = 0.3
const HARM_HP_NOISE_COEF1 = 0.35
const HARM_SNR_INCR_dB1 = 2
const HIGH_RATE_OR_LOW_QUALITY_HARMONIC_SHAPING1 = 0.2
const HP_NOISE_COEF1 = 0.25
const LOW_FREQ_SHAPING1 = 4
const LOW_QUALITY_LOW_FREQ_SHAPING_DECR1 = 0.5
const SHAPE_WHITE_NOISE_FRACTION1 = 3e-05
const SUBFR_SMTH_COEF1 = 0.4

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* Compute gain to make warped filter coefficients have a zero mean log frequency response on a   */
//	/* non-warped frequency scale. (So that it can be implemented with a minimum-phase monic filter.) */
//	/* Note: A monic filter is one with the first coefficient equal to 1.0. In Silk we omit the first */
//	/* coefficient in an array of coefficients, for monic filters.                                    */

func Opus_silk_LoadOSCEModels(tls *libc.TLS, decState uintptr, data uintptr, len1 int32) (r int32) {
	_ = decState
	_ = data
	_ = len1
	return SILK_NO_ERROR
}

func Opus_silk_NLSF2A(tls *libc.TLS, a_Q12 uintptr, NLSF uintptr, d int32, arch int32) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var Ptmp, Qtmp, cos_val, delta, f_frac, f_int OpusT_opus_int32
	var dd, i, k int32
	var ordering, v1 uintptr
	var _ /* P at bp+96 */ [13]OpusT_opus_int32
	var _ /* Q at bp+148 */ [13]OpusT_opus_int32
	var _ /* a32_QA1 at bp+200 */ [24]OpusT_opus_int32
	var _ /* cos_LSF_QA at bp+0 */ [24]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = Ptmp, Qtmp, cos_val, dd, delta, f_frac, f_int, i, k, ordering, v1
	_ = true
	if !(d == int32(10) || d == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+10099, __ccgo_ts+10132, int32(89))
	}
	/* convert LSFs to 2*cos(LSF), using piecewise linear curve from table */
	if d == int32(16) {
		v1 = uintptr(unsafe.Pointer(&ordering16))
	} else {
		v1 = uintptr(unsafe.Pointer(&ordering10))
	}
	ordering = v1
	k = 0
	for {
		if !(k < d) {
			break
		}
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) >= libc.Int32FromInt32(0)
		/* f_int on a scale 0-127 (rounded down) */
		f_int = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) >> (libc.Int32FromInt32(15) - libc.Int32FromInt32(7))
		/* f_frac, range: 0..255 */
		f_frac = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF + uintptr(k)*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(f_int)<<(libc.Int32FromInt32(15)-libc.Int32FromInt32(7)))
		_ = f_int >= libc.Int32FromInt32(0)
		_ = f_int < libc.Int32FromInt32(LSF_COS_TAB_SZ_FIX)
		/* Read start and end value from table */
		cos_val = int32(Opus_silk_LSFCosTab_FIX_Q12[f_int])                  /* Q12 */
		delta = int32(Opus_silk_LSFCosTab_FIX_Q12[f_int+int32(1)]) - cos_val /* Q12, with a range of 0..200 */
		/* Linear interpolation */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp)))[*(*uint8)(unsafe.Pointer(ordering + uintptr(k)))] = ((libc.Int32FromUint32(libc.Uint32FromInt32(cos_val)<<libc.Int32FromInt32(8))+delta*f_frac)>>(libc.Int32FromInt32(20)-libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1) /* QA */
		goto _2
	_2:
		;
		k = k + 1
	}
	dd = d >> libc.Int32FromInt32(1)
	/* generate even and odd polynomials using convolution */
	silk_NLSF2A_find_poly(tls, bp+96, bp, dd)
	silk_NLSF2A_find_poly(tls, bp+148, bp+1*4, dd)
	/* convert even and odd polynomials to opus_int32 Q12 filter coefs */
	k = 0
	for {
		if !(k < dd) {
			break
		}
		Ptmp = (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 96)))[k+int32(1)] + (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 96)))[k]
		Qtmp = (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 148)))[k+int32(1)] - (*(*[13]OpusT_opus_int32)(unsafe.Pointer(bp + 148)))[k]
		/* the Ptmp and Qtmp values at this stage need to fit in int32 */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[k] = -Qtmp - Ptmp           /* QA+1 */
		(*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[d-k-int32(1)] = Qtmp - Ptmp /* QA+1 */
		goto _3
	_3:
		;
		k = k + 1
	}
	/* Convert int32 coefficients to Q12 int16 coefs */
	Opus_silk_LPC_fit(tls, a_Q12, bp+200, int32(12), libc.Int32FromInt32(QA1)+libc.Int32FromInt32(1), d)
	i = 0
	for {
		_ = arch
		if !(Opus_silk_LPC_inverse_pred_gain_c(tls, a_Q12, d) == 0 && i < int32(MAX_LPC_STABILIZE_ITERATIONS)) {
			break
		}
		/* Prediction coefficients are (too close to) unstable; apply bandwidth expansion   */
		/* on the unscaled coefficients, convert to Q12 and measure again                   */
		Opus_silk_bwexpander_32(tls, bp+200, d, int32(65536)-libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(2))<<i))
		k = 0
		for {
			if !(k < d) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a_Q12 + uintptr(k)*2)) = int16(((*(*[24]OpusT_opus_int32)(unsafe.Pointer(bp + 200)))[k]>>(libc.Int32FromInt32(QA1)+libc.Int32FromInt32(1)-libc.Int32FromInt32(12)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)) /* QA+1 -> Q12 */
			goto _5
		_5:
			;
			k = k + 1
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

/*
This ordering was found to maximize quality. It improves numerical accuracy of

	silk_NLSF2A_find_poly() compared to "standard" ordering.
*/
var ordering16 = [16]uint8{
	1:  uint8(15),
	2:  uint8(8),
	3:  uint8(7),
	4:  uint8(4),
	5:  uint8(11),
	6:  uint8(12),
	7:  uint8(3),
	8:  uint8(2),
	9:  uint8(13),
	10: uint8(10),
	11: uint8(5),
	12: uint8(6),
	13: uint8(9),
	14: uint8(14),
	15: uint8(1),
}

var ordering10 = [10]uint8{
	1: uint8(9),
	2: uint8(6),
	3: uint8(3),
	4: uint8(4),
	5: uint8(5),
	6: uint8(8),
	7: uint8(1),
	8: uint8(2),
	9: uint8(7),
}

const MAX_LOOPS = 20
const silk_int16_MAX21 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/* Constant Definitions */

// C documentation
//
//	/* NLSF stabilizer, for a single input data vector */

func Opus_silk_NLSF2A_FLP(tls *libc.TLS, pAR uintptr, NLSF_Q15 uintptr, LPC_order int32, arch int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	var _ /* a_fix_Q12 at bp+0 */ [16]OpusT_opus_int16
	_ = i
	Opus_silk_NLSF2A(tls, bp, NLSF_Q15, LPC_order, arch)
	i = 0
	for {
		if !(i < LPC_order) {
			break
		}
		*(*float32)(unsafe.Pointer(pAR + uintptr(i)*4)) = float32(float32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(4096)))
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/******************************************/
//	/* Floating-point NLSF processing wrapper */
//	/******************************************/

func Opus_silk_NLSF_VQ(tls *libc.TLS, err_Q24 uintptr, in_Q15 uintptr, pCB_Q8 uintptr, pWght_Q9 uintptr, K int32, LPC_order int32) {
	var cb_Q8_ptr, w_Q9_ptr uintptr
	var diff_Q15, diffw_Q24, pred_Q24, sum_error_Q24 OpusT_opus_int32
	var i, m, v3 int32
	_, _, _, _, _, _, _, _, _ = cb_Q8_ptr, diff_Q15, diffw_Q24, i, m, pred_Q24, sum_error_Q24, w_Q9_ptr, v3
	if !(LPC_order&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+8917, __ccgo_ts+8958, int32(49))
	}
	/* Loop over codebook */
	cb_Q8_ptr = pCB_Q8
	w_Q9_ptr = pWght_Q9
	i = 0
	for {
		if !(i < K) {
			break
		}
		sum_error_Q24 = 0
		pred_Q24 = 0
		m = LPC_order - int32(2)
		for {
			if !(m >= 0) {
				break
			}
			/* Compute weighted absolute predictive quantization error for index m + 1 */
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_Q15 + uintptr(m+int32(1))*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(cb_Q8_ptr + uintptr(m+int32(1))))))<<libc.Int32FromInt32(7)) /* range: [ -32767 : 32767 ]*/
			diffw_Q24 = int32(int16(diff_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q9_ptr + uintptr(m+int32(1))*2)))
			if diffw_Q24-pred_Q24>>libc.Int32FromInt32(1) > 0 {
				v3 = diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1)
			} else {
				v3 = -(diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1))
			}
			sum_error_Q24 = sum_error_Q24 + v3
			pred_Q24 = diffw_Q24
			/* Compute weighted absolute predictive quantization error for index m */
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in_Q15 + uintptr(m)*2))) - libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(cb_Q8_ptr + uintptr(m)))))<<libc.Int32FromInt32(7)) /* range: [ -32767 : 32767 ]*/
			diffw_Q24 = int32(int16(diff_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q9_ptr + uintptr(m)*2)))
			if diffw_Q24-pred_Q24>>libc.Int32FromInt32(1) > 0 {
				v3 = diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1)
			} else {
				v3 = -(diffw_Q24 - pred_Q24>>libc.Int32FromInt32(1))
			}
			sum_error_Q24 = sum_error_Q24 + v3
			pred_Q24 = diffw_Q24
			_ = sum_error_Q24 >= libc.Int32FromInt32(0)
			goto _2
		_2:
			;
			m = m - int32(2)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(err_Q24 + uintptr(i)*4)) = sum_error_Q24
		cb_Q8_ptr = cb_Q8_ptr + uintptr(LPC_order)
		w_Q9_ptr = w_Q9_ptr + uintptr(LPC_order)*2
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Unpack predictor values and indices for entropy coding tables */

func Opus_silk_NLSF_VQ_weights_laroia(tls *libc.TLS, pNLSFW_Q_OUT uintptr, pNLSF_Q15 uintptr, D int32) {
	var k, v1, v2, v3, v5 int32
	var tmp1_int, tmp2_int OpusT_opus_int32
	_, _, _, _, _, _, _ = k, tmp1_int, tmp2_int, v1, v2, v3, v5
	if !(D > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10149, __ccgo_ts+10173, int32(51))
	}
	if !(D&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10206, __ccgo_ts+10173, int32(52))
	}
	/* First value */
	v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _4
_4:
	tmp1_int = v3
	tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
	v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + 1*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _9
_9:
	tmp2_int = v3
	tmp2_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp2_int
	v1 = tmp1_int + tmp2_int
	v2 = int32(silk_int16_MAX21)
	if v1 < v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _14
_14:
	*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT)) = int16(v3)
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT))) > libc.Int32FromInt32(0)
	/* Main loop */
	k = int32(1)
	for {
		if !(k < D-int32(1)) {
			break
		}
		v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k)*2)))
		v2 = int32(1)
		if v1 > v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _20
	_20:
		tmp1_int = v3
		tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
		v1 = tmp1_int + tmp2_int
		v2 = int32(silk_int16_MAX21)
		if v1 < v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _25
	_25:
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k)*2)) = int16(v3)
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k)*2))) > libc.Int32FromInt32(0)
		v1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(2))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(k+int32(1))*2)))
		v2 = int32(1)
		if v1 > v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _30
	_30:
		tmp2_int = v3
		tmp2_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp2_int
		v1 = tmp1_int + tmp2_int
		v2 = int32(silk_int16_MAX21)
		if v1 < v2 {
			v5 = v1
		} else {
			v5 = v2
		}
		v3 = v5
		goto _35
	_35:
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k+int32(1))*2)) = int16(v3)
		_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(k+int32(1))*2))) > libc.Int32FromInt32(0)
		goto _16
	_16:
		;
		k = k + int32(2)
	}
	/* Last value */
	v1 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(D-int32(1))*2)))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _40
_40:
	tmp1_int = v3
	tmp1_int = libc.Int32FromInt32(1) << (libc.Int32FromInt32(15) + libc.Int32FromInt32(NLSF_W_Q)) / tmp1_int
	v1 = tmp1_int + tmp2_int
	v2 = int32(silk_int16_MAX21)
	if v1 < v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _45
_45:
	*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(D-int32(1))*2)) = int16(v3)
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSFW_Q_OUT + uintptr(D-int32(1))*2))) > libc.Int32FromInt32(0)
}

const silk_int16_MAX22 = 0x7FFF
const RESAMPLER_DOWN_ORDER_FIR0 = 18
const RESAMPLER_DOWN_ORDER_FIR1 = 24
const RESAMPLER_DOWN_ORDER_FIR2 = 36
const RESAMPLER_MAX_BATCH_SIZE_MS = 10
const RESAMPLER_MAX_FS_KHZ = 48
const RESAMPLER_ORDER_FIR_12 = 8
const USE_silk_resampler_copy = 0
const USE_silk_resampler_private_IIR_FIR = 2
const USE_silk_resampler_private_down_FIR = 3
const USE_silk_resampler_private_up2_HQ_wrapper = 1

var silk_resampler_down2_0 = int16(9872)
var silk_resampler_down2_1 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_0 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_1 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Tables with delay compensation values to equalize total delay for different modes */
var delay_matrix_enc = [6][3]OpusT_opus_int8{
	0: {
		0: int8(6),
		2: int8(3),
	},
	1: {
		1: int8(7),
		2: int8(3),
	},
	2: {
		1: int8(1),
		2: int8(10),
	},
	3: {
		1: int8(2),
		2: int8(6),
	},
	4: {
		0: int8(18),
		1: int8(10),
		2: int8(12),
	},
	5: {
		2: int8(44),
	},
}

var delay_matrix_dec = [3][6]OpusT_opus_int8{
	0: {
		0: int8(4),
		2: int8(2),
	},
	1: {
		1: int8(9),
		2: int8(4),
		3: int8(7),
		4: int8(4),
		5: int8(4),
	},
	2: {
		1: int8(3),
		2: int8(12),
		3: int8(7),
		4: int8(7),
		5: int8(7),
	},
}

/* Simple way to make [8000, 12000, 16000, 24000, 48000] to [0, 1, 2, 3, 4] */

// C documentation
//
//	/* Initialize/reset the resampler state for a given pair of input/output sampling rates */

func Opus_silk_NLSF_decode(tls *libc.TLS, pNLSF_Q15 uintptr, NLSFIndices uintptr, psNLSF_CB uintptr) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var NLSF_Q15_tmp OpusT_opus_int32
	var i, v2, v3 int32
	var pCB_Wght_Q9, pCB_element uintptr
	var _ /* ec_ix at bp+16 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+0 */ [16]OpusT_opus_uint8
	var _ /* res_Q10 at bp+48 */ [16]OpusT_opus_int16
	_, _, _, _, _, _ = NLSF_Q15_tmp, i, pCB_Wght_Q9, pCB_element, v2, v3
	/* Unpack entropy table indices and predictor for current CB1 index */
	Opus_silk_NLSF_unpack(tls, bp+16, bp, psNLSF_CB, int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices))))
	/* Predictive residual dequantizer */
	silk_NLSF_residual_dequant(tls, bp+48, NLSFIndices+1, bp, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FquantStepSize_Q16), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)
	/* Apply inverse square-rooted weights to first stage and add to output */
	pCB_element = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_NLSF_Q8 + uintptr(int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices)))*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
	pCB_Wght_Q9 = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_Wght_Q9 + uintptr(int32(*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices)))*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))*2
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)) {
			break
		}
		NLSF_Q15_tmp = libc.Int32FromUint32(libc.Uint32FromInt32(int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 48)))[i]))<<libc.Int32FromInt32(14))/int32(*(*OpusT_opus_int16)(unsafe.Pointer(pCB_Wght_Q9 + uintptr(i)*2))) + libc.Int32FromUint32(libc.Uint32FromInt16(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pCB_element + uintptr(i)))))<<libc.Int32FromInt32(7))
		if NLSF_Q15_tmp > int32(32767) {
			v2 = int32(32767)
		} else {
			if NLSF_Q15_tmp < 0 {
				v3 = 0
			} else {
				v3 = NLSF_Q15_tmp
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(i)*2)) = int16(v2)
		goto _1
	_1:
		;
		i = i + 1
	}
	/* NLSF stabilization */
	Opus_silk_NLSF_stabilize(tls, pNLSF_Q15, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FdeltaMin_Q15, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
}

const silk_int16_MAX9 = 32767

func Opus_silk_NLSF_del_dec_quant(tls *libc.TLS, indices uintptr, x_Q10 uintptr, w_Q5 uintptr, pred_coef_Q8 uintptr, ec_ix uintptr, ec_rates_Q5 uintptr, quant_step_size_Q16 int32, inv_quant_step_size_Q6 OpusT_opus_int16, mu_Q20 OpusT_opus_int32, order OpusT_opus_int16) (r OpusT_opus_int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var RD_Q25 [8]OpusT_opus_int32
	var RD_max_Q25, RD_min_Q25 [4]OpusT_opus_int32
	var RD_tmp_Q25, max_min_Q25, min_Q25, min_max_Q25 OpusT_opus_int32
	var diff_Q10, i, in_Q10, ind_max_min, ind_min_max, ind_tmp, j, nStates, pred_Q10, rate0_Q5, rate1_Q5, res_Q10, v4, v5 int32
	var ind_sort [4]int32
	var out0_Q10, out1_Q10 OpusT_opus_int16
	var out0_Q10_table, out1_Q10_table [20]int32
	var prev_out_Q10 [8]OpusT_opus_int16
	var rates_Q5, v11 uintptr
	var _ /* ind at bp+0 */ [4][16]OpusT_opus_int8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = RD_Q25, RD_max_Q25, RD_min_Q25, RD_tmp_Q25, diff_Q10, i, in_Q10, ind_max_min, ind_min_max, ind_sort, ind_tmp, j, max_min_Q25, min_Q25, min_max_Q25, nStates, out0_Q10, out0_Q10_table, out1_Q10, out1_Q10_table, pred_Q10, prev_out_Q10, rate0_Q5, rate1_Q5, rates_Q5, res_Q10, v11, v4, v5
	i = -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
	for {
		if !(i <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)-libc.Int32FromInt32(1)) {
			break
		}
		out0_Q10 = int16(libc.Int32FromUint32(libc.Uint32FromInt32(i) << libc.Int32FromInt32(10)))
		out1_Q10 = int16(int32(out0_Q10) + libc.Int32FromInt32(1024))
		if i > 0 {
			out0_Q10 = int16(int32(out0_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
			out1_Q10 = int16(int32(out1_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
		} else {
			if i == 0 {
				out1_Q10 = int16(int32(out1_Q10) - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
			} else {
				if i == -int32(1) {
					out0_Q10 = int16(int32(out0_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
				} else {
					out0_Q10 = int16(int32(out0_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
					out1_Q10 = int16(int32(out1_Q10) + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5)))
				}
			}
		}
		out0_Q10_table[i+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)] = int32(out0_Q10) * int32(int16(quant_step_size_Q16)) >> int32(16)
		out1_Q10_table[i+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)] = int32(out1_Q10) * int32(int16(quant_step_size_Q16)) >> int32(16)
		goto _1
	_1:
		;
		i = i + 1
	}
	_ = libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)&(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)-libc.Int32FromInt32(1)) == libc.Int32FromInt32(0) /* must be power of two */
	nStates = int32(1)
	RD_Q25[0] = 0
	prev_out_Q10[0] = 0
	i = int32(order) - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		rates_Q5 = ec_rates_Q5 + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i)*2)))
		in_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x_Q10 + uintptr(i)*2)))
		j = 0
		for {
			if !(j < nStates) {
				break
			}
			pred_Q10 = int32(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pred_coef_Q8 + uintptr(i))))) * int32(prev_out_Q10[j]) >> int32(8)
			res_Q10 = in_Q10 - pred_Q10
			ind_tmp = int32(inv_quant_step_size_Q6) * int32(int16(res_Q10)) >> int32(16)
			if ind_tmp > libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)-libc.Int32FromInt32(1) {
				v4 = libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT) - libc.Int32FromInt32(1)
			} else {
				if ind_tmp < -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT) {
					v5 = -int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
				} else {
					v5 = ind_tmp
				}
				v4 = v5
			}
			ind_tmp = v4
			*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i))) = int8(ind_tmp)
			/* compute outputs for ind_tmp and ind_tmp + 1 */
			out0_Q10 = int16(out0_Q10_table[ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)])
			out1_Q10 = int16(out1_Q10_table[ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE_EXT)])
			out0_Q10 = int16(int32(out0_Q10) + pred_Q10)
			out1_Q10 = int16(int32(out1_Q10) + pred_Q10)
			prev_out_Q10[j] = out0_Q10
			prev_out_Q10[j+nStates] = out1_Q10
			/* compute RD for ind_tmp and ind_tmp + 1 */
			if ind_tmp+int32(1) >= int32(NLSF_QUANT_MAX_AMPLITUDE) {
				if ind_tmp+int32(1) == int32(NLSF_QUANT_MAX_AMPLITUDE) {
					rate0_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					rate1_Q5 = int32(280)
				} else {
					rate0_Q5 = libc.Int32FromInt32(280) - libc.Int32FromInt32(43)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) + int32(int16(libc.Int32FromInt32(43)))*int32(int16(ind_tmp))
					rate1_Q5 = rate0_Q5 + int32(43)
				}
			} else {
				if ind_tmp <= -int32(NLSF_QUANT_MAX_AMPLITUDE) {
					if ind_tmp == -int32(NLSF_QUANT_MAX_AMPLITUDE) {
						rate0_Q5 = int32(280)
						rate1_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(1)+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					} else {
						rate0_Q5 = libc.Int32FromInt32(280) - libc.Int32FromInt32(43)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) + int32(int16(-libc.Int32FromInt32(43)))*int32(int16(ind_tmp))
						rate1_Q5 = rate0_Q5 - int32(43)
					}
				} else {
					rate0_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
					rate1_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(rates_Q5 + uintptr(ind_tmp+int32(1)+int32(NLSF_QUANT_MAX_AMPLITUDE)))))
				}
			}
			RD_tmp_Q25 = RD_Q25[j]
			diff_Q10 = in_Q10 - int32(out0_Q10)
			RD_Q25[j] = RD_tmp_Q25 + int32(int16(diff_Q10))*int32(int16(diff_Q10))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q5 + uintptr(i)*2))) + int32(int16(mu_Q20))*int32(int16(rate0_Q5))
			diff_Q10 = in_Q10 - int32(out1_Q10)
			RD_Q25[j+nStates] = RD_tmp_Q25 + int32(int16(diff_Q10))*int32(int16(diff_Q10))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(w_Q5 + uintptr(i)*2))) + int32(int16(mu_Q20))*int32(int16(rate1_Q5))
			goto _3
		_3:
			;
			j = j + 1
		}
		if nStates <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)/libc.Int32FromInt32(2) {
			/* double number of states and copy */
			j = 0
			for {
				if !(j < nStates) {
					break
				}
				*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j+nStates)*16 + uintptr(i))) = int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i)))) + int32(1))
				goto _6
			_6:
				;
				j = j + 1
			}
			nStates = libc.Int32FromUint32(libc.Uint32FromInt32(nStates) << libc.Int32FromInt32(1))
			j = nStates
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				*(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j)*16 + uintptr(i))) = *(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(j-nStates)*16 + uintptr(i)))
				goto _7
			_7:
				;
				j = j + 1
			}
		} else {
			/* sort lower and upper half of RD_Q25, pairwise */
			j = 0
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				if RD_Q25[j] > RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] {
					RD_max_Q25[j] = RD_Q25[j]
					RD_min_Q25[j] = RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					RD_Q25[j] = RD_min_Q25[j]
					RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] = RD_max_Q25[j]
					/* swap prev_out values */
					out0_Q10 = prev_out_Q10[j]
					prev_out_Q10[j] = prev_out_Q10[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					prev_out_Q10[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)] = out0_Q10
					ind_sort[j] = j + libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)
				} else {
					RD_min_Q25[j] = RD_Q25[j]
					RD_max_Q25[j] = RD_Q25[j+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
					ind_sort[j] = j
				}
				goto _8
			_8:
				;
				j = j + 1
			}
			/* compare the highest RD values of the winning half with the lowest one in the losing half, and copy if necessary */
			/* afterwards ind_sort[] will contain the indices of the NLSF_QUANT_DEL_DEC_STATES winning RD values */
			for int32(1) != 0 {
				min_max_Q25 = int32(silk_int32_MAX)
				max_min_Q25 = 0
				ind_min_max = 0
				ind_max_min = 0
				j = 0
				for {
					if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
						break
					}
					if min_max_Q25 > RD_max_Q25[j] {
						min_max_Q25 = RD_max_Q25[j]
						ind_min_max = j
					}
					if max_min_Q25 < RD_min_Q25[j] {
						max_min_Q25 = RD_min_Q25[j]
						ind_max_min = j
					}
					goto _9
				_9:
					;
					j = j + 1
				}
				if min_max_Q25 >= max_min_Q25 {
					break
				}
				/* copy ind_min_max to ind_max_min */
				ind_sort[ind_max_min] = ind_sort[ind_min_max] ^ libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)
				RD_Q25[ind_max_min] = RD_Q25[ind_min_max+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
				prev_out_Q10[ind_max_min] = prev_out_Q10[ind_min_max+libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)]
				RD_min_Q25[ind_max_min] = 0
				RD_max_Q25[ind_min_max] = int32(silk_int32_MAX)
				libc.Xmemcpy(tls, bp+uintptr(ind_max_min)*16, bp+uintptr(ind_min_max)*16, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(1))
			}
			/* increment index if it comes from the upper half */
			j = 0
			for {
				if !(j < libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)) {
					break
				}
				v11 = bp + uintptr(j)*16 + uintptr(i)
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + ind_sort[j]>>libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))
				goto _10
			_10:
				;
				j = j + 1
			}
		}
		goto _2
	_2:
		;
		i = i - 1
	}
	/* last sample: find winner, copy indices and return RD value */
	ind_tmp = 0
	min_Q25 = int32(silk_int32_MAX)
	j = 0
	for {
		if !(j < libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))) {
			break
		}
		if min_Q25 > RD_Q25[j] {
			min_Q25 = RD_Q25[j]
			ind_tmp = j
		}
		goto _12
	_12:
		;
		j = j + 1
	}
	j = 0
	for {
		if !(j < int32(order)) {
			break
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j))) = *(*OpusT_opus_int8)(unsafe.Pointer(bp + uintptr(ind_tmp&(libc.Int32FromInt32(1)<<libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2)-libc.Int32FromInt32(1)))*16 + uintptr(j)))
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j)))) >= -libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(j)))) <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
		goto _13
	_13:
		;
		j = j + 1
	}
	v11 = indices
	*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + ind_tmp>>libc.Int32FromInt32(NLSF_QUANT_DEL_DEC_STATES_LOG2))
	_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(indices))) <= libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE_EXT)
	_ = min_Q25 >= libc.Int32FromInt32(0)
	return min_Q25
}

// C documentation
//
//	/* Limit, stabilize, convert and quantize NLSFs */

func Opus_silk_NLSF_encode(tls *libc.TLS, NLSFIndices uintptr, pNLSF_Q15 uintptr, psNLSF_CB uintptr, pW_Q2 uintptr, NLSF_mu_Q20 int32, nSurvivors int32, signalType int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var NLSF_tmp_Q15 [16]OpusT_opus_int16
	var RD_Q25, _saved_stack, err_Q24, iCDF_ptr, pCB_Wght_Q9, pCB_element, st, tempIndices1, tempIndices2, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var W_tmp_Q9, a32_nrm, b32_inv, b32_nrm, result, ret, v103, v104, v107, v108, v112, v113, v116 OpusT_opus_int32
	var a_headrm, b_headrm, bits_q7, i, ind1, lshift, prob_Q8, s, v105, v106, v110, v111, v115, v118, v119, v120, v121, v122 int32
	var _ /* W_adj_Q5 at bp+36 */ [16]OpusT_opus_int16
	var _ /* bestIndex at bp+0 */ int32
	var _ /* ec_ix at bp+84 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+68 */ [16]OpusT_opus_uint8
	var _ /* res_Q10 at bp+4 */ [16]OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = NLSF_tmp_Q15, RD_Q25, W_tmp_Q9, _saved_stack, a32_nrm, a_headrm, b32_inv, b32_nrm, b_headrm, bits_q7, err_Q24, i, iCDF_ptr, ind1, lshift, pCB_Wght_Q9, pCB_element, prob_Q8, result, ret, s, st, tempIndices1, tempIndices2, v1, v103, v104, v105, v106, v107, v108, v11, v110, v111, v112, v113, v115, v116, v118, v119, v120, v121, v122, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(signalType >= 0 && signalType <= int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+8842, __ccgo_ts+8895, int32(63))
	}
	_ = NLSF_mu_Q20 <= int32(32767) && NLSF_mu_Q20 >= 0
	/* NLSF stabilization */
	Opus_silk_NLSF_stabilize(tls, pNLSF_Q15, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FdeltaMin_Q15, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
	/* First stage: VQ */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt16((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8895, int32(70))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt16((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	err_Q24 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt16((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_silk_NLSF_VQ(tls, err_Q24, pNLSF_Q15, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_NLSF_Q8, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_Wght_Q9, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors), int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
	/* Sort the quantization errors */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nSurvivors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8895, int32(74))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nSurvivors) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	tempIndices1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nSurvivors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_silk_insertion_sort_increasing(tls, err_Q24, tempIndices1, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors), nSurvivors)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nSurvivors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8895, int32(77))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nSurvivors) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	RD_Q25 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nSurvivors)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _80
_80:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _84
_84:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _88
_88:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _92
_92:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nSurvivors*libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8895, int32(78))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _96
_96:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nSurvivors*libc.Int32FromInt32(MAX_LPC_ORDER)) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _100
_100:
	tempIndices2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nSurvivors*libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
	/* Loop over survivors */
	s = 0
	for {
		if !(s < nSurvivors) {
			break
		}
		ind1 = *(*int32)(unsafe.Pointer(tempIndices1 + uintptr(s)*4))
		/* Residual after first stage */
		pCB_element = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_NLSF_Q8 + uintptr(ind1*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))
		pCB_Wght_Q9 = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_Wght_Q9 + uintptr(ind1*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder))*2
		i = 0
		for {
			if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)) {
				break
			}
			NLSF_tmp_Q15[i] = int16(libc.Int32FromUint16(libc.Uint16FromInt16(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pCB_element + uintptr(i)))))) << libc.Int32FromInt32(7))
			W_tmp_Q9 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pCB_Wght_Q9 + uintptr(i)*2)))
			(*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 4)))[i] = int16(int32(int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(pNLSF_Q15 + uintptr(i)*2)))-int32(NLSF_tmp_Q15[i]))) * int32(int16(W_tmp_Q9)) >> libc.Int32FromInt32(14))
			v103 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pW_Q2 + uintptr(i)*2)))
			v104 = int32(int16(W_tmp_Q9)) * int32(int16(W_tmp_Q9))
			v105 = int32(21)
			_ = v104 != libc.Int32FromInt32(0)
			_ = v105 >= libc.Int32FromInt32(0)
			if v103 > 0 {
				v106 = v103
			} else {
				v106 = -v103
			}
			v107 = v106
			if v107 != 0 {
				v110 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v107)))
			} else {
				v110 = int32(32)
			}
			v108 = v110
			goto _109
		_109:
			a_headrm = v108 - int32(1)
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v103) << a_headrm)
			if v104 > 0 {
				v111 = v104
			} else {
				v111 = -v104
			}
			v112 = v111
			if v112 != 0 {
				v115 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v112)))
			} else {
				v115 = int32(32)
			}
			v113 = v115
			goto _114
		_114:
			b_headrm = v113 - int32(1)
			b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v104) << b_headrm)
			b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
			result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
			result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
			lshift = int32(29) + a_headrm - b_headrm - v105
			if lshift < libc.Int32FromInt32(0) {
				if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
					if result > libc.Int32FromUint32(0x80000000)>>-lshift {
						v119 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						if result < int32(silk_int32_MAX)>>-lshift {
							v120 = int32(silk_int32_MAX) >> -lshift
						} else {
							v120 = result
						}
						v119 = v120
					}
					v118 = v119
				} else {
					if result > int32(silk_int32_MAX)>>-lshift {
						v121 = int32(silk_int32_MAX) >> -lshift
					} else {
						if result < libc.Int32FromUint32(0x80000000)>>-lshift {
							v122 = libc.Int32FromUint32(0x80000000) >> -lshift
						} else {
							v122 = result
						}
						v121 = v122
					}
					v118 = v121
				}
				v116 = libc.Int32FromUint32(libc.Uint32FromInt32(v118) << -lshift)
				goto _117
			} else {
				if lshift < libc.Int32FromInt32(32) {
					v116 = result >> lshift
					goto _117
				} else {
					v116 = 0
					goto _117
				}
			}
		_117:
			(*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 36)))[i] = int16(v116)
			goto _102
		_102:
			;
			i = i + 1
		}
		/* Unpack entropy table indices and predictor for current CB1 index */
		Opus_silk_NLSF_unpack(tls, bp+84, bp+68, psNLSF_CB, ind1)
		/* Trellis quantizer */
		*(*OpusT_opus_int32)(unsafe.Pointer(RD_Q25 + uintptr(s)*4)) = Opus_silk_NLSF_del_dec_quant(tls, tempIndices2+uintptr(s*int32(MAX_LPC_ORDER)), bp+4, bp+36, bp+68, bp+84, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fec_Rates_Q5, int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FquantStepSize_Q16), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FinvQuantStepSize_Q6, NLSF_mu_Q20, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)
		/* Add rate for first stage */
		iCDF_ptr = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FCB1_iCDF + uintptr(signalType>>libc.Int32FromInt32(1)*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).FnVectors))
		if ind1 == 0 {
			prob_Q8 = int32(256) - libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(iCDF_ptr + uintptr(ind1))))
		} else {
			prob_Q8 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(iCDF_ptr + uintptr(ind1-int32(1))))) - libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(iCDF_ptr + uintptr(ind1))))
		}
		bits_q7 = libc.Int32FromInt32(8)<<libc.Int32FromInt32(7) - Opus_silk_lin2log(tls, prob_Q8)
		*(*OpusT_opus_int32)(unsafe.Pointer(RD_Q25 + uintptr(s)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(RD_Q25 + uintptr(s)*4)) + int32(int16(bits_q7))*int32(int16(NLSF_mu_Q20>>libc.Int32FromInt32(2)))
		goto _101
	_101:
		;
		s = s + 1
	}
	/* Find the lowest rate-distortion error */
	Opus_silk_insertion_sort_increasing(tls, RD_Q25, bp, nSurvivors, int32(1))
	*(*OpusT_opus_int8)(unsafe.Pointer(NLSFIndices)) = int8(*(*int32)(unsafe.Pointer(tempIndices1 + uintptr(*(*int32)(unsafe.Pointer(bp)))*4)))
	libc.Xmemcpy(tls, NLSFIndices+1, tempIndices2+uintptr(*(*int32)(unsafe.Pointer(bp))*int32(MAX_LPC_ORDER)), libc.Uint64FromInt16((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)*libc.Uint64FromInt64(1))
	/* Decode */
	Opus_silk_NLSF_decode(tls, pNLSF_Q15, NLSFIndices, psNLSF_CB)
	ret = *(*OpusT_opus_int32)(unsafe.Pointer(RD_Q25))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _126
_126:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/* Compute quantization errors for an LPC_order element input vector for a VQ codebook */

func Opus_silk_NLSF_stabilize(tls *libc.TLS, NLSF_Q15 uintptr, NDeltaMin_Q15 uintptr, L int32) {
	var I, i, k, loops, v10, v5, v6, v7, v8, v9 int32
	var center_freq_Q15 OpusT_opus_int16
	var diff_Q15, max_center_Q15, min_center_Q15, min_diff_Q15 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = I, center_freq_Q15, diff_Q15, i, k, loops, max_center_Q15, min_center_Q15, min_diff_Q15, v10, v5, v6, v7, v8, v9
	I = 0
	/* This is necessary to ensure an output within range of a opus_int16 */
	_ = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))) >= libc.Int32FromInt32(1)
	loops = 0
	for {
		if !(loops < int32(MAX_LOOPS)) {
			break
		}
		/**************************/
		/* Find smallest distance */
		/**************************/
		/* First element */
		min_diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15)))
		I = 0
		/* Middle elements */
		i = int32(1)
		for {
			if !(i <= L-int32(1)) {
				break
			}
			diff_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2))) - (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))))
			if diff_Q15 < min_diff_Q15 {
				min_diff_Q15 = diff_Q15
				I = i
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		/* Last element */
		diff_Q15 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))))
		if diff_Q15 < min_diff_Q15 {
			min_diff_Q15 = diff_Q15
			I = L
		}
		/***************************************************/
		/* Now check if the smallest distance non-negative */
		/***************************************************/
		if min_diff_Q15 >= 0 {
			return
		}
		if I == 0 {
			/* Move away from lower limit */
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)) = *(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15))
		} else {
			if I == L {
				/* Move away from higher limit */
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)) = int16(libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2))))
			} else {
				/* Find the lower extreme for the location of the current center frequency */
				min_center_Q15 = 0
				k = 0
				for {
					if !(k < I) {
						break
					}
					min_center_Q15 = min_center_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(k)*2)))
					goto _3
				_3:
					;
					k = k + 1
				}
				min_center_Q15 = min_center_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1)
				/* Find the upper extreme for the location of the current center frequency */
				max_center_Q15 = libc.Int32FromInt32(1) << libc.Int32FromInt32(15)
				k = L
				for {
					if !(k > I) {
						break
					}
					max_center_Q15 = max_center_Q15 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(k)*2)))
					goto _4
				_4:
					;
					k = k - 1
				}
				max_center_Q15 = max_center_Q15 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1)
				/* Move apart, sorted by value, keeping the same center frequency */
				if min_center_Q15 > max_center_Q15 {
					if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) > min_center_Q15 {
						v6 = min_center_Q15
					} else {
						if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) < max_center_Q15 {
							v7 = max_center_Q15
						} else {
							v7 = (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1) + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1)
						}
						v6 = v7
					}
					v5 = v6
				} else {
					if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) > max_center_Q15 {
						v8 = max_center_Q15
					} else {
						if (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1)+(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1) < min_center_Q15 {
							v9 = min_center_Q15
						} else {
							v9 = (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))>>int32(1) + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2))))&int32(1)
						}
						v8 = v9
					}
					v5 = v8
				}
				center_freq_Q15 = int16(v5)
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2)) = int16(int32(center_freq_Q15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2)))>>int32(1))
				*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(I-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(I)*2))))
			}
		}
		goto _1
	_1:
		;
		loops = loops + 1
	}
	/* Safe and simple fall back method, which is less ideal than the above */
	if loops == int32(MAX_LOOPS) {
		/* Insertion sort (fast for already almost sorted arrays):   */
		/* Best case:  O(n)   for an already sorted array            */
		/* Worst case: O(n^2) for an inversely sorted array          */
		Opus_silk_insertion_sort_increasing_all_values_int16(tls, NLSF_Q15, L)
		/* First NLSF should be no less than NDeltaMin[0] */
		v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)))
		v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15)))
		if v5 > v6 {
			v8 = v5
		} else {
			v8 = v6
		}
		v7 = v8
		goto _13
	_13:
		*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15)) = int16(v7)
		/* Keep delta_min distance between the NLSFs */
		i = int32(1)
		for {
			if !(i < L) {
				break
			}
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))) > int32(silk_int16_MAX21) {
				v5 = int32(silk_int16_MAX21)
			} else {
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2))) < int32(libc.Int16FromInt32(0x8000)) {
					v6 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i-int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i)*2)))
				}
				v5 = v6
			}
			v7 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)))
			v8 = int32(int16(v5))
			if v7 > v8 {
				v10 = v7
			} else {
				v10 = v8
			}
			v9 = v10
			goto _21
		_21:
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)) = int16(v9)
			goto _15
		_15:
			;
			i = i + 1
		}
		/* Last NLSF should be no higher than 1 - NDeltaMin[L] */
		v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)))
		v6 = libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(L)*2)))
		if v5 < v6 {
			v8 = v5
		} else {
			v8 = v6
		}
		v7 = v8
		goto _26
	_26:
		*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(L-int32(1))*2)) = int16(v7)
		/* Keep NDeltaMin distance between the NLSFs */
		i = L - int32(2)
		for {
			if !(i >= 0) {
				break
			}
			v5 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)))
			v6 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(NDeltaMin_Q15 + uintptr(i+int32(1))*2)))
			if v5 < v6 {
				v8 = v5
			} else {
				v8 = v6
			}
			v7 = v8
			goto _32
		_32:
			*(*OpusT_opus_int16)(unsafe.Pointer(NLSF_Q15 + uintptr(i)*2)) = int16(v7)
			goto _28
		_28:
			;
			i = i - 1
		}
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

/*
R. Laroia, N. Phamdo and N. Farvardin, "Robust and Efficient Quantization of Speech LSP
Parameters Using Structured Vector Quantization", Proc. IEEE Int. Conf. Acoust., Speech,
Signal Processing, pp. 641-644, 1991.
*/

// C documentation
//
//	/* Laroia low complexity NLSF weights */

func Opus_silk_NLSF_unpack(tls *libc.TLS, ec_ix uintptr, pred_Q8 uintptr, psNLSF_CB uintptr, CB1_index int32) {
	var ec_sel_ptr, v2 uintptr
	var entry OpusT_opus_uint8
	var i int32
	_, _, _, _ = ec_sel_ptr, entry, i, v2
	ec_sel_ptr = (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fec_sel + uintptr(CB1_index*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)/int32(2))
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)) {
			break
		}
		v2 = ec_sel_ptr
		ec_sel_ptr = ec_sel_ptr + 1
		entry = *(*OpusT_opus_uint8)(unsafe.Pointer(v2))
		*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i)*2)) = int16(int32(int16(libc.Int32FromUint8(entry)>>libc.Int32FromInt32(1)&libc.Int32FromInt32(7))) * int32(int16(libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE)+libc.Int32FromInt32(1))))
		*(*OpusT_opus_uint8)(unsafe.Pointer(pred_Q8 + uintptr(i))) = *(*OpusT_opus_uint8)(unsafe.Pointer((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fpred_Q8 + uintptr(i+libc.Int32FromUint8(entry)&int32(1)*(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)-int32(1)))))
		*(*OpusT_opus_int16)(unsafe.Pointer(ec_ix + uintptr(i+int32(1))*2)) = int16(int32(int16(libc.Int32FromUint8(entry)>>libc.Int32FromInt32(5)&libc.Int32FromInt32(7))) * int32(int16(libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE)+libc.Int32FromInt32(1))))
		*(*OpusT_opus_uint8)(unsafe.Pointer(pred_Q8 + uintptr(i+int32(1)))) = *(*OpusT_opus_uint8)(unsafe.Pointer((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Fpred_Q8 + uintptr(i+libc.Int32FromUint8(entry)>>int32(4)&int32(1)*(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer(psNLSF_CB)).Forder)-int32(1))+int32(1))))
		goto _1
	_1:
		;
		i = i + int32(2)
	}
}

// C documentation
//
//	/* Delayed-decision quantizer for NLSF residuals */

func Opus_silk_NSQ_c(tls *libc.TLS, psEncC uintptr, NSQ uintptr, psIndices uintptr, x16 uintptr, pulses uintptr, PredCoef_Q12 uintptr, LTPCoef_Q14 uintptr, AR_Q13 uintptr, HarmShapeGain_Q14 uintptr, Tilt_Q14 uintptr, LF_shp_Q14 uintptr, Gains_Q16 uintptr, pitchL uintptr, Lambda_Q10 int32, LTP_scale_Q14 int32) {
	var AR_shp_Q13, A_Q12, B_Q14, _saved_stack, pxq, sLTP, sLTP_Q15, st, x_sc_Q10, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var HarmShapeFIRPacked_Q14 OpusT_opus_int32
	var LSF_interpolation_flag, k, lag, offset_Q10, start_idx int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = AR_shp_Q13, A_Q12, B_Q14, HarmShapeFIRPacked_Q14, LSF_interpolation_flag, _saved_stack, k, lag, offset_Q10, pxq, sLTP, sLTP_Q15, st, start_idx, x_sc_Q10, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed)
	/* Set unvoiced lag to the previous one, overwrite later for voiced */
	lag = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FlagPrev
	_ = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 != libc.Int32FromInt32(0)
	offset_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType)>>int32(1))*4 + uintptr((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FquantOffsetType)*2)))
	if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FNLSFInterpCoef_Q2) == int32(4) {
		LSF_interpolation_flag = 0
	} else {
		LSF_interpolation_flag = int32(1)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8374, int32(120))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sLTP_Q15 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8374, int32(121))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8374, int32(122))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	x_sc_Q10 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Set up pointers to start of sub frame */
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
	pxq = NSQ + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*2
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr) {
			break
		}
		A_Q12 = PredCoef_Q12 + uintptr((k>>int32(1)|(int32(1)-LSF_interpolation_flag))*int32(MAX_LPC_ORDER))*2
		B_Q14 = LTPCoef_Q14 + uintptr(k*int32(LTP_ORDER))*2
		AR_shp_Q13 = AR_Q13 + uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*2
		/* Noise shape parameters */
		_ = *(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4)) >= libc.Int32FromInt32(0)
		HarmShapeFIRPacked_Q14 = *(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4)) >> libc.Int32FromInt32(2)
		HarmShapeFIRPacked_Q14 = HarmShapeFIRPacked_Q14 | libc.Int32FromUint32(libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4))>>libc.Int32FromInt32(1))<<libc.Int32FromInt32(16))
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag = 0
		if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) == int32(TYPE_VOICED) {
			/* Voiced */
			lag = *(*int32)(unsafe.Pointer(pitchL + uintptr(k)*4))
			/* Re-whitening */
			if k&(int32(3)-libc.Int32FromUint32(libc.Uint32FromInt32(LSF_interpolation_flag)<<libc.Int32FromInt32(1))) == 0 {
				/* Rewhiten with new A coefs */
				start_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length - lag - (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
				if !(start_idx > libc.Int32FromInt32(0)) {
					Opus_celt_fatal(tls, __ccgo_ts+6678, __ccgo_ts+8374, int32(146))
				}
				Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(start_idx)*2, NSQ+uintptr(start_idx+k*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2, A_Q12, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length-start_idx, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
				(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag = int32(1)
				(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
			}
		}
		silk_nsq_scale_states(tls, psEncC, NSQ, x16, x_sc_Q10, sLTP, sLTP_Q15, k, LTP_scale_Q14, Gains_Q16, pitchL, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType))
		silk_noise_shape_quantizer(tls, NSQ, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType), x_sc_Q10, pulses, pxq, sLTP_Q15, A_Q12, B_Q14, AR_shp_Q13, lag, HarmShapeFIRPacked_Q14, *(*int32)(unsafe.Pointer(Tilt_Q14 + uintptr(k)*4)), *(*OpusT_opus_int32)(unsafe.Pointer(LF_shp_Q14 + uintptr(k)*4)), *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(k)*4)), Lambda_Q10, offset_Q10, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
		x16 = x16 + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2
		pulses = pulses + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)
		pxq = pxq + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2
		goto _77
	_77:
		;
		k = k + 1
	}
	/* Update lagPrev for next frame */
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FlagPrev = *(*int32)(unsafe.Pointer(pitchL + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr-int32(1))*4))
	/* Save quantized speech and noise shaping signals */
	libc.Xmemmove(tls, NSQ, NSQ+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*2, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*libc.Uint64FromInt64(2))
	libc.Xmemmove(tls, NSQ+1280, NSQ+1280+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*4, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _79
	_79:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _81
_81:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

/******************************/
/* silk_noise_shape_quantizer */
/******************************/

func Opus_silk_NSQ_del_dec_c(tls *libc.TLS, psEncC uintptr, NSQ uintptr, psIndices uintptr, x16 uintptr, pulses uintptr, PredCoef_Q12 uintptr, LTPCoef_Q14 uintptr, AR_Q13 uintptr, HarmShapeGain_Q14 uintptr, Tilt_Q14 uintptr, LF_shp_Q14 uintptr, Gains_Q16 uintptr, pitchL uintptr, Lambda_Q10 int32, LTP_scale_Q14 int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var AR_shp_Q13, A_Q12, B_Q14, _saved_stack, delayedGain_Q10, psDD, psDelDec, pxq, sLTP, sLTP_Q15, st, x_sc_Q10, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var Gain_Q10, HarmShapeFIRPacked_Q14, RDmin_Q10 OpusT_opus_int32
	var LSF_interpolation_flag, Winner_ind, decisionDelay, i, k, lag, last_smple_idx, offset_Q10, start_idx, subfr, v30, v31, v32, v34 int32
	var _ /* smpl_buf_idx at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = AR_shp_Q13, A_Q12, B_Q14, Gain_Q10, HarmShapeFIRPacked_Q14, LSF_interpolation_flag, RDmin_Q10, Winner_ind, _saved_stack, decisionDelay, delayedGain_Q10, i, k, lag, last_smple_idx, offset_Q10, psDD, psDelDec, pxq, sLTP, sLTP_Q15, st, start_idx, subfr, x_sc_Q10, v1, v11, v13, v15, v17, v19, v21, v23, v3, v30, v31, v32, v34, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Set unvoiced lag to the previous one, overwrite later for voiced */
	lag = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FlagPrev
	_ = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 != libc.Int32FromInt32(0)
	/* Initialize delayed decision states */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision)*(libc.Uint64FromInt64(1300)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(153))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision) * (libc.Uint64FromInt64(1300) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	psDelDec = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision)*(libc.Uint64FromInt64(1300)/libc.Uint64FromInt64(1)))
	libc.Xmemset(tls, psDelDec, 0, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision)*libc.Uint64FromInt64(1300))
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision) {
			break
		}
		psDD = psDelDec + uintptr(k)*1300
		(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed = (k + int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed)) & int32(3)
		(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeedInit = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed
		(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 = 0
		(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14 = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14
		(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14 = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14
		*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024)) = *(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length-int32(1))*4))
		libc.Xmemcpy(tls, psDD, NSQ+3840, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, psDD+1184, NSQ+4224, libc.Uint64FromInt64(96))
		goto _29
	_29:
		;
		k = k + 1
	}
	offset_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType)>>int32(1))*4 + uintptr((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FquantOffsetType)*2)))
	*(*int32)(unsafe.Pointer(bp)) = 0 /* index of oldest samples */
	v30 = int32(DECISION_DELAY)
	v31 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length
	if v30 < v31 {
		v34 = v30
	} else {
		v34 = v31
	}
	v32 = v34
	goto _33
_33:
	decisionDelay = v32
	/* For voiced frames limit the decision delay to lower than the pitch lag */
	if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) == int32(TYPE_VOICED) {
		k = 0
		for {
			if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr) {
				break
			}
			v30 = decisionDelay
			v31 = *(*int32)(unsafe.Pointer(pitchL + uintptr(k)*4)) - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2) - int32(1)
			if v30 < v31 {
				v34 = v30
			} else {
				v34 = v31
			}
			v32 = v34
			goto _39
		_39:
			decisionDelay = v32
			goto _35
		_35:
			;
			k = k + 1
		}
	} else {
		if lag > 0 {
			v30 = decisionDelay
			v31 = lag - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2) - int32(1)
			if v30 < v31 {
				v34 = v30
			} else {
				v34 = v31
			}
			v32 = v34
			goto _44
		_44:
			decisionDelay = v32
		}
	}
	if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FNLSFInterpCoef_Q2) == int32(4) {
		LSF_interpolation_flag = 0
	} else {
		LSF_interpolation_flag = int32(1)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _49
_49:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _53
_53:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _57
_57:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _59
	_59:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _61
_61:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(189))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _63
	_63:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _65
_65:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _67
	_67:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _69
_69:
	sLTP_Q15 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _71
	_71:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _73
_73:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _75
	_75:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _77
_77:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _79
	_79:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _81
_81:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _83
	_83:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _85
_85:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(190))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _87
	_87:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _89
_89:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _91
	_91:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _93
_93:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length+(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _95
	_95:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _97
_97:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _99
	_99:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _101
_101:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _103
	_103:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _105
_105:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _107
	_107:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _109
_109:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(191))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _111
	_111:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _113
_113:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _115
	_115:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _117
_117:
	x_sc_Q10 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _119
	_119:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _121
_121:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _123
	_123:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _125
_125:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _127
	_127:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _129
_129:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _131
	_131:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _133
_133:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(DECISION_DELAY))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(192))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _135
	_135:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _137
_137:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(DECISION_DELAY)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _139
	_139:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _141
_141:
	delayedGain_Q10 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(DECISION_DELAY))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Set up pointers to start of sub frame */
	pxq = NSQ + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*2
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
	subfr = 0
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr) {
			break
		}
		A_Q12 = PredCoef_Q12 + uintptr((k>>int32(1)|(int32(1)-LSF_interpolation_flag))*int32(MAX_LPC_ORDER))*2
		B_Q14 = LTPCoef_Q14 + uintptr(k*int32(LTP_ORDER))*2
		AR_shp_Q13 = AR_Q13 + uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*2
		/* Noise shape parameters */
		_ = *(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4)) >= libc.Int32FromInt32(0)
		HarmShapeFIRPacked_Q14 = *(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4)) >> libc.Int32FromInt32(2)
		HarmShapeFIRPacked_Q14 = HarmShapeFIRPacked_Q14 | libc.Int32FromUint32(libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(HarmShapeGain_Q14 + uintptr(k)*4))>>libc.Int32FromInt32(1))<<libc.Int32FromInt32(16))
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag = 0
		if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) == int32(TYPE_VOICED) {
			/* Voiced */
			lag = *(*int32)(unsafe.Pointer(pitchL + uintptr(k)*4))
			/* Re-whitening */
			if k&(int32(3)-libc.Int32FromUint32(libc.Uint32FromInt32(LSF_interpolation_flag)<<libc.Int32FromInt32(1))) == 0 {
				if k == int32(2) {
					/* RESET DELAYED DECISIONS */
					/* Find winner */
					RDmin_Q10 = (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec))).FRD_Q10
					Winner_ind = 0
					i = int32(1)
					for {
						if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision) {
							break
						}
						if (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(i)*1300))).FRD_Q10 < RDmin_Q10 {
							RDmin_Q10 = (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(i)*1300))).FRD_Q10
							Winner_ind = i
						}
						goto _143
					_143:
						;
						i = i + 1
					}
					i = 0
					for {
						if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision) {
							break
						}
						if i != Winner_ind {
							(*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(i)*1300))).FRD_Q10 += libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
							_ = (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(i)*1300))).FRD_Q10 >= libc.Int32FromInt32(0)
						}
						goto _144
					_144:
						;
						i = i + 1
					}
					/* Copy final part of signals from winner state to output and long-term filter states */
					psDD = psDelDec + uintptr(Winner_ind)*1300
					last_smple_idx = *(*int32)(unsafe.Pointer(bp)) + decisionDelay
					i = 0
					for {
						if !(i < decisionDelay) {
							break
						}
						last_smple_idx = (last_smple_idx - int32(1)) % int32(DECISION_DELAY)
						if last_smple_idx < 0 {
							last_smple_idx = last_smple_idx + int32(DECISION_DELAY)
						}
						*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i-decisionDelay))) = int8((*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 544 + uintptr(last_smple_idx)*4))>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
						if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + 1*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
							v30 = int32(silk_int16_MAX9)
						} else {
							if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + 1*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
								v31 = int32(libc.Int16FromInt32(0x8000))
							} else {
								v31 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + 1*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
							}
							v30 = v31
						}
						*(*OpusT_opus_int16)(unsafe.Pointer(pxq + uintptr(i-decisionDelay)*2)) = int16(v30)
						*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-decisionDelay+i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(last_smple_idx)*4))
						goto _145
					_145:
						;
						i = i + 1
					}
					subfr = 0
				}
				/* Rewhiten with new A coefs */
				start_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length - lag - (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
				if !(start_idx > libc.Int32FromInt32(0)) {
					Opus_celt_fatal(tls, __ccgo_ts+6678, __ccgo_ts+8490, int32(250))
				}
				Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(start_idx)*2, NSQ+uintptr(start_idx+k*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2, A_Q12, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length-start_idx, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
				(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
				(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag = int32(1)
			}
		}
		silk_nsq_del_dec_scale_states(tls, psEncC, NSQ, psDelDec, x16, x_sc_Q10, sLTP, sLTP_Q15, k, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision, LTP_scale_Q14, Gains_Q16, pitchL, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType), decisionDelay)
		v30 = subfr
		subfr = subfr + 1
		silk_noise_shape_quantizer_del_dec(tls, NSQ, psDelDec, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType), x_sc_Q10, pulses, pxq, sLTP_Q15, delayedGain_Q10, A_Q12, B_Q14, AR_shp_Q13, lag, HarmShapeFIRPacked_Q14, *(*int32)(unsafe.Pointer(Tilt_Q14 + uintptr(k)*4)), *(*OpusT_opus_int32)(unsafe.Pointer(LF_shp_Q14 + uintptr(k)*4)), *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(k)*4)), Lambda_Q10, offset_Q10, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length, v30, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision, bp, decisionDelay, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
		x16 = x16 + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2
		pulses = pulses + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)
		pxq = pxq + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*2
		goto _142
	_142:
		;
		k = k + 1
	}
	/* Find winner */
	RDmin_Q10 = (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec))).FRD_Q10
	Winner_ind = 0
	k = int32(1)
	for {
		if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision) {
			break
		}
		if (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(k)*1300))).FRD_Q10 < RDmin_Q10 {
			RDmin_Q10 = (*(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDelDec + uintptr(k)*1300))).FRD_Q10
			Winner_ind = k
		}
		goto _149
	_149:
		;
		k = k + 1
	}
	/* Copy final part of signals from winner state to output and long-term filter states */
	psDD = psDelDec + uintptr(Winner_ind)*1300
	(*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed = int8((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeedInit)
	last_smple_idx = *(*int32)(unsafe.Pointer(bp)) + decisionDelay
	Gain_Q10 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr-int32(1))*4)) >> libc.Int32FromInt32(6)
	i = 0
	for {
		if !(i < decisionDelay) {
			break
		}
		last_smple_idx = (last_smple_idx - int32(1)) % int32(DECISION_DELAY)
		if last_smple_idx < 0 {
			last_smple_idx = last_smple_idx + int32(DECISION_DELAY)
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i-decisionDelay))) = int8((*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 544 + uintptr(last_smple_idx)*4))>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
		if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
			v30 = int32(silk_int16_MAX9)
		} else {
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v31 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v31 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v30 = v31
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(pxq + uintptr(i-decisionDelay)*2)) = int16(v30)
		*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-decisionDelay+i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(last_smple_idx)*4))
		goto _150
	_150:
		;
		i = i + 1
	}
	libc.Xmemcpy(tls, NSQ+3840, psDD+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	libc.Xmemcpy(tls, NSQ+4224, psDD+1184, libc.Uint64FromInt64(96))
	/* Update states */
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14
	(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FlagPrev = *(*int32)(unsafe.Pointer(pitchL + uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr-int32(1))*4))
	/* Save quantized speech signal */
	libc.Xmemmove(tls, NSQ, NSQ+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*2, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*libc.Uint64FromInt64(2))
	libc.Xmemmove(tls, NSQ+1280, NSQ+1280+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)*4, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _154
	_154:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _156
_156:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

// C documentation
//
//	/******************************************/
//	/* Noise shape quantizer for one subframe */
//	/******************************************/

func Opus_silk_NSQ_wrapper_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, psIndices uintptr, psNSQ uintptr, pulses uintptr, x1 uintptr) {
	bp := tls.Alloc(1008)
	defer tls.Free(1008)
	var LTP_scale_Q14, Lambda_Q10, i, j int32
	var v3, v6 OpusT_opus_int32
	var _ /* AR_Q13 at bp+760 */ [96]OpusT_opus_int16
	var _ /* Gains_Q16 at bp+640 */ [4]OpusT_opus_int32
	var _ /* HarmShapeGain_Q14 at bp+984 */ [4]int32
	var _ /* LF_shp_Q14 at bp+952 */ [4]OpusT_opus_int32
	var _ /* LTPCoef_Q14 at bp+720 */ [20]OpusT_opus_int16
	var _ /* PredCoef_Q12 at bp+656 */ [2][16]OpusT_opus_int16
	var _ /* Tilt_Q14 at bp+968 */ [4]int32
	var _ /* x16 at bp+0 */ [320]OpusT_opus_int16
	_, _, _, _, _, _ = LTP_scale_Q14, Lambda_Q10, i, j, v3, v6
	/* Convert control struct to fix control struct */
	/* Noise shape parameters */
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		j = 0
		for {
			if !(j < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder) {
				break
			}
			v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 244 + uintptr(i*int32(MAX_SHAPE_LPC_ORDER)+j)*4))*libc.Float32FromFloat32(8192))))
			goto _4
		_4:
			(*(*[96]OpusT_opus_int16)(unsafe.Pointer(bp + 760)))[i*int32(MAX_SHAPE_LPC_ORDER)+j] = int16(v3)
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 644 + uintptr(i)*4))*libc.Float32FromFloat32(16384))))
		goto _7
	_7:
		v6 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 628 + uintptr(i)*4))*libc.Float32FromFloat32(16384))))
		goto _9
	_9:
		(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 952)))[i] = libc.Int32FromUint32(libc.Uint32FromInt32(v3)<<libc.Int32FromInt32(16)) | libc.Int32FromUint16(libc.Uint16FromInt32(v6))
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 660 + uintptr(i)*4))*libc.Float32FromFloat32(16384))))
		goto _11
	_11:
		(*(*[4]int32)(unsafe.Pointer(bp + 968)))[i] = v3
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 676 + uintptr(i)*4))*libc.Float32FromFloat32(16384))))
		goto _13
	_13:
		(*(*[4]int32)(unsafe.Pointer(bp + 984)))[i] = v3
		goto _5
	_5:
		;
		i = i + 1
	}
	v3 = int32(Opus_lrintf(tls, float32((*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLambda*libc.Float32FromFloat32(1024))))
	goto _15
_15:
	Lambda_Q10 = v3
	/* prediction and coding parameters */
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr*int32(LTP_ORDER)) {
			break
		}
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 144 + uintptr(i)*4))*libc.Float32FromFloat32(16384))))
		goto _18
	_18:
		(*(*[20]OpusT_opus_int16)(unsafe.Pointer(bp + 720)))[i] = int16(v3)
		goto _16
	_16:
		;
		i = i + 1
	}
	j = 0
	for {
		if !(j < int32(2)) {
			break
		}
		i = 0
		for {
			if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder) {
				break
			}
			v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + 16 + uintptr(j)*64 + uintptr(i)*4))*libc.Float32FromFloat32(4096))))
			goto _22
		_22:
			*(*OpusT_opus_int16)(unsafe.Pointer(bp + 656 + uintptr(j)*32 + uintptr(i)*2)) = int16(v3)
			goto _20
		_20:
			;
			i = i + 1
		}
		goto _19
	_19:
		;
		j = j + 1
	}
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(i)*4))*libc.Float32FromFloat32(65536))))
		goto _25
	_25:
		(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 640)))[i] = v3
		_ = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 640)))[i] > libc.Int32FromInt32(0)
		goto _23
	_23:
		;
		i = i + 1
	}
	if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) == int32(TYPE_VOICED) {
		LTP_scale_Q14 = int32(Opus_silk_LTPScales_table_Q14[(*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FLTP_scaleIndex])
	} else {
		LTP_scale_Q14 = 0
	}
	/* Convert input to fix */
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length) {
			break
		}
		v3 = int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(x1 + uintptr(i)*4))))
		goto _28
	_28:
		(*(*[320]OpusT_opus_int16)(unsafe.Pointer(bp)))[i] = int16(v3)
		goto _26
	_26:
		;
		i = i + 1
	}
	/* Call NSQ */
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnStatesDelayedDecision > int32(1) || (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fwarping_Q16 > 0 {
		_ = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch
		Opus_silk_NSQ_del_dec_c(tls, psEnc, psNSQ, psIndices, bp, pulses, bp+656, bp+720, bp+760, bp+984, bp+968, bp+952, bp+640, psEncCtrl+228, Lambda_Q10, LTP_scale_Q14)
	} else {
		_ = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch
		Opus_silk_NSQ_c(tls, psEnc, psNSQ, psIndices, bp, pulses, bp+656, bp+720, bp+760, bp+984, bp+968, bp+952, bp+640, psEncCtrl+228, Lambda_Q10, LTP_scale_Q14)
	}
}

// C documentation
//
//	/***********************************************/
//	/* Floating-point Silk LTP quantiation wrapper */
//	/***********************************************/

func Opus_silk_PLC(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, lost int32, arch int32) {
	/* PLC control function */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Ffs_kHz {
		Opus_silk_PLC_Reset(tls, psDec)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Ffs_kHz = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz
	}
	if lost != 0 {
		/****************************/
		/* Generate Signal          */
		/****************************/
		silk_PLC_conceal(tls, psDec, psDecCtrl, frame, arch)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt + 1
	} else {
		/****************************/
		/* Update state             */
		/****************************/
		silk_PLC_update(tls, psDec, psDecCtrl)
	}
}

// C documentation
//
//	/**************************************************/
//	/* Update state of PLC                            */
//	/**************************************************/

func Opus_silk_PLC_Reset(tls *libc.TLS, psDec uintptr) {
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) << (libc.Int32FromInt32(8) - libc.Int32FromInt32(1)))
	*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72)) = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4292 + 72 + 1*4)) = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Fsubfr_length = int32(20)
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Fnb_subfr = int32(2)
}

func Opus_silk_PLC_glue_frames(tls *libc.TLS, psDec uintptr, frame uintptr, length int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var LZ, frac_Q24, gain_Q16, lzeros, slope_Q16, y, v1, v11, v12, v2, v5, v6, v7 OpusT_opus_int32
	var i, v4, v9 int32
	var m, r, x OpusT_opus_uint32
	var psPLC uintptr
	var _ /* energy at bp+12 */ OpusT_opus_int32
	var _ /* energy_shift at bp+8 */ int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = LZ, frac_Q24, gain_Q16, i, lzeros, m, psPLC, r, slope_Q16, x, y, v1, v11, v12, v2, v4, v5, v6, v7, v9
	psPLC = psDec + 4292
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		/* Calculate energy in concealed residual */
		Opus_silk_sum_sqr_shift(tls, psPLC+60, psPLC+64, frame, length)
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Flast_frame_lost = int32(1)
	} else {
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FsPLC.Flast_frame_lost != 0 {
			/* Calculate residual in decoded signal if last frame was lost */
			Opus_silk_sum_sqr_shift(tls, bp+12, bp+8, frame, length)
			/* Normalize energies */
			if *(*int32)(unsafe.Pointer(bp + 8)) > (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift {
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy >> (*(*int32)(unsafe.Pointer(bp + 8)) - (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift)
			} else {
				if *(*int32)(unsafe.Pointer(bp + 8)) < (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift {
					*(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) >> ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy_shift - *(*int32)(unsafe.Pointer(bp + 8)))
				}
			}
			/* Fade in the energy difference */
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) > (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy {
				v1 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy
				if v1 != 0 {
					v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
				} else {
					v4 = int32(32)
				}
				v2 = v4
				goto _3
			_3:
				LZ = v2
				LZ = LZ - int32(1)
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy) << LZ)
				v1 = int32(24) - LZ
				v2 = 0
				if v1 > v2 {
					v4 = v1
				} else {
					v4 = v2
				}
				v5 = v4
				goto _8
			_8:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) >> v5
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) > int32(1) {
					v4 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12))
				} else {
					v4 = int32(1)
				}
				frac_Q24 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fconc_energy / v4
				v1 = frac_Q24
				if v1 <= libc.Int32FromInt32(0) {
					v2 = 0
					goto _13
				}
				v5 = v1
				v6 = v5
				if v6 != 0 {
					v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v6)))
				} else {
					v4 = int32(32)
				}
				v7 = v4
				goto _17
			_17:
				lzeros = v7
				*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
				v11 = v5
				v9 = int32(24) - lzeros
				x = libc.Uint32FromInt32(v11)
				r = libc.Uint32FromInt32(v9)
				m = libc.Uint32FromInt32(-v9)
				if v9 == libc.Int32FromInt32(0) {
					v12 = v11
					goto _22
				} else {
					if v9 < libc.Int32FromInt32(0) {
						v12 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
						goto _22
					} else {
						v12 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
						goto _22
					}
				}
			_22:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v12 & int32(0x7f)
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
					y = int32(32768)
				} else {
					y = int32(46214)
				}
				y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
				y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
				v2 = y
				goto _13
			_13:
				gain_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << libc.Int32FromInt32(4))
				slope_Q16 = (libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) - gain_Q16) / length
				/* Make slope 4x steeper to avoid missing onsets after DTX */
				slope_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(slope_Q16) << libc.Int32FromInt32(2))
				i = 0
				for {
					if !(i < length) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(int32(int64(gain_Q16) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2))) >> libc.Int32FromInt32(16)))
					gain_Q16 = gain_Q16 + slope_Q16
					if gain_Q16 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) {
						break
					}
					goto _23
				_23:
					;
					i = i + 1
				}
			}
		}
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Flast_frame_lost = 0
	}
}

const silk_int16_MAX10 = 0x7FFF

/* shell coder; pulse-subframe length is hardcoded */

func Opus_silk_ResetDecoder(tls *libc.TLS, decState uintptr) (r int32) {
	var channel_state uintptr
	var n, ret int32
	_, _, _ = channel_state, n, ret
	ret = SILK_NO_ERROR
	channel_state = decState
	n = 0
	for {
		if !(n < int32(DECODER_NUM_CHANNELS)) {
			break
		}
		ret = Opus_silk_reset_decoder(tls, channel_state+uintptr(n)*4392)
		goto _1
	_1:
		;
		n = n + 1
	}
	libc.Xmemset(tls, decState+8784, 0, libc.Uint64FromInt64(12))
	/* Not strictly needed, but it's cleaner that way */
	(*OpusT_silk_decoder)(unsafe.Pointer(decState)).Fprev_decode_only_middle = 0
	return ret
}

func Opus_silk_VAD_GetSA_Q8_c(tls *libc.TLS, psEncC uintptr, pIn uintptr) (r1 int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var HPstateTmp OpusT_opus_int16
	var NrgToNoiseRatio_Q8 [4]OpusT_opus_int32
	var SA_Q15, SNR_Q7, b1, dec_subframe_length, dec_subframe_offset, decimated_framelength, decimated_framelength1, decimated_framelength2, i, input_tilt, pSNR_dB_Q7, ret, s, v33, v34, v35, v37 int32
	var X, _saved_stack, psSilk_VAD, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var X_offset [4]int32
	var lzeros, smooth_coef_Q16, speech_nrg, sumSquared, x_tmp, y, v43, v44, v46, v47, v48, v51, v53 OpusT_opus_int32
	var m, r, x OpusT_opus_uint32
	var _ /* Xnrg at bp+8 */ [4]OpusT_opus_int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = HPstateTmp, NrgToNoiseRatio_Q8, SA_Q15, SNR_Q7, X, X_offset, _saved_stack, b1, dec_subframe_length, dec_subframe_offset, decimated_framelength, decimated_framelength1, decimated_framelength2, i, input_tilt, lzeros, m, pSNR_dB_Q7, psSilk_VAD, r, ret, s, smooth_coef_Q16, speech_nrg, st, sumSquared, x, x_tmp, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v33, v34, v35, v37, v43, v44, v46, v47, v48, v5, v51, v53, v7, v9
	ret = 0
	psSilk_VAD = psEncC + 36
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Safety checks */
	_ = true
	if !(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ) >= (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length) {
		Opus_celt_fatal(tls, __ccgo_ts+8638, __ccgo_ts+8697, int32(104))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length <= libc.Int32FromInt32(512)) {
		Opus_celt_fatal(tls, __ccgo_ts+8711, __ccgo_ts+8697, int32(105))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == libc.Int32FromInt32(8)*((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length>>libc.Int32FromInt32(3))) {
		Opus_celt_fatal(tls, __ccgo_ts+8757, __ccgo_ts+8697, int32(106))
	}
	/***********************/
	/* Filter and Decimate */
	/***********************/
	decimated_framelength1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(1)
	decimated_framelength2 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(2)
	decimated_framelength = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> int32(3)
	/* Decimate into 4 bands:
	   0       L      3L       L              3L                             5L
	           -      --       -              --                             --
	           8       8       2               4                              4
	   [0-1 kHz| temp. |1-2 kHz|    2-4 kHz    |            4-8 kHz           |
	   They're arranged to allow the minimal ( frame_length / 4 ) extra
	   scratch space during the downsampling process */
	X_offset[0] = 0
	X_offset[int32(1)] = decimated_framelength + decimated_framelength2
	X_offset[int32(2)] = X_offset[int32(1)] + decimated_framelength
	X_offset[int32(3)] = X_offset[int32(2)] + decimated_framelength2
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8697, int32(127))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	X = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(X_offset[int32(3)]+decimated_framelength1)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* 0-8 kHz to 0-4 kHz and 4-8 kHz */
	Opus_silk_ana_filt_bank_1(tls, pIn, psSilk_VAD, X, X+uintptr(X_offset[int32(3)])*2, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length)
	/* 0-4 kHz to 0-2 kHz and 2-4 kHz */
	Opus_silk_ana_filt_bank_1(tls, X, psSilk_VAD+8, X, X+uintptr(X_offset[int32(2)])*2, decimated_framelength1)
	/* 0-2 kHz to 0-1 kHz and 1-2 kHz */
	Opus_silk_ana_filt_bank_1(tls, X, psSilk_VAD+16, X, X+uintptr(X_offset[int32(1)])*2, decimated_framelength2)
	/*********************************************/
	/* HP filter on lowest band (differentiator) */
	/*********************************************/
	*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2))) >> libc.Int32FromInt32(1))
	HPstateTmp = *(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(decimated_framelength-int32(1))*2))
	i = decimated_framelength - int32(1)
	for {
		if !(i > 0) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2))) >> libc.Int32FromInt32(1))
		v1 = X + uintptr(i)*2
		*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(i-int32(1))*2))))
		goto _29
	_29:
		;
		i = i - 1
	}
	v1 = X
	*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) - int32((*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).FHPstate))
	(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).FHPstate = HPstateTmp
	/*************************************/
	/* Calculate the energy in each band */
	/*************************************/
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* Find the decimated framelength in the non-uniformly divided bands */
		v33 = int32(VAD_N_BANDS) - b1
		v34 = libc.Int32FromInt32(VAD_N_BANDS) - libc.Int32FromInt32(1)
		if v33 < v34 {
			v37 = v33
		} else {
			v37 = v34
		}
		v35 = v37
		goto _36
	_36:
		decimated_framelength = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length >> v35
		/* Split length into subframe lengths */
		dec_subframe_length = decimated_framelength >> int32(VAD_INTERNAL_SUBFRAMES_LOG2)
		dec_subframe_offset = 0
		/* Compute energy per sub-frame */
		/* initialize with summed energy of last subframe */
		(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 24 + uintptr(b1)*4))
		s = 0
		for {
			if !(s < libc.Int32FromInt32(1)<<libc.Int32FromInt32(VAD_INTERNAL_SUBFRAMES_LOG2)) {
				break
			}
			sumSquared = 0
			i = 0
			for {
				if !(i < dec_subframe_length) {
					break
				}
				/* The energy will be less than dec_subframe_length * ( silk_int16_MIN / 8 ) ^ 2.            */
				/* Therefore we can accumulate with no risk of overflow (unless dec_subframe_length > 128)  */
				x_tmp = int32(*(*OpusT_opus_int16)(unsafe.Pointer(X + uintptr(X_offset[b1]+i+dec_subframe_offset)*2))) >> libc.Int32FromInt32(3)
				sumSquared = sumSquared + int32(int16(x_tmp))*int32(int16(x_tmp))
				/* Safety check */
				_ = sumSquared >= libc.Int32FromInt32(0)
				goto _39
			_39:
				;
				i = i + 1
			}
			/* Add/saturate summed energy of current subframe */
			if s < libc.Int32FromInt32(1)<<libc.Int32FromInt32(VAD_INTERNAL_SUBFRAMES_LOG2)-libc.Int32FromInt32(1) {
				if (libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])+libc.Uint32FromInt32(sumSquared))&uint32(0x80000000) != 0 {
					v33 = int32(silk_int32_MAX)
				} else {
					v33 = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] + sumSquared
				}
				(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = v33
			} else {
				/* Look-ahead subframe */
				if (libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])+libc.Uint32FromInt32(sumSquared>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
					v33 = int32(silk_int32_MAX)
				} else {
					v33 = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] + sumSquared>>libc.Int32FromInt32(1)
				}
				(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] = v33
			}
			dec_subframe_offset = dec_subframe_offset + dec_subframe_length
			goto _38
		_38:
			;
			s = s + 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 24 + uintptr(b1)*4)) = sumSquared
		goto _32
	_32:
		;
		b1 = b1 + 1
	}
	/********************/
	/* Noise estimation */
	/********************/
	silk_VAD_GetNoiseLevels(tls, bp+8, psSilk_VAD)
	/***********************************************/
	/* Signal-plus-noise to noise ratio estimation */
	/***********************************************/
	sumSquared = 0
	input_tilt = 0
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		speech_nrg = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] - *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))
		if speech_nrg > 0 {
			/* Divide, with sufficient resolution */
			if libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])&uint32(0xFF800000) == uint32(0) {
				NrgToNoiseRatio_Q8[b1] = libc.Int32FromUint32(libc.Uint32FromInt32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1])<<libc.Int32FromInt32(8)) / (*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)) + libc.Int32FromInt32(1))
			} else {
				NrgToNoiseRatio_Q8[b1] = (*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1] / (*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))>>libc.Int32FromInt32(8) + libc.Int32FromInt32(1))
			}
			/* Convert to log domain */
			SNR_Q7 = Opus_silk_lin2log(tls, NrgToNoiseRatio_Q8[b1]) - libc.Int32FromInt32(8)*libc.Int32FromInt32(128)
			/* Sum-of-squares */
			sumSquared = sumSquared + int32(int16(SNR_Q7))*int32(int16(SNR_Q7)) /* Q14 */
			/* Tilt measure */
			if speech_nrg < libc.Int32FromInt32(1)<<libc.Int32FromInt32(20) {
				/* Scale down SNR value for small subband speech energies */
				v43 = speech_nrg
				if v43 <= libc.Int32FromInt32(0) {
					v44 = 0
					goto _45
				}
				v46 = v43
				v47 = v46
				if v47 != 0 {
					v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
				} else {
					v33 = int32(32)
				}
				v48 = v33
				goto _49
			_49:
				lzeros = v48
				*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
				v51 = v46
				v34 = int32(24) - lzeros
				x = libc.Uint32FromInt32(v51)
				r = libc.Uint32FromInt32(v34)
				m = libc.Uint32FromInt32(-v34)
				if v34 == libc.Int32FromInt32(0) {
					v53 = v51
					goto _54
				} else {
					if v34 < libc.Int32FromInt32(0) {
						v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
						goto _54
					} else {
						v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
						goto _54
					}
				}
			_54:
				*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
				if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
					y = int32(32768)
				} else {
					y = int32(46214)
				}
				y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
				y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
				v44 = y
				goto _45
			_45:
				SNR_Q7 = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(v44)<<libc.Int32FromInt32(6))) * int64(int16(SNR_Q7)) >> libc.Int32FromInt32(16))
			}
			input_tilt = int32(int64(input_tilt) + int64(tiltWeights[b1])*int64(int16(SNR_Q7))>>libc.Int32FromInt32(16))
		} else {
			NrgToNoiseRatio_Q8[b1] = int32(256)
		}
		goto _42
	_42:
		;
		b1 = b1 + 1
	}
	/* Mean-of-squares */
	sumSquared = sumSquared / libc.Int32FromInt32(VAD_N_BANDS) /* Q14 */
	/* Root-mean-square approximation, scale to dBs, and write to output pointer */
	v43 = sumSquared
	if v43 <= libc.Int32FromInt32(0) {
		v44 = 0
		goto _57
	}
	v46 = v43
	v47 = v46
	if v47 != 0 {
		v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
	} else {
		v33 = int32(32)
	}
	v48 = v33
	goto _61
_61:
	lzeros = v48
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v51 = v46
	v34 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v51)
	r = libc.Uint32FromInt32(v34)
	m = libc.Uint32FromInt32(-v34)
	if v34 == libc.Int32FromInt32(0) {
		v53 = v51
		goto _66
	} else {
		if v34 < libc.Int32FromInt32(0) {
			v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _66
		} else {
			v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _66
		}
	}
_66:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
		y = int32(32768)
	} else {
		y = int32(46214)
	}
	y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
	y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
	v44 = y
	goto _57
_57:
	pSNR_dB_Q7 = int32(int16(libc.Int32FromInt32(3) * v44)) /* Q7 */
	/*********************************/
	/* Speech Probability Estimation */
	/*********************************/
	SA_Q15 = Opus_silk_sigm_Q15(tls, int32(int64(libc.Int32FromInt32(VAD_SNR_FACTOR_Q16))*int64(int16(pSNR_dB_Q7))>>libc.Int32FromInt32(16))-int32(VAD_NEGATIVE_OFFSET_Q5))
	/**************************/
	/* Frequency Tilt Measure */
	/**************************/
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Finput_tilt_Q15 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_sigm_Q15(tls, input_tilt)-libc.Int32FromInt32(16384)) << libc.Int32FromInt32(1))
	/**************************************************/
	/* Scale the sigmoid output based on power levels */
	/**************************************************/
	speech_nrg = 0
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* Accumulate signal-without-noise energies, higher frequency bands have more weight */
		speech_nrg = speech_nrg + (b1+int32(1))*(((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 8)))[b1]-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)))>>int32(4))
		goto _67
	_67:
		;
		b1 = b1 + 1
	}
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == int32(20)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz {
		speech_nrg = speech_nrg >> int32(1)
	}
	/* Power scaling */
	if speech_nrg <= 0 {
		SA_Q15 = SA_Q15 >> int32(1)
	} else {
		if speech_nrg < int32(16384) {
			speech_nrg = libc.Int32FromUint32(libc.Uint32FromInt32(speech_nrg) << libc.Int32FromInt32(16))
			/* square-root */
			v43 = speech_nrg
			if v43 <= libc.Int32FromInt32(0) {
				v44 = 0
				goto _70
			}
			v46 = v43
			v47 = v46
			if v47 != 0 {
				v33 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v47)))
			} else {
				v33 = int32(32)
			}
			v48 = v33
			goto _74
		_74:
			lzeros = v48
			*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
			v51 = v46
			v34 = int32(24) - lzeros
			x = libc.Uint32FromInt32(v51)
			r = libc.Uint32FromInt32(v34)
			m = libc.Uint32FromInt32(-v34)
			if v34 == libc.Int32FromInt32(0) {
				v53 = v51
				goto _79
			} else {
				if v34 < libc.Int32FromInt32(0) {
					v53 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
					goto _79
				} else {
					v53 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
					goto _79
				}
			}
		_79:
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v53 & int32(0x7f)
			if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
				y = int32(32768)
			} else {
				y = int32(46214)
			}
			y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
			y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
			v44 = y
			goto _70
		_70:
			speech_nrg = v44
			SA_Q15 = int32(int64(libc.Int32FromInt32(32768)+speech_nrg) * int64(int16(SA_Q15)) >> libc.Int32FromInt32(16))
		}
	}
	/* Copy the resulting speech activity in Q8 */
	v33 = SA_Q15 >> int32(7)
	v34 = int32(silk_uint8_MAX1)
	if v33 < v34 {
		v37 = v33
	} else {
		v37 = v34
	}
	v35 = v37
	goto _83
_83:
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fspeech_activity_Q8 = v35
	/***********************************/
	/* Energy Level and SNR estimation */
	/***********************************/
	/* Smoothing coefficient */
	smooth_coef_Q16 = int32(int64(libc.Int32FromInt32(VAD_SNR_SMOOTH_COEF_Q18)) * int64(int16(int32(int64(SA_Q15)*int64(int16(SA_Q15))>>libc.Int32FromInt32(16)))) >> libc.Int32FromInt32(16))
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fframe_length == int32(10)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz {
		smooth_coef_Q16 = smooth_coef_Q16 >> int32(1)
	}
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		/* compute smoothed energy-to-noise ratio per band */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4))) + int64(NrgToNoiseRatio_Q8[b1]-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)))*int64(int16(smooth_coef_Q16))>>libc.Int32FromInt32(16))
		/* signal to noise ratio in dB per band */
		SNR_Q7 = int32(3) * (Opus_silk_lin2log(tls, *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4))) - libc.Int32FromInt32(8)*libc.Int32FromInt32(128))
		/* quality = sigmoid( 0.25 * ( SNR_dB - 16 ) ); */
		*(*int32)(unsafe.Pointer(psEncC + 4712 + uintptr(b1)*4)) = Opus_silk_sigm_Q15(tls, (SNR_Q7-libc.Int32FromInt32(16)*libc.Int32FromInt32(128))>>int32(4))
		goto _85
	_85:
		;
		b1 = b1 + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _87
	_87:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _89
_89:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/**************************/
//	/* Noise level estimation */
//	/**************************/

func Opus_silk_VAD_Init(tls *libc.TLS, psSilk_VAD uintptr) (r int32) {
	var b1, ret, v6 int32
	var v2, v3, v4 OpusT_opus_int32
	_, _, _, _, _, _ = b1, ret, v2, v3, v4, v6
	ret = 0
	/* reset state memory */
	libc.Xmemset(tls, psSilk_VAD, 0, libc.Uint64FromInt64(112))
	/* init noise levels */
	/* Initialize array with approx pink noise levels (psd proportional to inverse of frequency) */
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		v2 = libc.Int32FromInt32(VAD_NOISE_LEVELS_BIAS) / (b1 + libc.Int32FromInt32(1))
		v3 = int32(1)
		if v2 > v3 {
			v6 = v2
		} else {
			v6 = v3
		}
		v4 = v6
		goto _5
	_5:
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(b1)*4)) = v4
		goto _1
	_1:
		;
		b1 = b1 + 1
	}
	/* Initialize state */
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4)) = libc.Int32FromInt32(100) * *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(b1)*4))
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(b1)*4)) = libc.Int32FromInt32(silk_int32_MAX) / *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(b1)*4))
		goto _7
	_7:
		;
		b1 = b1 + 1
	}
	(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter = int32(15)
	/* init smoothed energy-to-noise ratio*/
	b1 = 0
	for {
		if !(b1 < int32(VAD_N_BANDS)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 40 + uintptr(b1)*4)) = libc.Int32FromInt32(100) * libc.Int32FromInt32(256) /* 100 * 256 --> 20 dB SNR */
		goto _8
	_8:
		;
		b1 = b1 + 1
	}
	return ret
}

// C documentation
//
//	/* Weighting factors for tilt measure */
var tiltWeights = [4]OpusT_opus_int32{
	0: int32(30000),
	1: int32(6000),
	2: -int32(12000),
	3: -int32(12000),
}

// C documentation
//
//	/***************************************/
//	/* Get the speech activity level in Q8 */
//	/***************************************/

func Opus_silk_VQ_WMat_EC_c(tls *libc.TLS, ind uintptr, res_nrg_Q15 uintptr, rate_dist_Q8 uintptr, gain_Q7 uintptr, XX_Q17 uintptr, xX_Q17 uintptr, cb_Q7 uintptr, cb_gain_Q7 uintptr, cl_Q5 uintptr, subfr_len int32, max_gain_Q7 OpusT_opus_int32, L int32) {
	var bits_res_Q8, bits_tot_Q8, penalty, sum1_Q15, sum2_Q24 OpusT_opus_int32
	var cb_row_Q7 uintptr
	var gain_tmp_Q7, k, v2 int32
	var neg_xX_Q24 [5]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _ = bits_res_Q8, bits_tot_Q8, cb_row_Q7, gain_tmp_Q7, k, neg_xX_Q24, penalty, sum1_Q15, sum2_Q24, v2
	/* Negate and convert to new Q domain */
	neg_xX_Q24[0] = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(xX_Q17))) << libc.Int32FromInt32(7))
	neg_xX_Q24[int32(1)] = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(xX_Q17 + 1*4))) << libc.Int32FromInt32(7))
	neg_xX_Q24[int32(2)] = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(xX_Q17 + 2*4))) << libc.Int32FromInt32(7))
	neg_xX_Q24[int32(3)] = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(xX_Q17 + 3*4))) << libc.Int32FromInt32(7))
	neg_xX_Q24[int32(4)] = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(xX_Q17 + 4*4))) << libc.Int32FromInt32(7))
	/* Loop over codebook */
	*(*OpusT_opus_int32)(unsafe.Pointer(rate_dist_Q8)) = int32(silk_int32_MAX)
	*(*OpusT_opus_int32)(unsafe.Pointer(res_nrg_Q15)) = int32(silk_int32_MAX)
	cb_row_Q7 = cb_Q7
	/* If things go really bad, at least *ind is set to something safe. */
	*(*OpusT_opus_int8)(unsafe.Pointer(ind)) = 0
	k = 0
	for {
		if !(k < L) {
			break
		}
		gain_tmp_Q7 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(cb_gain_Q7 + uintptr(k))))
		/* Weighted rate */
		/* Quantization error: 1 - 2 * xX * cb + cb' * XX * cb */
		sum1_Q15 = int32(float64(libc.Float64FromFloat64(1.001)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(15))) + libc.Float64FromFloat64(0.5))
		/* Penalty for too large gain */
		if gain_tmp_Q7-max_gain_Q7 > 0 {
			v2 = gain_tmp_Q7 - max_gain_Q7
		} else {
			v2 = 0
		}
		penalty = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << libc.Int32FromInt32(11))
		/* first row of XX_Q17 */
		sum2_Q24 = neg_xX_Q24[0] + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 1*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 1)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 2*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 2)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 3*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 3)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 4*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4)))
		sum2_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(sum2_Q24) << libc.Int32FromInt32(1))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7)))
		sum1_Q15 = int32(int64(sum1_Q15) + int64(sum2_Q24)*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7))))>>libc.Int32FromInt32(16))
		/* second row of XX_Q17 */
		sum2_Q24 = neg_xX_Q24[int32(1)] + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 7*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 2)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 8*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 3)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 9*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4)))
		sum2_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(sum2_Q24) << libc.Int32FromInt32(1))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 6*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 1)))
		sum1_Q15 = int32(int64(sum1_Q15) + int64(sum2_Q24)*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 1))))>>libc.Int32FromInt32(16))
		/* third row of XX_Q17 */
		sum2_Q24 = neg_xX_Q24[int32(2)] + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 13*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 3)))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 14*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4)))
		sum2_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(sum2_Q24) << libc.Int32FromInt32(1))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 12*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 2)))
		sum1_Q15 = int32(int64(sum1_Q15) + int64(sum2_Q24)*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 2))))>>libc.Int32FromInt32(16))
		/* fourth row of XX_Q17 */
		sum2_Q24 = neg_xX_Q24[int32(3)] + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 19*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4)))
		sum2_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(sum2_Q24) << libc.Int32FromInt32(1))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 18*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 3)))
		sum1_Q15 = int32(int64(sum1_Q15) + int64(sum2_Q24)*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 3))))>>libc.Int32FromInt32(16))
		/* last row of XX_Q17 */
		sum2_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(neg_xX_Q24[int32(4)]) << libc.Int32FromInt32(1))
		sum2_Q24 = sum2_Q24 + *(*OpusT_opus_int32)(unsafe.Pointer(XX_Q17 + 24*4))*int32(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4)))
		sum1_Q15 = int32(int64(sum1_Q15) + int64(sum2_Q24)*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(cb_row_Q7 + 4))))>>libc.Int32FromInt32(16))
		/* find best */
		if sum1_Q15 >= 0 {
			/* Translate residual energy to bits using high-rate assumption (6 dB ==> 1 bit/sample) */
			bits_res_Q8 = int32(int16(subfr_len)) * int32(int16(Opus_silk_lin2log(tls, sum1_Q15+penalty)-libc.Int32FromInt32(15)<<libc.Int32FromInt32(7)))
			/* In the following line we reduce the codelength component by half ("-1"); seems to slightly improve quality */
			bits_tot_Q8 = bits_res_Q8 + libc.Int32FromUint32(uint32(*(*OpusT_opus_uint8)(unsafe.Pointer(cl_Q5 + uintptr(k))))<<(libc.Int32FromInt32(3)-libc.Int32FromInt32(1)))
			if bits_tot_Q8 <= *(*OpusT_opus_int32)(unsafe.Pointer(rate_dist_Q8)) {
				*(*OpusT_opus_int32)(unsafe.Pointer(rate_dist_Q8)) = bits_tot_Q8
				*(*OpusT_opus_int32)(unsafe.Pointer(res_nrg_Q15)) = sum1_Q15 + penalty
				*(*OpusT_opus_int8)(unsafe.Pointer(ind)) = int8(k)
				*(*int32)(unsafe.Pointer(gain_Q7)) = gain_tmp_Q7
			}
		}
		/* Go to next cbk vector */
		cb_row_Q7 = cb_row_Q7 + uintptr(LTP_ORDER)
		goto _1
	_1:
		;
		k = k + 1
	}
}

const CELT_SIG_SCALE13 = 32768
const MAX_SUM_LOG_GAIN_DB2 = "250.0f"
const VARIABLE_HP_MAX_DELTA_FREQ1 = 0.4
const VARIABLE_HP_SMTH_COEF11 = 0.1
const silk_int16_MAX13 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* High-pass filter with cutoff frequency adaptation based on pitch lag statistics */

func Opus_silk_ana_filt_bank_1(tls *libc.TLS, in uintptr, S uintptr, outL uintptr, outH uintptr, N OpusT_opus_int32) {
	var N2, k, v2, v3 int32
	var X, Y, in32, out_1, out_2 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _ = N2, X, Y, in32, k, out_1, out_2, v2, v3
	N2 = N >> libc.Int32FromInt32(1)
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < N2) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k)*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for even input sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) + int64(Y)*int64(A_fb1_21)>>libc.Int32FromInt32(16))
		out_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for odd input sample, and add to output of previous section */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(A_fb1_20) >> libc.Int32FromInt32(16))
		out_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = in32 + X
		/* Add/subtract, convert back to int16 and store to output */
		if ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX17) {
			v2 = int32(silk_int16_MAX17)
		} else {
			if ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = ((out_2+out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(outL + uintptr(k)*2)) = int16(v2)
		if ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX17) {
			v2 = int32(silk_int16_MAX17)
		} else {
			if ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = ((out_2-out_1)>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(outH + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Second order ARMA filter, alternative implementation */

func Opus_silk_apply_sine_window_FLP(tls *libc.TLS, px_win uintptr, px uintptr, win_type int32, length int32) {
	var S0, S1, c, freq float32
	var k int32
	_, _, _, _, _ = S0, S1, c, freq, k
	if !(win_type == int32(1) || win_type == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+10797, __ccgo_ts+10846, int32(48))
	}
	/* Length must be multiple of 4 */
	if !(length&libc.Int32FromInt32(3) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10884, __ccgo_ts+10846, int32(51))
	}
	freq = libc.Float32FromFloat32(3.1415926536) / float32(length+libc.Int32FromInt32(1))
	/* Approximation of 2 * cos(f) */
	c = libc.Float32FromFloat32(2) - float32(freq*freq)
	/* Initialize state */
	if win_type < int32(2) {
		/* Start from 0 */
		S0 = libc.Float32FromFloat32(0)
		/* Approximation of sin(f) */
		S1 = freq
	} else {
		/* Start from 1 */
		S0 = libc.Float32FromFloat32(1)
		/* Approximation of cos(f) */
		S1 = float32(libc.Float32FromFloat32(0.5) * c)
	}
	/* Uses the recursive equation:   sin(n*f) = 2 * cos(f) * sin((n-1)*f) - sin((n-2)*f)   */
	/* 4 samples at a time */
	k = 0
	for {
		if !(k < length) {
			break
		}
		*(*float32)(unsafe.Pointer(px_win + uintptr(k+0)*4)) = float32(float32(*(*float32)(unsafe.Pointer(px + uintptr(k+0)*4))*libc.Float32FromFloat32(0.5)) * (S0 + S1))
		*(*float32)(unsafe.Pointer(px_win + uintptr(k+int32(1))*4)) = float32(*(*float32)(unsafe.Pointer(px + uintptr(k+int32(1))*4)) * S1)
		S0 = float32(c*S1) - S0
		*(*float32)(unsafe.Pointer(px_win + uintptr(k+int32(2))*4)) = float32(float32(*(*float32)(unsafe.Pointer(px + uintptr(k+int32(2))*4))*libc.Float32FromFloat32(0.5)) * (S1 + S0))
		*(*float32)(unsafe.Pointer(px_win + uintptr(k+int32(3))*4)) = float32(*(*float32)(unsafe.Pointer(px + uintptr(k+int32(3))*4)) * S0)
		S1 = float32(c*S0) - S1
		goto _1
	_1:
		;
		k = k + int32(4)
	}
}

const PI3 = "3.1415926536f"

// C documentation
//
//	/* Calculates correlation vector X'*t */

func Opus_silk_autocorrelation_FLP(tls *libc.TLS, results uintptr, inputData uintptr, inputDataSize int32, correlationCount int32, arch int32) {
	var i int32
	_ = i
	if correlationCount > inputDataSize {
		correlationCount = inputDataSize
	}
	i = 0
	for {
		if !(i < correlationCount) {
			break
		}
		_ = arch
		*(*float32)(unsafe.Pointer(results + uintptr(i)*4)) = float32(Opus_silk_inner_product_FLP_c(tls, inputData, inputData+uintptr(i)*4, inputDataSize-i))
		goto _1
	_1:
		;
		i = i + 1
	}
}

const FIND_LPC_COND_FAC1 = 1e-05
const LAMBDA_OFFSET2 = "1.2f"
const LAMBDA_QUANT_OFFSET2 = "0.8f"
const MAX_FRAME_SIZE = 384

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/* Compute reflection coefficients from input signal */

func Opus_silk_biquad_alt_stride1(tls *libc.TLS, in uintptr, B_Q28 uintptr, A_Q28 uintptr, S uintptr, out uintptr, len1 OpusT_opus_int32) {
	var A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, inval, out32_Q14 OpusT_opus_int32
	var k, v2, v3 int32
	_, _, _, _, _, _, _, _, _ = A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, inval, k, out32_Q14, v2, v3
	/* Negate A_Q28 values and split in two parts */
	A0_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) & int32(0x00003FFF)              /* lower part */
	A0_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) >> libc.Int32FromInt32(14)       /* upper part */
	A1_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) & int32(0x00003FFF)        /* lower part */
	A1_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) >> libc.Int32FromInt32(14) /* upper part */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* S[ 0 ], S[ 1 ]: Q12 */
		inval = int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2)))
		out32_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(int16(inval))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + (int32(int64(out32_Q14)*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(out32_Q14)*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(int16(inval))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = (int32(int64(out32_Q14)*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32_Q14)*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(int16(inval))>>libc.Int32FromInt32(16))
		/* Scale back to Q0 and saturate */
		if (out32_Q14+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX17) {
			v2 = int32(silk_int16_MAX17)
		} else {
			if (out32_Q14+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14 + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

func Opus_silk_biquad_alt_stride2_c(tls *libc.TLS, in uintptr, B_Q28 uintptr, A_Q28 uintptr, S uintptr, out uintptr, len1 OpusT_opus_int32) {
	var A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28 OpusT_opus_int32
	var k, v2, v3 int32
	var out32_Q14 [2]OpusT_opus_int32
	_, _, _, _, _, _, _, _ = A0_L_Q28, A0_U_Q28, A1_L_Q28, A1_U_Q28, k, out32_Q14, v2, v3
	/* Negate A_Q28 values and split in two parts */
	A0_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) & int32(0x00003FFF)              /* lower part */
	A0_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28)) >> libc.Int32FromInt32(14)       /* upper part */
	A1_L_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) & int32(0x00003FFF)        /* lower part */
	A1_U_Q28 = -*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4)) >> libc.Int32FromInt32(14) /* upper part */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* S[ 0 ], S[ 1 ], S[ 2 ], S[ 3 ]: Q12 */
		out32_Q14[0] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		out32_Q14[int32(1)] = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + (int32(int64(out32_Q14[0])*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) + (int32(int64(out32_Q14[int32(1)])*int64(int16(A0_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(out32_Q14[0])*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))) + int64(out32_Q14[int32(1)])*int64(int16(A0_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = (int32(int64(out32_Q14[0])*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = (int32(int64(out32_Q14[int32(1)])*int64(int16(A1_L_Q28))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(14)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32_Q14[0])*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))) + int64(out32_Q14[int32(1)])*int64(int16(A1_U_Q28))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+0)*2)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))>>libc.Int32FromInt32(16))
		/* Scale back to Q0 and saturate */
		if (out32_Q14[0]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX17) {
			v2 = int32(silk_int16_MAX17)
		} else {
			if (out32_Q14[0]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14[0] + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+0)*2)) = int16(v2)
		if (out32_Q14[int32(1)]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) > int32(silk_int16_MAX17) {
			v2 = int32(silk_int16_MAX17)
		} else {
			if (out32_Q14[int32(1)]+libc.Int32FromInt32(1)<<libc.Int32FromInt32(14)-int32(1))>>int32(14) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_Q14[int32(1)] + libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) - int32(1)) >> int32(14)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX18 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Chirp (bandwidth expand) LP AR filter.
//	   This logic is reused in _celt_lpc(). Any bug fixes should also be applied there. */

func Opus_silk_burg_modified_FLP(tls *libc.TLS, A uintptr, x uintptr, minInvGain float32, subfr_length int32, nb_subfr int32, D int32, arch int32) (r float32) {
	bp := tls.Alloc(784)
	defer tls.Free(784)
	var Af [24]float64
	var Atmp, C0, invGain, nrg_b, nrg_f, num, rc, tmp1, tmp2, v3 float64
	var k, n, reached_max_gain, s int32
	var x_ptr uintptr
	var _ /* CAb at bp+584 */ [25]float64
	var _ /* CAf at bp+384 */ [25]float64
	var _ /* C_first_row at bp+0 */ [24]float64
	var _ /* C_last_row at bp+192 */ [24]float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Af, Atmp, C0, invGain, k, n, nrg_b, nrg_f, num, rc, reached_max_gain, s, tmp1, tmp2, x_ptr, v3
	if !(subfr_length*nb_subfr <= libc.Int32FromInt32(MAX_FRAME_SIZE)) {
		Opus_celt_fatal(tls, __ccgo_ts+11705, __ccgo_ts+11765, int32(56))
	}
	/* Compute autocorrelations, added over subframes */
	C0 = Opus_silk_energy_FLP(tls, x, nb_subfr*subfr_length)
	libc.Xmemset(tls, bp, 0, libc.Uint64FromInt32(SILK_MAX_ORDER_LPC)*libc.Uint64FromInt64(8))
	s = 0
	for {
		if !(s < nb_subfr) {
			break
		}
		x_ptr = x + uintptr(s*subfr_length)*4
		n = int32(1)
		for {
			if !(n < D+int32(1)) {
				break
			}
			_ = arch
			*(*float64)(unsafe.Pointer(bp + uintptr(n-int32(1))*8)) += Opus_silk_inner_product_FLP_c(tls, x_ptr, x_ptr+uintptr(n)*4, subfr_length-n)
			goto _2
		_2:
			;
			n = n + 1
		}
		goto _1
	_1:
		;
		s = s + 1
	}
	libc.Xmemcpy(tls, bp+192, bp, libc.Uint64FromInt32(SILK_MAX_ORDER_LPC)*libc.Uint64FromInt64(8))
	/* Initialize */
	v3 = C0 + float64(libc.Float64FromFloat32(1e-05)*C0) + libc.Float64FromFloat32(1e-09)
	(*(*[25]float64)(unsafe.Pointer(bp + 384)))[0] = v3
	(*(*[25]float64)(unsafe.Pointer(bp + 584)))[0] = v3
	invGain = libc.Float64FromFloat32(1)
	reached_max_gain = 0
	n = 0
	for {
		if !(n < D) {
			break
		}
		/* Update first row of correlation matrix (without first element) */
		/* Update last row of correlation matrix (without last element, stored in reversed order) */
		/* Update C * Af */
		/* Update C * flipud(Af) (stored in reversed order) */
		s = 0
		for {
			if !(s < nb_subfr) {
				break
			}
			x_ptr = x + uintptr(s*subfr_length)*4
			tmp1 = float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(n)*4)))
			tmp2 = float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(subfr_length-n-int32(1))*4)))
			k = 0
			for {
				if !(k < n) {
					break
				}
				*(*float64)(unsafe.Pointer(bp + uintptr(k)*8)) -= float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(n)*4)) * *(*float32)(unsafe.Pointer(x_ptr + uintptr(n-k-int32(1))*4)))
				*(*float64)(unsafe.Pointer(bp + 192 + uintptr(k)*8)) -= float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(subfr_length-n-int32(1))*4)) * *(*float32)(unsafe.Pointer(x_ptr + uintptr(subfr_length-n+k)*4)))
				Atmp = Af[k]
				tmp1 = tmp1 + float64(float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(n-k-int32(1))*4)))*Atmp)
				tmp2 = tmp2 + float64(float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(subfr_length-n+k)*4)))*Atmp)
				goto _6
			_6:
				;
				k = k + 1
			}
			k = 0
			for {
				if !(k <= n) {
					break
				}
				*(*float64)(unsafe.Pointer(bp + 384 + uintptr(k)*8)) -= float64(tmp1 * float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(n-k)*4))))
				*(*float64)(unsafe.Pointer(bp + 584 + uintptr(k)*8)) -= float64(tmp2 * float64(*(*float32)(unsafe.Pointer(x_ptr + uintptr(subfr_length-n+k-int32(1))*4))))
				goto _7
			_7:
				;
				k = k + 1
			}
			goto _5
		_5:
			;
			s = s + 1
		}
		tmp1 = (*(*[24]float64)(unsafe.Pointer(bp)))[n]
		tmp2 = (*(*[24]float64)(unsafe.Pointer(bp + 192)))[n]
		k = 0
		for {
			if !(k < n) {
				break
			}
			Atmp = Af[k]
			tmp1 = tmp1 + float64((*(*[24]float64)(unsafe.Pointer(bp + 192)))[n-k-int32(1)]*Atmp)
			tmp2 = tmp2 + float64((*(*[24]float64)(unsafe.Pointer(bp)))[n-k-int32(1)]*Atmp)
			goto _8
		_8:
			;
			k = k + 1
		}
		(*(*[25]float64)(unsafe.Pointer(bp + 384)))[n+int32(1)] = tmp1
		(*(*[25]float64)(unsafe.Pointer(bp + 584)))[n+int32(1)] = tmp2
		/* Calculate nominator and denominator for the next order reflection (parcor) coefficient */
		num = (*(*[25]float64)(unsafe.Pointer(bp + 584)))[n+int32(1)]
		nrg_b = (*(*[25]float64)(unsafe.Pointer(bp + 584)))[0]
		nrg_f = (*(*[25]float64)(unsafe.Pointer(bp + 384)))[0]
		k = 0
		for {
			if !(k < n) {
				break
			}
			Atmp = Af[k]
			num = num + float64((*(*[25]float64)(unsafe.Pointer(bp + 584)))[n-k]*Atmp)
			nrg_b = nrg_b + float64((*(*[25]float64)(unsafe.Pointer(bp + 584)))[k+int32(1)]*Atmp)
			nrg_f = nrg_f + float64((*(*[25]float64)(unsafe.Pointer(bp + 384)))[k+int32(1)]*Atmp)
			goto _9
		_9:
			;
			k = k + 1
		}
		_ = nrg_f > libc.Float64FromFloat64(0)
		_ = nrg_b > libc.Float64FromFloat64(0)
		/* Calculate the next order reflection (parcor) coefficient */
		rc = float64(-libc.Float64FromFloat64(2)*num) / (nrg_f + nrg_b)
		_ = rc > -libc.Float64FromFloat64(1) && rc < float64(1)
		/* Update inverse prediction gain */
		tmp1 = float64(invGain * (float64(1) - float64(rc*rc)))
		if tmp1 <= float64(minInvGain) {
			/* Max prediction gain exceeded; set reflection coefficient such that max prediction gain is exactly hit */
			rc = libc.Xsqrt(tls, float64(1)-float64(minInvGain)/invGain)
			if num > libc.Float64FromInt32(0) {
				/* Ensure adjusted reflection coefficients has the original sign */
				rc = -rc
			}
			invGain = float64(minInvGain)
			reached_max_gain = int32(1)
		} else {
			invGain = tmp1
		}
		/* Update the AR coefficients */
		k = 0
		for {
			if !(k < (n+int32(1))>>int32(1)) {
				break
			}
			tmp1 = Af[k]
			tmp2 = Af[n-k-int32(1)]
			Af[k] = tmp1 + float64(rc*tmp2)
			Af[n-k-int32(1)] = tmp2 + float64(rc*tmp1)
			goto _10
		_10:
			;
			k = k + 1
		}
		Af[n] = rc
		if reached_max_gain != 0 {
			/* Reached max prediction gain; set remaining coefficients to zero and exit loop */
			k = n + int32(1)
			for {
				if !(k < D) {
					break
				}
				Af[k] = float64(0)
				goto _11
			_11:
				;
				k = k + 1
			}
			break
		}
		/* Update C * Af and C * Ab */
		k = 0
		for {
			if !(k <= n+int32(1)) {
				break
			}
			tmp1 = (*(*[25]float64)(unsafe.Pointer(bp + 384)))[k]
			*(*float64)(unsafe.Pointer(bp + 384 + uintptr(k)*8)) += float64(rc * (*(*[25]float64)(unsafe.Pointer(bp + 584)))[n-k+int32(1)])
			*(*float64)(unsafe.Pointer(bp + 584 + uintptr(n-k+int32(1))*8)) += float64(rc * tmp1)
			goto _12
		_12:
			;
			k = k + 1
		}
		goto _4
	_4:
		;
		n = n + 1
	}
	if reached_max_gain != 0 {
		/* Convert to silk_float */
		k = 0
		for {
			if !(k < D) {
				break
			}
			*(*float32)(unsafe.Pointer(A + uintptr(k)*4)) = float32(-Af[k])
			goto _13
		_13:
			;
			k = k + 1
		}
		/* Subtract energy of preceding samples from C0 */
		s = 0
		for {
			if !(s < nb_subfr) {
				break
			}
			C0 = C0 - Opus_silk_energy_FLP(tls, x+uintptr(s*subfr_length)*4, D)
			goto _14
		_14:
			;
			s = s + 1
		}
		/* Approximate residual energy */
		nrg_f = float64(C0 * invGain)
	} else {
		/* Compute residual energy and store coefficients as silk_float */
		nrg_f = (*(*[25]float64)(unsafe.Pointer(bp + 384)))[0]
		tmp1 = float64(1)
		k = 0
		for {
			if !(k < D) {
				break
			}
			Atmp = Af[k]
			nrg_f = nrg_f + float64((*(*[25]float64)(unsafe.Pointer(bp + 384)))[k+int32(1)]*Atmp)
			tmp1 = tmp1 + float64(Atmp*Atmp)
			*(*float32)(unsafe.Pointer(A + uintptr(k)*4)) = float32(-Atmp)
			goto _15
		_15:
			;
			k = k + 1
		}
		nrg_f = nrg_f - float64(float64(libc.Float64FromFloat32(1e-05)*C0)*tmp1)
	}
	/* Return residual energy */
	return float32(nrg_f)
}

// C documentation
//
//	/* Chirp (bw expand) LP AR filter */

func Opus_silk_bwexpander(tls *libc.TLS, ar uintptr, d int32, chirp_Q16 OpusT_opus_int32) {
	var chirp_minus_one_Q16 OpusT_opus_int32
	var i int32
	_, _ = chirp_minus_one_Q16, i
	chirp_minus_one_Q16 = chirp_Q16 - int32(65536)
	/* NB: Dont use silk_SMULWB, instead of silk_RSHIFT_ROUND( silk_MUL(), 16 ), below.  */
	/* Bias in silk_SMULWB can lead to unstable filters                                */
	i = 0
	for {
		if !(i < d-int32(1)) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(i)*2)) = int16((chirp_Q16*int32(*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(i)*2)))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
		chirp_Q16 = chirp_Q16 + (chirp_Q16*chirp_minus_one_Q16>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(d-int32(1))*2)) = int16((chirp_Q16*int32(*(*OpusT_opus_int16)(unsafe.Pointer(ar + uintptr(d-int32(1))*2)))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
}

const __restrict_arr = "restrict"

/* config_ccgo.h
 *
 * ccgo build configuration for producing a pure-Go libopus translation.
 *
 * We include the project's generated config.h, then disable all CPU RTCD and
 * x86 intrinsics so only portable C paths are used.
 */

/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Get CPU Info by asm method */

/* Get CPU Info by c method */
/* #undef CPU_INFO_BY_C */

/* Custom modes */
/* #undef CUSTOM_MODES */

/* Disable DNN debug float */

/* Disable dot product instructions */
/* #undef DISABLE_DOT_PROD */

/* Do not build the float API */
/* #undef DISABLE_FLOAT_API */

/* Disable bitstream fixes from RFC 8251 */
/* #undef DISABLE_UPDATE_DRAFT */

/* Assertions */
/* #undef ENABLE_ASSERTIONS */

/* Deep PLC */
/* #undef ENABLE_DEEP_PLC */

/* DRED */
/* #undef ENABLE_DRED */

/* Hardening */

/* LOSSGEN */
/* #undef ENABLE_LOSSGEN */

/* Opus custom API */
/* #undef ENABLE_OPUS_CUSTOM_API */

/* Enable Opus Speech Coding Enhancement */
/* #undef ENABLE_OSCE */

/* Enable Opus Speech Coding Enhancement Blind BWE */
/* #undef ENABLE_OSCE_BWE */

/* Enable dumping of OSCE training data */
/* #undef ENABLE_OSCE_TRAINING_DATA */

/* Scalable quality extension */
/* #undef ENABLE_QEXT */

/* 24-bit internal resolution for fixed-point */

/* Debug fixed-point implementation */
/* #undef FIXED_DEBUG */

/* Compile as fixed-point (for machines without a fast enough FPU) */
/* #undef FIXED_POINT */

/* Float approximations */

/* Fuzzing */
/* #undef FUZZING */

/* Define to 1 if you have the <alloca.h> header file. */
/* #undef HAVE_ALLOCA_H */

/* NE10 library is installed on host. Make sure it is on target! */
/* #undef HAVE_ARM_NE10 */

/* Define to 1 if you have the <dlfcn.h> header file. */

/* Define to 1 if you have the `elf_aux_info' function. */
/* #undef HAVE_ELF_AUX_INFO */

/* Define to 1 if you have the <inttypes.h> header file. */

/* Define to 1 if you have the `lrint' function. */

/* Define to 1 if you have the `lrintf' function. */

/* Define to 1 if you have the <stdint.h> header file. */

/* Define to 1 if you have the <stdio.h> header file. */

/* Define to 1 if you have the <stdlib.h> header file. */

/* Define to 1 if you have the <strings.h> header file. */

/* Define to 1 if you have the <string.h> header file. */

/* Define to 1 if you have the <sys/stat.h> header file. */

/* Define to 1 if you have the <sys/types.h> header file. */

/* Define to 1 if you have the <unistd.h> header file. */

/* Define to 1 if you have the `__malloc_hook' function. */
/* #undef HAVE___MALLOC_HOOK */

/* Define to the sub-directory where libtool stores uninstalled libraries. */

/* Make use of ARM asm optimization */
/* #undef OPUS_ARM_ASM */

/* Use generic ARMv4 inline asm optimizations */
/* #undef OPUS_ARM_INLINE_ASM */

/* Use ARMv5E inline asm optimizations */
/* #undef OPUS_ARM_INLINE_EDSP */

/* Use ARMv6 inline asm optimizations */
/* #undef OPUS_ARM_INLINE_MEDIA */

/* Use ARM NEON inline asm optimizations */
/* #undef OPUS_ARM_INLINE_NEON */

/* Compiler supports Aarch64 DOTPROD Intrinsics */
/* #undef OPUS_ARM_MAY_HAVE_DOTPROD */

/* Define if assembler supports EDSP instructions */
/* #undef OPUS_ARM_MAY_HAVE_EDSP */

/* Define if assembler supports ARMv6 media instructions */
/* #undef OPUS_ARM_MAY_HAVE_MEDIA */

/* Define if compiler supports NEON instructions */
/* #undef OPUS_ARM_MAY_HAVE_NEON */

/* Compiler supports ARMv7/Aarch64 Neon Intrinsics */
/* #undef OPUS_ARM_MAY_HAVE_NEON_INTR */

/* Define if binary requires Aarch64 Neon Intrinsics */
/* #undef OPUS_ARM_PRESUME_AARCH64_NEON_INTR */

/* Define if binary requires Aarch64 dotprod Intrinsics */
/* #undef OPUS_ARM_PRESUME_DOTPROD */

/* Define if binary requires EDSP instruction support */
/* #undef OPUS_ARM_PRESUME_EDSP */

/* Define if binary requires ARMv6 media instruction support */
/* #undef OPUS_ARM_PRESUME_MEDIA */

/* Define if binary requires NEON instruction support */
/* #undef OPUS_ARM_PRESUME_NEON */

/* Define if binary requires NEON intrinsics support */
/* #undef OPUS_ARM_PRESUME_NEON_INTR */

/* This is a build of OPUS */

/* Run bit-exactness checks between optimized and C implementations */
/* #undef OPUS_CHECK_ASM */

/* Use run-time CPU capabilities detection */

/* Compiler supports X86 AVX2 Intrinsics */

/* Compiler supports X86 SSE Intrinsics */

/* Compiler supports X86 SSE2 Intrinsics */

/* Compiler supports X86 SSE4.1 Intrinsics */

/* Define if binary requires AVX2 intrinsics support */
/* #undef OPUS_X86_PRESUME_AVX2 */

/* Define if binary requires SSE intrinsics support */

/* Define if binary requires SSE2 intrinsics support */

/* Define if binary requires SSE4.1 intrinsics support */
/* #undef OPUS_X86_PRESUME_SSE4_1 */

/* Define to the address where bug reports for this package should be sent. */

/* Define to the full name of this package. */

/* Define to the full name and version of this package. */

/* Define to the one symbol short name of this package. */

/* Define to the home page for this package. */

/* Define to the version of this package. */

/* Define to 1 if all of the C90 standard headers exist (not just the ones
   required in a freestanding environment). This macro is provided for
   backward compatibility; new code need not use it. */

/* Make use of alloca */
/* #undef USE_ALLOCA */

/* Use C99 variable-size arrays */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
/* #undef inline */

/* Define to the equivalent of the C99 'restrict' keyword, or to
   nothing if this is not supported.  Do not define if restrict is
   supported directly.  */
/* Work around a bug in Sun C++: it does not support _Restrict or
   __restrict__, even though the corresponding Sun C compiler ends up with
   "#define restrict _Restrict" or "#define restrict __restrict__" in the
   previous line.  Perhaps some future version of Sun C++ will work with
   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */

/* Enable ccgo-specific concurrency-safe pseudostack plumbing.
 * See celt/stack_alloc.h for details.
 */

/* Temp allocation mode: NONTHREADSAFE_PSEUDOSTACK is fastest, but the upstream
 * implementation uses global variables. We'll patch the generated Go to store
 * the pseudostack state in per-decoder TLS (no shared globals).
 */

/* Disable runtime CPU detection tables and any x86 intrinsic paths.
 *
 * Important: many libopus headers use `#if defined(OPUS_...)` checks, so we
 * must UNDEFINE these macros (not merely set them to 0).
 */

/* Also request that intrinsics are not used even if headers try. */
/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

type OpusT_prevent_empty_translation_unit_warning = int32

func Opus_silk_bwexpander_32(tls *libc.TLS, ar uintptr, d int32, chirp_Q16 OpusT_opus_int32) {
	var chirp_minus_one_Q16 OpusT_opus_int32
	var i int32
	_, _ = chirp_minus_one_Q16, i
	chirp_minus_one_Q16 = chirp_Q16 - int32(65536)
	i = 0
	for {
		if !(i < d-int32(1)) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(i)*4)) = int32(int64(chirp_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(i)*4))) >> libc.Int32FromInt32(16))
		chirp_Q16 = chirp_Q16 + (chirp_Q16*chirp_minus_one_Q16>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1))+int32(1))>>int32(1)
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(d-int32(1))*4)) = int32(int64(chirp_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(ar + uintptr(d-int32(1))*4))) >> libc.Int32FromInt32(16))
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Chirp (bandwidth expand) LP AR filter */

func Opus_silk_bwexpander_FLP(tls *libc.TLS, ar uintptr, d int32, chirp float32) {
	var cfac float32
	var i int32
	_, _ = cfac, i
	cfac = chirp
	i = 0
	for {
		if !(i < d-int32(1)) {
			break
		}
		*(*float32)(unsafe.Pointer(ar + uintptr(i)*4)) *= cfac
		cfac = cfac * chirp
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*float32)(unsafe.Pointer(ar + uintptr(d-int32(1))*4)) *= cfac
}

// C documentation
//
//	/* sum of squares of a silk_float array, with result as double */

func Opus_silk_control_SNR(tls *libc.TLS, psEncC uintptr, TargetRate_bps OpusT_opus_int32) (r int32) {
	var bound, id, v1 int32
	var snr_table uintptr
	_, _, _, _ = bound, id, snr_table, v1
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FTargetRate_bps = TargetRate_bps
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(2) {
		TargetRate_bps = TargetRate_bps - (int32(2000) + (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz/int32(16))
	}
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz == int32(8) {
		bound = int32(107)
		snr_table = uintptr(unsafe.Pointer(&silk_TargetRate_NB_21))
	} else {
		if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz == int32(12) {
			bound = int32(155)
			snr_table = uintptr(unsafe.Pointer(&silk_TargetRate_MB_21))
		} else {
			bound = int32(191)
			snr_table = uintptr(unsafe.Pointer(&silk_TargetRate_WB_21))
		}
	}
	id = (TargetRate_bps + int32(200)) / int32(400)
	if id-int32(10) < bound-int32(1) {
		v1 = id - int32(10)
	} else {
		v1 = bound - int32(1)
	}
	id = v1
	if id <= 0 {
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FSNR_dB_Q7 = 0
	} else {
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FSNR_dB_Q7 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(snr_table + uintptr(id)))) * int32(21)
	}
	return SILK_NO_ERROR
}

const CELT_SIG_SCALE15 = 32768
const silk_int16_MAX17 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

/* Copyright (c) 2010 Xiph.Org Foundation
 * Copyright (c) 2013 Parrot */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// C documentation
//
//	/*********************************/
//	/* Initialize Silk Encoder state */
//	/*********************************/

func Opus_silk_control_audio_bandwidth(tls *libc.TLS, psEncC uintptr, encControl uintptr) (r int32) {
	var fs_Hz OpusT_opus_int32
	var fs_kHz, orig_kHz, v1 int32
	_, _, _, _ = fs_Hz, fs_kHz, orig_kHz, v1
	orig_kHz = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
	/* Handle a bandwidth-switching reset where we need to be aware what the last sampling rate was. */
	if orig_kHz == 0 {
		orig_kHz = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fsaved_fs_kHz
	}
	fs_kHz = orig_kHz
	fs_Hz = int32(int16(fs_kHz)) * int32(int16(libc.Int32FromInt32(1000)))
	if fs_Hz == 0 {
		/* Encoder has just been initialized */
		if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FdesiredInternal_fs_Hz < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FAPI_fs_Hz {
			v1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FdesiredInternal_fs_Hz
		} else {
			v1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FAPI_fs_Hz
		}
		fs_Hz = v1
		fs_kHz = fs_Hz / libc.Int32FromInt32(1000)
	} else {
		if fs_Hz > (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FAPI_fs_Hz || fs_Hz > (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FmaxInternal_fs_Hz || fs_Hz < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FminInternal_fs_Hz {
			/* Make sure internal rate is not higher than external rate or maximum allowed, or lower than minimum allowed */
			fs_Hz = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FAPI_fs_Hz
			if fs_Hz < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FmaxInternal_fs_Hz {
				v1 = fs_Hz
			} else {
				v1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FmaxInternal_fs_Hz
			}
			fs_Hz = v1
			if fs_Hz > (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FminInternal_fs_Hz {
				v1 = fs_Hz
			} else {
				v1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FminInternal_fs_Hz
			}
			fs_Hz = v1
			fs_kHz = fs_Hz / libc.Int32FromInt32(1000)
		} else {
			/* State machine for the internal sampling rate switching */
			if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Ftransition_frame_no >= libc.Int32FromInt32(TRANSITION_TIME_MS)/(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)) {
				/* Stop transition phase */
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = 0
			}
			if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fallow_bandwidth_switch != 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FopusCanSwitch != 0 {
				/* Check if we should switch down */
				if int32(int16(orig_kHz))*int32(int16(libc.Int32FromInt32(1000))) > (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FdesiredInternal_fs_Hz {
					/* Switch down */
					if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode == 0 {
						/* New transition */
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Ftransition_frame_no = libc.Int32FromInt32(TRANSITION_TIME_MS) / (libc.Int32FromInt32(SUB_FRAME_LENGTH_MS) * libc.Int32FromInt32(MAX_NB_SUBFR))
						/* Reset transition filter state */
						libc.Xmemset(tls, psEncC+16, 0, libc.Uint64FromInt64(8))
					}
					if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FopusCanSwitch != 0 {
						/* Stop transition phase */
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = 0
						/* Switch to a lower sample frequency */
						if orig_kHz == int32(16) {
							v1 = int32(12)
						} else {
							v1 = int32(8)
						}
						fs_kHz = v1
					} else {
						if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Ftransition_frame_no <= 0 {
							(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FswitchReady = int32(1)
							/* Make room for redundancy */
							*(*int32)(unsafe.Pointer(encControl + 60)) -= (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxBits * int32(5) / ((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms + int32(5))
						} else {
							/* Direction: down (at double speed) */
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = -int32(2)
						}
					}
				} else {
					/* Check if we should switch up */
					if int32(int16(orig_kHz))*int32(int16(libc.Int32FromInt32(1000))) < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FdesiredInternal_fs_Hz {
						/* Switch up */
						if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FopusCanSwitch != 0 {
							/* Switch to a higher sample frequency */
							if orig_kHz == int32(8) {
								v1 = int32(12)
							} else {
								v1 = int32(16)
							}
							fs_kHz = v1
							/* New transition */
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Ftransition_frame_no = 0
							/* Reset transition filter state */
							libc.Xmemset(tls, psEncC+16, 0, libc.Uint64FromInt64(8))
							/* Direction: up */
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = int32(1)
						} else {
							if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode == 0 {
								(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FswitchReady = int32(1)
								/* Make room for redundancy */
								*(*int32)(unsafe.Pointer(encControl + 60)) -= (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxBits * int32(5) / ((*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms + int32(5))
							} else {
								/* Direction: up */
								(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = int32(1)
							}
						}
					} else {
						if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode < 0 {
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FsLP.Fmode = int32(1)
						}
					}
				}
			}
		}
	}
	return fs_kHz
}

const MAX_SUM_LOG_GAIN_DB1 = 250

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

func Opus_silk_control_encoder(tls *libc.TLS, psEnc uintptr, encControl uintptr, allow_bw_switch int32, channelNb int32, force_fs_kHz int32) (r int32) {
	var fs_kHz, ret int32
	_, _ = fs_kHz, ret
	ret = 0
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FuseDTX = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseDTX
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FuseCBR = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseCBR
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FmaxInternal_fs_Hz = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FminInternal_fs_Hz = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FdesiredInternal_fs_Hz = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FuseInBandFEC = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseInBandFEC
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnChannelsAPI = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnChannelsInternal = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fallow_bandwidth_switch = allow_bw_switch
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FchannelNb = channelNb
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fcontrolled_since_last_payload != 0 && (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprefillFlag == 0 {
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz != (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fprev_API_fs_Hz && (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz > 0 {
			/* Change in API sampling rate in the middle of encoding a packet */
			ret = ret + silk_setup_resamplers(tls, psEnc, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz)
		}
		return ret
	}
	/* Beyond this point we know that there are no previously coded frames in the payload buffer */
	/********************************************/
	/* Determine internal sampling rate         */
	/********************************************/
	fs_kHz = Opus_silk_control_audio_bandwidth(tls, psEnc, encControl)
	if force_fs_kHz != 0 {
		fs_kHz = force_fs_kHz
	}
	/********************************************/
	/* Prepare resampler and buffered data      */
	/********************************************/
	ret = ret + silk_setup_resamplers(tls, psEnc, fs_kHz)
	/********************************************/
	/* Set internal sampling frequency          */
	/********************************************/
	ret = ret + silk_setup_fs(tls, psEnc, fs_kHz, (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms)
	/********************************************/
	/* Set encoding complexity                  */
	/********************************************/
	ret = ret + silk_setup_complexity(tls, psEnc, (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity)
	/********************************************/
	/* Set packet loss rate measured by farend  */
	/********************************************/
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FPacketLoss_perc = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpacketLossPercentage
	/********************************************/
	/* Set LBRR usage                           */
	/********************************************/
	ret = ret + silk_setup_LBRR(tls, psEnc, encControl)
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fcontrolled_since_last_payload = int32(1)
	return ret
}

func Opus_silk_corrMatrix_FLP(tls *libc.TLS, x uintptr, L int32, Order int32, XX uintptr, arch int32) {
	var energy float64
	var j, lag int32
	var ptr1, ptr2 uintptr
	_, _, _, _, _ = energy, j, lag, ptr1, ptr2
	ptr1 = x + uintptr(Order-int32(1))*4        /* First sample of column 0 of X */
	energy = Opus_silk_energy_FLP(tls, ptr1, L) /* X[:,0]'*X[:,0] */
	*(*float32)(unsafe.Pointer(XX + uintptr(libc.Int32FromInt32(0)*Order+libc.Int32FromInt32(0))*4)) = float32(energy)
	j = int32(1)
	for {
		if !(j < Order) {
			break
		}
		/* Calculate X[:,j]'*X[:,j] */
		energy = energy + float64(float32(*(*float32)(unsafe.Pointer(ptr1 + uintptr(-j)*4))**(*float32)(unsafe.Pointer(ptr1 + uintptr(-j)*4)))-float32(*(*float32)(unsafe.Pointer(ptr1 + uintptr(L-j)*4))**(*float32)(unsafe.Pointer(ptr1 + uintptr(L-j)*4))))
		*(*float32)(unsafe.Pointer(XX + uintptr(j*Order+j)*4)) = float32(energy)
		goto _1
	_1:
		;
		j = j + 1
	}
	ptr2 = x + uintptr(Order-int32(2))*4 /* First sample of column 1 of X */
	lag = int32(1)
	for {
		if !(lag < Order) {
			break
		}
		/* Calculate X[:,0]'*X[:,lag] */
		_ = arch
		energy = Opus_silk_inner_product_FLP_c(tls, ptr1, ptr2, L)
		*(*float32)(unsafe.Pointer(XX + uintptr(lag*Order+libc.Int32FromInt32(0))*4)) = float32(energy)
		*(*float32)(unsafe.Pointer(XX + uintptr(libc.Int32FromInt32(0)*Order+lag)*4)) = float32(energy)
		/* Calculate X[:,j]'*X[:,j + lag] */
		j = int32(1)
		for {
			if !(j < Order-lag) {
				break
			}
			energy = energy + float64(float32(*(*float32)(unsafe.Pointer(ptr1 + uintptr(-j)*4))**(*float32)(unsafe.Pointer(ptr2 + uintptr(-j)*4)))-float32(*(*float32)(unsafe.Pointer(ptr1 + uintptr(L-j)*4))**(*float32)(unsafe.Pointer(ptr2 + uintptr(L-j)*4))))
			*(*float32)(unsafe.Pointer(XX + uintptr((lag+j)*Order+j)*4)) = float32(energy)
			*(*float32)(unsafe.Pointer(XX + uintptr(j*Order+(lag+j))*4)) = float32(energy)
			goto _3
		_3:
			;
			j = j + 1
		}
		ptr2 -= 4 /* Next column of X */
		goto _2
	_2:
		;
		lag = lag + 1
	}
}

const LBRR_SPEECH_ACTIVITY_THRES1 = 0.3
const SPEECH_ACTIVITY_DTX_THRES3 = 0.05
const WARPING_MULTIPLIER2 = "0.015f"

func Opus_silk_corrVector_FLP(tls *libc.TLS, x uintptr, t uintptr, L int32, Order int32, Xt uintptr, arch int32) {
	var lag int32
	var ptr1 uintptr
	_, _ = lag, ptr1
	ptr1 = x + uintptr(Order-int32(1))*4 /* Points to first sample of column 0 of X: X[:,0] */
	lag = 0
	for {
		if !(lag < Order) {
			break
		}
		/* Calculate X[:,lag]'*t */
		_ = arch
		*(*float32)(unsafe.Pointer(Xt + uintptr(lag)*4)) = float32(Opus_silk_inner_product_FLP_c(tls, ptr1, t, L))
		ptr1 -= 4 /* Next column of X */
		goto _1
	_1:
		;
		lag = lag + 1
	}
}

// C documentation
//
//	/* Calculates correlation matrix X'*X */

func Opus_silk_decode_core(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, xq uintptr, pulses uintptr, arch int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var A_Q12, B_Q14, _saved_stack, pexc_Q14, pred_lag_ptr, pres_Q14, pxq, res_Q14, sLPC_Q14, sLTP, sLTP_Q15, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var Gain_Q10, LPC_pred_Q10, LTP_pred_Q13, a32_nrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, err_Q32, gain_adj_Q16, inv_gain_Q31, offset_Q10, rand_seed, result, result1, v103, v106, v107, v110, v117, v118, v121 OpusT_opus_int32
	var NLSF_interpolation_flag, a_headrm, b_headrm, b_headrm1, i, k, lag, lshift, lshift1, sLTP_buf_idx, signalType, start_idx, v104, v105, v109, v112, v113, v114, v115, v116, v119, v120, v124, v125, v129 int32
	var _ /* A_Q12_tmp at bp+0 */ [16]OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = A_Q12, B_Q14, Gain_Q10, LPC_pred_Q10, LTP_pred_Q13, NLSF_interpolation_flag, _saved_stack, a32_nrm, a_headrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, b_headrm, b_headrm1, err_Q32, gain_adj_Q16, i, inv_gain_Q31, k, lag, lshift, lshift1, offset_Q10, pexc_Q14, pred_lag_ptr, pres_Q14, pxq, rand_seed, res_Q14, result, result1, sLPC_Q14, sLTP, sLTP_Q15, sLTP_buf_idx, signalType, st, start_idx, v1, v103, v104, v105, v106, v107, v109, v11, v110, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v124, v125, v129, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	lag = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 != libc.Int32FromInt32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6656, int32(58))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6656, int32(59))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	sLTP_Q15 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6656, int32(60))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	res_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Work around a clang bug (verified with clang 6.0 through clang 20.1.0) that causes the last
	   memset to be flagged as an invalid read by valgrind (not caught by asan). */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _80
_80:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _84
_84:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _88
_88:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _92
_92:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6656, int32(66))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _96
_96:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _100
_100:
	sLPC_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length+libc.Int32FromInt32(MAX_LPC_ORDER))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	offset_Q10 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)>>int32(1))*4 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType)*2)))
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2) < libc.Int32FromInt32(1)<<libc.Int32FromInt32(2) {
		NLSF_interpolation_flag = int32(1)
	} else {
		NLSF_interpolation_flag = 0
	}
	/* Decode excitation */
	rand_seed = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FSeed)
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			break
		}
		rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(rand_seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
		*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(pulses + uintptr(i)*2)))) << libc.Int32FromInt32(14))
		if *(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) > 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) -= libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10) << libc.Int32FromInt32(4)
		} else {
			if *(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) < 0 {
				*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) += libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10) << libc.Int32FromInt32(4)
			}
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) += offset_Q10 << int32(4)
		if rand_seed < 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(psDec + 4 + uintptr(i)*4))
		}
		rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(rand_seed) + libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(pulses + uintptr(i)*2))))
		goto _101
	_101:
		;
		i = i + 1
	}
	/* Copy LPC state */
	libc.Xmemcpy(tls, sLPC_Q14, psDec+1284, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	pexc_Q14 = psDec + 4
	pxq = xq
	sLTP_buf_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length
	/* Loop over subframes */
	k = 0
	for {
		if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		pres_Q14 = res_Q14
		A_Q12 = psDecCtrl + 32 + uintptr(k>>int32(1))*32
		/* Preload LPC coefficients to array on stack. Gives small performance gain */
		libc.Xmemcpy(tls, bp, A_Q12, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
		B_Q14 = psDecCtrl + 96 + uintptr(k*int32(LTP_ORDER))*2
		signalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
		Gain_Q10 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4)) >> int32(6)
		v103 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
		v104 = int32(47)
		_ = v103 != libc.Int32FromInt32(0)
		_ = v104 > libc.Int32FromInt32(0)
		if v103 > 0 {
			v105 = v103
		} else {
			v105 = -v103
		}
		v106 = v105
		if v106 != 0 {
			v109 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v106)))
		} else {
			v109 = int32(32)
		}
		v107 = v109
		goto _108
	_108:
		b_headrm1 = v107 - int32(1)
		b32_nrm1 = libc.Int32FromUint32(libc.Uint32FromInt32(v103) << b_headrm1)
		b32_inv1 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm1 >> libc.Int32FromInt32(16))
		result1 = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv1) << libc.Int32FromInt32(16))
		err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm1)*int64(int16(b32_inv1))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
		result1 = int32(int64(result1) + int64(err_Q32)*int64(b32_inv1)>>libc.Int32FromInt32(16))
		lshift1 = int32(61) - b_headrm1 - v104
		if lshift1 <= libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift1 > int32(silk_int32_MAX)>>-lshift1 {
				if result1 > libc.Int32FromUint32(0x80000000)>>-lshift1 {
					v113 = libc.Int32FromUint32(0x80000000) >> -lshift1
				} else {
					if result1 < int32(silk_int32_MAX)>>-lshift1 {
						v114 = int32(silk_int32_MAX) >> -lshift1
					} else {
						v114 = result1
					}
					v113 = v114
				}
				v112 = v113
			} else {
				if result1 > int32(silk_int32_MAX)>>-lshift1 {
					v115 = int32(silk_int32_MAX) >> -lshift1
				} else {
					if result1 < libc.Int32FromUint32(0x80000000)>>-lshift1 {
						v116 = libc.Int32FromUint32(0x80000000) >> -lshift1
					} else {
						v116 = result1
					}
					v115 = v116
				}
				v112 = v115
			}
			v110 = libc.Int32FromUint32(libc.Uint32FromInt32(v112) << -lshift1)
			goto _111
		} else {
			if lshift1 < libc.Int32FromInt32(32) {
				v110 = result1 >> lshift1
				goto _111
			} else {
				v110 = 0
				goto _111
			}
		}
	_111:
		inv_gain_Q31 = v110
		/* Calculate gain adjustment factor */
		if *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4)) != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 {
			v103 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16
			v106 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
			v104 = int32(16)
			_ = v106 != libc.Int32FromInt32(0)
			_ = v104 >= libc.Int32FromInt32(0)
			if v103 > 0 {
				v105 = v103
			} else {
				v105 = -v103
			}
			v107 = v105
			if v107 != 0 {
				v109 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v107)))
			} else {
				v109 = int32(32)
			}
			v110 = v109
			goto _123
		_123:
			a_headrm = v110 - int32(1)
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v103) << a_headrm)
			if v106 > 0 {
				v112 = v106
			} else {
				v112 = -v106
			}
			v117 = v112
			if v117 != 0 {
				v113 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v117)))
			} else {
				v113 = int32(32)
			}
			v118 = v113
			goto _128
		_128:
			b_headrm = v118 - int32(1)
			b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v106) << b_headrm)
			b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
			result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
			a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
			result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
			lshift = int32(29) + a_headrm - b_headrm - v104
			if lshift < libc.Int32FromInt32(0) {
				if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
					if result > libc.Int32FromUint32(0x80000000)>>-lshift {
						v115 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						if result < int32(silk_int32_MAX)>>-lshift {
							v116 = int32(silk_int32_MAX) >> -lshift
						} else {
							v116 = result
						}
						v115 = v116
					}
					v114 = v115
				} else {
					if result > int32(silk_int32_MAX)>>-lshift {
						v119 = int32(silk_int32_MAX) >> -lshift
					} else {
						if result < libc.Int32FromUint32(0x80000000)>>-lshift {
							v120 = libc.Int32FromUint32(0x80000000) >> -lshift
						} else {
							v120 = result
						}
						v119 = v120
					}
					v114 = v119
				}
				v121 = libc.Int32FromUint32(libc.Uint32FromInt32(v114) << -lshift)
				goto _131
			} else {
				if lshift < libc.Int32FromInt32(32) {
					v121 = result >> lshift
					goto _131
				} else {
					v121 = 0
					goto _131
				}
			}
		_131:
			gain_adj_Q16 = v121
			/* Scale short term state */
			i = 0
			for {
				if !(i < int32(MAX_LPC_ORDER)) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _137
			_137:
				;
				i = i + 1
			}
		} else {
			gain_adj_Q16 = libc.Int32FromInt32(1) << libc.Int32FromInt32(16)
		}
		/* Save inv_gain */
		_ = inv_gain_Q31 != libc.Int32FromInt32(0)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(psDecCtrl + 16 + uintptr(k)*4))
		/* Avoid abrupt transition from voiced PLC to unvoiced normal decoding */
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) && int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) != int32(TYPE_VOICED) && k < libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2) {
			libc.Xmemset(tls, B_Q14, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
			*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*2)) = int16(int32(float64(libc.Float64FromFloat64(0.25)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5)))
			signalType = int32(TYPE_VOICED)
			*(*int32)(unsafe.Pointer(psDecCtrl + uintptr(k)*4)) = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev
		}
		if signalType == int32(TYPE_VOICED) {
			/* Voiced */
			lag = *(*int32)(unsafe.Pointer(psDecCtrl + uintptr(k)*4))
			/* Re-whitening */
			if k == 0 || k == int32(2) && NLSF_interpolation_flag != 0 {
				/* Rewhiten with new A coefs */
				start_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - lag - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
				if !(start_idx > libc.Int32FromInt32(0)) {
					Opus_celt_fatal(tls, __ccgo_ts+6678, __ccgo_ts+6656, int32(150))
				}
				if k == int32(2) {
					libc.Xmemcpy(tls, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*2, xq, libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*libc.Uint64FromInt64(2))
				}
				Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(start_idx)*2, psDec+1348+uintptr(start_idx+k*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*2, A_Q12, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-start_idx, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, arch)
				/* After rewhitening the LTP state is unscaled */
				if k == 0 {
					/* Do LTP downscaling to reduce inter-packet dependency */
					inv_gain_Q31 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(inv_gain_Q31)*int64(int16((*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
				}
				i = 0
				for {
					if !(i < lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4)) = int32(int64(inv_gain_Q31) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-i-int32(1))*2))) >> libc.Int32FromInt32(16))
					goto _138
				_138:
					;
					i = i + 1
				}
			} else {
				/* Update LTP state when Gain changes */
				if gain_adj_Q16 != libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) {
					i = 0
					for {
						if !(i < lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)) {
							break
						}
						*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx-i-int32(1))*4))) >> libc.Int32FromInt32(16))
						goto _139
					_139:
						;
						i = i + 1
					}
				}
			}
		}
		/* Long-term prediction */
		if signalType == int32(TYPE_VOICED) {
			/* Set up pointer */
			pred_lag_ptr = sLTP_Q15 + uintptr(sLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
			i = 0
			for {
				if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
					break
				}
				/* Unrolled loop */
				/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
				LTP_pred_Q13 = int32(2)
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 1*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 2*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 3*2)))>>libc.Int32FromInt32(16))
				LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 4*2)))>>libc.Int32FromInt32(16))
				pred_lag_ptr += 4
				/* Generate LPC excitation */
				*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(pexc_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(LTP_pred_Q13)<<libc.Int32FromInt32(1))
				/* Update states */
				*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(sLTP_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))) << libc.Int32FromInt32(1))
				sLTP_buf_idx = sLTP_buf_idx + 1
				goto _140
			_140:
				;
				i = i + 1
			}
		} else {
			pres_Q14 = pexc_Q14
		}
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
				break
			}
			/* Short-term prediction */
			if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(10) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16)) {
				Opus_celt_fatal(tls, __ccgo_ts+6589, __ccgo_ts+6656, int32(205))
			}
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[0])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(1)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(2)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(3)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(4)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(5)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(6)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(7)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(8)])>>libc.Int32FromInt32(16))
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(9)])>>libc.Int32FromInt32(16))
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order == int32(16) {
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(11))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(10)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(12))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(11)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(13))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(12)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(14))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(13)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(15))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(14)])>>libc.Int32FromInt32(16))
				LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i-int32(16))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(15)])>>libc.Int32FromInt32(16))
			}
			/* Add prediction to LPC excitation */
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v105 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v109 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v109 = LPC_pred_Q10
				}
				v105 = v109
			}
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v105)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v113 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v114 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v114 = LPC_pred_Q10
					}
					v113 = v114
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v113)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
					v112 = libc.Int32FromUint32(0x80000000)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v115 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v116 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v116 = LPC_pred_Q10
						}
						v115 = v116
					}
					v112 = *(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v115)<<libc.Int32FromInt32(4))
				}
				v104 = v112
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v120 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v124 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v124 = LPC_pred_Q10
					}
					v120 = v124
				}
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v120)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
					v119 = int32(silk_int32_MAX)
				} else {
					if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
						v125 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
					} else {
						if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
							v129 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
						} else {
							v129 = LPC_pred_Q10
						}
						v125 = v129
					}
					v119 = *(*OpusT_opus_int32)(unsafe.Pointer(pres_Q14 + uintptr(i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v125)<<libc.Int32FromInt32(4))
				}
				v104 = v119
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v104
			/* Scale with gain */
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX3) {
				v104 = int32(silk_int16_MAX3)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v105 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v105 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14 + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v104 = v105
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(pxq + uintptr(i)*2)) = int16(v104)
			goto _141
		_141:
			;
			i = i + 1
		}
		/* Update LPC filter state */
		libc.Xmemcpy(tls, sLPC_Q14, sLPC_Q14+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		pexc_Q14 = pexc_Q14 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*4
		pxq = pxq + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length)*2
		goto _102
	_102:
		;
		k = k + 1
	}
	/* Save LPC state */
	libc.Xmemcpy(tls, psDec+1284, sLPC_Q14, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _158
	_158:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _160
_160:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

const silk_int16_MAX4 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/****************/
//	/* Decode frame */
//	/****************/

func Opus_silk_decode_frame(tls *libc.TLS, psDec uintptr, psRangeDec uintptr, pOut uintptr, pN uintptr, lostFlag int32, condCoding int32, arch int32) (r int32) {
	var L, mv_len, ret int32
	var _saved_stack, psDecCtrl, pulses, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = L, _saved_stack, mv_len, psDecCtrl, pulses, ret, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	ret = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	L = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(140)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6710, int32(64))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(140) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	psDecCtrl = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(140)/libc.Uint64FromInt64(1)))
	(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = 0
	/* Safety checks */
	if !(L > 0 && L <= libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+6733, __ccgo_ts+6710, int32(68))
	}
	if lostFlag == FLAG_DECODE_NORMAL || lostFlag == int32(FLAG_DECODE_LBRR) && *(*int32)(unsafe.Pointer(psDec + 2432 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FnFramesDecoded)*4)) == int32(1) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _30
		_30:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _32
	_32:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _34
		_34:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v7 = st
		goto _36
	_36:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v9 = libc.Xmalloc(tls, uint64(16))
			goto _38
		_38:
			st = v9
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v11 = st
		goto _40
	_40:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v13 = libc.Xmalloc(tls, uint64(16))
			goto _42
		_42:
			st = v13
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v15 = st
		goto _44
	_44:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6710, int32(78))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v17 = libc.Xmalloc(tls, uint64(16))
			goto _46
		_46:
			st = v17
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v19 = st
		goto _48
	_48:
		*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1))) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v21 = libc.Xmalloc(tls, uint64(16))
			goto _50
		_50:
			st = v21
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v23 = st
		goto _52
	_52:
		pulses = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((L+libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)) & ^(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)-libc.Int32FromInt32(1)))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
		/*********************************************/
		/* Decode quantization indices of side info  */
		/*********************************************/
		Opus_silk_decode_indices(tls, psDec, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FnFramesDecoded, lostFlag, condCoding)
		/*********************************************/
		/* Decode quantization indices of excitation */
		/*********************************************/
		Opus_silk_decode_pulses(tls, psRangeDec, pulses, int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType), int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType), (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)
		/********************************************/
		/* Decode parameters and pulse signal       */
		/********************************************/
		Opus_silk_decode_parameters(tls, psDec, psDecCtrl, condCoding)
		/********************************************************/
		/* Run inverse NSQ                                      */
		/********************************************************/
		Opus_silk_decode_core(tls, psDec, psDecCtrl, pOut, pulses, arch)
		/*************************/
		/* Update output buffer. */
		/*************************/
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length >= (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			Opus_celt_fatal(tls, __ccgo_ts+6782, __ccgo_ts+6710, int32(104))
		}
		mv_len = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
		libc.Xmemmove(tls, psDec+1348, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*2, libc.Uint64FromInt32(mv_len)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+1348+uintptr(mv_len)*2, pOut, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*libc.Uint64FromInt64(2))
		/********************************************************/
		/* Update PLC state                                     */
		/********************************************************/
		Opus_silk_PLC(tls, psDec, psDecCtrl, pOut, 0, arch)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt = 0
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType >= 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType <= int32(2)) {
			Opus_celt_fatal(tls, __ccgo_ts+6845, __ccgo_ts+6710, int32(127))
		}
		/* A frame has been decoded without errors */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = 0
	} else {
		/* Handle packet loss by extrapolation */
		Opus_silk_PLC(tls, psDec, psDecCtrl, pOut, int32(1), arch)
		/*************************/
		/* Update output buffer. */
		/*************************/
		if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length >= (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			Opus_celt_fatal(tls, __ccgo_ts+6782, __ccgo_ts+6710, int32(145))
		}
		mv_len = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length
		libc.Xmemmove(tls, psDec+1348, psDec+1348+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*2, libc.Uint64FromInt32(mv_len)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, psDec+1348+uintptr(mv_len)*2, pOut, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*libc.Uint64FromInt64(2))
	}
	/************************************************/
	/* Comfort noise generation / estimation        */
	/************************************************/
	Opus_silk_CNG(tls, psDec, psDecCtrl, pOut, L)
	/****************************************************************/
	/* Ensure smooth connection of extrapolated and good frames     */
	/****************************************************************/
	Opus_silk_PLC_glue_frames(tls, psDec, pOut, L)
	/* Update some decoder state variables */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev = *(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1))*4))
	/* Set output frame length */
	*(*OpusT_opus_int32)(unsafe.Pointer(pN)) = L
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/* Decode parameters from payload */

func Opus_silk_decode_indices(tls *libc.TLS, psDec uintptr, psRangeDec uintptr, FrameIndex int32, decode_LBRR int32, condCoding int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var Ix, decode_absolute_lagIndex, delta_lagIndex, i, k int32
	var v1 uintptr
	var _ /* ec_ix at bp+0 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+32 */ [16]OpusT_opus_uint8
	_, _, _, _, _, _ = Ix, decode_absolute_lagIndex, delta_lagIndex, i, k, v1
	/*******************************************/
	/* Decode signal type and quantizer offset */
	/*******************************************/
	if decode_LBRR != 0 || *(*int32)(unsafe.Pointer(psDec + 2416 + uintptr(FrameIndex)*4)) != 0 {
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_type_offset_VAD_iCDF)), uint32(8)) + int32(2)
	} else {
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_type_offset_no_VAD_iCDF)), uint32(8))
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType = int8(Ix >> libc.Int32FromInt32(1))
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FquantOffsetType = int8(Ix & libc.Int32FromInt32(1))
	/****************/
	/* Decode gains */
	/****************/
	/* First subframe */
	if condCoding == int32(CODE_CONDITIONALLY) {
		/* Conditional coding */
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856)) = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8)))
	} else {
		/* Independent coding, in two stages: MSB bits followed by 3 LSBs */
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856)) = int8(libc.Int32FromUint32(libc.Uint32FromInt32(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_gain_iCDF))+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)*8, uint32(8))) << libc.Int32FromInt32(3)))
		v1 = psDec + 2856
		*(*OpusT_opus_int8)(unsafe.Pointer(v1)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v1))) + int32(int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF)), uint32(8)))))
	}
	/* Remaining subframes */
	i = int32(1)
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + uintptr(i))) = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8)))
		goto _2
	_2:
		;
		i = i + 1
	}
	/**********************/
	/* Decode LSF Indices */
	/**********************/
	*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8)) = int8(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).FCB1_iCDF+uintptr(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)>>int32(1)*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).FnVectors)), uint32(8)))
	Opus_silk_NLSF_unpack(tls, bp, bp+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8))))
	if !(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Forder) == (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
		Opus_celt_fatal(tls, __ccgo_ts+6920, __ccgo_ts+6982, int32(82))
	}
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Forder)) {
			break
		}
		Ix = Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)).Fec_iCDF+uintptr((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]), uint32(8))
		if Ix == 0 {
			Ix = Ix - Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
		} else {
			if Ix == libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE) {
				Ix = Ix + Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
			}
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 8 + uintptr(i+int32(1)))) = int8(Ix - libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE))
		goto _3
	_3:
		;
		i = i + 1
	}
	/* Decode LSF interpolation factor */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_NLSF_interpolation_factor_iCDF)), uint32(8)))
	} else {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(4)
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/*********************/
		/* Decode pitch lags */
		/*********************/
		/* Get lag index */
		decode_absolute_lagIndex = int32(1)
		if condCoding == int32(CODE_CONDITIONALLY) && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevSignalType == int32(TYPE_VOICED) {
			/* Decode Delta index */
			delta_lagIndex = int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pitch_delta_iCDF)), uint32(8))))
			if delta_lagIndex > 0 {
				delta_lagIndex = delta_lagIndex - int32(9)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex = int16(int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevLagIndex) + delta_lagIndex)
				decode_absolute_lagIndex = 0
			}
		}
		if decode_absolute_lagIndex != 0 {
			/* Absolute decoding */
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex = int16(int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pitch_lag_iCDF)), uint32(8)))) * ((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz >> int32(1)))
			v1 = psDec + 2856 + 26
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + int32(int16(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF, uint32(8)))))
		}
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevLagIndex = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex
		/* Get contour index */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FcontourIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF, uint32(8)))
		/********************/
		/* Decode LTP gains */
		/********************/
		/* Decode PERIndex value */
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_LTP_per_index_iCDF)), uint32(8)))
		k = 0
		for {
			if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 4 + uintptr(k))) = int8(Opus_ec_dec_icdf(tls, psRangeDec, Opus_silk_LTP_gain_iCDF_ptrs[(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex], uint32(8)))
			goto _5
		_5:
			;
			k = k + 1
		}
		/**********************/
		/* Decode LTP scaling */
		/**********************/
		if condCoding == CODE_INDEPENDENTLY {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_LTPscale_iCDF)), uint32(8)))
		} else {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex = 0
		}
	}
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fec_prevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
	/***************/
	/* Decode seed */
	/***************/
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FSeed = int8(Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF)), uint32(8)))
}

// C documentation
//
//	/*********************************************/
//	/* Decode quantization indices of excitation */
//	/*********************************************/

func Opus_silk_decode_parameters(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, condCoding int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var Ix, i, k int32
	var cbk_ptr_Q7 uintptr
	var _ /* pNLSF0_Q15 at bp+32 */ [16]OpusT_opus_int16
	var _ /* pNLSF_Q15 at bp+0 */ [16]OpusT_opus_int16
	_, _, _, _ = Ix, cbk_ptr_Q7, i, k
	/* Dequant Gains */
	Opus_silk_gains_dequant(tls, psDecCtrl+16, psDec+2856, psDec+2312, libc.BoolInt32(condCoding == int32(CODE_CONDITIONALLY)), (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
	/****************/
	/* Decode NLSFs */
	/****************/
	Opus_silk_NLSF_decode(tls, bp, psDec+2856+8, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB)
	/* Convert NLSF parameters to AR prediction filter coefficients */
	Opus_silk_NLSF2A(tls, psDecCtrl+32+1*32, bp, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
	/* If just reset, e.g., because internal Fs changed, do not allow interpolation */
	/* improves the case of packet loss in the first frame after a switch           */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset == int32(1) {
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2 = int8(4)
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2) < int32(4) {
		/* Calculation of the interpolated NLSF0 vector from the interpolation factor, */
		/* the previous NLSF1, and the current NLSF1                                   */
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			(*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 32)))[i] = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2))) + int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FNLSFInterpCoef_Q2)*(int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i])-int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDec + 2344 + uintptr(i)*2))))>>int32(2))
			goto _1
		_1:
			;
			i = i + 1
		}
		/* Convert NLSF parameters to AR prediction filter coefficients */
		Opus_silk_NLSF2A(tls, psDecCtrl+32, bp+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch)
	} else {
		/* Copy LPC coefficients for first half from second half */
		libc.Xmemcpy(tls, psDecCtrl+32, psDecCtrl+32+1*32, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	}
	libc.Xmemcpy(tls, psDec+2344, bp, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	/* After a packet loss do BWE of LPC coefs */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt != 0 {
		Opus_silk_bwexpander(tls, psDecCtrl+32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(BWE_AFTER_LOSS_Q16))
		Opus_silk_bwexpander(tls, psDecCtrl+32+1*32, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(BWE_AFTER_LOSS_Q16))
	}
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/*********************/
		/* Decode pitch lags */
		/*********************/
		/* Decode pitch values */
		Opus_silk_decode_pitch(tls, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FlagIndex, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FcontourIndex, psDecCtrl, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
		/* Decode Codebook Index */
		cbk_ptr_Q7 = Opus_silk_LTP_vq_ptrs_Q7[(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex] /* set pointer to start of codebook */
		k = 0
		for {
			if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
				break
			}
			Ix = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psDec + 2856 + 4 + uintptr(k))))
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(psDecCtrl + 96 + uintptr(k*int32(LTP_ORDER)+i)*2)) = int16(libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(cbk_ptr_Q7 + uintptr(Ix*int32(LTP_ORDER)+i)))) << libc.Int32FromInt32(7)))
				goto _3
			_3:
				;
				i = i + 1
			}
			goto _2
		_2:
			;
			k = k + 1
		}
		/**********************/
		/* Decode LTP scaling */
		/**********************/
		Ix = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FLTP_scaleIndex)
		(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = int32(Opus_silk_LTPScales_table_Q14[Ix])
	} else {
		libc.Xmemset(tls, psDecCtrl, 0, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)*libc.Uint64FromInt64(4))
		libc.Xmemset(tls, psDecCtrl+96, 0, libc.Uint64FromInt32(libc.Int32FromInt32(LTP_ORDER)*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)*libc.Uint64FromInt64(2))
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FPERIndex = 0
		(*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14 = 0
	}
}

// C documentation
//
//	/* Decode side-information parameters from payload */

func Opus_silk_decode_pitch(tls *libc.TLS, lagIndex OpusT_opus_int16, contourIndex OpusT_opus_int8, pitch_lags uintptr, Fs_kHz int32, nb_subfr int32) {
	var Lag_CB_ptr uintptr
	var cbk_size, k, lag, max_lag, min_lag, v2, v3, v4, v5, v6 int32
	_, _, _, _, _, _, _, _, _, _, _ = Lag_CB_ptr, cbk_size, k, lag, max_lag, min_lag, v2, v3, v4, v5, v6
	if Fs_kHz == int32(8) {
		if nb_subfr == int32(PE_MAX_NB_SUBFR) {
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2))
			cbk_size = int32(PE_NB_CBKS_STAGE2_EXT)
		} else {
			if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
				Opus_celt_fatal(tls, __ccgo_ts+9912, __ccgo_ts+9963, int32(54))
			}
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2_10_ms))
			cbk_size = int32(PE_NB_CBKS_STAGE2_10MS)
		}
	} else {
		if nb_subfr == int32(PE_MAX_NB_SUBFR) {
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3))
			cbk_size = int32(PE_NB_CBKS_STAGE3_MAX)
		} else {
			if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
				Opus_celt_fatal(tls, __ccgo_ts+9912, __ccgo_ts+9963, int32(63))
			}
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3_10_ms))
			cbk_size = int32(PE_NB_CBKS_STAGE3_10MS)
		}
	}
	min_lag = int32(int16(libc.Int32FromInt32(PE_MIN_LAG_MS))) * int32(int16(Fs_kHz))
	max_lag = int32(int16(libc.Int32FromInt32(PE_MAX_LAG_MS))) * int32(int16(Fs_kHz))
	lag = min_lag + int32(lagIndex)
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		*(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) = lag + int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k*cbk_size+int32(contourIndex)))))
		if min_lag > max_lag {
			if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) > min_lag {
				v3 = min_lag
			} else {
				if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) < max_lag {
					v4 = max_lag
				} else {
					v4 = *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4))
				}
				v3 = v4
			}
			v2 = v3
		} else {
			if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) > max_lag {
				v5 = max_lag
			} else {
				if *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) < min_lag {
					v6 = min_lag
				} else {
					v6 = *(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4))
				}
				v5 = v6
			}
			v2 = v5
		}
		*(*int32)(unsafe.Pointer(pitch_lags + uintptr(k)*4)) = v2
		goto _1
	_1:
		;
		k = k + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func Opus_silk_decode_pulses(tls *libc.TLS, psRangeDec uintptr, pulses uintptr, signalType int32, quantOffsetType int32, frame_length int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var RateLevelIndex, abs_q, i, iter, j, k, nLS int32
	var cdf_ptr, pulses_ptr uintptr
	var nLshifts [20]int32
	var _ /* sum_pulses at bp+0 */ [20]int32
	_, _, _, _, _, _, _, _, _, _ = RateLevelIndex, abs_q, cdf_ptr, i, iter, j, k, nLS, nLshifts, pulses_ptr
	/*********************/
	/* Decode rate level */
	/*********************/
	RateLevelIndex = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_rate_levels_iCDF))+uintptr(signalType>>int32(1))*9, uint32(8))
	/* Calculate number of shell blocks */
	_ = libc.Int32FromInt32(1)<<libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH) == libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)
	iter = frame_length >> libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	if iter*int32(SHELL_CODEC_FRAME_LENGTH) < frame_length {
		if !(frame_length == libc.Int32FromInt32(12)*libc.Int32FromInt32(10)) {
			Opus_celt_fatal(tls, __ccgo_ts+7007, __ccgo_ts+7049, int32(59))
		} /* Make sure only happens for 10 ms @ 12 kHz */
		iter = iter + 1
	}
	/***************************************************/
	/* Sum-Weighted-Pulses Decoding                    */
	/***************************************************/
	cdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF)) + uintptr(RateLevelIndex)*18
	i = 0
	for {
		if !(i < iter) {
			break
		}
		nLshifts[i] = 0
		(*(*[20]int32)(unsafe.Pointer(bp)))[i] = Opus_ec_dec_icdf(tls, psRangeDec, cdf_ptr, uint32(8))
		/* LSB indication */
		for (*(*[20]int32)(unsafe.Pointer(bp)))[i] == libc.Int32FromInt32(SILK_MAX_PULSES)+libc.Int32FromInt32(1) {
			nLshifts[i] = nLshifts[i] + 1
			/* When we've already got 10 LSBs, we shift the table to not allow (SILK_MAX_PULSES + 1) */
			(*(*[20]int32)(unsafe.Pointer(bp)))[i] = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF))+uintptr(libc.Int32FromInt32(N_RATE_LEVELS)-libc.Int32FromInt32(1))*18+libc.BoolUintptr(nLshifts[i] == libc.Int32FromInt32(10)), uint32(8))
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	/***************************************************/
	/* Shell decoding                                  */
	/***************************************************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if (*(*[20]int32)(unsafe.Pointer(bp)))[i] > 0 {
			Opus_silk_shell_decoder(tls, pulses+uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2, psRangeDec, (*(*[20]int32)(unsafe.Pointer(bp)))[i])
		} else {
			libc.Xmemset(tls, pulses+uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2, 0, libc.Uint64FromInt32(SHELL_CODEC_FRAME_LENGTH)*libc.Uint64FromInt64(2))
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	/***************************************************/
	/* LSB Decoding                                    */
	/***************************************************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if nLshifts[i] > 0 {
			nLS = nLshifts[i]
			pulses_ptr = pulses + uintptr(int32(int16(i))*int32(int16(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))))*2
			k = 0
			for {
				if !(k < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				abs_q = int32(*(*OpusT_opus_int16)(unsafe.Pointer(pulses_ptr + uintptr(k)*2)))
				j = 0
				for {
					if !(j < nLS) {
						break
					}
					abs_q = libc.Int32FromUint32(libc.Uint32FromInt32(abs_q) << libc.Int32FromInt32(1))
					abs_q = abs_q + Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_lsb_iCDF)), uint32(8))
					goto _5
				_5:
					;
					j = j + 1
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(pulses_ptr + uintptr(k)*2)) = int16(abs_q)
				goto _4
			_4:
				;
				k = k + 1
			}
			/* Mark the number of pulses non-zero for sign decoding. */
			*(*int32)(unsafe.Pointer(bp + uintptr(i)*4)) |= nLS << int32(5)
		}
		goto _3
	_3:
		;
		i = i + 1
	}
	/****************************************/
	/* Decode and add signs to pulse signal */
	/****************************************/
	Opus_silk_decode_signs(tls, psRangeDec, pulses, frame_length, signalType, quantOffsetType, bp)
}

// C documentation
//
//	/* Set decoder sampling rate */

func Opus_silk_decode_signs(tls *libc.TLS, psRangeDec uintptr, pulses uintptr, length int32, signalType int32, quantOffsetType int32, sum_pulses uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j, p, v2 int32
	var icdf_ptr, q_ptr, v4 uintptr
	var _ /* icdf at bp+0 */ [2]OpusT_opus_uint8
	_, _, _, _, _, _, _ = i, icdf_ptr, j, p, q_ptr, v2, v4
	(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(0)
	q_ptr = pulses
	i = int32(int16(libc.Int32FromInt32(7))) * int32(int16(quantOffsetType+libc.Int32FromUint32(libc.Uint32FromInt32(signalType)<<libc.Int32FromInt32(1))))
	icdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_sign_iCDF)) + uintptr(i)
	length = (length + libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)/libc.Int32FromInt32(2)) >> int32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	i = 0
	for {
		if !(i < length) {
			break
		}
		p = *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4))
		if p > 0 {
			if p&int32(0x1F) < int32(6) {
				v2 = p & int32(0x1F)
			} else {
				v2 = int32(6)
			}
			(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_uint8)(unsafe.Pointer(icdf_ptr + uintptr(v2)))
			j = 0
			for {
				if !(j < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(q_ptr + uintptr(j)*2))) > 0 {
					/* attach sign */
					/* implementation with shift, subtraction, multiplication */
					v4 = q_ptr + uintptr(j)*2
					*(*OpusT_opus_int16)(unsafe.Pointer(v4)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v4))) * (libc.Int32FromUint32(libc.Uint32FromInt32(Opus_ec_dec_icdf(tls, psRangeDec, bp, uint32(8)))<<libc.Int32FromInt32(1)) - libc.Int32FromInt32(1)))
				}
				goto _3
			_3:
				;
				j = j + 1
			}
		}
		q_ptr = q_ptr + uintptr(SHELL_CODEC_FRAME_LENGTH)*2
		goto _1
	_1:
		;
		i = i + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/************************/
//	/* Reset Decoder State  */
//	/************************/

func Opus_silk_decoder_set_fs(tls *libc.TLS, psDec uintptr, fs_kHz int32, fs_API_Hz OpusT_opus_int32) (r int32) {
	var frame_length, ret int32
	_, _ = frame_length, ret
	ret = 0
	if !(fs_kHz == int32(8) || fs_kHz == int32(12) || fs_kHz == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+7073, __ccgo_ts+7135, int32(43))
	}
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+7160, __ccgo_ts+7135, int32(44))
	}
	/* New (sub)frame length */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length = int32(int16(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS))) * int32(int16(fs_kHz))
	frame_length = int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)) * int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length))
	/* Initialize resampler when switching internal or external sampling frequency */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz || (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_API_hz != fs_API_Hz {
		/* Initialize the resampler for dec_API.c preparing resampling from fs_kHz to API_fs_Hz */
		ret = ret + Opus_silk_resampler_init(tls, psDec+2448, int32(int16(fs_kHz))*int32(int16(libc.Int32FromInt32(1000))), fs_API_Hz, 0)
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_API_hz = fs_API_Hz
	}
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz || frame_length != (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length {
		if fs_kHz == int32(8) {
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_NB_iCDF))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_NB_iCDF))
			}
		} else {
			if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_iCDF))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_iCDF))
			}
		}
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz != fs_kHz {
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length = int32(int16(libc.Int32FromInt32(LTP_MEM_LENGTH_MS))) * int32(int16(fs_kHz))
			if fs_kHz == int32(8) || fs_kHz == int32(12) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order = int32(MIN_LPC_ORDER)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_NB_MB))
			} else {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order = int32(MAX_LPC_ORDER)
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_WB))
			}
			if fs_kHz == int32(16) {
				(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF))
			} else {
				if fs_kHz == int32(12) {
					(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform6_iCDF))
				} else {
					if fs_kHz == int32(8) {
						(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF))
					} else {
						/* unsupported sampling rate */
						if !(libc.Int32FromInt32(0) != 0) {
							Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+7135, int32(89))
						}
					}
				}
			}
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = int32(1)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlagPrev = int32(100)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLastGainIndex = int8(10)
			(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = TYPE_NO_VOICE_ACTIVITY
			libc.Xmemset(tls, psDec+1348, 0, libc.Uint64FromInt64(960))
			libc.Xmemset(tls, psDec+1284, 0, libc.Uint64FromInt64(64))
		}
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz = fs_kHz
		(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length = frame_length
	}
	/* Check that settings are valid */
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length > 0 && (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length <= libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+7247, __ccgo_ts+7135, int32(104))
	}
	return ret
}

const CELT_SIG_SCALE11 = 32768

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

// C documentation
//
//	/************************/
//	/* Decoder Super Struct */
//	/************************/
type OpusT_silk_decoder = struct {
	Fchannel_state           [2]OpusT_silk_decoder_state
	FsStereo                 OpusT_stereo_dec_state
	FnChannelsAPI            int32
	FnChannelsInternal       int32
	Fprev_decode_only_middle int32
}

/*********************/
/* Decoder functions */
/*********************/

func Opus_silk_encode_do_VAD_FLP(tls *libc.TLS, psEnc uintptr, activity int32) {
	var activity_threshold int32
	_ = activity_threshold
	activity_threshold = int32(float64(libc.Float32FromFloat32(0.05)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(8))) + libc.Float64FromFloat64(0.5))
	/****************************/
	/* Voice Activity Detection */
	/****************************/
	_ = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch
	Opus_silk_VAD_GetSA_Q8_c(tls, psEnc, psEnc+5112+uintptr(1)*2)
	/* If Opus VAD is inactive and Silk VAD is active: lower Silk VAD to just under the threshold */
	if activity == VAD_NO_ACTIVITY && (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8 >= activity_threshold {
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8 = activity_threshold - int32(1)
	}
	/**************************************************/
	/* Convert speech activity into VAD and DTX flags */
	/**************************************************/
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8 < activity_threshold {
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType = TYPE_NO_VOICE_ACTIVITY
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter + 1
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter <= int32(NB_SPEECH_FRAMES_BEFORE_DTX) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FinDTX = 0
		} else {
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter > libc.Int32FromInt32(MAX_CONSECUTIVE_DTX)+libc.Int32FromInt32(NB_SPEECH_FRAMES_BEFORE_DTX) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter = int32(NB_SPEECH_FRAMES_BEFORE_DTX)
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FinDTX = 0
			}
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4736 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded))) = 0
	} else {
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnoSpeechCounter = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FinDTX = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType = int8(TYPE_UNVOICED)
		*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4736 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded))) = int8(1)
	}
}

// C documentation
//
//	/****************/
//	/* Encode frame */
//	/****************/

func Opus_silk_encode_frame_FLP(tls *libc.TLS, psEnc uintptr, pnBytesOut uintptr, psRangeEnc uintptr, condCoding int32, maxBits int32, useCBR int32) (r int32) {
	bp := tls.Alloc(3568)
	defer tls.Free(3568)
	var LastGainIndex_copy2 OpusT_opus_int8
	var _saved_stack, ec_buf_copy, res_pitch_frame, sNSQ_copy, st, x_frame, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var best_gain_mult [4]OpusT_opus_int16
	var best_sum, gain_lock [4]int32
	var bits_margin, ec_prevSignalType_copy, found_lower, found_upper, i, iter, j, maxIter, ret, sum, v29, v64 int32
	var ec_prevLagIndex_copy, gainMult_Q8, tmp OpusT_opus_int16
	var gainMult_lower, gainMult_upper, gainsID, gainsID_lower, gainsID_upper, k, nBits, nBits_lower, nBits_upper, seed_copy, v30, v31, v32, v33 OpusT_opus_int32
	var v71 float32
	var _ /* pGains_Q16 at bp+3552 */ [4]OpusT_opus_int32
	var _ /* res_pitch at bp+748 */ [672]float32
	var _ /* sEncCtrl at bp+0 */ OpusT_silk_encoder_control_FLP
	var _ /* sRangeEnc_copy at bp+3440 */ OpusT_ec_enc
	var _ /* sRangeEnc_copy2 at bp+3496 */ OpusT_ec_enc
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = LastGainIndex_copy2, _saved_stack, best_gain_mult, best_sum, bits_margin, ec_buf_copy, ec_prevLagIndex_copy, ec_prevSignalType_copy, found_lower, found_upper, gainMult_Q8, gainMult_lower, gainMult_upper, gain_lock, gainsID, gainsID_lower, gainsID_upper, i, iter, j, k, maxIter, nBits, nBits_lower, nBits_upper, res_pitch_frame, ret, sNSQ_copy, seed_copy, st, sum, tmp, x_frame, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v30, v31, v32, v33, v5, v64, v7, v71, v9
	ret = 0
	gain_lock = [4]int32{}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Using ALLOC() instead of a regular stack allocation to minimize real stack use when using the pseudostack.
	   This is useful on some embedded systems. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4352)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10922, int32(115))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(4352) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sNSQ_copy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4352)/libc.Uint64FromInt64(1)))
	/* For CBR, 5 bits below budget is close enough. For VBR, allow up to 25% below the cap if we initially busted the budget. */
	if useCBR != 0 {
		v29 = int32(5)
	} else {
		v29 = maxBits / int32(4)
	}
	bits_margin = v29
	/* This is totally unnecessary but many compilers (including gcc) are too dumb to realise it */
	v33 = libc.Int32FromInt32(0)
	gainMult_upper = v33
	v32 = v33
	gainMult_lower = v32
	v31 = v32
	nBits_upper = v31
	v30 = v31
	nBits_lower = v30
	LastGainIndex_copy2 = int8(v30)
	v1 = psEnc + 4620
	v30 = *(*OpusT_opus_int32)(unsafe.Pointer(v1))
	*(*OpusT_opus_int32)(unsafe.Pointer(v1)) = *(*OpusT_opus_int32)(unsafe.Pointer(v1)) + 1
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FSeed = int8(v30 & int32(3))
	/**************************************************************/
	/* Set up Input Pointers, and insert frame in input buffer    */
	/**************************************************************/
	/* pointers aligned with start of frame to encode */
	x_frame = psEnc + 7300 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length)*4     /* start of frame to encode */
	res_pitch_frame = bp + 748 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length)*4 /* start of pitch LPC residual frame */
	/***************************************/
	/* Ensure smooth bandwidth transitions */
	/***************************************/
	Opus_silk_LP_variable_cutoff(tls, psEnc+16, psEnc+5112+uintptr(1)*2, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length)
	/*******************************************/
	/* Copy new frame to front of input buffer */
	/*******************************************/
	k = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length - libc.Int32FromInt32(1)
	for {
		if !(k >= libc.Int32FromInt32(0)) {
			break
		}
		*(*float32)(unsafe.Pointer(x_frame + uintptr(int32(LA_SHAPE_MS)*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz)*4 + uintptr(k)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(psEnc + 5112 + uintptr(1)*2 + uintptr(k)*2)))
		goto _36
	_36:
		;
		k = k - 1
	}
	/* Add tiny signal to avoid high CPU load from denormalized floating point numbers */
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		*(*float32)(unsafe.Pointer(x_frame + uintptr(int32(LA_SHAPE_MS)*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz+i*((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length>>int32(3)))*4)) += float32(float32(libc.Int32FromInt32(1)-i&libc.Int32FromInt32(2)) * libc.Float32FromFloat32(1e-06))
		goto _37
	_37:
		;
		i = i + 1
	}
	if !((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprefillFlag != 0) {
		/*****************************************/
		/* Find pitch lags, initial LPC analysis */
		/*****************************************/
		Opus_silk_find_pitch_lags_FLP(tls, psEnc, bp, bp+748, x_frame, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch)
		/************************/
		/* Noise shape analysis */
		/************************/
		Opus_silk_noise_shape_analysis_FLP(tls, psEnc, bp, res_pitch_frame, x_frame)
		/***************************************************/
		/* Find linear prediction coefficients (LPC + LTP) */
		/***************************************************/
		Opus_silk_find_pred_coefs_FLP(tls, psEnc, bp, res_pitch_frame, x_frame, condCoding)
		/****************************************/
		/* Process gains                        */
		/****************************************/
		Opus_silk_process_gains_FLP(tls, psEnc, bp, condCoding)
		/****************************************/
		/* Low Bitrate Redundant Encoding       */
		/****************************************/
		silk_LBRR_encode_FLP(tls, psEnc, bp, x_frame, condCoding)
		/* Loop over quantizer and entroy coding to control bitrate */
		maxIter = int32(6)
		gainMult_Q8 = int16(int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(8))) + libc.Float64FromFloat64(0.5)))
		found_lower = 0
		found_upper = 0
		gainsID = Opus_silk_gains_ID(tls, psEnc+4752, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)
		gainsID_lower = -int32(1)
		gainsID_upper = -int32(1)
		/* Copy part of the input state */
		libc.Xmemcpy(tls, bp+3440, psRangeEnc, libc.Uint64FromInt64(56))
		libc.Xmemcpy(tls, sNSQ_copy, psEnc+148, libc.Uint64FromInt64(4352))
		seed_copy = int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FSeed)
		ec_prevLagIndex_copy = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevLagIndex
		ec_prevSignalType_copy = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevSignalType
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _39
		_39:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _41
	_41:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _43
		_43:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v7 = st
		goto _45
	_45:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v9 = libc.Xmalloc(tls, uint64(16))
			goto _47
		_47:
			st = v9
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v11 = st
		goto _49
	_49:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v13 = libc.Xmalloc(tls, uint64(16))
			goto _51
		_51:
			st = v13
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v15 = st
		goto _53
	_53:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1275))*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10922, int32(187))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v17 = libc.Xmalloc(tls, uint64(16))
			goto _55
		_55:
			st = v17
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v19 = st
		goto _57
	_57:
		*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1275)) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v21 = libc.Xmalloc(tls, uint64(16))
			goto _59
		_59:
			st = v21
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v23 = st
		goto _61
	_61:
		ec_buf_copy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1275))*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
		iter = 0
		for {
			if gainsID == gainsID_lower {
				nBits = nBits_lower
			} else {
				if gainsID == gainsID_upper {
					nBits = nBits_upper
				} else {
					/* Restore part of the input state */
					if iter > 0 {
						libc.Xmemcpy(tls, psRangeEnc, bp+3440, libc.Uint64FromInt64(56))
						libc.Xmemcpy(tls, psEnc+148, sNSQ_copy, libc.Uint64FromInt64(4352))
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FSeed = int8(seed_copy)
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevLagIndex = ec_prevLagIndex_copy
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevSignalType = ec_prevSignalType_copy
					}
					/*****************************************/
					/* Noise shaping quantization            */
					/*****************************************/
					Opus_silk_NSQ_wrapper_FLP(tls, psEnc, bp, psEnc+4752, psEnc+148, psEnc+4788, x_frame)
					if iter == maxIter && !(found_lower != 0) {
						libc.Xmemcpy(tls, bp+3496, psRangeEnc, libc.Uint64FromInt64(56))
					}
					/****************************************/
					/* Encode Parameters                    */
					/****************************************/
					Opus_silk_encode_indices(tls, psEnc, psRangeEnc, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded, 0, condCoding)
					/****************************************/
					/* Encode Excitation Signal             */
					/****************************************/
					Opus_silk_encode_pulses(tls, psRangeEnc, int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType), int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType), psEnc+4788, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length)
					v1 = psRangeEnc
					v29 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
					goto _65
				_65:
					nBits = v29
					/* If we still bust after the last iteration, do some damage control. */
					if iter == maxIter && !(found_lower != 0) && nBits > maxBits {
						libc.Xmemcpy(tls, psRangeEnc, bp+3496, libc.Uint64FromInt64(56))
						/* Keep gains the same as the last frame. */
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex = (*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FlastGainIndexPrev
						i = 0
						for {
							if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
								break
							}
							*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4752 + uintptr(i))) = int8(4)
							goto _66
						_66:
							;
							i = i + 1
						}
						if condCoding != int32(CODE_CONDITIONALLY) {
							*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4752)) = (*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FlastGainIndexPrev
						}
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevLagIndex = ec_prevLagIndex_copy
						(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fec_prevSignalType = ec_prevSignalType_copy
						/* Clear all pulses. */
						i = 0
						for {
							if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length) {
								break
							}
							*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4788 + uintptr(i))) = 0
							goto _67
						_67:
							;
							i = i + 1
						}
						Opus_silk_encode_indices(tls, psEnc, psRangeEnc, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded, 0, condCoding)
						Opus_silk_encode_pulses(tls, psRangeEnc, int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType), int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType), psEnc+4788, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length)
						v1 = psRangeEnc
						v29 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
						goto _70
					_70:
						nBits = v29
					}
					if useCBR == 0 && iter == 0 && nBits <= maxBits {
						break
					}
				}
			}
			if iter == maxIter {
				if found_lower != 0 && (gainsID == gainsID_lower || nBits > maxBits) {
					/* Restore output state from earlier iteration that did meet the bitrate budget */
					libc.Xmemcpy(tls, psRangeEnc, bp+3496, libc.Uint64FromInt64(56))
					if !((*(*OpusT_ec_enc)(unsafe.Pointer(bp + 3496))).Foffs <= libc.Uint32FromInt32(1275)) {
						Opus_celt_fatal(tls, __ccgo_ts+10955, __ccgo_ts+10922, int32(261))
					}
					libc.Xmemcpy(tls, (*OpusT_ec_enc)(unsafe.Pointer(psRangeEnc)).Fbuf, ec_buf_copy, uint64((*(*OpusT_ec_enc)(unsafe.Pointer(bp + 3496))).Foffs))
					libc.Xmemcpy(tls, psEnc+148, sNSQ_copy+1*4352, libc.Uint64FromInt64(4352))
					(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex = LastGainIndex_copy2
				}
				break
			}
			if nBits > maxBits {
				if found_lower == 0 && iter >= int32(2) {
					/* Adjust the quantizer's rate/distortion tradeoff and discard previous "upper" results */
					if float32((*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FLambda*libc.Float32FromFloat32(1.5)) > libc.Float32FromFloat32(1.5) {
						v71 = float32((*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FLambda * libc.Float32FromFloat32(1.5))
					} else {
						v71 = libc.Float32FromFloat32(1.5)
					}
					(*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FLambda = v71
					/* Reducing dithering can help us hit the target. */
					(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = 0
					found_upper = 0
					gainsID_upper = -int32(1)
				} else {
					found_upper = int32(1)
					nBits_upper = nBits
					gainMult_upper = int32(gainMult_Q8)
					gainsID_upper = gainsID
				}
			} else {
				if nBits < maxBits-bits_margin {
					found_lower = int32(1)
					nBits_lower = nBits
					gainMult_lower = int32(gainMult_Q8)
					if gainsID != gainsID_lower {
						gainsID_lower = gainsID
						/* Copy part of the output state */
						libc.Xmemcpy(tls, bp+3496, psRangeEnc, libc.Uint64FromInt64(56))
						if !((*OpusT_ec_enc)(unsafe.Pointer(psRangeEnc)).Foffs <= libc.Uint32FromInt32(1275)) {
							Opus_celt_fatal(tls, __ccgo_ts+11002, __ccgo_ts+10922, int32(291))
						}
						libc.Xmemcpy(tls, ec_buf_copy, (*OpusT_ec_enc)(unsafe.Pointer(psRangeEnc)).Fbuf, uint64((*OpusT_ec_enc)(unsafe.Pointer(psRangeEnc)).Foffs))
						libc.Xmemcpy(tls, sNSQ_copy+1*4352, psEnc+148, libc.Uint64FromInt64(4352))
						LastGainIndex_copy2 = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex
					}
				} else {
					/* Close enough */
					break
				}
			}
			if !(found_lower != 0) && nBits > maxBits {
				i = 0
				for {
					if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
						break
					}
					sum = 0
					j = i * (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length
					for {
						if !(j < (i+int32(1))*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length) {
							break
						}
						sum = sum + libc.Xabs(tls, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psEnc + 4788 + uintptr(j)))))
						goto _73
					_73:
						;
						j = j + 1
					}
					if iter == 0 || sum < best_sum[i] && !(gain_lock[i] != 0) {
						best_sum[i] = sum
						best_gain_mult[i] = gainMult_Q8
					} else {
						gain_lock[i] = int32(1)
					}
					goto _72
				_72:
					;
					i = i + 1
				}
			}
			if found_lower&found_upper == 0 {
				/* Adjust gain according to high-rate rate/distortion curve */
				if nBits > maxBits {
					v30 = int32(1024)
					v31 = int32(gainMult_Q8) * int32(3) / int32(2)
					if v30 < v31 {
						v29 = v30
					} else {
						v29 = v31
					}
					v32 = v29
					goto _77
				_77:
					gainMult_Q8 = int16(v32)
				} else {
					v30 = int32(64)
					v31 = int32(gainMult_Q8) * int32(4) / int32(5)
					if v30 > v31 {
						v29 = v30
					} else {
						v29 = v31
					}
					v32 = v29
					goto _82
				_82:
					gainMult_Q8 = int16(v32)
				}
			} else {
				/* Adjust gain by interpolating */
				gainMult_Q8 = int16(gainMult_lower + (gainMult_upper-gainMult_lower)*(maxBits-nBits_lower)/(nBits_upper-nBits_lower))
				/* New gain multiplier must be between 25% and 75% of old range (note that gainMult_upper < gainMult_lower) */
				if int32(gainMult_Q8) > gainMult_lower+(gainMult_upper-gainMult_lower)>>int32(2) {
					gainMult_Q8 = int16(gainMult_lower + (gainMult_upper-gainMult_lower)>>libc.Int32FromInt32(2))
				} else {
					if int32(gainMult_Q8) < gainMult_upper-(gainMult_upper-gainMult_lower)>>int32(2) {
						gainMult_Q8 = int16(gainMult_upper - (gainMult_upper-gainMult_lower)>>libc.Int32FromInt32(2))
					}
				}
			}
			i = 0
			for {
				if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
					break
				}
				if gain_lock[i] != 0 {
					tmp = best_gain_mult[i]
				} else {
					tmp = gainMult_Q8
				}
				if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 728 + uintptr(i)*4)))*int64(tmp)>>libc.Int32FromInt32(16)) > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(8) {
					v29 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(8)
				} else {
					if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 728 + uintptr(i)*4)))*int64(tmp)>>libc.Int32FromInt32(16)) < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(8) {
						v64 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(8)
					} else {
						v64 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 728 + uintptr(i)*4))) * int64(tmp) >> libc.Int32FromInt32(16))
					}
					v29 = v64
				}
				(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 3552)))[i] = libc.Int32FromUint32(libc.Uint32FromInt32(v29) << libc.Int32FromInt32(8))
				goto _84
			_84:
				;
				i = i + 1
			}
			/* Quantize gains */
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex = (*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(bp))).FlastGainIndexPrev
			Opus_silk_gains_quant(tls, psEnc+4752, bp+3552, psEnc+7288, libc.BoolInt32(condCoding == int32(CODE_CONDITIONALLY)), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)
			/* Unique identifier of gains vector */
			gainsID = Opus_silk_gains_ID(tls, psEnc+4752, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)
			/* Overwrite unquantized gains with quantized gains and convert back to Q0 from Q16 */
			i = 0
			for {
				if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
					break
				}
				*(*float32)(unsafe.Pointer(bp + uintptr(i)*4)) = float32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp + 3552)))[i]) / libc.Float32FromFloat32(65536)
				goto _87
			_87:
				;
				i = i + 1
			}
			goto _62
		_62:
			;
			iter = iter + 1
		}
	}
	/* Update input buffer */
	libc.Xmemmove(tls, psEnc+7300, psEnc+7300+uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length)*4, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length+libc.Int32FromInt32(LA_SHAPE_MS)*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz)*libc.Uint64FromInt64(4))
	/* Exit without entropy coding */
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprefillFlag != 0 {
		/* No payload */
		*(*OpusT_opus_int32)(unsafe.Pointer(pnBytesOut)) = 0
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _89
		_89:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _91
	_91:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	/* Parameters needed for next frame */
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevLag = *(*int32)(unsafe.Pointer(bp + 228 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr-int32(1))*4))
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevSignalType = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType
	/****************************************/
	/* Finalize payload                     */
	/****************************************/
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffirst_frame_after_reset = 0
	/* Payload size */
	v1 = psRangeEnc
	v29 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _94
_94:
	*(*OpusT_opus_int32)(unsafe.Pointer(pnBytesOut)) = (v29 + libc.Int32FromInt32(7)) >> libc.Int32FromInt32(3)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _96
	_96:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _98
_98:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

// C documentation
//
//	/* Low-Bitrate Redundancy (LBRR) encoding. Reuse all parameters but encode excitation at lower bitrate  */

func Opus_silk_encode_indices(tls *libc.TLS, psEncC uintptr, psRangeEnc uintptr, FrameIndex int32, encode_LBRR int32, condCoding int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var delta_lagIndex, encode_absolute_lagIndex, i, k, typeOffset int32
	var pitch_high_bits, pitch_low_bits OpusT_opus_int32
	var psIndices uintptr
	var _ /* ec_ix at bp+0 */ [16]OpusT_opus_int16
	var _ /* pred_Q8 at bp+32 */ [16]OpusT_opus_uint8
	_, _, _, _, _, _, _, _ = delta_lagIndex, encode_absolute_lagIndex, i, k, pitch_high_bits, pitch_low_bits, psIndices, typeOffset
	if encode_LBRR != 0 {
		psIndices = psEncC + 6216 + uintptr(FrameIndex)*36
	} else {
		psIndices = psEncC + 4752
	}
	/*******************************************/
	/* Encode signal type and quantizer offset */
	/*******************************************/
	typeOffset = int32(2)*int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) + int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FquantOffsetType)
	if !(typeOffset >= 0 && typeOffset < int32(6)) {
		Opus_celt_fatal(tls, __ccgo_ts+8063, __ccgo_ts+8115, int32(59))
	}
	if !(encode_LBRR == 0 || typeOffset >= int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+8140, __ccgo_ts+8115, int32(60))
	}
	if encode_LBRR != 0 || typeOffset >= int32(2) {
		Opus_ec_enc_icdf(tls, psRangeEnc, typeOffset-int32(2), uintptr(unsafe.Pointer(&Opus_silk_type_offset_VAD_iCDF)), uint32(8))
	} else {
		Opus_ec_enc_icdf(tls, psRangeEnc, typeOffset, uintptr(unsafe.Pointer(&Opus_silk_type_offset_no_VAD_iCDF)), uint32(8))
	}
	/****************/
	/* Encode gains */
	/****************/
	/* first subframe */
	if condCoding == int32(CODE_CONDITIONALLY) {
		/* conditional coding */
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices))) >= 0 && int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices))) < libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - -libc.Int32FromInt32(4) + libc.Int32FromInt32(1)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices))), uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8))
	} else {
		/* independent coding, in two stages: MSB bits followed by 3 LSBs */
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices))) >= 0 && int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices))) < int32(N_LEVELS_QGAIN)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices)))>>int32(3), uintptr(unsafe.Pointer(&Opus_silk_gain_iCDF))+uintptr((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType)*8, uint32(8))
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices)))&int32(7), uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF)), uint32(8))
	}
	/* remaining subframes */
	i = int32(1)
	for {
		if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr) {
			break
		}
		_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + uintptr(i)))) >= 0 && int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + uintptr(i)))) < libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - -libc.Int32FromInt32(4) + libc.Int32FromInt32(1)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + uintptr(i)))), uintptr(unsafe.Pointer(&Opus_silk_delta_gain_iCDF)), uint32(8))
		goto _1
	_1:
		;
		i = i + 1
	}
	/****************/
	/* Encode NLSFs */
	/****************/
	Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8))), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).FCB1_iCDF+uintptr(int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType)>>int32(1)*int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).FnVectors)), uint32(8))
	Opus_silk_NLSF_unpack(tls, bp, bp+32, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8))))
	if !(int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).Forder) == (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder) {
		Opus_celt_fatal(tls, __ccgo_ts+8194, __ccgo_ts+8115, int32(93))
	}
	i = 0
	for {
		if !(i < int32((*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).Forder)) {
			break
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8 + uintptr(i+int32(1))))) >= int32(NLSF_QUANT_MAX_AMPLITUDE) {
			Opus_ec_enc_icdf(tls, psRangeEnc, libc.Int32FromInt32(2)*libc.Int32FromInt32(NLSF_QUANT_MAX_AMPLITUDE), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).Fec_iCDF+uintptr((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]), uint32(8))
			Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8 + uintptr(i+int32(1)))))-int32(NLSF_QUANT_MAX_AMPLITUDE), uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
		} else {
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8 + uintptr(i+int32(1))))) <= -int32(NLSF_QUANT_MAX_AMPLITUDE) {
				Opus_ec_enc_icdf(tls, psRangeEnc, 0, (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).Fec_iCDF+uintptr((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]), uint32(8))
				Opus_ec_enc_icdf(tls, psRangeEnc, -int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8 + uintptr(i+int32(1)))))-int32(NLSF_QUANT_MAX_AMPLITUDE), uintptr(unsafe.Pointer(&Opus_silk_NLSF_EXT_iCDF)), uint32(8))
			} else {
				Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 8 + uintptr(i+int32(1)))))+int32(NLSF_QUANT_MAX_AMPLITUDE), (*OpusT_silk_NLSF_CB_struct)(unsafe.Pointer((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB)).Fec_iCDF+uintptr((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp)))[i]), uint32(8))
			}
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	/* Encode NLSF interpolation factor */
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(MAX_NB_SUBFR) {
		_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FNLSFInterpCoef_Q2) >= 0 && int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FNLSFInterpCoef_Q2) < int32(5)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FNLSFInterpCoef_Q2), uintptr(unsafe.Pointer(&Opus_silk_NLSF_interpolation_factor_iCDF)), uint32(8))
	}
	if int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType) == int32(TYPE_VOICED) {
		/*********************/
		/* Encode pitch lags */
		/*********************/
		/* lag index */
		encode_absolute_lagIndex = int32(1)
		if condCoding == int32(CODE_CONDITIONALLY) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fec_prevSignalType == int32(TYPE_VOICED) {
			/* Delta Encoding */
			delta_lagIndex = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FlagIndex) - int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fec_prevLagIndex)
			if delta_lagIndex < -int32(8) || delta_lagIndex > int32(11) {
				delta_lagIndex = 0
			} else {
				delta_lagIndex = delta_lagIndex + int32(9)
				encode_absolute_lagIndex = 0 /* Only use delta */
			}
			_ = delta_lagIndex >= 0 && delta_lagIndex < int32(21)
			Opus_ec_enc_icdf(tls, psRangeEnc, delta_lagIndex, uintptr(unsafe.Pointer(&Opus_silk_pitch_delta_iCDF)), uint32(8))
		}
		if encode_absolute_lagIndex != 0 {
			pitch_high_bits = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FlagIndex) / ((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz >> libc.Int32FromInt32(1))
			pitch_low_bits = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FlagIndex) - int32(int16(pitch_high_bits))*int32(int16((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz>>libc.Int32FromInt32(1)))
			_ = pitch_low_bits < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz/libc.Int32FromInt32(2)
			_ = pitch_high_bits < libc.Int32FromInt32(32)
			Opus_ec_enc_icdf(tls, psRangeEnc, pitch_high_bits, uintptr(unsafe.Pointer(&Opus_silk_pitch_lag_iCDF)), uint32(8))
			Opus_ec_enc_icdf(tls, psRangeEnc, pitch_low_bits, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fpitch_lag_low_bits_iCDF, uint32(8))
		}
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fec_prevLagIndex = (*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FlagIndex
		/* Contour index */
		_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex) >= libc.Int32FromInt32(0)
		_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex) < int32(34) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz > int32(8) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(4) || int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex) < int32(11) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz == int32(8) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(4) || int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex) < int32(12) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz > int32(8) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(2) || int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex) < int32(3) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz == int32(8) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(2)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FcontourIndex), (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fpitch_contour_iCDF, uint32(8))
		/********************/
		/* Encode LTP gains */
		/********************/
		/* PERIndex value */
		_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FPERIndex) >= 0 && int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FPERIndex) < int32(3)
		Opus_ec_enc_icdf(tls, psRangeEnc, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FPERIndex), uintptr(unsafe.Pointer(&Opus_silk_LTP_per_index_iCDF)), uint32(8))
		/* Codebook Indices */
		k = 0
		for {
			if !(k < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr) {
				break
			}
			_ = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 4 + uintptr(k)))) >= 0 && int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 4 + uintptr(k)))) < int32(8)<<(*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FPERIndex
			Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices + 4 + uintptr(k)))), Opus_silk_LTP_gain_iCDF_ptrs[(*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FPERIndex], uint32(8))
			goto _3
		_3:
			;
			k = k + 1
		}
		/**********************/
		/* Encode LTP scaling */
		/**********************/
		if condCoding == CODE_INDEPENDENTLY {
			_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FLTP_scaleIndex) >= 0 && int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FLTP_scaleIndex) < int32(3)
			Opus_ec_enc_icdf(tls, psRangeEnc, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FLTP_scaleIndex), uintptr(unsafe.Pointer(&Opus_silk_LTPscale_iCDF)), uint32(8))
		}
		_ = !(condCoding != 0) || int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FLTP_scaleIndex) == 0
	}
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fec_prevSignalType = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FsignalType)
	/***************/
	/* Encode seed */
	/***************/
	_ = int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed) >= 0 && int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed) < int32(4)
	Opus_ec_enc_icdf(tls, psRangeEnc, int32((*OpusT_SideInfoIndices)(unsafe.Pointer(psIndices)).FSeed), uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF)), uint32(8))
}

/*********************************************/
/* Encode quantization indices of excitation */
/*********************************************/

func Opus_silk_encode_pulses(tls *libc.TLS, psRangeEnc uintptr, signalType int32, quantOffsetType int32, pulses uintptr, frame_length int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var RateLevelIndex, bit, i, iter, j, k, nLS, scale_down, v30 int32
	var _saved_stack, abs_pulses, abs_pulses_ptr, cdf_ptr, nBits_ptr, nRshifts, pulses_ptr, st, sum_pulses, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var abs_q, minSumBits_Q5, sumBits_Q5 OpusT_opus_int32
	var _ /* pulses_comb at bp+0 */ [8]int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = RateLevelIndex, _saved_stack, abs_pulses, abs_pulses_ptr, abs_q, bit, cdf_ptr, i, iter, j, k, minSumBits_Q5, nBits_ptr, nLS, nRshifts, pulses_ptr, scale_down, st, sumBits_Q5, sum_pulses, v1, v11, v13, v15, v17, v19, v21, v23, v3, v30, v5, v7, v9
	RateLevelIndex = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	libc.Xmemset(tls, bp, 0, libc.Uint64FromInt32(8)*libc.Uint64FromInt64(4)) /* Fixing Valgrind reported problem*/
	/****************************/
	/* Prepare for shell coding */
	/****************************/
	/* Calculate number of shell blocks */
	_ = libc.Int32FromInt32(1)<<libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH) == libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)
	iter = frame_length >> libc.Int32FromInt32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	if iter*int32(SHELL_CODEC_FRAME_LENGTH) < frame_length {
		if !(frame_length == libc.Int32FromInt32(12)*libc.Int32FromInt32(10)) {
			Opus_celt_fatal(tls, __ccgo_ts+7007, __ccgo_ts+8264, int32(89))
		} /* Make sure only happens for 10 ms @ 12 kHz */
		iter = iter + 1
		libc.Xmemset(tls, pulses+uintptr(frame_length), 0, libc.Uint64FromInt32(SHELL_CODEC_FRAME_LENGTH)*libc.Uint64FromInt64(1))
	}
	/* Take the absolute value of the pulses */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(iter*libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8264, int32(95))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(iter*libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	abs_pulses = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(iter*libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	_ = !(libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)&libc.Int32FromInt32(3) != 0)
	i = 0
	for {
		if !(i < iter*int32(SHELL_CODEC_FRAME_LENGTH)) {
			break
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+0)))) > 0 {
			v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+0))))
		} else {
			v30 = -int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+0))))
		}
		*(*int32)(unsafe.Pointer(abs_pulses + uintptr(i+0)*4)) = v30
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(1))))) > 0 {
			v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(1)))))
		} else {
			v30 = -int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(1)))))
		}
		*(*int32)(unsafe.Pointer(abs_pulses + uintptr(i+int32(1))*4)) = v30
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(2))))) > 0 {
			v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(2)))))
		} else {
			v30 = -int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(2)))))
		}
		*(*int32)(unsafe.Pointer(abs_pulses + uintptr(i+int32(2))*4)) = v30
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(3))))) > 0 {
			v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(3)))))
		} else {
			v30 = -int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i+int32(3)))))
		}
		*(*int32)(unsafe.Pointer(abs_pulses + uintptr(i+int32(3))*4)) = v30
		goto _29
	_29:
		;
		i = i + int32(4)
	}
	/* Calc sum pulses per shell code frame */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _37
_37:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _41
_41:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _45
_45:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _49
_49:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(iter)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8264, int32(105))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _53
_53:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(iter) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _57
_57:
	sum_pulses = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(iter)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _59
	_59:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _61
_61:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _63
	_63:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _65
_65:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _67
	_67:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _69
_69:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _71
	_71:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _73
_73:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(iter)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8264, int32(106))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _75
	_75:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _77
_77:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(iter) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _79
	_79:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _81
_81:
	nRshifts = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(iter)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	abs_pulses_ptr = abs_pulses
	i = 0
	for {
		if !(i < iter) {
			break
		}
		*(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) = 0
		for int32(1) != 0 {
			/* 1+1 -> 2 */
			scale_down = combine_and_check(tls, bp, abs_pulses_ptr, libc.Int32FromUint8(Opus_silk_max_pulses_table[0]), int32(8))
			/* 2+2 -> 4 */
			scale_down = scale_down + combine_and_check(tls, bp, bp, libc.Int32FromUint8(Opus_silk_max_pulses_table[int32(1)]), int32(4))
			/* 4+4 -> 8 */
			scale_down = scale_down + combine_and_check(tls, bp, bp, libc.Int32FromUint8(Opus_silk_max_pulses_table[int32(2)]), int32(2))
			/* 8+8 -> 16 */
			scale_down = scale_down + combine_and_check(tls, sum_pulses+uintptr(i)*4, bp, libc.Int32FromUint8(Opus_silk_max_pulses_table[int32(3)]), int32(1))
			if scale_down != 0 {
				/* We need to downscale the quantization signal */
				*(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) = *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) + 1
				k = 0
				for {
					if !(k < int32(SHELL_CODEC_FRAME_LENGTH)) {
						break
					}
					*(*int32)(unsafe.Pointer(abs_pulses_ptr + uintptr(k)*4)) = *(*int32)(unsafe.Pointer(abs_pulses_ptr + uintptr(k)*4)) >> int32(1)
					goto _83
				_83:
					;
					k = k + 1
				}
			} else {
				/* Jump out of while(1) loop and go to next shell coding frame */
				break
			}
		}
		abs_pulses_ptr = abs_pulses_ptr + uintptr(SHELL_CODEC_FRAME_LENGTH)*4
		goto _82
	_82:
		;
		i = i + 1
	}
	/**************/
	/* Rate level */
	/**************/
	/* find rate level that leads to fewest bits for coding of pulses per block info */
	minSumBits_Q5 = int32(silk_int32_MAX)
	k = 0
	for {
		if !(k < libc.Int32FromInt32(N_RATE_LEVELS)-libc.Int32FromInt32(1)) {
			break
		}
		nBits_ptr = uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_BITS_Q5)) + uintptr(k)*18
		sumBits_Q5 = libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_rate_levels_BITS_Q5)) + uintptr(signalType>>int32(1))*9 + uintptr(k))))
		i = 0
		for {
			if !(i < iter) {
				break
			}
			if *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) > 0 {
				sumBits_Q5 = sumBits_Q5 + libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(nBits_ptr + uintptr(libc.Int32FromInt32(SILK_MAX_PULSES)+libc.Int32FromInt32(1)))))
			} else {
				sumBits_Q5 = sumBits_Q5 + libc.Int32FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(nBits_ptr + uintptr(*(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4))))))
			}
			goto _85
		_85:
			;
			i = i + 1
		}
		if sumBits_Q5 < minSumBits_Q5 {
			minSumBits_Q5 = sumBits_Q5
			RateLevelIndex = k
		}
		goto _84
	_84:
		;
		k = k + 1
	}
	Opus_ec_enc_icdf(tls, psRangeEnc, RateLevelIndex, uintptr(unsafe.Pointer(&Opus_silk_rate_levels_iCDF))+uintptr(signalType>>int32(1))*9, uint32(8))
	/***************************************************/
	/* Sum-Weighted-Pulses Encoding                    */
	/***************************************************/
	cdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF)) + uintptr(RateLevelIndex)*18
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) == 0 {
			Opus_ec_enc_icdf(tls, psRangeEnc, *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4)), cdf_ptr, uint32(8))
		} else {
			Opus_ec_enc_icdf(tls, psRangeEnc, libc.Int32FromInt32(SILK_MAX_PULSES)+libc.Int32FromInt32(1), cdf_ptr, uint32(8))
			k = 0
			for {
				if !(k < *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4))-int32(1)) {
					break
				}
				Opus_ec_enc_icdf(tls, psRangeEnc, libc.Int32FromInt32(SILK_MAX_PULSES)+libc.Int32FromInt32(1), uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF))+uintptr(libc.Int32FromInt32(N_RATE_LEVELS)-libc.Int32FromInt32(1))*18, uint32(8))
				goto _87
			_87:
				;
				k = k + 1
			}
			Opus_ec_enc_icdf(tls, psRangeEnc, *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4)), uintptr(unsafe.Pointer(&Opus_silk_pulses_per_block_iCDF))+uintptr(libc.Int32FromInt32(N_RATE_LEVELS)-libc.Int32FromInt32(1))*18, uint32(8))
		}
		goto _86
	_86:
		;
		i = i + 1
	}
	/******************/
	/* Shell Encoding */
	/******************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4)) > 0 {
			Opus_silk_shell_encoder(tls, psRangeEnc, abs_pulses+uintptr(i*int32(SHELL_CODEC_FRAME_LENGTH))*4)
		}
		goto _88
	_88:
		;
		i = i + 1
	}
	/****************/
	/* LSB Encoding */
	/****************/
	i = 0
	for {
		if !(i < iter) {
			break
		}
		if *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) > 0 {
			pulses_ptr = pulses + uintptr(i*int32(SHELL_CODEC_FRAME_LENGTH))
			nLS = *(*int32)(unsafe.Pointer(nRshifts + uintptr(i)*4)) - int32(1)
			k = 0
			for {
				if !(k < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses_ptr + uintptr(k)))) > 0 {
					v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses_ptr + uintptr(k))))
				} else {
					v30 = -int32(*(*OpusT_opus_int8)(unsafe.Pointer(pulses_ptr + uintptr(k))))
				}
				abs_q = int32(int8(v30))
				j = nLS
				for {
					if !(j > 0) {
						break
					}
					bit = abs_q >> j & int32(1)
					Opus_ec_enc_icdf(tls, psRangeEnc, bit, uintptr(unsafe.Pointer(&Opus_silk_lsb_iCDF)), uint32(8))
					goto _92
				_92:
					;
					j = j - 1
				}
				bit = abs_q & int32(1)
				Opus_ec_enc_icdf(tls, psRangeEnc, bit, uintptr(unsafe.Pointer(&Opus_silk_lsb_iCDF)), uint32(8))
				goto _90
			_90:
				;
				k = k + 1
			}
		}
		goto _89
	_89:
		;
		i = i + 1
	}
	/****************/
	/* Encode signs */
	/****************/
	Opus_silk_encode_signs(tls, psRangeEnc, pulses, frame_length, signalType, quantOffsetType, sum_pulses)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _96
_96:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

// C documentation
//
//	/* Gain scalar quantization with hysteresis, uniform on log scale */

func Opus_silk_encode_signs(tls *libc.TLS, psRangeEnc uintptr, pulses uintptr, length int32, signalType int32, quantOffsetType int32, sum_pulses uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j, p, v2 int32
	var icdf_ptr, q_ptr uintptr
	var _ /* icdf at bp+0 */ [2]OpusT_opus_uint8
	_, _, _, _, _, _ = i, icdf_ptr, j, p, q_ptr, v2
	(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(0)
	q_ptr = pulses
	i = int32(int16(libc.Int32FromInt32(7))) * int32(int16(quantOffsetType+libc.Int32FromUint32(libc.Uint32FromInt32(signalType)<<libc.Int32FromInt32(1))))
	icdf_ptr = uintptr(unsafe.Pointer(&Opus_silk_sign_iCDF)) + uintptr(i)
	length = (length + libc.Int32FromInt32(SHELL_CODEC_FRAME_LENGTH)/libc.Int32FromInt32(2)) >> int32(LOG2_SHELL_CODEC_FRAME_LENGTH)
	i = 0
	for {
		if !(i < length) {
			break
		}
		p = *(*int32)(unsafe.Pointer(sum_pulses + uintptr(i)*4))
		if p > 0 {
			if p&int32(0x1F) < int32(6) {
				v2 = p & int32(0x1F)
			} else {
				v2 = int32(6)
			}
			(*(*[2]OpusT_opus_uint8)(unsafe.Pointer(bp)))[0] = *(*OpusT_opus_uint8)(unsafe.Pointer(icdf_ptr + uintptr(v2)))
			j = 0
			for {
				if !(j < int32(SHELL_CODEC_FRAME_LENGTH)) {
					break
				}
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(q_ptr + uintptr(j)))) != 0 {
					Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(q_ptr + uintptr(j))))>>int32(15)+int32(1), bp, uint32(8))
				}
				goto _3
			_3:
				;
				j = j + 1
			}
		}
		q_ptr = q_ptr + uintptr(SHELL_CODEC_FRAME_LENGTH)
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Decodes signs of excitation */

func Opus_silk_energy_FLP(tls *libc.TLS, data uintptr, dataSize int32) (r float64) {
	var i int32
	var result float64
	_, _ = i, result
	/* 4x unrolled loop */
	result = float64(0)
	i = 0
	for {
		if !(i < dataSize-int32(3)) {
			break
		}
		result = result + (float64(float64(*(*float32)(unsafe.Pointer(data + uintptr(i+0)*4)))*float64(*(*float32)(unsafe.Pointer(data + uintptr(i+0)*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(1))*4)))*float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(1))*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(2))*4)))*float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(2))*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(3))*4)))*float64(*(*float32)(unsafe.Pointer(data + uintptr(i+int32(3))*4)))))
		goto _1
	_1:
		;
		i = i + int32(4)
	}
	/* add any remaining products */
	for {
		if !(i < dataSize) {
			break
		}
		result = result + float64(float64(*(*float32)(unsafe.Pointer(data + uintptr(i)*4)))*float64(*(*float32)(unsafe.Pointer(data + uintptr(i)*4))))
		goto _2
	_2:
		;
		i = i + 1
	}
	_ = result >= libc.Float64FromFloat64(0)
	return result
}

// C documentation
//
//	/* inner product of two silk_float arrays, with result as double */

func Opus_silk_find_LPC_FLP(tls *libc.TLS, psEncC uintptr, NLSF_Q15 uintptr, x uintptr, minInvGain float32, arch int32) {
	bp := tls.Alloc(1696)
	defer tls.Free(1696)
	var k, subfr_length int32
	var res_nrg, res_nrg_2nd, res_nrg_interp float32
	var _ /* LPC_res at bp+160 */ [384]float32
	var _ /* NLSF0_Q15 at bp+64 */ [16]OpusT_opus_int16
	var _ /* a at bp+0 */ [16]float32
	var _ /* a_tmp at bp+96 */ [16]float32
	_, _, _, _, _ = k, res_nrg, res_nrg_2nd, res_nrg_interp, subfr_length
	subfr_length = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length + (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder
	/* Default: No interpolation */
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2 = int8(4)
	/* Burg AR analysis for the full frame */
	res_nrg = Opus_silk_burg_modified_FLP(tls, bp, x, minInvGain, subfr_length, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, arch)
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs != 0 && !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffirst_frame_after_reset != 0) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(MAX_NB_SUBFR) {
		/* Optimal solution for last 10 ms; subtract residual energy here, as that's easier than        */
		/* adding it to the residual energy of the first 10 ms in each iteration of the search below    */
		res_nrg = res_nrg - Opus_silk_burg_modified_FLP(tls, bp+96, x+uintptr(libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2)*subfr_length)*4, minInvGain, subfr_length, libc.Int32FromInt32(MAX_NB_SUBFR)/libc.Int32FromInt32(2), (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, arch)
		/* Convert to NLSFs */
		Opus_silk_A2NLSF_FLP(tls, NLSF_Q15, bp+96, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
		/* Search over interpolation indices to find the one with lowest residual energy */
		res_nrg_2nd = libc.Float32FromFloat32(3.4028234663852886e+38)
		k = int32(3)
		for {
			if !(k >= 0) {
				break
			}
			/* Interpolate NLSFs for first half */
			Opus_silk_interpolate(tls, bp+64, psEncC+4500, NLSF_Q15, k, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
			/* Convert to LPC for residual energy evaluation */
			Opus_silk_NLSF2A_FLP(tls, bp+96, bp+64, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
			/* Calculate residual energy with LSF interpolation */
			Opus_silk_LPC_analysis_filter_FLP(tls, bp+160, bp+96, x, int32(2)*subfr_length, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
			res_nrg_interp = float32(Opus_silk_energy_FLP(tls, bp+160+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)*4, subfr_length-(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder) + Opus_silk_energy_FLP(tls, bp+160+uintptr((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)*4+uintptr(subfr_length)*4, subfr_length-(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder))
			/* Determine whether current interpolated NLSFs are best so far */
			if res_nrg_interp < res_nrg {
				/* Interpolation has lower residual energy */
				res_nrg = res_nrg_interp
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2 = int8(k)
			} else {
				if res_nrg_interp > res_nrg_2nd {
					/* No reason to continue iterating - residual energies will continue to climb */
					break
				}
			}
			res_nrg_2nd = res_nrg_interp
			goto _1
		_1:
			;
			k = k - 1
		}
	}
	if int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2) == int32(4) {
		/* NLSF interpolation is currently inactive, calculate NLSFs from full frame AR coefficients */
		Opus_silk_A2NLSF_FLP(tls, NLSF_Q15, bp, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
	}
	if !(int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2) == int32(4) || (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs != 0 && !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffirst_frame_after_reset != 0) && (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(MAX_NB_SUBFR)) {
		Opus_celt_fatal(tls, __ccgo_ts+11045, __ccgo_ts+11210, int32(103))
	}
}

const LTP_CORR_INV_MAX1 = 0.03
const __FLT_MAX__2 = 3.40282346638528859811704183484516925e+38

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

func Opus_silk_find_LTP_FLP(tls *libc.TLS, XX uintptr, xX uintptr, r_ptr uintptr, lag uintptr, subfr_length int32, nb_subfr int32, arch int32) {
	var XX_ptr, lag_ptr, xX_ptr uintptr
	var k int32
	var temp, xx, v2 float32
	_, _, _, _, _, _, _ = XX_ptr, k, lag_ptr, temp, xX_ptr, xx, v2
	xX_ptr = xX
	XX_ptr = XX
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		lag_ptr = r_ptr - uintptr(*(*int32)(unsafe.Pointer(lag + uintptr(k)*4))+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
		Opus_silk_corrMatrix_FLP(tls, lag_ptr, subfr_length, int32(LTP_ORDER), XX_ptr, arch)
		Opus_silk_corrVector_FLP(tls, lag_ptr, r_ptr, subfr_length, int32(LTP_ORDER), xX_ptr, arch)
		xx = float32(Opus_silk_energy_FLP(tls, r_ptr, subfr_length+int32(LTP_ORDER)))
		if xx > float32(float32(libc.Float32FromFloat32(0.03)*libc.Float32FromFloat32(0.5))*(*(*float32)(unsafe.Pointer(XX_ptr))+*(*float32)(unsafe.Pointer(XX_ptr + 24*4))))+libc.Float32FromFloat32(1) {
			v2 = xx
		} else {
			v2 = float32(float32(libc.Float32FromFloat32(0.03)*libc.Float32FromFloat32(0.5))*(*(*float32)(unsafe.Pointer(XX_ptr))+*(*float32)(unsafe.Pointer(XX_ptr + 24*4)))) + libc.Float32FromFloat32(1)
		}
		temp = libc.Float32FromFloat32(1) / v2
		Opus_silk_scale_vector_FLP(tls, XX_ptr, temp, libc.Int32FromInt32(LTP_ORDER)*libc.Int32FromInt32(LTP_ORDER))
		Opus_silk_scale_vector_FLP(tls, xX_ptr, temp, int32(LTP_ORDER))
		r_ptr = r_ptr + uintptr(subfr_length)*4
		XX_ptr = XX_ptr + uintptr(libc.Int32FromInt32(LTP_ORDER)*libc.Int32FromInt32(LTP_ORDER))*4
		xX_ptr = xX_ptr + uintptr(LTP_ORDER)*4
		goto _1
	_1:
		;
		k = k + 1
	}
}

const FIND_PITCH_BANDWIDTH_EXPANSION1 = 0.99
const FIND_PITCH_WHITE_NOISE_FRACTION1 = 0.001
const LTP_CORR_INV_MAX2 = "0.03f"

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

func Opus_silk_find_pitch_lags_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, res uintptr, x uintptr, arch int32) {
	bp := tls.Alloc(1744)
	defer tls.Free(1744)
	var Wsig_ptr, x_buf, x_buf_ptr uintptr
	var buf_len int32
	var res_nrg, thrhld, v1 float32
	var _ /* A at bp+68 */ [16]float32
	var _ /* Wsig at bp+196 */ [384]float32
	var _ /* auto_corr at bp+0 */ [17]float32
	var _ /* refl_coef at bp+132 */ [16]float32
	_, _, _, _, _, _, _ = Wsig_ptr, buf_len, res_nrg, thrhld, x_buf, x_buf_ptr, v1
	/******************************************/
	/* Set up buffer lengths etc based on Fs  */
	/******************************************/
	buf_len = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch + (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length + (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length
	/* Safety check */
	if !(buf_len >= (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length) {
		Opus_celt_fatal(tls, __ccgo_ts+11239, __ccgo_ts+11301, int32(59))
	}
	x_buf = x - uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length)*4
	/******************************************/
	/* Estimate LPC AR coefficients           */
	/******************************************/
	/* Calculate windowed signal */
	/* First LA_LTP samples */
	x_buf_ptr = x_buf + uintptr(buf_len)*4 - uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length)*4
	Wsig_ptr = bp + 196
	Opus_silk_apply_sine_window_FLP(tls, Wsig_ptr, x_buf_ptr, int32(1), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch)
	/* Middle non-windowed samples */
	Wsig_ptr = Wsig_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch)*4
	x_buf_ptr = x_buf_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch)*4
	libc.Xmemcpy(tls, Wsig_ptr, x_buf_ptr, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch<<libc.Int32FromInt32(1))*libc.Uint64FromInt64(4))
	/* Last LA_LTP samples */
	Wsig_ptr = Wsig_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch<<int32(1))*4
	x_buf_ptr = x_buf_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch<<int32(1))*4
	Opus_silk_apply_sine_window_FLP(tls, Wsig_ptr, x_buf_ptr, int32(2), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch)
	/* Calculate autocorrelation sequence */
	Opus_silk_autocorrelation_FLP(tls, bp, bp+196, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder+int32(1), arch)
	/* Add white noise, as a fraction of the energy */
	*(*float32)(unsafe.Pointer(bp)) += float32((*(*[17]float32)(unsafe.Pointer(bp)))[0]*libc.Float32FromFloat32(0.001)) + libc.Float32FromInt32(1)
	/* Calculate the reflection coefficients using Schur */
	res_nrg = Opus_silk_schur_FLP(tls, bp+132, bp, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder)
	/* Prediction gain */
	if res_nrg > libc.Float32FromFloat32(1) {
		v1 = res_nrg
	} else {
		v1 = libc.Float32FromFloat32(1)
	}
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FpredGain = (*(*[17]float32)(unsafe.Pointer(bp)))[0] / v1
	/* Convert reflection coefficients to prediction coefficients */
	Opus_silk_k2a_FLP(tls, bp+68, bp+132, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder)
	/* Bandwidth expansion */
	Opus_silk_bwexpander_FLP(tls, bp+68, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder, libc.Float32FromFloat32(0.99))
	/*****************************************/
	/* LPC analysis filtering                */
	/*****************************************/
	Opus_silk_LPC_analysis_filter_FLP(tls, res, bp+68, x_buf, buf_len, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder)
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) != TYPE_NO_VOICE_ACTIVITY && (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffirst_frame_after_reset == 0 {
		/* Threshold for pitch estimator */
		thrhld = libc.Float32FromFloat32(0.6)
		thrhld = thrhld - float32(libc.Float32FromFloat32(0.004)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationLPCOrder))
		thrhld = thrhld - float32(float32(libc.Float32FromFloat32(0.1)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8))*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(256)))
		thrhld = thrhld - float32(libc.Float32FromFloat32(0.15)*float32(int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevSignalType)>>libc.Int32FromInt32(1)))
		thrhld = thrhld - float32(float32(libc.Float32FromFloat32(0.1)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Finput_tilt_Q15))*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(32768)))
		/*****************************************/
		/* Call Pitch estimator                  */
		/*****************************************/
		if Opus_silk_pitch_analysis_core_FLP(tls, res, psEncCtrl+228, psEnc+4752+26, psEnc+4752+28, psEnc+10180, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevLag, float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationThreshold_Q16)/libc.Float32FromFloat32(65536), thrhld, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpitchEstimationComplexity, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr, arch) == 0 {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType = int8(TYPE_VOICED)
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType = int8(TYPE_UNVOICED)
		}
	} else {
		libc.Xmemset(tls, psEncCtrl+228, 0, libc.Uint64FromInt64(16))
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FlagIndex = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FcontourIndex = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FLTPCorr = libc.Float32FromInt32(0)
	}
}

const MAX_PREDICTION_POWER_GAIN3 = 10000
const MAX_PREDICTION_POWER_GAIN_AFTER_RESET1 = 100

// C documentation
//
//	/* Find LPC and LTP coefficients */

func Opus_silk_find_pred_coefs_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, res_pitch uintptr, x uintptr, condCoding int32) {
	bp := tls.Alloc(2064)
	defer tls.Free(2064)
	var i int32
	var minInvGain float32
	var x_pre_ptr, x_ptr uintptr
	var _ /* LPC_in_pre at bp+528 */ [384]float32
	var _ /* NLSF_Q15 at bp+496 */ [16]OpusT_opus_int16
	var _ /* XXLTP at bp+0 */ [100]float32
	var _ /* invGains at bp+480 */ [4]float32
	var _ /* xXLTP at bp+400 */ [20]float32
	_, _, _, _ = i, minInvGain, x_pre_ptr, x_ptr
	/* Set to NLSF_Q15 to zero so we don't copy junk to the state. */
	*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 496)) = [16]OpusT_opus_int16{}
	/* Weighting for weighted least squares */
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		_ = *(*float32)(unsafe.Pointer(psEncCtrl + uintptr(i)*4)) > libc.Float32FromFloat32(0)
		(*(*[4]float32)(unsafe.Pointer(bp + 480)))[i] = libc.Float32FromFloat32(1) / *(*float32)(unsafe.Pointer(psEncCtrl + uintptr(i)*4))
		goto _1
	_1:
		;
		i = i + 1
	}
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		/**********/
		/* VOICED */
		/**********/
		if !((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length-(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder >= *(*int32)(unsafe.Pointer(psEncCtrl + 228))+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)) {
			Opus_celt_fatal(tls, __ccgo_ts+11337, __ccgo_ts+11454, int32(63))
		}
		/* LTP analysis */
		Opus_silk_find_LTP_FLP(tls, bp, bp+400, res_pitch, psEncCtrl+228, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch)
		/* Quantize LTP gain parameters */
		Opus_silk_quant_LTP_gains_FLP(tls, psEncCtrl+144, psEnc+4752+4, psEnc+4752+32, psEnc+4656, psEncCtrl+708, bp, bp+400, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch)
		/* Control LTP scaling */
		Opus_silk_LTP_scale_ctrl_FLP(tls, psEnc, psEncCtrl, condCoding)
		/* Create LTP residual */
		Opus_silk_LTP_analysis_filter_FLP(tls, bp+528, x-uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)*4, psEncCtrl+144, psEncCtrl+228, bp+480, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)
	} else {
		/************/
		/* UNVOICED */
		/************/
		/* Create signal with prepended subframes, scaled by inverse gains */
		x_ptr = x - uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)*4
		x_pre_ptr = bp + 528
		i = 0
		for {
			if !(i < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
				break
			}
			Opus_silk_scale_copy_vector_FLP(tls, x_pre_ptr, x_ptr, (*(*[4]float32)(unsafe.Pointer(bp + 480)))[i], (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length+(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)
			x_pre_ptr = x_pre_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length+(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)*4
			x_ptr = x_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length)*4
			goto _2
		_2:
			;
			i = i + 1
		}
		libc.Xmemset(tls, psEncCtrl+144, 0, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr*libc.Int32FromInt32(LTP_ORDER))*libc.Uint64FromInt64(4))
		(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain = libc.Float32FromFloat32(0)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsum_log_gain_Q7 = 0
	}
	/* Limit on total predictive coding gain */
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffirst_frame_after_reset != 0 {
		minInvGain = libc.Float32FromFloat32(1) / libc.Float32FromFloat32(100)
	} else {
		minInvGain = float32(libc.Xpow(tls, libc.Float64FromInt32(2), float64((*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain/libc.Float32FromInt32(3)))) / libc.Float32FromFloat32(10000)
		minInvGain = minInvGain / (libc.Float32FromFloat32(0.25) + float32(libc.Float32FromFloat32(0.75)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality))
	}
	/* LPC_in_pre contains the LTP-filtered input for voiced, and the unfiltered input for unvoiced */
	Opus_silk_find_LPC_FLP(tls, psEnc, bp+496, bp+528, minInvGain, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch)
	/* Quantize LSFs */
	Opus_silk_process_NLSFs_FLP(tls, psEnc, psEncCtrl+16, bp+496, psEnc+4500)
	/* Calculate residual energy using quantized LPC coefficients */
	Opus_silk_residual_energy_FLP(tls, psEncCtrl+712, bp+528, psEncCtrl+16, psEncCtrl, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder)
	/* Copy to prediction struct for use in next frame for interpolation */
	libc.Xmemcpy(tls, psEnc+4500, bp+496, libc.Uint64FromInt64(32))
}

const MAX_PREDICTION_POWER_GAIN4 = "1e4f"
const MAX_PREDICTION_POWER_GAIN_AFTER_RESET2 = "1e2f"

/************************************************/
/* LPC analysis filter                          */
/* NB! State is kept internally and the         */
/* filter always starts with zero state         */
/* first Order output samples are set to zero   */
/************************************************/

// C documentation
//
//	/* 16th order LPC analysis filter, does not write first 16 samples */

func Opus_silk_gains_ID(tls *libc.TLS, ind uintptr, nb_subfr int32) (r OpusT_opus_int32) {
	var gainsID OpusT_opus_int32
	var k int32
	_, _ = gainsID, k
	gainsID = 0
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		gainsID = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) + libc.Int32FromUint32(libc.Uint32FromInt32(gainsID)<<libc.Int32FromInt32(8))
		goto _1
	_1:
		;
		k = k + 1
	}
	return gainsID
}

// C documentation
//
//	/* Interpolate two vectors */

func Opus_silk_gains_dequant(tls *libc.TLS, gain_Q16 uintptr, ind uintptr, prev_ind uintptr, conditional int32, nb_subfr int32) {
	var double_step_size_threshold, ind_tmp, k, v2, v3, v4, v6 int32
	var v11, v12, v13 OpusT_opus_int32
	var v7 uintptr
	_, _, _, _, _, _, _, _, _, _, _ = double_step_size_threshold, ind_tmp, k, v11, v12, v13, v2, v3, v4, v6, v7
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		if k == 0 && conditional == 0 {
			/* Gain index is not allowed to go down more than 16 steps (~21.8 dB) */
			v2 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
			v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) - int32(16)
			if v2 > v3 {
				v6 = v2
			} else {
				v6 = v3
			}
			v4 = v6
			goto _5
		_5:
			*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v4)
		} else {
			/* Delta index */
			ind_tmp = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) + -int32(4)
			/* Accumulate deltas */
			double_step_size_threshold = libc.Int32FromInt32(2)*libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - libc.Int32FromInt32(N_LEVELS_QGAIN) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			if ind_tmp > double_step_size_threshold {
				v7 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v7)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v7))) + (libc.Int32FromUint32(libc.Uint32FromInt32(ind_tmp)<<libc.Int32FromInt32(1)) - double_step_size_threshold))
			} else {
				v7 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v7)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v7))) + ind_tmp)
			}
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
			v2 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
		} else {
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) < 0 {
				v3 = 0
			} else {
				v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			}
			v2 = v3
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v2)
		/* Scale and convert to linear scale */
		v11 = int32(int64(libc.Int32FromInt32(65536)*((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))/(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1)))*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))>>libc.Int32FromInt32(16)) + (libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6) + libc.Int32FromInt32(16)*libc.Int32FromInt32(128))
		v12 = int32(3967)
		if v11 < v12 {
			v2 = v11
		} else {
			v2 = v12
		}
		v13 = v2
		goto _14
	_14:
		*(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)) = Opus_silk_log2lin(tls, v13) /* 3967 = 31 in Q7 */
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* Compute unique identifier of gain indices vector */

func Opus_silk_gains_quant(tls *libc.TLS, ind uintptr, gain_Q16 uintptr, prev_ind uintptr, conditional int32, nb_subfr int32) {
	var double_step_size_threshold, k, v2, v3, v4, v5, v6 int32
	var v11 uintptr
	var v19, v20, v21 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = double_step_size_threshold, k, v11, v19, v2, v20, v21, v3, v4, v5, v6
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		/* Convert to log scale, scale, floor() */
		*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(int32(int64(libc.Int32FromInt32(65536)*(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1))/((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))) * int64(int16(Opus_silk_lin2log(tls, *(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)))-(libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6)+libc.Int32FromInt32(16)*libc.Int32FromInt32(128)))) >> libc.Int32FromInt32(16)))
		/* Round towards previous quantized gain (hysteresis) */
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) {
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = *(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) + 1
		}
		if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
			v2 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
		} else {
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < 0 {
				v3 = 0
			} else {
				v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
			}
			v2 = v3
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
		/* Compute delta indices and limit */
		if k == 0 && conditional == 0 {
			/* Full index */
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) {
					v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) + -int32(4)
				} else {
					if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
						v4 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
					} else {
						v4 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
					}
					v3 = v4
				}
				v2 = v3
			} else {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1) {
					v5 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
				} else {
					if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))+-int32(4) {
						v6 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))) + -int32(4)
					} else {
						v6 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
					}
					v5 = v6
				}
				v2 = v5
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
			*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = *(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))
		} else {
			/* Delta index */
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) - int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))
			/* Double the quantization step size for large gain increases, so that the max gain level can be reached */
			double_step_size_threshold = libc.Int32FromInt32(2)*libc.Int32FromInt32(MAX_DELTA_GAIN_QUANT) - libc.Int32FromInt32(N_LEVELS_QGAIN) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > double_step_size_threshold {
				*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(double_step_size_threshold + (int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))-double_step_size_threshold+int32(1))>>int32(1))
			}
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > int32(MAX_DELTA_GAIN_QUANT) {
				v2 = int32(MAX_DELTA_GAIN_QUANT)
			} else {
				if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) < -int32(4) {
					v3 = -int32(4)
				} else {
					v3 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))
				}
				v2 = v3
			}
			*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))) = int8(v2)
			/* Accumulate deltas */
			if int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))) > double_step_size_threshold {
				v11 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + (libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k))))<<libc.Int32FromInt32(1)) - double_step_size_threshold))
				v2 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)))
				v3 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
				if v2 < v3 {
					v5 = v2
				} else {
					v5 = v3
				}
				v4 = v5
				goto _15
			_15:
				*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind)) = int8(v4)
			} else {
				v11 = prev_ind
				*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(ind + uintptr(k)))))
			}
			/* Shift to make non-negative */
			v11 = ind + uintptr(k)
			*(*OpusT_opus_int8)(unsafe.Pointer(v11)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v11))) - -libc.Int32FromInt32(4))
		}
		/* Scale and convert to linear scale */
		v19 = int32(int64(libc.Int32FromInt32(65536)*((libc.Int32FromInt32(MAX_QGAIN_DB)-libc.Int32FromInt32(MIN_QGAIN_DB))*libc.Int32FromInt32(128)/libc.Int32FromInt32(6))/(libc.Int32FromInt32(N_LEVELS_QGAIN)-libc.Int32FromInt32(1)))*int64(int16(*(*OpusT_opus_int8)(unsafe.Pointer(prev_ind))))>>libc.Int32FromInt32(16)) + (libc.Int32FromInt32(MIN_QGAIN_DB)*libc.Int32FromInt32(128)/libc.Int32FromInt32(6) + libc.Int32FromInt32(16)*libc.Int32FromInt32(128))
		v20 = int32(3967)
		if v19 < v20 {
			v2 = v19
		} else {
			v2 = v20
		}
		v21 = v2
		goto _22
	_22:
		*(*OpusT_opus_int32)(unsafe.Pointer(gain_Q16 + uintptr(k)*4)) = Opus_silk_log2lin(tls, v21) /* 3967 = 31 in Q7 */
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* Gains scalar dequantization, uniform on log scale */

func Opus_silk_init_decoder(tls *libc.TLS, psDec uintptr) (r int32) {
	/* Clear the entire encoder state, except anything copied */
	libc.Xmemset(tls, psDec, 0, libc.Uint64FromInt64(4392))
	Opus_silk_reset_decoder(tls, psDec)
	return 0
}

const silk_int16_MAX3 = 32767

// C documentation
//
//	/**********************************************************/
//	/* Core decoder. Performs inverse NSQ operation LTP + LPC */
//	/**********************************************************/

func Opus_silk_init_encoder(tls *libc.TLS, psEnc uintptr, arch int32) (r int32) {
	var ret int32
	_ = ret
	ret = 0
	/* Clear the entire encoder state */
	libc.Xmemset(tls, psEnc, 0, libc.Uint64FromInt64(10184))
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch = arch
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fvariable_HP_smth1_Q15 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(float64(int64(libc.Int32FromInt32(VARIABLE_HP_MIN_CUTOFF_HZ))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))-libc.Int32FromInt32(16)<<libc.Int32FromInt32(7)) << libc.Int32FromInt32(8))
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fvariable_HP_smth2_Q15 = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fvariable_HP_smth1_Q15
	/* Used to deactivate LSF interpolation, pitch prediction */
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffirst_frame_after_reset = int32(1)
	/* Initialize Silk VAD */
	ret = ret + Opus_silk_VAD_Init(tls, psEnc+36)
	return ret
}

const PE_D_SRCH_LENGTH = 24
const PE_FLATCONTOUR_BIAS = "0.05f"
const PE_MAX_FS_KHZ = 16
const PE_MAX_LAG_MS = 18
const PE_MAX_NB_SUBFR = 4
const PE_MIN_LAG_MS = 2
const PE_NB_CBKS_STAGE2 = 3
const PE_NB_CBKS_STAGE2_10MS = 3
const PE_NB_CBKS_STAGE2_EXT = 11
const PE_NB_CBKS_STAGE3_10MS = 12
const PE_NB_CBKS_STAGE3_MAX = 34
const PE_NB_CBKS_STAGE3_MID = 24
const PE_NB_CBKS_STAGE3_MIN = 16
const PE_NB_STAGE3_LAGS = 5
const PE_PREVLAG_BIAS = "0.2f"
const PE_SHORTLAG_BIAS = "0.2f"
const PE_SUBFR_LENGTH_MS = 5
const SILK_PE_MAX_COMPLEX = 2
const SILK_PE_MID_COMPLEX = 1
const SILK_PE_MIN_COMPLEX = 0
const WARPING_MULTIPLIER1 = 0.015

// C documentation
//
//	/* Control encoder */

func Opus_silk_inner_prod_aligned_scale(tls *libc.TLS, inVec1 uintptr, inVec2 uintptr, scale int32, len1 int32) (r OpusT_opus_int32) {
	var i int32
	var sum OpusT_opus_int32
	_, _ = i, sum
	sum = 0
	i = 0
	for {
		if !(i < len1) {
			break
		}
		sum = sum + int32(*(*OpusT_opus_int16)(unsafe.Pointer(inVec1 + uintptr(i)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(inVec2 + uintptr(i)*2)))>>scale
		goto _1
	_1:
		;
		i = i + 1
	}
	return sum
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Approximation of 128 * log2() (very close inverse of silk_log2lin()) */
//	/* Convert input to a log scale    */

func Opus_silk_inner_product_FLP_c(tls *libc.TLS, data1 uintptr, data2 uintptr, dataSize int32) (r float64) {
	var i int32
	var result float64
	_, _ = i, result
	/* 4x unrolled loop */
	result = float64(0)
	i = 0
	for {
		if !(i < dataSize-int32(3)) {
			break
		}
		result = result + (float64(float64(*(*float32)(unsafe.Pointer(data1 + uintptr(i+0)*4)))*float64(*(*float32)(unsafe.Pointer(data2 + uintptr(i+0)*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(1))*4)))*float64(*(*float32)(unsafe.Pointer(data2 + uintptr(i+int32(1))*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(2))*4)))*float64(*(*float32)(unsafe.Pointer(data2 + uintptr(i+int32(2))*4)))) + float64(float64(*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(3))*4)))*float64(*(*float32)(unsafe.Pointer(data2 + uintptr(i+int32(3))*4)))))
		goto _1
	_1:
		;
		i = i + int32(4)
	}
	/* add any remaining products */
	for {
		if !(i < dataSize) {
			break
		}
		result = result + float64(float64(*(*float32)(unsafe.Pointer(data1 + uintptr(i)*4)))*float64(*(*float32)(unsafe.Pointer(data2 + uintptr(i)*4))))
		goto _2
	_2:
		;
		i = i + 1
	}
	return result
}

// C documentation
//
//	/* step up function, converts reflection coefficients to prediction coefficients */

func Opus_silk_insertion_sort_decreasing_FLP(tls *libc.TLS, a uintptr, idx uintptr, L int32, K int32) {
	var i, j int32
	var value float32
	_, _, _ = i, j, value
	/* Safety checks */
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10564, __ccgo_ts+12490, int32(50))
	}
	if !(L > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10603, __ccgo_ts+12490, int32(51))
	}
	if !(L >= K) {
		Opus_celt_fatal(tls, __ccgo_ts+10627, __ccgo_ts+12490, int32(52))
	}
	/* Write start indices in index vector */
	i = 0
	for {
		if !(i < K) {
			break
		}
		*(*int32)(unsafe.Pointer(idx + uintptr(i)*4)) = i
		goto _1
	_1:
		;
		i = i + 1
	}
	/* Sort vector elements by value, decreasing order */
	i = int32(1)
	for {
		if !(i < K) {
			break
		}
		value = *(*float32)(unsafe.Pointer(a + uintptr(i)*4))
		j = i - int32(1)
		for {
			if !(j >= 0 && value > *(*float32)(unsafe.Pointer(a + uintptr(j)*4))) {
				break
			}
			*(*float32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*float32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4)) /* Shift index */
			goto _3
		_3:
			;
			j = j - 1
		}
		*(*float32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
		*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i     /* Write index */
		goto _2
	_2:
		;
		i = i + 1
	}
	/* If less than L values are asked check the remaining values,      */
	/* but only spend CPU to ensure that the K first values are correct */
	i = K
	for {
		if !(i < L) {
			break
		}
		value = *(*float32)(unsafe.Pointer(a + uintptr(i)*4))
		if value > *(*float32)(unsafe.Pointer(a + uintptr(K-int32(1))*4)) {
			j = K - int32(2)
			for {
				if !(j >= 0 && value > *(*float32)(unsafe.Pointer(a + uintptr(j)*4))) {
					break
				}
				*(*float32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*float32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
				*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4)) /* Shift index */
				goto _5
			_5:
				;
				j = j - 1
			}
			*(*float32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i     /* Write index */
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

func Opus_silk_insertion_sort_increasing(tls *libc.TLS, a uintptr, idx uintptr, L int32, K int32) {
	var i, j int32
	var value OpusT_opus_int32
	_, _, _ = i, j, value
	/* Safety checks */
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10564, __ccgo_ts+10588, int32(51))
	}
	if !(L > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10603, __ccgo_ts+10588, int32(52))
	}
	if !(L >= K) {
		Opus_celt_fatal(tls, __ccgo_ts+10627, __ccgo_ts+10588, int32(53))
	}
	/* Write start indices in index vector */
	i = 0
	for {
		if !(i < K) {
			break
		}
		*(*int32)(unsafe.Pointer(idx + uintptr(i)*4)) = i
		goto _1
	_1:
		;
		i = i + 1
	}
	/* Sort vector elements by value, increasing order */
	i = int32(1)
	for {
		if !(i < K) {
			break
		}
		value = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(i)*4))
		j = i - int32(1)
		for {
			if !(j >= 0 && value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4))) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4))                   /* Shift index */
			goto _3
		_3:
			;
			j = j - 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
		*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i              /* Write index */
		goto _2
	_2:
		;
		i = i + 1
	}
	/* If less than L values are asked for, check the remaining values, */
	/* but only spend CPU to ensure that the K first values are correct */
	i = K
	for {
		if !(i < L) {
			break
		}
		value = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(i)*4))
		if value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(K-int32(1))*4)) {
			j = K - int32(2)
			for {
				if !(j >= 0 && value < *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4))) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j)*4)) /* Shift value */
				*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = *(*int32)(unsafe.Pointer(idx + uintptr(j)*4))                   /* Shift index */
				goto _5
			_5:
				;
				j = j - 1
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(a + uintptr(j+int32(1))*4)) = value /* Write value */
			*(*int32)(unsafe.Pointer(idx + uintptr(j+int32(1))*4)) = i              /* Write index */
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

func Opus_silk_insertion_sort_increasing_all_values_int16(tls *libc.TLS, a uintptr, L int32) {
	var i, j, value int32
	_, _, _ = i, j, value
	/* Safety checks */
	if !(L > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10603, __ccgo_ts+10588, int32(144))
	}
	/* Sort vector elements by value, increasing order */
	i = int32(1)
	for {
		if !(i < L) {
			break
		}
		value = int32(*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(i)*2)))
		j = i - int32(1)
		for {
			if !(j >= 0 && value < int32(*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j)*2)))) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j+int32(1))*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j)*2)) /* Shift value */
			goto _2
		_2:
			;
			j = j - 1
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(a + uintptr(j+int32(1))*2)) = int16(value) /* Write value */
		goto _1
	_1:
		;
		i = i + 1
	}
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Compute number of bits to right shift the sum of squares of a vector */
//	/* of int16s to make it fit in an int32                                 */

func Opus_silk_interpolate(tls *libc.TLS, xi uintptr, x0 uintptr, x1 uintptr, ifact_Q2 int32, d int32) {
	var i int32
	_ = i
	if !(ifact_Q2 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+8288, __ccgo_ts+8320, int32(45))
	}
	if !(ifact_Q2 <= libc.Int32FromInt32(4)) {
		Opus_celt_fatal(tls, __ccgo_ts+8342, __ccgo_ts+8320, int32(46))
	}
	i = 0
	for {
		if !(i < d) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(xi + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x0 + uintptr(i)*2))) + int32(int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(i)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(x0 + uintptr(i)*2)))))*int32(int16(ifact_Q2))>>libc.Int32FromInt32(2))
		goto _1
	_1:
		;
		i = i + 1
	}
}

const silk_int16_MAX7 = 32767

// C documentation
//
//	/* Helper function, interpolates the filter taps */

func Opus_silk_k2a_FLP(tls *libc.TLS, A uintptr, rc uintptr, order OpusT_opus_int32) {
	var k, n int32
	var rck, tmp1, tmp2 float32
	_, _, _, _, _ = k, n, rck, tmp1, tmp2
	k = 0
	for {
		if !(k < order) {
			break
		}
		rck = *(*float32)(unsafe.Pointer(rc + uintptr(k)*4))
		n = 0
		for {
			if !(n < (k+int32(1))>>int32(1)) {
				break
			}
			tmp1 = *(*float32)(unsafe.Pointer(A + uintptr(n)*4))
			tmp2 = *(*float32)(unsafe.Pointer(A + uintptr(k-n-int32(1))*4))
			*(*float32)(unsafe.Pointer(A + uintptr(n)*4)) = tmp1 + float32(tmp2*rck)
			*(*float32)(unsafe.Pointer(A + uintptr(k-n-int32(1))*4)) = tmp2 + float32(tmp1*rck)
			goto _2
		_2:
			;
			n = n + 1
		}
		*(*float32)(unsafe.Pointer(A + uintptr(k)*4)) = -rck
		goto _1
	_1:
		;
		k = k + 1
	}
}

const MAX_PREDICTION_POWER_GAIN5 = 10000

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/* compute inverse of LPC prediction gain, and                          */
//	/* test if LPC coefficients are stable (all poles within unit circle)   */
//	/* this code is based on silk_a2k_FLP()                                 */

func Opus_silk_lin2log(tls *libc.TLS, inLin OpusT_opus_int32) (r1 OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var lzeros, v1, v2, v3, v6, v8 OpusT_opus_int32
	var m, r, x OpusT_opus_uint32
	var v5, v7 int32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _ = lzeros, m, r, x, v1, v2, v3, v5, v6, v7, v8
	v1 = inLin
	v2 = v1
	if v2 != 0 {
		v5 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v2)))
	} else {
		v5 = int32(32)
	}
	v3 = v5
	goto _4
_4:
	lzeros = v3
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v6 = v1
	v7 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v6)
	r = libc.Uint32FromInt32(v7)
	m = libc.Uint32FromInt32(-v7)
	if v7 == libc.Int32FromInt32(0) {
		v8 = v6
		goto _9
	} else {
		if v7 < libc.Int32FromInt32(0) {
			v8 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _9
		} else {
			v8 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _9
		}
	}
_9:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v8 & int32(0x7f)
	/* Piece-wise parabolic approximation */
	return int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))+int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))*(libc.Int32FromInt32(128)-*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))*int64(int16(libc.Int32FromInt32(179)))>>libc.Int32FromInt32(16)) + libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(31)-*(*OpusT_opus_int32)(unsafe.Pointer(bp)))<<libc.Int32FromInt32(7))
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Approximation of 2^() (very close inverse of silk_lin2log()) */
//	/* Convert input to a linear scale    */

func Opus_silk_log2lin(tls *libc.TLS, inLog_Q7 OpusT_opus_int32) (r OpusT_opus_int32) {
	var frac_Q7, out OpusT_opus_int32
	_, _ = frac_Q7, out
	if inLog_Q7 < 0 {
		return 0
	} else {
		if inLog_Q7 >= int32(3967) {
			return int32(silk_int32_MAX)
		}
	}
	out = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << (inLog_Q7 >> libc.Int32FromInt32(7)))
	frac_Q7 = inLog_Q7 & int32(0x7F)
	if inLog_Q7 < int32(2048) {
		/* Piece-wise parabolic approximation */
		out = out + out*int32(int64(frac_Q7)+int64(int32(int16(frac_Q7))*int32(int16(libc.Int32FromInt32(128)-frac_Q7)))*int64(int16(-libc.Int32FromInt32(174)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(7)
	} else {
		/* Piece-wise parabolic approximation */
		out = out + out>>libc.Int32FromInt32(7)*int32(int64(frac_Q7)+int64(int32(int16(frac_Q7))*int32(int16(libc.Int32FromInt32(128)-frac_Q7)))*int64(int16(-libc.Int32FromInt32(174)))>>libc.Int32FromInt32(16))
	}
	return out
}

const USE_CELT_FIR = 0
const silk_int16_MAX19 = 32767

/*******************************************/
/* LPC analysis filter                     */
/* NB! State is kept internally and the    */
/* filter always starts with zero state    */
/* first d output samples are set to zero  */
/*******************************************/

/* OPT: Using celt_fir() for this function should be faster, but it may cause
   integer overflows in intermediate values (not final results), which the
   current implementation silences by casting to unsigned. Enabling
   this should be safe in pretty much all cases, even though it is not technically
   C89-compliant. */

func Opus_silk_noise_shape_analysis_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, pitch_res uintptr, x2 uintptr) {
	bp := tls.Alloc(1168)
	defer tls.Free(1168)
	var BWExp, HarmShapeGain, SNR_adj_dB, Tilt, b, energy_variation, gain_add, gain_mult, log_energy, log_energy_prev, nrg, strength, warping, v1 float32
	var flat_part, k, nSamples, nSegs, shift, slope_part int32
	var pitch_res_ptr, psShapeSt, x_ptr uintptr
	var _ /* auto_corr at bp+960 */ [25]float32
	var _ /* rc at bp+1060 */ [25]float32
	var _ /* x_windowed at bp+0 */ [240]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = BWExp, HarmShapeGain, SNR_adj_dB, Tilt, b, energy_variation, flat_part, gain_add, gain_mult, k, log_energy, log_energy_prev, nSamples, nSegs, nrg, pitch_res_ptr, psShapeSt, shift, slope_part, strength, warping, x_ptr, v1
	psShapeSt = psEnc + 7288
	/* Point to start of first LPC analysis block */
	x_ptr = x2 - uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_shape)*4
	/****************/
	/* GAIN CONTROL */
	/****************/
	SNR_adj_dB = float32(float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FSNR_dB_Q7) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(128)))
	/* Input quality is the average of the quality in the lowest two VAD bands */
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Finput_quality = float32(float32(libc.Float32FromFloat32(0.5)*float32(*(*int32)(unsafe.Pointer(psEnc + 4712))+*(*int32)(unsafe.Pointer(psEnc + 4712 + 1*4)))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(32768)))
	/* Coding quality level, between 0.0 and 1.0 */
	v1 = float32(libc.Float64FromFloat64(1) / (libc.Float64FromFloat64(1) + libc.Xexp(tls, float64(-float32(libc.Float32FromFloat32(0.25)*(SNR_adj_dB-libc.Float32FromFloat32(20)))))))
	goto _2
_2:
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality = v1
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FuseCBR == 0 {
		/* Reduce coding SNR during low speech activity */
		b = libc.Float32FromFloat32(1) - float32(float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8)*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(256)))
		SNR_adj_dB = SNR_adj_dB - float32(float32(float32(float32(libc.Float32FromFloat32(2)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality)*(libc.Float32FromFloat32(0.5)+float32(libc.Float32FromFloat32(0.5)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Finput_quality)))*b)*b)
	}
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Reduce gains for periodic signals */
		SNR_adj_dB = SNR_adj_dB + float32(libc.Float32FromFloat32(2)*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FLTPCorr)
	} else {
		/* For unvoiced signals and low-quality input, adjust the quality slower than SNR_dB setting */
		SNR_adj_dB = SNR_adj_dB + float32((float32(float32(-libc.Float32FromFloat32(0.4)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FSNR_dB_Q7))*(libc.Float32FromInt32(1)/libc.Float32FromFloat32(128)))+libc.Float32FromFloat32(6))*(libc.Float32FromFloat32(1)-(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Finput_quality))
	}
	/*************************/
	/* SPARSENESS PROCESSING */
	/*************************/
	/* Set quantizer offset */
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Initially set to 0; may be overruled in process_gains(..) */
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = 0
	} else {
		/* Sparseness measure, based on relative fluctuations of energy per 2 milliseconds */
		nSamples = int32(2) * (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz
		energy_variation = libc.Float32FromFloat32(0)
		log_energy_prev = libc.Float32FromFloat32(0)
		pitch_res_ptr = pitch_res
		nSegs = int32(int16(libc.Int32FromInt32(SUB_FRAME_LENGTH_MS))) * int32(int16((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)) / int32(2)
		k = 0
		for {
			if !(k < nSegs) {
				break
			}
			nrg = float32(nSamples) + float32(Opus_silk_energy_FLP(tls, pitch_res_ptr, nSamples))
			v1 = float32(float64(libc.Float64FromFloat64(3.32192809488736) * libc.Xlog10(tls, float64(nrg))))
			goto _5
		_5:
			log_energy = v1
			if k > 0 {
				energy_variation = energy_variation + float32(libc.Xfabs(tls, float64(log_energy-log_energy_prev)))
			}
			log_energy_prev = log_energy
			pitch_res_ptr = pitch_res_ptr + uintptr(nSamples)*4
			goto _3
		_3:
			;
			k = k + 1
		}
		/* Set quantization offset depending on sparseness measure */
		if energy_variation > float32(libc.Float32FromFloat32(0.6)*float32(nSegs-libc.Int32FromInt32(1))) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = 0
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = int8(1)
		}
	}
	/*******************************/
	/* Control bandwidth expansion */
	/*******************************/
	/* More BWE for signals with high prediction gain */
	strength = float32(libc.Float32FromFloat32(0.001) * (*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FpredGain) /* between 0.0 and 1.0 */
	BWExp = libc.Float32FromFloat32(0.94) / (libc.Float32FromFloat32(1) + float32(strength*strength))
	/* Slightly more warping in analysis will move quantization noise up in frequency, where it's better masked */
	warping = float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fwarping_Q16)/libc.Float32FromFloat32(65536) + float32(libc.Float32FromFloat32(0.01)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality)
	/********************************************/
	/* Compute noise shaping AR coefs and gains */
	/********************************************/
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		flat_part = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz * int32(3)
		slope_part = ((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapeWinLength - flat_part) / int32(2)
		Opus_silk_apply_sine_window_FLP(tls, bp, x_ptr, int32(1), slope_part)
		shift = slope_part
		libc.Xmemcpy(tls, bp+uintptr(shift)*4, x_ptr+uintptr(shift)*4, libc.Uint64FromInt32(flat_part)*libc.Uint64FromInt64(4))
		shift = shift + flat_part
		Opus_silk_apply_sine_window_FLP(tls, bp+uintptr(shift)*4, x_ptr+uintptr(shift)*4, int32(2), slope_part)
		/* Update pointer: next LPC analysis block */
		x_ptr = x_ptr + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length)*4
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fwarping_Q16 > 0 {
			/* Calculate warped auto correlation */
			Opus_silk_warped_autocorrelation_FLP(tls, bp+960, bp, warping, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapeWinLength, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		} else {
			/* Calculate regular auto correlation */
			Opus_silk_autocorrelation_FLP(tls, bp+960, bp, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapeWinLength, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder+int32(1), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Farch)
		}
		/* Add white noise, as a fraction of energy */
		*(*float32)(unsafe.Pointer(bp + 960)) += float32((*(*[25]float32)(unsafe.Pointer(bp + 960)))[0]*libc.Float32FromFloat32(3e-05)) + libc.Float32FromFloat32(1)
		/* Convert correlations to prediction coefficients, and compute residual energy */
		nrg = Opus_silk_schur_FLP(tls, bp+1060, bp+960, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		Opus_silk_k2a_FLP(tls, psEncCtrl+244+uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*4, bp+1060, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) = float32(libc.Xsqrt(tls, float64(nrg)))
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fwarping_Q16 > 0 {
			/* Adjust gain for warping */
			*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) *= warped_gain(tls, psEncCtrl+244+uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*4, warping, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		}
		/* Bandwidth expansion for synthesis filter shaping */
		Opus_silk_bwexpander_FLP(tls, psEncCtrl+244+uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*4, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder, BWExp)
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fwarping_Q16 > 0 {
			/* Convert to monic warped prediction coefficients and limit absolute values */
			warped_true2monic_coefs(tls, psEncCtrl+244+uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*4, warping, libc.Float32FromFloat32(3.999), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		} else {
			/* Limit absolute values */
			limit_coefs(tls, psEncCtrl+244+uintptr(k*int32(MAX_SHAPE_LPC_ORDER))*4, libc.Float32FromFloat32(3.999), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FshapingLPCOrder)
		}
		goto _6
	_6:
		;
		k = k + 1
	}
	/*****************/
	/* Gain tweaking */
	/*****************/
	/* Increase gains during low speech activity */
	gain_mult = float32(libc.Xpow(tls, libc.Float64FromFloat32(2), float64(-libc.Float32FromFloat32(0.16)*SNR_adj_dB)))
	gain_add = float32(libc.Xpow(tls, libc.Float64FromFloat32(2), float64(libc.Float32FromFloat32(0.16)*libc.Float32FromInt32(MIN_QGAIN_DB))))
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) *= gain_mult
		*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) += gain_add
		goto _7
	_7:
		;
		k = k + 1
	}
	/************************************************/
	/* Control low-frequency shaping and noise tilt */
	/************************************************/
	/* Less low frequency shaping for noisy inputs */
	strength = float32(libc.Float32FromFloat32(4) * (libc.Float32FromFloat32(1) + float32(libc.Float32FromFloat32(0.5)*(float32(float32(*(*int32)(unsafe.Pointer(psEnc + 4712)))*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(32768)))-libc.Float32FromFloat32(1)))))
	strength = strength * float32(float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8)*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(256)))
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Reduce low frequencies quantization noise for periodic signals, depending on pitch lag */
		/*f = 400; freqz([1, -0.98 + 2e-4 * f], [1, -0.97 + 7e-4 * f], 2^12, Fs); axis([0, 1000, -10, 1])*/
		k = 0
		for {
			if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
				break
			}
			b = libc.Float32FromFloat32(0.2)/float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz) + libc.Float32FromFloat32(3)/float32(*(*int32)(unsafe.Pointer(psEncCtrl + 228 + uintptr(k)*4)))
			*(*float32)(unsafe.Pointer(psEncCtrl + 628 + uintptr(k)*4)) = -libc.Float32FromFloat32(1) + b
			*(*float32)(unsafe.Pointer(psEncCtrl + 644 + uintptr(k)*4)) = libc.Float32FromFloat32(1) - b - float32(b*strength)
			goto _8
		_8:
			;
			k = k + 1
		}
		Tilt = -libc.Float32FromFloat32(0.25) - float32(float32(float32((libc.Float32FromInt32(1)-libc.Float32FromFloat32(0.25))*libc.Float32FromFloat32(0.35))*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8))*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(256)))
	} else {
		b = libc.Float32FromFloat32(1.3) / float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz)
		*(*float32)(unsafe.Pointer(psEncCtrl + 628)) = -libc.Float32FromFloat32(1) + b
		*(*float32)(unsafe.Pointer(psEncCtrl + 644)) = libc.Float32FromFloat32(1) - b - float32(float32(b*strength)*libc.Float32FromFloat32(0.6))
		k = int32(1)
		for {
			if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
				break
			}
			*(*float32)(unsafe.Pointer(psEncCtrl + 628 + uintptr(k)*4)) = *(*float32)(unsafe.Pointer(psEncCtrl + 628))
			*(*float32)(unsafe.Pointer(psEncCtrl + 644 + uintptr(k)*4)) = *(*float32)(unsafe.Pointer(psEncCtrl + 644))
			goto _9
		_9:
			;
			k = k + 1
		}
		Tilt = -libc.Float32FromFloat32(0.25)
	}
	/****************************/
	/* HARMONIC SHAPING CONTROL */
	/****************************/
	if libc.Bool(int32(USE_HARM_SHAPING) != 0) && int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Harmonic noise shaping */
		HarmShapeGain = libc.Float32FromFloat32(0.3)
		/* More harmonic noise shaping for high bitrates or noisy input */
		HarmShapeGain = HarmShapeGain + float32(libc.Float32FromFloat32(0.2)*(libc.Float32FromFloat32(1)-float32((libc.Float32FromFloat32(1)-(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Finput_quality)))
		/* Less harmonic noise shaping for less periodic signals */
		HarmShapeGain = HarmShapeGain * float32(libc.Xsqrt(tls, float64((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FLTPCorr)))
	} else {
		HarmShapeGain = libc.Float32FromFloat32(0)
	}
	/*************************/
	/* Smooth over subframes */
	/*************************/
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		*(*float32)(unsafe.Pointer(psShapeSt + 4)) += float32(libc.Float32FromFloat32(0.4) * (HarmShapeGain - (*OpusT_silk_shape_state_FLP)(unsafe.Pointer(psShapeSt)).FHarmShapeGain_smth))
		*(*float32)(unsafe.Pointer(psEncCtrl + 676 + uintptr(k)*4)) = (*OpusT_silk_shape_state_FLP)(unsafe.Pointer(psShapeSt)).FHarmShapeGain_smth
		*(*float32)(unsafe.Pointer(psShapeSt + 8)) += float32(libc.Float32FromFloat32(0.4) * (Tilt - (*OpusT_silk_shape_state_FLP)(unsafe.Pointer(psShapeSt)).FTilt_smth))
		*(*float32)(unsafe.Pointer(psEncCtrl + 660 + uintptr(k)*4)) = (*OpusT_silk_shape_state_FLP)(unsafe.Pointer(psShapeSt)).FTilt_smth
		goto _10
	_10:
		;
		k = k + 1
	}
}

const BANDWIDTH_EXPANSION2 = "0.94f"
const BG_SNR_DECR_dB2 = "2.0f"
const ENERGY_VARIATION_THRESHOLD_QNT_OFFSET2 = "0.6f"
const FIND_PITCH_WHITE_NOISE_FRACTION2 = "1e-3f"
const HARMONIC_SHAPING2 = "0.3f"
const HARM_HP_NOISE_COEF2 = "0.35f"
const HARM_SNR_INCR_dB2 = "2.0f"
const HIGH_RATE_OR_LOW_QUALITY_HARMONIC_SHAPING2 = "0.2f"
const HP_NOISE_COEF2 = "0.25f"
const LAMBDA_OFFSET1 = 1.2
const LAMBDA_QUANT_OFFSET1 = 0.8
const LOW_FREQ_SHAPING2 = "4.0f"
const LOW_QUALITY_LOW_FREQ_SHAPING_DECR2 = "0.5f"
const SHAPE_WHITE_NOISE_FRACTION2 = "3e-5f"
const SUBFR_SMTH_COEF2 = "0.4f"

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* Processing of gains */

func Opus_silk_pitch_analysis_core_FLP(tls *libc.TLS, frame uintptr, pitch_out uintptr, lagIndex uintptr, contourIndex uintptr, LTPCorr uintptr, prevLag int32, search_thres1 float32, search_thres2 float32, Fs_kHz int32, complexity int32, nb_subfr int32, arch int32) (r int32) {
	bp := tls.Alloc(13680)
	defer tls.Free(13680)
	var CBimax, CBimax_new, cbk_size, d, end_lag, frame_length, frame_length_4kHz, frame_length_8kHz, i, j, k2, lag, lag_counter, lag_new, length_d_comp, length_d_srch, max_lag, max_lag_4kHz, max_lag_8kHz, min_lag, min_lag_4kHz, min_lag_8kHz, nb_cbk_search, sf_length, sf_length_4kHz, sf_length_8kHz, start_lag, v13, v3, v4, v8, v9 int32
	var CCmax, CCmax_b, CCmax_new, CCmax_new_b, Cmax, contour_bias, delta_lag_log2_sqr, lag_log2, prevLag_log2, threshold, v17, v18 float32
	var Lag_CB_ptr, basis_ptr, target_ptr, v1 uintptr
	var cross_corr, energy, energy_tmp, normalizer float64
	var k, k1 OpusT_opus_int32
	var _ /* C at bp+2904 */ [4][149]float32
	var _ /* CC at bp+5548 */ [11]float32
	var _ /* cross_corr_st3 at bp+8708 */ [4][34][5]float32
	var _ /* d_comp at bp+5688 */ [149]OpusT_opus_int16
	var _ /* d_srch at bp+5592 */ [24]int32
	var _ /* energies_st3 at bp+5988 */ [4][34][5]float32
	var _ /* filt_state at bp+2880 */ [6]OpusT_opus_int32
	var _ /* frame_12_FIX at bp+12708 */ [480]OpusT_opus_int16
	var _ /* frame_16_FIX at bp+11428 */ [640]OpusT_opus_int16
	var _ /* frame_4_FIX at bp+2560 */ [160]OpusT_opus_int16
	var _ /* frame_4kHz at bp+1280 */ [160]float32
	var _ /* frame_8_FIX at bp+1920 */ [320]OpusT_opus_int16
	var _ /* frame_8kHz at bp+0 */ [320]float32
	var _ /* xcorr at bp+5288 */ [65]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = CBimax, CBimax_new, CCmax, CCmax_b, CCmax_new, CCmax_new_b, Cmax, Lag_CB_ptr, basis_ptr, cbk_size, contour_bias, cross_corr, d, delta_lag_log2_sqr, end_lag, energy, energy_tmp, frame_length, frame_length_4kHz, frame_length_8kHz, i, j, k, k1, k2, lag, lag_counter, lag_log2, lag_new, length_d_comp, length_d_srch, max_lag, max_lag_4kHz, max_lag_8kHz, min_lag, min_lag_4kHz, min_lag_8kHz, nb_cbk_search, normalizer, prevLag_log2, sf_length, sf_length_4kHz, sf_length_8kHz, start_lag, target_ptr, threshold, v1, v13, v17, v18, v3, v4, v8, v9
	/* Check for valid sampling frequency */
	if !(Fs_kHz == int32(8) || Fs_kHz == int32(12) || Fs_kHz == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+11799, __ccgo_ts+11861, int32(112))
	}
	/* Check for valid complexity setting */
	if !(complexity >= libc.Int32FromInt32(SILK_PE_MIN_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11901, __ccgo_ts+11861, int32(115))
	}
	if !(complexity <= libc.Int32FromInt32(SILK_PE_MAX_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11953, __ccgo_ts+11861, int32(116))
	}
	_ = search_thres1 >= libc.Float32FromFloat32(0) && search_thres1 <= libc.Float32FromFloat32(1)
	_ = search_thres2 >= libc.Float32FromFloat32(0) && search_thres2 <= libc.Float32FromFloat32(1)
	/* Set up frame lengths max / min lag for the sampling frequency */
	frame_length = (libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS) + nb_subfr*int32(PE_SUBFR_LENGTH_MS)) * Fs_kHz
	frame_length_4kHz = (libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS) + nb_subfr*int32(PE_SUBFR_LENGTH_MS)) * int32(4)
	frame_length_8kHz = (libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS) + nb_subfr*int32(PE_SUBFR_LENGTH_MS)) * int32(8)
	sf_length = int32(PE_SUBFR_LENGTH_MS) * Fs_kHz
	sf_length_4kHz = libc.Int32FromInt32(PE_SUBFR_LENGTH_MS) * libc.Int32FromInt32(4)
	sf_length_8kHz = libc.Int32FromInt32(PE_SUBFR_LENGTH_MS) * libc.Int32FromInt32(8)
	min_lag = int32(PE_MIN_LAG_MS) * Fs_kHz
	min_lag_4kHz = libc.Int32FromInt32(PE_MIN_LAG_MS) * libc.Int32FromInt32(4)
	min_lag_8kHz = libc.Int32FromInt32(PE_MIN_LAG_MS) * libc.Int32FromInt32(8)
	max_lag = int32(PE_MAX_LAG_MS)*Fs_kHz - int32(1)
	max_lag_4kHz = libc.Int32FromInt32(PE_MAX_LAG_MS) * libc.Int32FromInt32(4)
	max_lag_8kHz = libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(8) - libc.Int32FromInt32(1)
	/* Resample from input sampled at Fs_kHz to 8 kHz */
	if Fs_kHz == int32(16) {
		v1 = frame
		k = frame_length - libc.Int32FromInt32(1)
		for {
			if !(k >= libc.Int32FromInt32(0)) {
				break
			}
			if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) > int32(silk_int16_MAX27) {
				v3 = int32(silk_int16_MAX27)
			} else {
				if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) < int32(libc.Int16FromInt32(0x8000)) {
					v4 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v4 = int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4))))
				}
				v3 = v4
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(bp + 11428 + uintptr(k)*2)) = int16(v3)
			goto _2
		_2:
			;
			k = k - 1
		}
		libc.Xmemset(tls, bp+2880, 0, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(4))
		Opus_silk_resampler_down2(tls, bp+2880, bp+1920, bp+11428, frame_length)
		k1 = frame_length_8kHz - libc.Int32FromInt32(1)
		for {
			if !(k1 >= libc.Int32FromInt32(0)) {
				break
			}
			*(*float32)(unsafe.Pointer(bp + uintptr(k1)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(bp + 1920 + uintptr(k1)*2)))
			goto _5
		_5:
			;
			k1 = k1 - 1
		}
	} else {
		if Fs_kHz == int32(12) {
			v1 = frame
			k = frame_length - libc.Int32FromInt32(1)
			for {
				if !(k >= libc.Int32FromInt32(0)) {
					break
				}
				if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) > int32(silk_int16_MAX27) {
					v3 = int32(silk_int16_MAX27)
				} else {
					if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) < int32(libc.Int16FromInt32(0x8000)) {
						v4 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v4 = int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4))))
					}
					v3 = v4
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(bp + 12708 + uintptr(k)*2)) = int16(v3)
				goto _7
			_7:
				;
				k = k - 1
			}
			libc.Xmemset(tls, bp+2880, 0, libc.Uint64FromInt32(6)*libc.Uint64FromInt64(4))
			Opus_silk_resampler_down2_3(tls, bp+2880, bp+1920, bp+12708, frame_length)
			k1 = frame_length_8kHz - libc.Int32FromInt32(1)
			for {
				if !(k1 >= libc.Int32FromInt32(0)) {
					break
				}
				*(*float32)(unsafe.Pointer(bp + uintptr(k1)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(bp + 1920 + uintptr(k1)*2)))
				goto _10
			_10:
				;
				k1 = k1 - 1
			}
		} else {
			if !(Fs_kHz == libc.Int32FromInt32(8)) {
				Opus_celt_fatal(tls, __ccgo_ts+12005, __ccgo_ts+11861, int32(151))
			}
			v1 = frame
			k = frame_length_8kHz - libc.Int32FromInt32(1)
			for {
				if !(k >= libc.Int32FromInt32(0)) {
					break
				}
				if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) > int32(silk_int16_MAX27) {
					v3 = int32(silk_int16_MAX27)
				} else {
					if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) < int32(libc.Int16FromInt32(0x8000)) {
						v4 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v4 = int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4))))
					}
					v3 = v4
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(bp + 1920 + uintptr(k)*2)) = int16(v3)
				goto _12
			_12:
				;
				k = k - 1
			}
		}
	}
	/* Decimate again to 4 kHz */
	libc.Xmemset(tls, bp+2880, 0, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(4))
	Opus_silk_resampler_down2(tls, bp+2880, bp+2560, bp+1920, frame_length_8kHz)
	k1 = frame_length_4kHz - libc.Int32FromInt32(1)
	for {
		if !(k1 >= libc.Int32FromInt32(0)) {
			break
		}
		*(*float32)(unsafe.Pointer(bp + 1280 + uintptr(k1)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(bp + 2560 + uintptr(k1)*2)))
		goto _15
	_15:
		;
		k1 = k1 - 1
	}
	/* Low-pass filter */
	i = frame_length_4kHz - int32(1)
	for {
		if !(i > 0) {
			break
		}
		if float32(int32((*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i]))+(*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i-int32(1)] > libc.Float32FromInt32(silk_int16_MAX27) {
			v17 = libc.Float32FromInt32(silk_int16_MAX27)
		} else {
			if float32(int32((*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i]))+(*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i-int32(1)] < float32(libc.Int16FromInt32(0x8000)) {
				v18 = float32(libc.Int16FromInt32(0x8000))
			} else {
				v18 = float32(int32((*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i])) + (*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i-int32(1)]
			}
			v17 = v18
		}
		(*(*[160]float32)(unsafe.Pointer(bp + 1280)))[i] = float32(int16(v17))
		goto _16
	_16:
		;
		i = i - 1
	}
	/******************************************************************************
	 * FIRST STAGE, operating in 4 khz
	 ******************************************************************************/
	libc.Xmemset(tls, bp+2904, 0, libc.Uint64FromInt64(4)*libc.Uint64FromInt32(nb_subfr)*libc.Uint64FromInt32(libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(PE_MAX_FS_KHZ)>>libc.Int32FromInt32(1)+libc.Int32FromInt32(5)))
	target_ptr = bp + 1280 + uintptr(libc.Int32FromUint32(libc.Uint32FromInt32(sf_length_4kHz)<<libc.Int32FromInt32(2)))*4
	k2 = 0
	for {
		if !(k2 < nb_subfr>>int32(1)) {
			break
		}
		/* Check that we are within range of the array */
		if !(target_ptr >= bp+1280) {
			Opus_celt_fatal(tls, __ccgo_ts+12035, __ccgo_ts+11861, int32(172))
		}
		if !(target_ptr+uintptr(sf_length_8kHz)*4 <= bp+1280+uintptr(frame_length_4kHz)*4) {
			Opus_celt_fatal(tls, __ccgo_ts+12078, __ccgo_ts+11861, int32(173))
		}
		basis_ptr = target_ptr - uintptr(min_lag_4kHz)*4
		/* Check that we are within range of the array */
		if !(basis_ptr >= bp+1280) {
			Opus_celt_fatal(tls, __ccgo_ts+12158, __ccgo_ts+11861, int32(178))
		}
		if !(basis_ptr+uintptr(sf_length_8kHz)*4 <= bp+1280+uintptr(frame_length_4kHz)*4) {
			Opus_celt_fatal(tls, __ccgo_ts+12200, __ccgo_ts+11861, int32(179))
		}
		Opus_celt_pitch_xcorr_c(tls, target_ptr, target_ptr-uintptr(max_lag_4kHz)*4, bp+5288, sf_length_8kHz, max_lag_4kHz-min_lag_4kHz+int32(1), arch)
		/* Calculate first vector products before loop */
		cross_corr = float64((*(*[65]OpusT_opus_val32)(unsafe.Pointer(bp + 5288)))[max_lag_4kHz-min_lag_4kHz])
		normalizer = Opus_silk_energy_FLP(tls, target_ptr, sf_length_8kHz) + Opus_silk_energy_FLP(tls, basis_ptr, sf_length_8kHz) + float64(float32(sf_length_8kHz)*libc.Float32FromFloat32(4000))
		*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(min_lag_4kHz)*4)) += float32(float64(libc.Float64FromInt32(2)*cross_corr) / normalizer)
		/* From now on normalizer is computed recursively */
		d = min_lag_4kHz + int32(1)
		for {
			if !(d <= max_lag_4kHz) {
				break
			}
			basis_ptr -= 4
			/* Check that we are within range of the array */
			_ = basis_ptr >= bp+1280
			_ = basis_ptr+uintptr(sf_length_8kHz)*4 <= bp+1280+uintptr(frame_length_4kHz)*4
			cross_corr = float64((*(*[65]OpusT_opus_val32)(unsafe.Pointer(bp + 5288)))[max_lag_4kHz-d])
			/* Add contribution of new sample and remove contribution from oldest sample */
			normalizer = normalizer + (float64(float64(*(*float32)(unsafe.Pointer(basis_ptr)))*float64(*(*float32)(unsafe.Pointer(basis_ptr)))) - float64(float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(sf_length_8kHz)*4)))*float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(sf_length_8kHz)*4)))))
			*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(d)*4)) += float32(float64(libc.Float64FromInt32(2)*cross_corr) / normalizer)
			goto _20
		_20:
			;
			d = d + 1
		}
		/* Update target pointer */
		target_ptr = target_ptr + uintptr(sf_length_8kHz)*4
		goto _19
	_19:
		;
		k2 = k2 + 1
	}
	/* Apply short-lag bias */
	i = max_lag_4kHz
	for {
		if !(i >= min_lag_4kHz) {
			break
		}
		*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(i)*4)) -= float32(*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(i)*4))*float32(i)) / libc.Float32FromFloat32(4096)
		goto _21
	_21:
		;
		i = i - 1
	}
	/* Sort */
	length_d_srch = int32(4) + int32(2)*complexity
	if !(libc.Int32FromInt32(3)*length_d_srch <= libc.Int32FromInt32(PE_D_SRCH_LENGTH)) {
		Opus_celt_fatal(tls, __ccgo_ts+12279, __ccgo_ts+11861, int32(218))
	}
	Opus_silk_insertion_sort_decreasing_FLP(tls, bp+2904+uintptr(min_lag_4kHz)*4, bp+5592, max_lag_4kHz-min_lag_4kHz+int32(1), length_d_srch)
	/* Escape if correlation is very low already here */
	Cmax = *(*float32)(unsafe.Pointer(bp + 2904 + uintptr(min_lag_4kHz)*4))
	if Cmax < libc.Float32FromFloat32(0.2) {
		libc.Xmemset(tls, pitch_out, 0, libc.Uint64FromInt32(nb_subfr)*libc.Uint64FromInt64(4))
		*(*float32)(unsafe.Pointer(LTPCorr)) = libc.Float32FromFloat32(0)
		*(*OpusT_opus_int16)(unsafe.Pointer(lagIndex)) = 0
		*(*OpusT_opus_int8)(unsafe.Pointer(contourIndex)) = 0
		return int32(1)
	}
	threshold = float32(search_thres1 * Cmax)
	i = 0
	for {
		if !(i < length_d_srch) {
			break
		}
		/* Convert to 8 kHz indices for the sorted correlation that exceeds the threshold */
		if *(*float32)(unsafe.Pointer(bp + 2904 + uintptr(min_lag_4kHz+i)*4)) > threshold {
			(*(*[24]int32)(unsafe.Pointer(bp + 5592)))[i] = libc.Int32FromUint32(libc.Uint32FromInt32((*(*[24]int32)(unsafe.Pointer(bp + 5592)))[i]+min_lag_4kHz) << libc.Int32FromInt32(1))
		} else {
			length_d_srch = i
			break
		}
		goto _22
	_22:
		;
		i = i + 1
	}
	if !(length_d_srch > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+12335, __ccgo_ts+11861, int32(241))
	}
	i = min_lag_8kHz - int32(5)
	for {
		if !(i < max_lag_8kHz+int32(5)) {
			break
		}
		(*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i] = 0
		goto _23
	_23:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < length_d_srch) {
			break
		}
		(*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[(*(*[24]int32)(unsafe.Pointer(bp + 5592)))[i]] = int16(1)
		goto _24
	_24:
		;
		i = i + 1
	}
	/* Convolution */
	i = max_lag_8kHz + int32(3)
	for {
		if !(i >= min_lag_8kHz) {
			break
		}
		v1 = bp + 5688 + uintptr(i)*2
		*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + (int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i-int32(1)]) + int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i-int32(2)])))
		goto _25
	_25:
		;
		i = i - 1
	}
	length_d_srch = 0
	i = min_lag_8kHz
	for {
		if !(i < max_lag_8kHz+int32(1)) {
			break
		}
		if int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i+int32(1)]) > 0 {
			(*(*[24]int32)(unsafe.Pointer(bp + 5592)))[length_d_srch] = i
			length_d_srch = length_d_srch + 1
		}
		goto _27
	_27:
		;
		i = i + 1
	}
	/* Convolution */
	i = max_lag_8kHz + int32(3)
	for {
		if !(i >= min_lag_8kHz) {
			break
		}
		v1 = bp + 5688 + uintptr(i)*2
		*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + (int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i-int32(1)]) + int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i-int32(2)]) + int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i-int32(3)])))
		goto _28
	_28:
		;
		i = i - 1
	}
	length_d_comp = 0
	i = min_lag_8kHz
	for {
		if !(i < max_lag_8kHz+int32(4)) {
			break
		}
		if int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[i]) > 0 {
			(*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[length_d_comp] = int16(i - libc.Int32FromInt32(2))
			length_d_comp = length_d_comp + 1
		}
		goto _30
	_30:
		;
		i = i + 1
	}
	/**********************************************************************************
	 ** SECOND STAGE, operating at 8 kHz, on lag sections with high correlation
	 *************************************************************************************/
	/*********************************************************************************
	 * Find energy of each subframe projected onto its history, for a range of delays
	 *********************************************************************************/
	libc.Xmemset(tls, bp+2904, 0, libc.Uint64FromInt32(libc.Int32FromInt32(PE_MAX_NB_SUBFR)*(libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(PE_MAX_FS_KHZ)>>libc.Int32FromInt32(1)+libc.Int32FromInt32(5)))*libc.Uint64FromInt64(4))
	if Fs_kHz == int32(8) {
		target_ptr = frame + uintptr(libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS)*libc.Int32FromInt32(8))*4
	} else {
		target_ptr = bp + uintptr(libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS)*libc.Int32FromInt32(8))*4
	}
	k2 = 0
	for {
		if !(k2 < nb_subfr) {
			break
		}
		energy_tmp = Opus_silk_energy_FLP(tls, target_ptr, sf_length_8kHz) + float64(1)
		j = 0
		for {
			if !(j < length_d_comp) {
				break
			}
			d = int32((*(*[149]OpusT_opus_int16)(unsafe.Pointer(bp + 5688)))[j])
			basis_ptr = target_ptr - uintptr(d)*4
			_ = arch
			cross_corr = Opus_silk_inner_product_FLP_c(tls, basis_ptr, target_ptr, sf_length_8kHz)
			if cross_corr > libc.Float64FromFloat32(0) {
				energy = Opus_silk_energy_FLP(tls, basis_ptr, sf_length_8kHz)
				*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(k2)*596 + uintptr(d)*4)) = float32(float64(libc.Float64FromInt32(2)*cross_corr) / (energy + energy_tmp))
			} else {
				*(*float32)(unsafe.Pointer(bp + 2904 + uintptr(k2)*596 + uintptr(d)*4)) = libc.Float32FromFloat32(0)
			}
			goto _32
		_32:
			;
			j = j + 1
		}
		target_ptr = target_ptr + uintptr(sf_length_8kHz)*4
		goto _31
	_31:
		;
		k2 = k2 + 1
	}
	/* search over lag range and lags codebook */
	/* scale factor for lag codebook, as a function of center lag */
	CCmax = libc.Float32FromFloat32(0) /* This value doesn't matter */
	CCmax_b = -libc.Float32FromFloat32(1000)
	CBimax = 0      /* To avoid returning undefined lag values */
	lag = -int32(1) /* To check if lag with strong enough correlation has been found */
	if prevLag > 0 {
		if Fs_kHz == int32(12) {
			prevLag = libc.Int32FromUint32(libc.Uint32FromInt32(prevLag)<<libc.Int32FromInt32(1)) / int32(3)
		} else {
			if Fs_kHz == int32(16) {
				prevLag = prevLag >> int32(1)
			}
		}
		v17 = float32(float64(libc.Float64FromFloat64(3.32192809488736) * libc.Xlog10(tls, float64(float32(prevLag)))))
		goto _34
	_34:
		prevLag_log2 = v17
	} else {
		prevLag_log2 = libc.Float32FromInt32(0)
	}
	/* Set up stage 2 codebook based on number of subframes */
	if nb_subfr == int32(PE_MAX_NB_SUBFR) {
		cbk_size = int32(PE_NB_CBKS_STAGE2_EXT)
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2))
		if Fs_kHz == int32(8) && complexity > SILK_PE_MIN_COMPLEX {
			/* If input is 8 khz use a larger codebook here because it is last stage */
			nb_cbk_search = int32(PE_NB_CBKS_STAGE2_EXT)
		} else {
			nb_cbk_search = int32(PE_NB_CBKS_STAGE2)
		}
	} else {
		cbk_size = int32(PE_NB_CBKS_STAGE2_10MS)
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage2_10_ms))
		nb_cbk_search = int32(PE_NB_CBKS_STAGE2_10MS)
	}
	k2 = 0
	for {
		if !(k2 < length_d_srch) {
			break
		}
		d = (*(*[24]int32)(unsafe.Pointer(bp + 5592)))[k2]
		j = 0
		for {
			if !(j < nb_cbk_search) {
				break
			}
			(*(*[11]float32)(unsafe.Pointer(bp + 5548)))[j] = libc.Float32FromFloat32(0)
			i = 0
			for {
				if !(i < nb_subfr) {
					break
				}
				/* Try all codebooks */
				*(*float32)(unsafe.Pointer(bp + 5548 + uintptr(j)*4)) += *(*float32)(unsafe.Pointer(bp + 2904 + uintptr(i)*596 + uintptr(d+int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(i*cbk_size+j)))))*4))
				goto _37
			_37:
				;
				i = i + 1
			}
			goto _36
		_36:
			;
			j = j + 1
		}
		/* Find best codebook */
		CCmax_new = -libc.Float32FromFloat32(1000)
		CBimax_new = 0
		i = 0
		for {
			if !(i < nb_cbk_search) {
				break
			}
			if (*(*[11]float32)(unsafe.Pointer(bp + 5548)))[i] > CCmax_new {
				CCmax_new = (*(*[11]float32)(unsafe.Pointer(bp + 5548)))[i]
				CBimax_new = i
			}
			goto _38
		_38:
			;
			i = i + 1
		}
		/* Bias towards shorter lags */
		v17 = float32(float64(libc.Float64FromFloat64(3.32192809488736) * libc.Xlog10(tls, float64(float32(d)))))
		goto _40
	_40:
		lag_log2 = v17
		CCmax_new_b = CCmax_new - float32(float32(libc.Float32FromFloat32(0.2)*float32(nb_subfr))*lag_log2)
		/* Bias towards previous lag */
		if prevLag > 0 {
			delta_lag_log2_sqr = lag_log2 - prevLag_log2
			delta_lag_log2_sqr = delta_lag_log2_sqr * delta_lag_log2_sqr
			CCmax_new_b = CCmax_new_b - float32(float32(float32(libc.Float32FromFloat32(0.2)*float32(nb_subfr))**(*float32)(unsafe.Pointer(LTPCorr)))*delta_lag_log2_sqr)/(delta_lag_log2_sqr+libc.Float32FromFloat32(0.5))
		}
		if CCmax_new_b > CCmax_b && CCmax_new > float32(float32(nb_subfr)*search_thres2) {
			CCmax_b = CCmax_new_b
			CCmax = CCmax_new
			lag = d
			CBimax = CBimax_new
		}
		goto _35
	_35:
		;
		k2 = k2 + 1
	}
	if lag == -int32(1) {
		/* No suitable candidate found */
		libc.Xmemset(tls, pitch_out, 0, libc.Uint64FromInt32(PE_MAX_NB_SUBFR)*libc.Uint64FromInt64(4))
		*(*float32)(unsafe.Pointer(LTPCorr)) = libc.Float32FromFloat32(0)
		*(*OpusT_opus_int16)(unsafe.Pointer(lagIndex)) = 0
		*(*OpusT_opus_int8)(unsafe.Pointer(contourIndex)) = 0
		return int32(1)
	}
	/* Output normalized correlation */
	*(*float32)(unsafe.Pointer(LTPCorr)) = CCmax / float32(nb_subfr)
	_ = *(*float32)(unsafe.Pointer(LTPCorr)) >= libc.Float32FromFloat32(0)
	if Fs_kHz > int32(8) {
		/* Search in original signal */
		/* Compensate for decimation */
		if lag > int32(silk_int16_MAX27) {
			v3 = int32(silk_int16_MAX27)
		} else {
			if lag < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = lag
			}
			v3 = v4
		}
		_ = lag == v3
		if Fs_kHz == int32(12) {
			lag = int32(int16(lag))*int32(int16(libc.Int32FromInt32(3)))>>int32(1) + int32(int16(lag))*int32(int16(libc.Int32FromInt32(3)))&int32(1)
		} else { /* Fs_kHz == 16 */
			lag = libc.Int32FromUint32(libc.Uint32FromInt32(lag) << libc.Int32FromInt32(1))
		}
		if min_lag > max_lag {
			if lag > min_lag {
				v4 = min_lag
			} else {
				if lag < max_lag {
					v8 = max_lag
				} else {
					v8 = lag
				}
				v4 = v8
			}
			v3 = v4
		} else {
			if lag > max_lag {
				v9 = max_lag
			} else {
				if lag < min_lag {
					v13 = min_lag
				} else {
					v13 = lag
				}
				v9 = v13
			}
			v3 = v9
		}
		lag = v3
		v3 = lag - int32(2)
		v4 = min_lag
		if v3 > v4 {
			v9 = v3
		} else {
			v9 = v4
		}
		v8 = v9
		goto _51
	_51:
		start_lag = v8
		v3 = lag + int32(2)
		v4 = max_lag
		if v3 < v4 {
			v9 = v3
		} else {
			v9 = v4
		}
		v8 = v9
		goto _56
	_56:
		end_lag = v8
		lag_new = lag /* to avoid undefined lag */
		CBimax = 0    /* to avoid undefined lag */
		CCmax = -libc.Float32FromFloat32(1000)
		/* Calculate the correlations and energies needed in stage 3 */
		silk_P_Ana_calc_corr_st3(tls, bp+8708, frame, start_lag, sf_length, nb_subfr, complexity, arch)
		silk_P_Ana_calc_energy_st3(tls, bp+5988, frame, start_lag, sf_length, nb_subfr, complexity)
		lag_counter = 0
		if lag > int32(silk_int16_MAX27) {
			v3 = int32(silk_int16_MAX27)
		} else {
			if lag < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = lag
			}
			v3 = v4
		}
		_ = lag == v3
		contour_bias = libc.Float32FromFloat32(0.05) / float32(lag)
		/* Set up cbk parameters according to complexity setting and frame length */
		if nb_subfr == int32(PE_MAX_NB_SUBFR) {
			nb_cbk_search = int32(Opus_silk_nb_cbk_searchs_stage3[complexity])
			cbk_size = int32(PE_NB_CBKS_STAGE3_MAX)
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3))
		} else {
			nb_cbk_search = int32(PE_NB_CBKS_STAGE3_10MS)
			cbk_size = int32(PE_NB_CBKS_STAGE3_10MS)
			Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3_10_ms))
		}
		target_ptr = frame + uintptr(libc.Int32FromInt32(4)*libc.Int32FromInt32(PE_SUBFR_LENGTH_MS)*Fs_kHz)*4
		energy_tmp = Opus_silk_energy_FLP(tls, target_ptr, nb_subfr*sf_length) + float64(1)
		d = start_lag
		for {
			if !(d <= end_lag) {
				break
			}
			j = 0
			for {
				if !(j < nb_cbk_search) {
					break
				}
				cross_corr = float64(0)
				energy = energy_tmp
				k2 = 0
				for {
					if !(k2 < nb_subfr) {
						break
					}
					cross_corr = cross_corr + float64(*(*float32)(unsafe.Pointer(bp + 8708 + uintptr(k2)*680 + uintptr(j)*20 + uintptr(lag_counter)*4)))
					energy = energy + float64(*(*float32)(unsafe.Pointer(bp + 5988 + uintptr(k2)*680 + uintptr(j)*20 + uintptr(lag_counter)*4)))
					goto _62
				_62:
					;
					k2 = k2 + 1
				}
				if cross_corr > float64(0) {
					CCmax_new = float32(float64(libc.Float64FromInt32(2)*cross_corr) / energy)
					/* Reduce depending on flatness of contour */
					CCmax_new = CCmax_new * (libc.Float32FromFloat32(1) - float32(contour_bias*float32(j)))
				} else {
					CCmax_new = libc.Float32FromFloat32(0)
				}
				if CCmax_new > CCmax && d+int32(*(*OpusT_opus_int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3)) + uintptr(j)))) <= max_lag {
					CCmax = CCmax_new
					lag_new = d
					CBimax = j
				}
				goto _61
			_61:
				;
				j = j + 1
			}
			lag_counter = lag_counter + 1
			goto _60
		_60:
			;
			d = d + 1
		}
		k2 = 0
		for {
			if !(k2 < nb_subfr) {
				break
			}
			*(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) = lag_new + int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k2*cbk_size+CBimax))))
			if min_lag > int32(PE_MAX_LAG_MS)*Fs_kHz {
				if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) > min_lag {
					v4 = min_lag
				} else {
					if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) < int32(PE_MAX_LAG_MS)*Fs_kHz {
						v8 = int32(PE_MAX_LAG_MS) * Fs_kHz
					} else {
						v8 = *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4))
					}
					v4 = v8
				}
				v3 = v4
			} else {
				if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) > int32(PE_MAX_LAG_MS)*Fs_kHz {
					v9 = int32(PE_MAX_LAG_MS) * Fs_kHz
				} else {
					if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) < min_lag {
						v13 = min_lag
					} else {
						v13 = *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4))
					}
					v9 = v13
				}
				v3 = v9
			}
			*(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) = v3
			goto _63
		_63:
			;
			k2 = k2 + 1
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(lagIndex)) = int16(lag_new - min_lag)
		*(*OpusT_opus_int8)(unsafe.Pointer(contourIndex)) = int8(CBimax)
	} else { /* Fs_kHz == 8 */
		/* Save Lags */
		k2 = 0
		for {
			if !(k2 < nb_subfr) {
				break
			}
			*(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) = lag + int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k2*cbk_size+CBimax))))
			if min_lag_8kHz > libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(8) {
				if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) > min_lag_8kHz {
					v4 = min_lag_8kHz
				} else {
					if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) < libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(8) {
						v8 = libc.Int32FromInt32(PE_MAX_LAG_MS) * libc.Int32FromInt32(8)
					} else {
						v8 = *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4))
					}
					v4 = v8
				}
				v3 = v4
			} else {
				if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) > libc.Int32FromInt32(PE_MAX_LAG_MS)*libc.Int32FromInt32(8) {
					v9 = libc.Int32FromInt32(PE_MAX_LAG_MS) * libc.Int32FromInt32(8)
				} else {
					if *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) < min_lag_8kHz {
						v13 = min_lag_8kHz
					} else {
						v13 = *(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4))
					}
					v9 = v13
				}
				v3 = v9
			}
			*(*int32)(unsafe.Pointer(pitch_out + uintptr(k2)*4)) = v3
			goto _69
		_69:
			;
			k2 = k2 + 1
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(lagIndex)) = int16(lag - min_lag_8kHz)
		*(*OpusT_opus_int8)(unsafe.Pointer(contourIndex)) = int8(CBimax)
	}
	if !(int32(*(*OpusT_opus_int16)(unsafe.Pointer(lagIndex))) >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+12371, __ccgo_ts+11861, int32(474))
	}
	/* return as voiced */
	return 0
}

// C documentation
//
//	/***********************************************************************
//	 * Calculates the correlations used in stage 3 search. In order to cover
//	 * the whole lag codebook for all the searched offset lags (lag +- 2),
//	 * the following correlations are needed in each sub frame:
//	 *
//	 * sf1: lag range [-8,...,7] total 16 correlations
//	 * sf2: lag range [-4,...,4] total 9 correlations
//	 * sf3: lag range [-3,....4] total 8 correltions
//	 * sf4: lag range [-6,....8] total 15 correlations
//	 *
//	 * In total 48 correlations. The direct implementation computed in worst
//	 * case 4*12*5 = 240 correlations, but more likely around 120.
//	 ***********************************************************************/

func Opus_silk_process_NLSFs(tls *libc.TLS, psEncC uintptr, PredCoef_Q12 uintptr, pNLSF_Q15 uintptr, prev_NLSFq_Q15 uintptr) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var NLSF_mu_Q20, doInterpolate, i int32
	var i_sqr_Q15 OpusT_opus_int16
	var _ /* pNLSF0_temp_Q15 at bp+0 */ [16]OpusT_opus_int16
	var _ /* pNLSFW0_temp_QW at bp+64 */ [16]OpusT_opus_int16
	var _ /* pNLSFW_QW at bp+32 */ [16]OpusT_opus_int16
	_, _, _, _ = NLSF_mu_Q20, doInterpolate, i, i_sqr_Q15
	_ = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fspeech_activity_Q8 >= libc.Int32FromInt32(0)
	_ = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fspeech_activity_Q8 <= int32(float64(libc.Float64FromFloat64(1)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(8)))+libc.Float64FromFloat64(0.5))
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs == int32(1) || int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2) == libc.Int32FromInt32(1)<<libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+8976, __ccgo_ts+9079, int32(51))
	}
	/***********************/
	/* Calculate mu values */
	/***********************/
	/* NLSF_mu  = 0.003 - 0.0015 * psEnc->speech_activity; */
	NLSF_mu_Q20 = int32(int64(int32(float64(libc.Float64FromFloat64(0.003)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(20)))+libc.Float64FromFloat64(0.5))) + int64(int32(float64(-libc.Float64FromFloat64(0.001)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(28)))+libc.Float64FromFloat64(0.5)))*int64(int16((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fspeech_activity_Q8))>>libc.Int32FromInt32(16))
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fnb_subfr == int32(2) {
		/* Multiply by 1.5 for 10 ms packets */
		NLSF_mu_Q20 = NLSF_mu_Q20 + NLSF_mu_Q20>>int32(1)
	}
	if !(NLSF_mu_Q20 > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+9103, __ccgo_ts+9079, int32(63))
	}
	_ = NLSF_mu_Q20 <= int32(float64(libc.Float64FromFloat64(0.005)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(20)))+libc.Float64FromFloat64(0.5))
	/* Calculate NLSF weights */
	Opus_silk_NLSF_VQ_weights_laroia(tls, bp+32, pNLSF_Q15, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
	/* Update NLSF weights for interpolated NLSFs */
	doInterpolate = libc.BoolInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs == int32(1) && int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2) < int32(4))
	if doInterpolate != 0 {
		/* Calculate the interpolated NLSF vector for the first half */
		Opus_silk_interpolate(tls, bp, prev_NLSFq_Q15, pNLSF_Q15, int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2), (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
		/* Calculate first half NLSF weights for the interpolated NLSFs */
		Opus_silk_NLSF_VQ_weights_laroia(tls, bp+64, bp, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
		/* Update NLSF weights with contribution from first half */
		i_sqr_Q15 = int16(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int16((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2))*int32(int16((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2))) << libc.Int32FromInt32(11)))
		i = 0
		for {
			if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder) {
				break
			}
			(*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 32)))[i] = int16(int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 32)))[i])>>libc.Int32FromInt32(1) + int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 64)))[i])*int32(i_sqr_Q15)>>libc.Int32FromInt32(16))
			_ = int32((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 32)))[i]) >= libc.Int32FromInt32(1)
			goto _1
		_1:
			;
			i = i + 1
		}
	}
	Opus_silk_NLSF_encode(tls, psEncC+4752+8, pNLSF_Q15, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpsNLSF_CB, bp+32, NLSF_mu_Q20, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors, int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FsignalType))
	/* Convert quantized NLSFs back to LPC coefficients */
	Opus_silk_NLSF2A(tls, PredCoef_Q12+1*32, pNLSF_Q15, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
	if doInterpolate != 0 {
		/* Calculate the interpolated, quantized LSF vector for the first half */
		Opus_silk_interpolate(tls, bp, prev_NLSFq_Q15, pNLSF_Q15, int32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Findices.FNLSFInterpCoef_Q2), (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)
		/* Convert back to LPC coefficients */
		Opus_silk_NLSF2A(tls, PredCoef_Q12, bp, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder, (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Farch)
	} else {
		/* Copy LPC coefficients for first half from second half */
		if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder <= libc.Int32FromInt32(MAX_LPC_ORDER)) {
			Opus_celt_fatal(tls, __ccgo_ts+9137, __ccgo_ts+9079, int32(104))
		}
		libc.Xmemcpy(tls, PredCoef_Q12, PredCoef_Q12+1*32, libc.Uint64FromInt32((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder)*libc.Uint64FromInt64(2))
	}
}

const silk_int16_MAX15 = 32767

// C documentation
//
//	/* Convert Left/Right stereo signal to adaptive Mid/Side representation */

func Opus_silk_process_NLSFs_FLP(tls *libc.TLS, psEncC uintptr, PredCoef uintptr, NLSF_Q15 uintptr, prev_NLSF_Q15 uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var i, j int32
	var _ /* PredCoef_Q12 at bp+0 */ [2][16]OpusT_opus_int16
	_, _ = i, j
	Opus_silk_process_NLSFs(tls, psEncC, bp, NLSF_Q15, prev_NLSF_Q15)
	j = 0
	for {
		if !(j < int32(2)) {
			break
		}
		i = 0
		for {
			if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder) {
				break
			}
			*(*float32)(unsafe.Pointer(PredCoef + uintptr(j)*64 + uintptr(i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(bp + uintptr(j)*32 + uintptr(i)*2))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(4096)))
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		j = j + 1
	}
}

// C documentation
//
//	/****************************************/
//	/* Floating-point Silk NSQ wrapper      */
//	/****************************************/

func Opus_silk_process_gains_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, condCoding int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var InvMaxSqrVal, gain, quant_offset, s, v1 float32
	var k int32
	var psShapeSt uintptr
	var _ /* pGains_Q16 at bp+0 */ [4]OpusT_opus_int32
	_, _, _, _, _, _, _ = InvMaxSqrVal, gain, k, psShapeSt, quant_offset, s, v1
	psShapeSt = psEnc + 7288
	/* Gain reduction when LTP coding gain is high */
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		v1 = float32(libc.Float64FromFloat64(1) / (libc.Float64FromFloat64(1) + libc.Xexp(tls, float64(-float32(libc.Float32FromFloat32(0.25)*((*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain-libc.Float32FromFloat32(12)))))))
		goto _2
	_2:
		s = libc.Float32FromFloat32(1) - float32(libc.Float32FromFloat32(0.5)*v1)
		k = 0
		for {
			if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
				break
			}
			*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) *= s
			goto _3
		_3:
			;
			k = k + 1
		}
	}
	/* Limit the quantized signal */
	InvMaxSqrVal = float32(libc.Xpow(tls, libc.Float64FromFloat32(2), float64(libc.Float32FromFloat32(0.33)*(libc.Float32FromFloat32(21)-float32(float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FSNR_dB_Q7)*(libc.Float32FromInt32(1)/libc.Float32FromFloat32(128)))))) / float64((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length))
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		/* Soft limit on ratio residual energy and squared gains */
		gain = *(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4))
		gain = float32(libc.Xsqrt(tls, float64(float32(gain*gain)+float32(*(*float32)(unsafe.Pointer(psEncCtrl + 712 + uintptr(k)*4))*InvMaxSqrVal))))
		if gain < libc.Float32FromFloat32(32767) {
			v1 = gain
		} else {
			v1 = libc.Float32FromFloat32(32767)
		}
		*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) = v1
		goto _4
	_4:
		;
		k = k + 1
	}
	/* Prepare gains for noise shaping quantization */
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		(*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp)))[k] = int32(float32(*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) * libc.Float32FromFloat32(65536)))
		goto _6
	_6:
		;
		k = k + 1
	}
	/* Save unquantized gains and gain Index */
	libc.Xmemcpy(tls, psEncCtrl+728, bp, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)*libc.Uint64FromInt64(4))
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FlastGainIndexPrev = (*OpusT_silk_shape_state_FLP)(unsafe.Pointer(psShapeSt)).FLastGainIndex
	/* Quantize gains */
	Opus_silk_gains_quant(tls, psEnc+4752, bp, psShapeSt, libc.BoolInt32(condCoding == int32(CODE_CONDITIONALLY)), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)
	/* Overwrite unquantized gains with quantized gains and convert back to Q0 from Q16 */
	k = 0
	for {
		if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
			break
		}
		*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) = float32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp)))[k]) / libc.Float32FromFloat32(65536)
		goto _7
	_7:
		;
		k = k + 1
	}
	/* Set quantizer offset for voiced signals. Larger offset when LTP coding gain is low or tilt is high (ie low-pass) */
	if int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType) == int32(TYPE_VOICED) {
		if (*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLTPredCodGain+float32(float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Finput_tilt_Q15)*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(32768))) > libc.Float32FromFloat32(1) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = 0
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType = int8(1)
		}
	}
	/* Quantizer boundary adjustment */
	quant_offset = float32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Quantization_Offsets_Q10)) + uintptr(int32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FsignalType)>>int32(1))*4 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Findices.FquantOffsetType)*2))) / libc.Float32FromFloat32(1024)
	(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLambda = libc.Float32FromFloat32(1.2) + float32(-libc.Float32FromFloat32(0.05)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnStatesDelayedDecision)) + float32(float32(-libc.Float32FromFloat32(0.2)*float32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8))*(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(256))) + float32(-libc.Float32FromFloat32(0.1)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Finput_quality) + float32(-libc.Float32FromFloat32(0.2)*(*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).Fcoding_quality) + float32(libc.Float32FromFloat32(0.8)*quant_offset)
	_ = (*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLambda > libc.Float32FromFloat32(0)
	_ = (*OpusT_silk_encoder_control_FLP)(unsafe.Pointer(psEncCtrl)).FLambda < libc.Float32FromFloat32(2)
}

// C documentation
//
//	/* Add noise to matrix diagonal */

func Opus_silk_quant_LTP_gains(tls *libc.TLS, B_Q14 uintptr, cbk_index uintptr, periodicity_index uintptr, sum_log_gain_Q7 uintptr, pred_gain_dB_Q7 uintptr, XX_Q17 uintptr, xX_Q17 uintptr, subfr_len int32, nb_subfr int32, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var XX_Q17_ptr, cbk_gain_ptr_Q7, cbk_ptr_Q7, cl_ptr_Q5, xX_Q17_ptr uintptr
	var best_sum_log_gain_Q7, gain_safety, max_gain_Q7, min_rate_dist_Q7, rate_dist_Q7, res_nrg_Q15, sum_log_gain_tmp_Q7 OpusT_opus_int32
	var cbk_size, j, k, v3 int32
	var _ /* gain_Q7 at bp+12 */ int32
	var _ /* rate_dist_Q7_subfr at bp+8 */ OpusT_opus_int32
	var _ /* res_nrg_Q15_subfr at bp+4 */ OpusT_opus_int32
	var _ /* temp_idx at bp+0 */ [4]OpusT_opus_int8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = XX_Q17_ptr, best_sum_log_gain_Q7, cbk_gain_ptr_Q7, cbk_ptr_Q7, cbk_size, cl_ptr_Q5, gain_safety, j, k, max_gain_Q7, min_rate_dist_Q7, rate_dist_Q7, res_nrg_Q15, sum_log_gain_tmp_Q7, xX_Q17_ptr, v3
	/***************************************************/
	/* iterate over different codebooks with different */
	/* rates/distortions, and choose best */
	/***************************************************/
	min_rate_dist_Q7 = int32(silk_int32_MAX)
	best_sum_log_gain_Q7 = 0
	k = 0
	for {
		if !(k < int32(3)) {
			break
		}
		/* Safety margin for pitch gain control, to take into account factors
		   such as state rescaling/rewhitening. */
		gain_safety = int32(float64(libc.Float64FromFloat64(0.4)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7))) + libc.Float64FromFloat64(0.5))
		cl_ptr_Q5 = Opus_silk_LTP_gain_BITS_Q5_ptrs[k]
		cbk_ptr_Q7 = Opus_silk_LTP_vq_ptrs_Q7[k]
		cbk_gain_ptr_Q7 = Opus_silk_LTP_vq_gain_ptrs_Q7[k]
		cbk_size = int32(Opus_silk_LTP_vq_sizes[k])
		/* Set up pointers to first subframe */
		XX_Q17_ptr = XX_Q17
		xX_Q17_ptr = xX_Q17
		res_nrg_Q15 = 0
		rate_dist_Q7 = 0
		sum_log_gain_tmp_Q7 = *(*OpusT_opus_int32)(unsafe.Pointer(sum_log_gain_Q7))
		j = 0
		for {
			if !(j < nb_subfr) {
				break
			}
			max_gain_Q7 = Opus_silk_log2lin(tls, int32(float64(libc.Float64FromFloat32(250)/libc.Float64FromFloat64(6)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5))-sum_log_gain_tmp_Q7+int32(float64(int64(libc.Int32FromInt32(7))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5))) - gain_safety
			_ = arch
			Opus_silk_VQ_WMat_EC_c(tls, bp+uintptr(j), bp+4, bp+8, bp+12, XX_Q17_ptr, xX_Q17_ptr, cbk_ptr_Q7, cbk_gain_ptr_Q7, cl_ptr_Q5, subfr_len, max_gain_Q7, cbk_size)
			if (libc.Uint32FromInt32(res_nrg_Q15)+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))&uint32(0x80000000) != 0 {
				v3 = int32(silk_int32_MAX)
			} else {
				v3 = res_nrg_Q15 + *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))
			}
			res_nrg_Q15 = v3
			if (libc.Uint32FromInt32(rate_dist_Q7)+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 8))))&uint32(0x80000000) != 0 {
				v3 = int32(silk_int32_MAX)
			} else {
				v3 = rate_dist_Q7 + *(*OpusT_opus_int32)(unsafe.Pointer(bp + 8))
			}
			rate_dist_Q7 = v3
			if 0 > sum_log_gain_tmp_Q7+Opus_silk_lin2log(tls, gain_safety+*(*int32)(unsafe.Pointer(bp + 12)))-int32(float64(int64(libc.Int32FromInt32(7))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5)) {
				v3 = 0
			} else {
				v3 = sum_log_gain_tmp_Q7 + Opus_silk_lin2log(tls, gain_safety+*(*int32)(unsafe.Pointer(bp + 12))) - int32(float64(int64(libc.Int32FromInt32(7))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(7)))+libc.Float64FromFloat64(0.5))
			}
			sum_log_gain_tmp_Q7 = v3
			XX_Q17_ptr = XX_Q17_ptr + uintptr(libc.Int32FromInt32(LTP_ORDER)*libc.Int32FromInt32(LTP_ORDER))*4
			xX_Q17_ptr = xX_Q17_ptr + uintptr(LTP_ORDER)*4
			goto _2
		_2:
			;
			j = j + 1
		}
		if rate_dist_Q7 <= min_rate_dist_Q7 {
			min_rate_dist_Q7 = rate_dist_Q7
			*(*OpusT_opus_int8)(unsafe.Pointer(periodicity_index)) = int8(k)
			libc.Xmemcpy(tls, cbk_index, bp, libc.Uint64FromInt32(nb_subfr)*libc.Uint64FromInt64(1))
			best_sum_log_gain_Q7 = sum_log_gain_tmp_Q7
		}
		goto _1
	_1:
		;
		k = k + 1
	}
	cbk_ptr_Q7 = Opus_silk_LTP_vq_ptrs_Q7[*(*OpusT_opus_int8)(unsafe.Pointer(periodicity_index))]
	j = 0
	for {
		if !(j < nb_subfr) {
			break
		}
		k = 0
		for {
			if !(k < int32(LTP_ORDER)) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(j*int32(LTP_ORDER)+k)*2)) = int16(libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(cbk_ptr_Q7 + uintptr(int32(*(*OpusT_opus_int8)(unsafe.Pointer(cbk_index + uintptr(j))))*int32(LTP_ORDER)+k)))) << libc.Int32FromInt32(7)))
			goto _7
		_7:
			;
			k = k + 1
		}
		goto _6
	_6:
		;
		j = j + 1
	}
	if nb_subfr == int32(2) {
		res_nrg_Q15 = res_nrg_Q15 >> int32(1)
	} else {
		res_nrg_Q15 = res_nrg_Q15 >> int32(2)
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(sum_log_gain_Q7)) = best_sum_log_gain_Q7
	*(*int32)(unsafe.Pointer(pred_gain_dB_Q7)) = int32(int16(-libc.Int32FromInt32(3))) * int32(int16(Opus_silk_lin2log(tls, res_nrg_Q15)-libc.Int32FromInt32(15)<<libc.Int32FromInt32(7)))
}

// C documentation
//
//	/* Entropy constrained matrix-weighted VQ, hard-coded to 5-element vectors, for a single input data vector */

func Opus_silk_quant_LTP_gains_FLP(tls *libc.TLS, B uintptr, cbk_index uintptr, periodicity_index uintptr, sum_log_gain_Q7 uintptr, pred_gain_dB uintptr, XX uintptr, xX uintptr, subfr_len int32, nb_subfr int32, arch int32) {
	bp := tls.Alloc(528)
	defer tls.Free(528)
	var i, v1 int32
	var v3 OpusT_opus_int32
	var _ /* B_Q14 at bp+4 */ [20]OpusT_opus_int16
	var _ /* XX_Q17 at bp+44 */ [100]OpusT_opus_int32
	var _ /* pred_gain_dB_Q7 at bp+0 */ int32
	var _ /* xX_Q17 at bp+444 */ [20]OpusT_opus_int32
	_, _, _ = i, v1, v3
	i = 0
	for {
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(XX + uintptr(i)*4))*libc.Float32FromFloat32(131072))))
		goto _4
	_4:
		(*(*[100]OpusT_opus_int32)(unsafe.Pointer(bp + 44)))[i] = v3
		goto _2
	_2:
		;
		i = i + 1
		v1 = i
		if !(v1 < nb_subfr*int32(LTP_ORDER)*int32(LTP_ORDER)) {
			break
		}
	}
	i = 0
	for {
		v3 = int32(Opus_lrintf(tls, float32(*(*float32)(unsafe.Pointer(xX + uintptr(i)*4))*libc.Float32FromFloat32(131072))))
		goto _8
	_8:
		(*(*[20]OpusT_opus_int32)(unsafe.Pointer(bp + 444)))[i] = v3
		goto _6
	_6:
		;
		i = i + 1
		v1 = i
		if !(v1 < nb_subfr*int32(LTP_ORDER)) {
			break
		}
	}
	Opus_silk_quant_LTP_gains(tls, bp+4, cbk_index, periodicity_index, sum_log_gain_Q7, bp, bp+44, bp+444, subfr_len, nb_subfr, arch)
	i = 0
	for {
		if !(i < nb_subfr*int32(LTP_ORDER)) {
			break
		}
		*(*float32)(unsafe.Pointer(B + uintptr(i)*4)) = float32(float32((*(*[20]OpusT_opus_int16)(unsafe.Pointer(bp + 4)))[i]) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(16384)))
		goto _9
	_9:
		;
		i = i + 1
	}
	*(*float32)(unsafe.Pointer(pred_gain_dB)) = float32(float32(*(*int32)(unsafe.Pointer(bp))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(128)))
}

// C documentation
//
//	/* compute autocorrelation */

func Opus_silk_regularize_correlations_FLP(tls *libc.TLS, XX uintptr, xx uintptr, noise float32, D int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < D) {
			break
		}
		*(*float32)(unsafe.Pointer(XX + uintptr(i*D+i)*4)) += noise
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*float32)(unsafe.Pointer(xx)) += noise
}

const MAX_ITERATIONS_RESIDUAL_NRG = 10
const REGULARIZATION_FACTOR = 1e-08

// C documentation
//
//	/* Residual energy: nrg = wxx - 2 * wXx * c + c' * wXX * c */

func Opus_silk_resampler(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) (r int32) {
	var nSamples int32
	_ = nSamples
	/* Need at least 1 ms of input data */
	if !(inLen >= (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz) {
		Opus_celt_fatal(tls, __ccgo_ts+10259, __ccgo_ts+10239, int32(193))
	}
	/* Delay can't exceed the 1 ms of buffering */
	if !((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay <= (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz) {
		Opus_celt_fatal(tls, __ccgo_ts+10299, __ccgo_ts+10239, int32(195))
	}
	nSamples = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz - (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay
	/* Copy to delay buffer */
	libc.Xmemcpy(tls, S+168+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*2, in, libc.Uint64FromInt32(nSamples)*libc.Uint64FromInt64(2))
	switch (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function {
	case int32(USE_silk_resampler_private_up2_HQ_wrapper):
		Opus_silk_resampler_private_up2_HQ_wrapper(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_up2_HQ_wrapper(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	case int32(USE_silk_resampler_private_IIR_FIR):
		Opus_silk_resampler_private_IIR_FIR(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_IIR_FIR(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	case int32(USE_silk_resampler_private_down_FIR):
		Opus_silk_resampler_private_down_FIR(tls, S, out, S+168, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
		Opus_silk_resampler_private_down_FIR(tls, S, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)
	default:
		libc.Xmemcpy(tls, out, S+168, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)*libc.Uint64FromInt64(2))
		libc.Xmemcpy(tls, out+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz)*2, in+uintptr(nSamples)*2, libc.Uint64FromInt32(inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz)*libc.Uint64FromInt64(2))
	}
	/* Copy to delay buffer */
	libc.Xmemcpy(tls, S+168, in+uintptr(inLen-(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*2, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay)*libc.Uint64FromInt64(2))
	return 0
}

const ORDER_FIR = 4
const silk_int16_MAX23 = 32767

var silk_resampler_down2_01 = int16(9872)
var silk_resampler_down2_11 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_01 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_11 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Downsample by a factor 2/3, low quality */

func Opus_silk_resampler_down2(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var X, Y, in32, k, len2, out32 OpusT_opus_int32
	var v2, v3 int32
	_, _, _, _, _, _, _, _ = X, Y, in32, k, len2, out32, v2, v3
	len2 = inLen >> int32(1)
	if !(int32(silk_resampler_down2_02) > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10375, __ccgo_ts+10420, int32(46))
	}
	if !(int32(silk_resampler_down2_12) < libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+10446, __ccgo_ts+10420, int32(47))
	}
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < len2) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k)*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for even input sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_down2_12)>>libc.Int32FromInt32(16))
		out32 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*2)))) << libc.Int32FromInt32(10))
		/* All-pass section for odd input sample, and add to output of previous section */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(silk_resampler_down2_02) >> libc.Int32FromInt32(16))
		out32 = out32 + *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		out32 = out32 + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = in32 + X
		/* Add, convert back to int16 and store to output */
		if (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX23) {
			v2 = int32(silk_int16_MAX23)
		} else {
			if (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32>>(libc.Int32FromInt32(11)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(k)*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX24 = 0x7FFF

var silk_resampler_down2_03 = int16(9872)
var silk_resampler_down2_13 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_03 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_13 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Second order AR filter with single delay elements */

func Opus_silk_resampler_down2_3(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var _saved_stack, buf, buf_ptr, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var counter, nSamplesIn, res_Q6 OpusT_opus_int32
	var v29, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, buf, buf_ptr, counter, nSamplesIn, res_Q6, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v31, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10347, int32(51))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)+libc.Int32FromInt32(ORDER_FIR))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
	/* Iterate over blocks of frameSizeIn input samples */
	for int32(1) != 0 {
		if inLen < libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS)*libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ) {
			v29 = inLen
		} else {
			v29 = libc.Int32FromInt32(RESAMPLER_MAX_BATCH_SIZE_MS) * libc.Int32FromInt32(RESAMPLER_MAX_FS_KHZ)
		}
		nSamplesIn = v29
		/* Second-order AR filter (output in Q8) */
		Opus_silk_resampler_private_AR2(tls, S+4*4, buf+4*4, in, uintptr(unsafe.Pointer(&Opus_silk_Resampler_2_3_COEFS_LQ)), nSamplesIn)
		/* Interpolate filtered signal */
		buf_ptr = buf
		counter = nSamplesIn
		for counter > int32(2) {
			/* Inner product */
			res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))) * int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(2)]) >> libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(3)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(5)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(4)])>>libc.Int32FromInt32(16))
			/* Scale down, saturate and store in output array */
			v1 = out
			out += 2
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX23) {
				v29 = int32(silk_int16_MAX23)
			} else {
				if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v31 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v31 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v29 = v31
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = int16(v29)
			res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))) * int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(4)]) >> libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(5)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(3)])>>libc.Int32FromInt32(16))
			res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4)))*int64(Opus_silk_Resampler_2_3_COEFS_LQ[int32(2)])>>libc.Int32FromInt32(16))
			/* Scale down, saturate and store in output array */
			v1 = out
			out += 2
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX23) {
				v29 = int32(silk_int16_MAX23)
			} else {
				if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v31 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v31 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v29 = v31
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = int16(v29)
			buf_ptr = buf_ptr + uintptr(3)*4
			counter = counter - int32(3)
		}
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > 0 {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32(ORDER_FIR)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _39
_39:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_02 = int16(9872)
var silk_resampler_down2_12 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_02 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_12 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Downsample by a factor 2 */

func Opus_silk_resampler_init(tls *libc.TLS, S uintptr, Fs_Hz_in OpusT_opus_int32, Fs_Hz_out OpusT_opus_int32, forEnc int32) (r int32) {
	var up2x, v1, v2 int32
	_, _, _ = up2x, v1, v2
	/* Clear state */
	libc.Xmemset(tls, S, 0, libc.Uint64FromInt64(400))
	/* Input checking */
	if forEnc != 0 {
		if Fs_Hz_in != int32(8000) && Fs_Hz_in != int32(12000) && Fs_Hz_in != int32(16000) && Fs_Hz_in != int32(24000) && Fs_Hz_in != int32(48000) || Fs_Hz_out != int32(8000) && Fs_Hz_out != int32(12000) && Fs_Hz_out != int32(16000) {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+10239, int32(99))
			}
			return -int32(1)
		}
		if int32(5) < (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000))-int32(1) {
			v1 = int32(5)
		} else {
			v1 = (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000)) - int32(1)
		}
		if int32(5) < (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000))-int32(1) {
			v2 = int32(5)
		} else {
			v2 = (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000)) - int32(1)
		}
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay = int32(*(*OpusT_opus_int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&delay_matrix_enc)) + uintptr(v1)*3 + uintptr(v2))))
	} else {
		if Fs_Hz_in != int32(8000) && Fs_Hz_in != int32(12000) && Fs_Hz_in != int32(16000) || Fs_Hz_out != int32(8000) && Fs_Hz_out != int32(12000) && Fs_Hz_out != int32(16000) && Fs_Hz_out != int32(24000) && Fs_Hz_out != int32(48000) {
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+10239, int32(110))
			}
			return -int32(1)
		}
		if int32(5) < (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000))-int32(1) {
			v1 = int32(5)
		} else {
			v1 = (Fs_Hz_in>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_in > int32(16000)))>>libc.BoolInt32(Fs_Hz_in > int32(24000)) - int32(1)
		}
		if int32(5) < (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000))-int32(1) {
			v2 = int32(5)
		} else {
			v2 = (Fs_Hz_out>>libc.Int32FromInt32(12)-libc.BoolInt32(Fs_Hz_out > int32(16000)))>>libc.BoolInt32(Fs_Hz_out > int32(24000)) - int32(1)
		}
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinputDelay = int32(*(*OpusT_opus_int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&delay_matrix_dec)) + uintptr(v1)*6 + uintptr(v2))))
	}
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz = Fs_Hz_in / libc.Int32FromInt32(1000)
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_out_kHz = Fs_Hz_out / libc.Int32FromInt32(1000)
	/* Number of samples processed per batch */
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFs_in_kHz * int32(RESAMPLER_MAX_BATCH_SIZE_MS)
	/* Find resampler with the right sampling ratio */
	up2x = 0
	if Fs_Hz_out > Fs_Hz_in {
		/* Upsample */
		if Fs_Hz_out == Fs_Hz_in*int32(2) { /* Fs_out : Fs_in = 2 : 1 */
			/* Special case: directly use 2x upsampler */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_up2_HQ_wrapper)
		} else {
			/* Default resampler */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_IIR_FIR)
			up2x = int32(1)
		}
	} else {
		if Fs_Hz_out < Fs_Hz_in {
			/* Downsample */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = int32(USE_silk_resampler_private_down_FIR)
			if Fs_Hz_out*int32(4) == Fs_Hz_in*int32(3) { /* Fs_out : Fs_in = 3 : 4 */
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(3)
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR0)
				(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_3_4_COEFS))
			} else {
				if Fs_Hz_out*int32(3) == Fs_Hz_in*int32(2) { /* Fs_out : Fs_in = 2 : 3 */
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(2)
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR0)
					(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_2_3_COEFS))
				} else {
					if Fs_Hz_out*int32(2) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 2 */
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR1)
						(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_2_COEFS))
					} else {
						if Fs_Hz_out*int32(3) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 3 */
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
							(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_3_COEFS))
						} else {
							if Fs_Hz_out*int32(4) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 4 */
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
								(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_4_COEFS))
							} else {
								if Fs_Hz_out*int32(6) == Fs_Hz_in { /* Fs_out : Fs_in = 1 : 6 */
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs = int32(1)
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order = int32(RESAMPLER_DOWN_ORDER_FIR2)
									(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs = uintptr(unsafe.Pointer(&Opus_silk_Resampler_1_6_COEFS))
								} else {
									/* None available */
									if !(libc.Int32FromInt32(0) != 0) {
										Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+10239, int32(163))
									}
									return -int32(1)
								}
							}
						}
					}
				}
			}
		} else {
			/* Input and output sampling rates are equal: copy */
			(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).Fresampler_function = USE_silk_resampler_copy
		}
	}
	/* Ratio of input/output samples */
	(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(Fs_Hz_in)<<(libc.Int32FromInt32(14)+up2x))/Fs_Hz_out) << libc.Int32FromInt32(2))
	/* Make sure the ratio is rounded up */
	for int32(int64((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16)*int64(Fs_Hz_out)>>libc.Int32FromInt32(16)) < libc.Int32FromUint32(libc.Uint32FromInt32(Fs_Hz_in)<<up2x) {
		(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16 + 1
	}
	return 0
}

// C documentation
//
//	/* Resampler: convert from one sampling rate to another */
//	/* Input and output sampling rate are at most 48000 Hz  */

func Opus_silk_resampler_private_AR2(tls *libc.TLS, S uintptr, out_Q8 uintptr, in uintptr, A_Q14 uintptr, len1 OpusT_opus_int32) {
	var k, out32 OpusT_opus_int32
	_, _ = k, out32
	k = 0
	for {
		if !(k < len1) {
			break
		}
		out32 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2))))<<libc.Int32FromInt32(8))
		*(*OpusT_opus_int32)(unsafe.Pointer(out_Q8 + uintptr(k)*4)) = out32
		out32 = libc.Int32FromUint32(libc.Uint32FromInt32(out32) << libc.Int32FromInt32(2))
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))) + int64(out32)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q14)))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = int32(int64(out32) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(A_Q14 + 1*2))) >> libc.Int32FromInt32(16))
		goto _1
	_1:
		;
		k = k + 1
	}
}

const silk_int16_MAX25 = 32767

var silk_resampler_down2_04 = int16(9872)
var silk_resampler_down2_14 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_04 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_14 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

func Opus_silk_resampler_private_IIR_FIR(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var S, _saved_stack, buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var index_increment_Q16, max_index_Q16, nSamplesIn OpusT_opus_int32
	var v29 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = S, _saved_stack, buf, index_increment_Q16, max_index_Q16, nSamplesIn, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	S = SS
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10528, int32(78))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12)) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+libc.Int32FromInt32(RESAMPLER_ORDER_FIR_12))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S+24, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
	/* Iterate over blocks of frameSizeIn input samples */
	index_increment_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16
	for int32(1) != 0 {
		if inLen < (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize {
			v29 = inLen
		} else {
			v29 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize
		}
		nSamplesIn = v29
		/* Upsample 2x */
		Opus_silk_resampler_private_up2_HQ(tls, S, buf+8*2, in, nSamplesIn)
		max_index_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(nSamplesIn) << (libc.Int32FromInt32(16) + libc.Int32FromInt32(1))) /* + 1 because 2x upsampling */
		out = silk_resampler_private_IIR_FIR_INTERPOL(tls, out, buf, max_index_Q16, index_increment_Q16)
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > 0 {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn<<int32(1))*2, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S+24, buf+uintptr(nSamplesIn<<int32(1))*2, libc.Uint64FromInt32(RESAMPLER_ORDER_FIR_12)*libc.Uint64FromInt64(2))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_06 = int16(9872)
var silk_resampler_down2_16 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_06 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_16 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

// C documentation
//
//	/* Upsample by a factor 2, high quality */
//	/* Uses 2nd order allpass filters for the 2x upsampling, followed by a      */
//	/* notch filter just above Nyquist.                                         */

func Opus_silk_resampler_private_down_FIR(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, inLen OpusT_opus_int32) {
	var FIR_Coefs, S, _saved_stack, buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var index_increment_Q16, max_index_Q16, nSamplesIn OpusT_opus_int32
	var v29 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = FIR_Coefs, S, _saved_stack, buf, index_increment_Q16, max_index_Q16, nSamplesIn, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	S = SS
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10491, int32(159))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize+(*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Copy buffered samples to start of buffer */
	libc.Xmemcpy(tls, buf, S+24, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
	FIR_Coefs = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs + 2*2
	/* Iterate over blocks of frameSizeIn input samples */
	index_increment_Q16 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FinvRatio_Q16
	for int32(1) != 0 {
		if inLen < (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize {
			v29 = inLen
		} else {
			v29 = (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FbatchSize
		}
		nSamplesIn = v29
		/* Second-order AR filter (output in Q8) */
		Opus_silk_resampler_private_AR2(tls, S, buf+uintptr((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*4, in, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FCoefs, nSamplesIn)
		max_index_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(nSamplesIn) << libc.Int32FromInt32(16))
		/* Interpolate filtered signal */
		out = silk_resampler_private_down_FIR_INTERPOL(tls, out, buf, FIR_Coefs, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order, (*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Fracs, max_index_Q16, index_increment_Q16)
		in = in + uintptr(nSamplesIn)*2
		inLen = inLen - nSamplesIn
		if inLen > int32(1) {
			/* More iterations to do; copy last part of filtered signal to beginning of buffer */
			libc.Xmemcpy(tls, buf, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
		} else {
			break
		}
	}
	/* Copy last part of filtered signal to the state for the next call */
	libc.Xmemcpy(tls, S+24, buf+uintptr(nSamplesIn)*4, libc.Uint64FromInt32((*OpusT_silk_resampler_state_struct)(unsafe.Pointer(S)).FFIR_Order)*libc.Uint64FromInt64(4))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

var silk_resampler_down2_05 = int16(9872)
var silk_resampler_down2_15 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_05 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_15 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

func Opus_silk_resampler_private_up2_HQ(tls *libc.TLS, S uintptr, out uintptr, in uintptr, len1 OpusT_opus_int32) {
	var X, Y, in32, k, out32_1, out32_2 OpusT_opus_int32
	var v2, v3 int32
	_, _, _, _, _, _, _, _ = X, Y, in32, k, out32_1, out32_2, v2, v3
	_ = int32(silk_resampler_up2_hq_06[0]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_06[int32(1)]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_06[int32(2)]) < libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[0]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[int32(1)]) > libc.Int32FromInt32(0)
	_ = int32(silk_resampler_up2_hq_16[int32(2)]) < libc.Int32FromInt32(0)
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* Convert to Q10 */
		in32 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(in + uintptr(k)*2)))) << libc.Int32FromInt32(10))
		/* First all-pass section for even output sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_06[0]) >> libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S)) = in32 + X
		/* Second all-pass section for even output sample */
		Y = out32_1 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_06[int32(1)]) >> libc.Int32FromInt32(16))
		out32_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 1*4)) = out32_1 + X
		/* Third all-pass section for even output sample */
		Y = out32_2 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_up2_hq_06[int32(2)])>>libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 2*4)) = out32_2 + X
		/* Apply gain in Q15, convert back to int16 and store to output */
		if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
			v2 = int32(silk_int16_MAX25)
		} else {
			if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k)*2)) = int16(v2)
		/* First all-pass section for odd output sample */
		Y = in32 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_16[0]) >> libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 3*4)) = in32 + X
		/* Second all-pass section for odd output sample */
		Y = out32_1 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4))
		X = int32(int64(Y) * int64(silk_resampler_up2_hq_16[int32(1)]) >> libc.Int32FromInt32(16))
		out32_2 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 4*4)) = out32_1 + X
		/* Third all-pass section for odd output sample */
		Y = out32_2 - *(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4))
		X = int32(int64(Y) + int64(Y)*int64(silk_resampler_up2_hq_16[int32(2)])>>libc.Int32FromInt32(16))
		out32_1 = *(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4)) + X
		*(*OpusT_opus_int32)(unsafe.Pointer(S + 5*4)) = out32_2 + X
		/* Apply gain in Q15, convert back to int16 and store to output */
		if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
			v2 = int32(silk_int16_MAX25)
		} else {
			if (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (out32_1>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(out + uintptr(int32(2)*k+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		k = k + 1
	}
}

func Opus_silk_resampler_private_up2_HQ_wrapper(tls *libc.TLS, SS uintptr, out uintptr, in uintptr, len1 OpusT_opus_int32) {
	var S uintptr
	_ = S
	S = SS
	Opus_silk_resampler_private_up2_HQ(tls, S, out, in, len1)
}

const silk_int16_MAX26 = 0x7FFF

var silk_resampler_down2_07 = int16(9872)
var silk_resampler_down2_17 = int16(libc.Int32FromInt32(39809) - libc.Int32FromInt32(65536))
var silk_resampler_up2_hq_07 = [3]OpusT_opus_int16{
	0: int16(1746),
	1: int16(14986),
	2: int16(libc.Int32FromInt32(39083) - libc.Int32FromInt32(65536)),
}
var silk_resampler_up2_hq_17 = [3]OpusT_opus_int16{
	0: int16(6854),
	1: int16(25769),
	2: int16(libc.Int32FromInt32(55542) - libc.Int32FromInt32(65536)),
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* fprintf(1, '%d, ', round(1024 * ([1 ./ (1 + exp(-(1:5))), 1] - 1 ./ (1 + exp(-(0:5)))))); */
var sigm_LUT_slope_Q10 = [6]OpusT_opus_int32{
	0: int32(237),
	1: int32(153),
	2: int32(73),
	3: int32(30),
	4: int32(12),
	5: int32(7),
}

// C documentation
//
//	/* fprintf(1, '%d, ', round(32767 * 1 ./ (1 + exp(-(0:5))))); */
var sigm_LUT_pos_Q15 = [6]OpusT_opus_int32{
	0: int32(16384),
	1: int32(23955),
	2: int32(28861),
	3: int32(31213),
	4: int32(32178),
	5: int32(32548),
}

// C documentation
//
//	/* fprintf(1, '%d, ', round(32767 * 1 ./ (1 + exp((0:5))))); */
var sigm_LUT_neg_Q15 = [6]OpusT_opus_int32{
	0: int32(16384),
	1: int32(8812),
	2: int32(3906),
	3: int32(1554),
	4: int32(589),
	5: int32(219),
}

func Opus_silk_reset_decoder(tls *libc.TLS, psDec uintptr) (r int32) {
	var v1 int32
	_ = v1
	/* Clear the entire encoder state, except anything copied */
	libc.Xmemset(tls, psDec, 0, libc.Uint64FromInt64(4392)-libc.Uint64FromInt64(int64(psDec)-int64(psDec)))
	/* Used to deactivate LSF interpolation */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset = int32(1)
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fprev_gain_Q16 = int32(65536)
	v1 = 0
	goto _2
_2:
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Farch = v1
	/* Reset CNG state */
	Opus_silk_CNG_Reset(tls, psDec)
	/* Reset PLC state */
	Opus_silk_PLC_Reset(tls, psDec)
	return 0
}

// C documentation
//
//	/************************/
//	/* Init Decoder State   */
//	/************************/

func Opus_silk_residual_energy_FLP(tls *libc.TLS, nrgs uintptr, x uintptr, a uintptr, gains uintptr, subfr_length int32, nb_subfr int32, LPC_order int32) {
	bp := tls.Alloc(768)
	defer tls.Free(768)
	var LPC_res_ptr uintptr
	var shift int32
	var _ /* LPC_res at bp+0 */ [192]float32
	_, _ = LPC_res_ptr, shift
	LPC_res_ptr = bp + uintptr(LPC_order)*4
	shift = LPC_order + subfr_length
	/* Filter input to create the LPC residual for each frame half, and measure subframe energies */
	Opus_silk_LPC_analysis_filter_FLP(tls, bp, a, x+uintptr(0*shift)*4, int32(2)*shift, LPC_order)
	*(*float32)(unsafe.Pointer(nrgs)) = float32(float64(float64(*(*float32)(unsafe.Pointer(gains))**(*float32)(unsafe.Pointer(gains))) * Opus_silk_energy_FLP(tls, LPC_res_ptr+uintptr(0*shift)*4, subfr_length)))
	*(*float32)(unsafe.Pointer(nrgs + 1*4)) = float32(float64(float64(*(*float32)(unsafe.Pointer(gains + 1*4))**(*float32)(unsafe.Pointer(gains + 1*4))) * Opus_silk_energy_FLP(tls, LPC_res_ptr+uintptr(int32(1)*shift)*4, subfr_length)))
	if nb_subfr == int32(MAX_NB_SUBFR) {
		Opus_silk_LPC_analysis_filter_FLP(tls, bp, a+1*64, x+uintptr(int32(2)*shift)*4, int32(2)*shift, LPC_order)
		*(*float32)(unsafe.Pointer(nrgs + 2*4)) = float32(float64(float64(*(*float32)(unsafe.Pointer(gains + 2*4))**(*float32)(unsafe.Pointer(gains + 2*4))) * Opus_silk_energy_FLP(tls, LPC_res_ptr+uintptr(0*shift)*4, subfr_length)))
		*(*float32)(unsafe.Pointer(nrgs + 3*4)) = float32(float64(float64(*(*float32)(unsafe.Pointer(gains + 3*4))**(*float32)(unsafe.Pointer(gains + 3*4))) * Opus_silk_energy_FLP(tls, LPC_res_ptr+uintptr(int32(1)*shift)*4, subfr_length)))
	}
}

// C documentation
//
//	/* Autocorrelations for a warped frequency axis */

func Opus_silk_residual_energy_covar_FLP(tls *libc.TLS, c uintptr, wXX uintptr, wXx uintptr, wxx float32, D int32) (r float32) {
	var i, j, k int32
	var nrg, regularization, tmp float32
	_, _, _, _, _, _ = i, j, k, nrg, regularization, tmp
	nrg = libc.Float32FromFloat32(0)
	/* Safety checks */
	if !(D >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+11564, __ccgo_ts+11589, int32(50))
	}
	regularization = float32(libc.Float32FromFloat32(1e-08) * (*(*float32)(unsafe.Pointer(wXX)) + *(*float32)(unsafe.Pointer(wXX + uintptr(D*D-int32(1))*4))))
	k = 0
	for {
		if !(k < int32(MAX_ITERATIONS_RESIDUAL_NRG)) {
			break
		}
		nrg = wxx
		tmp = libc.Float32FromFloat32(0)
		i = 0
		for {
			if !(i < D) {
				break
			}
			tmp = tmp + float32(*(*float32)(unsafe.Pointer(wXx + uintptr(i)*4))**(*float32)(unsafe.Pointer(c + uintptr(i)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		nrg = nrg - float32(libc.Float32FromFloat32(2)*tmp)
		/* compute c' * wXX * c, assuming wXX is symmetric */
		i = 0
		for {
			if !(i < D) {
				break
			}
			tmp = libc.Float32FromFloat32(0)
			j = i + int32(1)
			for {
				if !(j < D) {
					break
				}
				tmp = tmp + float32(*(*float32)(unsafe.Pointer(wXX + uintptr(i+D*j)*4))**(*float32)(unsafe.Pointer(c + uintptr(j)*4)))
				goto _4
			_4:
				;
				j = j + 1
			}
			nrg = nrg + float32(*(*float32)(unsafe.Pointer(c + uintptr(i)*4))*(float32(libc.Float32FromFloat32(2)*tmp)+float32(*(*float32)(unsafe.Pointer(wXX + uintptr(i+D*i)*4))**(*float32)(unsafe.Pointer(c + uintptr(i)*4)))))
			goto _3
		_3:
			;
			i = i + 1
		}
		if nrg > libc.Float32FromInt32(0) {
			break
		} else {
			/* Add white noise */
			i = 0
			for {
				if !(i < D) {
					break
				}
				*(*float32)(unsafe.Pointer(wXX + uintptr(i+D*i)*4)) += regularization
				goto _5
			_5:
				;
				i = i + 1
			}
			/* Increase noise for next run */
			regularization = regularization * libc.Float32FromFloat32(2)
		}
		goto _1
	_1:
		;
		k = k + 1
	}
	if k == int32(MAX_ITERATIONS_RESIDUAL_NRG) {
		_ = nrg == libc.Float32FromInt32(0)
		nrg = libc.Float32FromFloat32(1)
	}
	return nrg
}

// C documentation
//
//	/* Calculates residual energies of input subframes where all subframes have LPC_order   */
//	/* of preceding samples                                                                 */

func Opus_silk_scale_copy_vector_FLP(tls *libc.TLS, data_out uintptr, data_in uintptr, gain float32, dataSize int32) {
	var dataSize4, i int32
	_, _ = dataSize4, i
	/* 4x unrolled loop */
	dataSize4 = dataSize & int32(0xFFFC)
	i = 0
	for {
		if !(i < dataSize4) {
			break
		}
		*(*float32)(unsafe.Pointer(data_out + uintptr(i+0)*4)) = float32(gain * *(*float32)(unsafe.Pointer(data_in + uintptr(i+0)*4)))
		*(*float32)(unsafe.Pointer(data_out + uintptr(i+int32(1))*4)) = float32(gain * *(*float32)(unsafe.Pointer(data_in + uintptr(i+int32(1))*4)))
		*(*float32)(unsafe.Pointer(data_out + uintptr(i+int32(2))*4)) = float32(gain * *(*float32)(unsafe.Pointer(data_in + uintptr(i+int32(2))*4)))
		*(*float32)(unsafe.Pointer(data_out + uintptr(i+int32(3))*4)) = float32(gain * *(*float32)(unsafe.Pointer(data_in + uintptr(i+int32(3))*4)))
		goto _1
	_1:
		;
		i = i + int32(4)
	}
	/* any remaining elements */
	for {
		if !(i < dataSize) {
			break
		}
		*(*float32)(unsafe.Pointer(data_out + uintptr(i)*4)) = float32(gain * *(*float32)(unsafe.Pointer(data_in + uintptr(i)*4)))
		goto _2
	_2:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* multiply a vector by a constant */

func Opus_silk_scale_vector_FLP(tls *libc.TLS, data1 uintptr, gain float32, dataSize int32) {
	var dataSize4, i int32
	_, _ = dataSize4, i
	/* 4x unrolled loop */
	dataSize4 = dataSize & int32(0xFFFC)
	i = 0
	for {
		if !(i < dataSize4) {
			break
		}
		*(*float32)(unsafe.Pointer(data1 + uintptr(i+0)*4)) *= gain
		*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(1))*4)) *= gain
		*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(2))*4)) *= gain
		*(*float32)(unsafe.Pointer(data1 + uintptr(i+int32(3))*4)) *= gain
		goto _1
	_1:
		;
		i = i + int32(4)
	}
	/* any remaining elements */
	for {
		if !(i < dataSize) {
			break
		}
		*(*float32)(unsafe.Pointer(data1 + uintptr(i)*4)) *= gain
		goto _2
	_2:
		;
		i = i + 1
	}
}

func Opus_silk_schur_FLP(tls *libc.TLS, refl_coef uintptr, auto_corr uintptr, order int32) (r float32) {
	bp := tls.Alloc(400)
	defer tls.Free(400)
	var Ctmp1, Ctmp2, rc_tmp, v3 float64
	var k, n, v1 int32
	var _ /* C at bp+0 */ [25][2]float64
	_, _, _, _, _, _, _ = Ctmp1, Ctmp2, k, n, rc_tmp, v1, v3
	if !(order >= 0 && order <= int32(SILK_MAX_ORDER_LPC)) {
		Opus_celt_fatal(tls, __ccgo_ts+12404, __ccgo_ts+12464, int32(44))
	}
	/* Copy correlations */
	k = 0
	for {
		v3 = float64(*(*float32)(unsafe.Pointer(auto_corr + uintptr(k)*4)))
		*(*float64)(unsafe.Pointer(bp + uintptr(k)*16 + 1*8)) = v3
		*(*float64)(unsafe.Pointer(bp + uintptr(k)*16)) = v3
		goto _2
	_2:
		;
		k = k + 1
		v1 = k
		if !(v1 <= order) {
			break
		}
	}
	k = 0
	for {
		if !(k < order) {
			break
		}
		/* Get reflection coefficient */
		if *(*float64)(unsafe.Pointer(bp + 1*8)) > float64(libc.Float32FromFloat32(1e-09)) {
			v3 = *(*float64)(unsafe.Pointer(bp + 1*8))
		} else {
			v3 = float64(libc.Float32FromFloat32(1e-09))
		}
		rc_tmp = -*(*float64)(unsafe.Pointer(bp + uintptr(k+int32(1))*16)) / v3
		/* Save the output */
		*(*float32)(unsafe.Pointer(refl_coef + uintptr(k)*4)) = float32(rc_tmp)
		/* Update correlations */
		n = 0
		for {
			if !(n < order-k) {
				break
			}
			Ctmp1 = *(*float64)(unsafe.Pointer(bp + uintptr(n+k+int32(1))*16))
			Ctmp2 = *(*float64)(unsafe.Pointer(bp + uintptr(n)*16 + 1*8))
			*(*float64)(unsafe.Pointer(bp + uintptr(n+k+int32(1))*16)) = Ctmp1 + float64(Ctmp2*rc_tmp)
			*(*float64)(unsafe.Pointer(bp + uintptr(n)*16 + 1*8)) = Ctmp2 + float64(Ctmp1*rc_tmp)
			goto _6
		_6:
			;
			n = n + 1
		}
		goto _4
	_4:
		;
		k = k + 1
	}
	/* Return residual energy */
	return float32(*(*float64)(unsafe.Pointer(bp + 1*8)))
}

func Opus_silk_shell_decoder(tls *libc.TLS, pulses0 uintptr, psRangeDec uintptr, pulses4 int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* pulses1 at bp+16 */ [8]OpusT_opus_int16
	var _ /* pulses2 at bp+8 */ [4]OpusT_opus_int16
	var _ /* pulses3 at bp+0 */ [2]OpusT_opus_int16
	/* this function operates on one shell code frame of 16 pulses */
	_ = true
	decode_split(tls, bp, bp+1*2, psRangeDec, pulses4, uintptr(unsafe.Pointer(&Opus_silk_shell_code_table3)))
	decode_split(tls, bp+8, bp+8+1*2, psRangeDec, int32((*(*[2]OpusT_opus_int16)(unsafe.Pointer(bp)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	decode_split(tls, bp+16, bp+16+1*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0, pulses0+1*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[0]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+2*2, pulses0+3*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+16+2*2, bp+16+3*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+4*2, pulses0+5*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(2)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+6*2, pulses0+7*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(3)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+8+2*2, bp+8+3*2, psRangeDec, int32((*(*[2]OpusT_opus_int16)(unsafe.Pointer(bp)))[int32(1)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	decode_split(tls, bp+16+4*2, bp+16+5*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(2)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+8*2, pulses0+9*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(4)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+10*2, pulses0+11*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(5)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, bp+16+6*2, bp+16+7*2, psRangeDec, int32((*(*[4]OpusT_opus_int16)(unsafe.Pointer(bp + 8)))[int32(3)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	decode_split(tls, pulses0+12*2, pulses0+13*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(6)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	decode_split(tls, pulses0+14*2, pulses0+15*2, psRangeDec, int32((*(*[8]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(7)]), uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
}

var silk_LTP_gain_iCDF_0 = [8]OpusT_opus_uint8{
	0: uint8(71),
	1: uint8(56),
	2: uint8(43),
	3: uint8(30),
	4: uint8(21),
	5: uint8(12),
	6: uint8(6),
}

var silk_LTP_gain_iCDF_1 = [16]OpusT_opus_uint8{
	0:  uint8(199),
	1:  uint8(165),
	2:  uint8(144),
	3:  uint8(124),
	4:  uint8(109),
	5:  uint8(96),
	6:  uint8(84),
	7:  uint8(71),
	8:  uint8(61),
	9:  uint8(51),
	10: uint8(42),
	11: uint8(32),
	12: uint8(23),
	13: uint8(15),
	14: uint8(8),
}

var silk_LTP_gain_iCDF_2 = [32]OpusT_opus_uint8{
	0:  uint8(241),
	1:  uint8(225),
	2:  uint8(211),
	3:  uint8(199),
	4:  uint8(187),
	5:  uint8(175),
	6:  uint8(164),
	7:  uint8(153),
	8:  uint8(142),
	9:  uint8(132),
	10: uint8(123),
	11: uint8(114),
	12: uint8(105),
	13: uint8(96),
	14: uint8(88),
	15: uint8(80),
	16: uint8(72),
	17: uint8(64),
	18: uint8(57),
	19: uint8(50),
	20: uint8(44),
	21: uint8(38),
	22: uint8(33),
	23: uint8(29),
	24: uint8(24),
	25: uint8(20),
	26: uint8(16),
	27: uint8(12),
	28: uint8(9),
	29: uint8(5),
	30: uint8(2),
}

var silk_LTP_gain_BITS_Q5_0 = [8]OpusT_opus_uint8{
	0: uint8(15),
	1: uint8(131),
	2: uint8(138),
	3: uint8(138),
	4: uint8(155),
	5: uint8(155),
	6: uint8(173),
	7: uint8(173),
}

var silk_LTP_gain_BITS_Q5_1 = [16]OpusT_opus_uint8{
	0:  uint8(69),
	1:  uint8(93),
	2:  uint8(115),
	3:  uint8(118),
	4:  uint8(131),
	5:  uint8(138),
	6:  uint8(141),
	7:  uint8(138),
	8:  uint8(150),
	9:  uint8(150),
	10: uint8(155),
	11: uint8(150),
	12: uint8(155),
	13: uint8(160),
	14: uint8(166),
	15: uint8(160),
}

var silk_LTP_gain_BITS_Q5_2 = [32]OpusT_opus_uint8{
	0:  uint8(131),
	1:  uint8(128),
	2:  uint8(134),
	3:  uint8(141),
	4:  uint8(141),
	5:  uint8(141),
	6:  uint8(145),
	7:  uint8(145),
	8:  uint8(145),
	9:  uint8(150),
	10: uint8(155),
	11: uint8(155),
	12: uint8(155),
	13: uint8(155),
	14: uint8(160),
	15: uint8(160),
	16: uint8(160),
	17: uint8(160),
	18: uint8(166),
	19: uint8(166),
	20: uint8(173),
	21: uint8(173),
	22: uint8(182),
	23: uint8(192),
	24: uint8(182),
	25: uint8(192),
	26: uint8(192),
	27: uint8(192),
	28: uint8(205),
	29: uint8(192),
	30: uint8(205),
	31: uint8(224),
}

var silk_LTP_gain_vq_0 = [8][5]OpusT_opus_int8{
	0: {
		0: int8(4),
		1: int8(6),
		2: int8(24),
		3: int8(7),
		4: int8(5),
	},
	1: {
		2: int8(2),
	},
	2: {
		0: int8(12),
		1: int8(28),
		2: int8(41),
		3: int8(13),
		4: int8(-int32(4)),
	},
	3: {
		0: int8(-int32(9)),
		1: int8(15),
		2: int8(42),
		3: int8(25),
		4: int8(14),
	},
	4: {
		0: int8(1),
		1: int8(-int32(2)),
		2: int8(62),
		3: int8(41),
		4: int8(-int32(9)),
	},
	5: {
		0: int8(-int32(10)),
		1: int8(37),
		2: int8(65),
		3: int8(-int32(4)),
		4: int8(3),
	},
	6: {
		0: int8(-int32(6)),
		1: int8(4),
		2: int8(66),
		3: int8(7),
		4: int8(-int32(8)),
	},
	7: {
		0: int8(16),
		1: int8(14),
		2: int8(38),
		3: int8(-int32(3)),
		4: int8(33),
	},
}

var silk_LTP_gain_vq_1 = [16][5]OpusT_opus_int8{
	0: {
		0: int8(13),
		1: int8(22),
		2: int8(39),
		3: int8(23),
		4: int8(12),
	},
	1: {
		0: int8(-int32(1)),
		1: int8(36),
		2: int8(64),
		3: int8(27),
		4: int8(-int32(6)),
	},
	2: {
		0: int8(-int32(7)),
		1: int8(10),
		2: int8(55),
		3: int8(43),
		4: int8(17),
	},
	3: {
		0: int8(1),
		1: int8(1),
		2: int8(8),
		3: int8(1),
		4: int8(1),
	},
	4: {
		0: int8(6),
		1: int8(-int32(11)),
		2: int8(74),
		3: int8(53),
		4: int8(-int32(9)),
	},
	5: {
		0: int8(-int32(12)),
		1: int8(55),
		2: int8(76),
		3: int8(-int32(12)),
		4: int8(8),
	},
	6: {
		0: int8(-int32(3)),
		1: int8(3),
		2: int8(93),
		3: int8(27),
		4: int8(-int32(4)),
	},
	7: {
		0: int8(26),
		1: int8(39),
		2: int8(59),
		3: int8(3),
		4: int8(-int32(8)),
	},
	8: {
		0: int8(2),
		2: int8(77),
		3: int8(11),
		4: int8(9),
	},
	9: {
		0: int8(-int32(8)),
		1: int8(22),
		2: int8(44),
		3: int8(-int32(6)),
		4: int8(7),
	},
	10: {
		0: int8(40),
		1: int8(9),
		2: int8(26),
		3: int8(3),
		4: int8(9),
	},
	11: {
		0: int8(-int32(7)),
		1: int8(20),
		2: int8(101),
		3: int8(-int32(7)),
		4: int8(4),
	},
	12: {
		0: int8(3),
		1: int8(-int32(8)),
		2: int8(42),
		3: int8(26),
	},
	13: {
		0: int8(-int32(15)),
		1: int8(33),
		2: int8(68),
		3: int8(2),
		4: int8(23),
	},
	14: {
		0: int8(-int32(2)),
		1: int8(55),
		2: int8(46),
		3: int8(-int32(2)),
		4: int8(15),
	},
	15: {
		0: int8(3),
		1: int8(-int32(1)),
		2: int8(21),
		3: int8(16),
		4: int8(41),
	},
}

var silk_LTP_gain_vq_2 = [32][5]OpusT_opus_int8{
	0: {
		0: int8(-int32(6)),
		1: int8(27),
		2: int8(61),
		3: int8(39),
		4: int8(5),
	},
	1: {
		0: int8(-int32(11)),
		1: int8(42),
		2: int8(88),
		3: int8(4),
		4: int8(1),
	},
	2: {
		0: int8(-int32(2)),
		1: int8(60),
		2: int8(65),
		3: int8(6),
		4: int8(-int32(4)),
	},
	3: {
		0: int8(-int32(1)),
		1: int8(-int32(5)),
		2: int8(73),
		3: int8(56),
		4: int8(1),
	},
	4: {
		0: int8(-int32(9)),
		1: int8(19),
		2: int8(94),
		3: int8(29),
		4: int8(-int32(9)),
	},
	5: {
		1: int8(12),
		2: int8(99),
		3: int8(6),
		4: int8(4),
	},
	6: {
		0: int8(8),
		1: int8(-int32(19)),
		2: int8(102),
		3: int8(46),
		4: int8(-int32(13)),
	},
	7: {
		0: int8(3),
		1: int8(2),
		2: int8(13),
		3: int8(3),
		4: int8(2),
	},
	8: {
		0: int8(9),
		1: int8(-int32(21)),
		2: int8(84),
		3: int8(72),
		4: int8(-int32(18)),
	},
	9: {
		0: int8(-int32(11)),
		1: int8(46),
		2: int8(104),
		3: int8(-int32(22)),
		4: int8(8),
	},
	10: {
		0: int8(18),
		1: int8(38),
		2: int8(48),
		3: int8(23),
	},
	11: {
		0: int8(-int32(16)),
		1: int8(70),
		2: int8(83),
		3: int8(-int32(21)),
		4: int8(11),
	},
	12: {
		0: int8(5),
		1: int8(-int32(11)),
		2: int8(117),
		3: int8(22),
		4: int8(-int32(8)),
	},
	13: {
		0: int8(-int32(6)),
		1: int8(23),
		2: int8(117),
		3: int8(-int32(12)),
		4: int8(3),
	},
	14: {
		0: int8(3),
		1: int8(-int32(8)),
		2: int8(95),
		3: int8(28),
		4: int8(4),
	},
	15: {
		0: int8(-int32(10)),
		1: int8(15),
		2: int8(77),
		3: int8(60),
		4: int8(-int32(15)),
	},
	16: {
		0: int8(-int32(1)),
		1: int8(4),
		2: int8(124),
		3: int8(2),
		4: int8(-int32(4)),
	},
	17: {
		0: int8(3),
		1: int8(38),
		2: int8(84),
		3: int8(24),
		4: int8(-int32(25)),
	},
	18: {
		0: int8(2),
		1: int8(13),
		2: int8(42),
		3: int8(13),
		4: int8(31),
	},
	19: {
		0: int8(21),
		1: int8(-int32(4)),
		2: int8(56),
		3: int8(46),
		4: int8(-int32(1)),
	},
	20: {
		0: int8(-int32(1)),
		1: int8(35),
		2: int8(79),
		3: int8(-int32(13)),
		4: int8(19),
	},
	21: {
		0: int8(-int32(7)),
		1: int8(65),
		2: int8(88),
		3: int8(-int32(9)),
		4: int8(-int32(14)),
	},
	22: {
		0: int8(20),
		1: int8(4),
		2: int8(81),
		3: int8(49),
		4: int8(-int32(29)),
	},
	23: {
		0: int8(20),
		2: int8(75),
		3: int8(3),
		4: int8(-int32(17)),
	},
	24: {
		0: int8(5),
		1: int8(-int32(9)),
		2: int8(44),
		3: int8(92),
		4: int8(-int32(8)),
	},
	25: {
		0: int8(1),
		1: int8(-int32(3)),
		2: int8(22),
		3: int8(69),
		4: int8(31),
	},
	26: {
		0: int8(-int32(6)),
		1: int8(95),
		2: int8(41),
		3: int8(-int32(12)),
		4: int8(5),
	},
	27: {
		0: int8(39),
		1: int8(67),
		2: int8(16),
		3: int8(-int32(4)),
		4: int8(1),
	},
	28: {
		1: int8(-int32(6)),
		2: int8(120),
		3: int8(55),
		4: int8(-int32(36)),
	},
	29: {
		0: int8(-int32(13)),
		1: int8(44),
		2: int8(122),
		3: int8(4),
		4: int8(-int32(24)),
	},
	30: {
		0: int8(81),
		1: int8(5),
		2: int8(11),
		3: int8(3),
		4: int8(7),
	},
	31: {
		0: int8(2),
		2: int8(9),
		3: int8(10),
		4: int8(88),
	},
}

// C documentation
//
//	/* Maximum frequency-dependent response of the pitch taps above,
//	   computed as max(abs(freqz(taps))) */
var silk_LTP_gain_vq_0_gain = [8]OpusT_opus_uint8{
	0: uint8(46),
	1: uint8(2),
	2: uint8(90),
	3: uint8(87),
	4: uint8(93),
	5: uint8(91),
	6: uint8(82),
	7: uint8(98),
}

var silk_LTP_gain_vq_1_gain = [16]OpusT_opus_uint8{
	0:  uint8(109),
	1:  uint8(120),
	2:  uint8(118),
	3:  uint8(12),
	4:  uint8(113),
	5:  uint8(115),
	6:  uint8(117),
	7:  uint8(119),
	8:  uint8(99),
	9:  uint8(59),
	10: uint8(87),
	11: uint8(111),
	12: uint8(63),
	13: uint8(111),
	14: uint8(112),
	15: uint8(80),
}

var silk_LTP_gain_vq_2_gain = [32]OpusT_opus_uint8{
	0:  uint8(126),
	1:  uint8(124),
	2:  uint8(125),
	3:  uint8(124),
	4:  uint8(129),
	5:  uint8(121),
	6:  uint8(126),
	7:  uint8(23),
	8:  uint8(132),
	9:  uint8(127),
	10: uint8(127),
	11: uint8(127),
	12: uint8(126),
	13: uint8(127),
	14: uint8(122),
	15: uint8(133),
	16: uint8(130),
	17: uint8(134),
	18: uint8(101),
	19: uint8(118),
	20: uint8(119),
	21: uint8(145),
	22: uint8(126),
	23: uint8(86),
	24: uint8(124),
	25: uint8(120),
	26: uint8(123),
	27: uint8(119),
	28: uint8(170),
	29: uint8(173),
	30: uint8(107),
	31: uint8(109),
}

var silk_NLSF_CB1_NB_MB_Q8 = [320]OpusT_opus_uint8{
	0:   uint8(12),
	1:   uint8(35),
	2:   uint8(60),
	3:   uint8(83),
	4:   uint8(108),
	5:   uint8(132),
	6:   uint8(157),
	7:   uint8(180),
	8:   uint8(206),
	9:   uint8(228),
	10:  uint8(15),
	11:  uint8(32),
	12:  uint8(55),
	13:  uint8(77),
	14:  uint8(101),
	15:  uint8(125),
	16:  uint8(151),
	17:  uint8(175),
	18:  uint8(201),
	19:  uint8(225),
	20:  uint8(19),
	21:  uint8(42),
	22:  uint8(66),
	23:  uint8(89),
	24:  uint8(114),
	25:  uint8(137),
	26:  uint8(162),
	27:  uint8(184),
	28:  uint8(209),
	29:  uint8(230),
	30:  uint8(12),
	31:  uint8(25),
	32:  uint8(50),
	33:  uint8(72),
	34:  uint8(97),
	35:  uint8(120),
	36:  uint8(147),
	37:  uint8(172),
	38:  uint8(200),
	39:  uint8(223),
	40:  uint8(26),
	41:  uint8(44),
	42:  uint8(69),
	43:  uint8(90),
	44:  uint8(114),
	45:  uint8(135),
	46:  uint8(159),
	47:  uint8(180),
	48:  uint8(205),
	49:  uint8(225),
	50:  uint8(13),
	51:  uint8(22),
	52:  uint8(53),
	53:  uint8(80),
	54:  uint8(106),
	55:  uint8(130),
	56:  uint8(156),
	57:  uint8(180),
	58:  uint8(205),
	59:  uint8(228),
	60:  uint8(15),
	61:  uint8(25),
	62:  uint8(44),
	63:  uint8(64),
	64:  uint8(90),
	65:  uint8(115),
	66:  uint8(142),
	67:  uint8(168),
	68:  uint8(196),
	69:  uint8(222),
	70:  uint8(19),
	71:  uint8(24),
	72:  uint8(62),
	73:  uint8(82),
	74:  uint8(100),
	75:  uint8(120),
	76:  uint8(145),
	77:  uint8(168),
	78:  uint8(190),
	79:  uint8(214),
	80:  uint8(22),
	81:  uint8(31),
	82:  uint8(50),
	83:  uint8(79),
	84:  uint8(103),
	85:  uint8(120),
	86:  uint8(151),
	87:  uint8(170),
	88:  uint8(203),
	89:  uint8(227),
	90:  uint8(21),
	91:  uint8(29),
	92:  uint8(45),
	93:  uint8(65),
	94:  uint8(106),
	95:  uint8(124),
	96:  uint8(150),
	97:  uint8(171),
	98:  uint8(196),
	99:  uint8(224),
	100: uint8(30),
	101: uint8(49),
	102: uint8(75),
	103: uint8(97),
	104: uint8(121),
	105: uint8(142),
	106: uint8(165),
	107: uint8(186),
	108: uint8(209),
	109: uint8(229),
	110: uint8(19),
	111: uint8(25),
	112: uint8(52),
	113: uint8(70),
	114: uint8(93),
	115: uint8(116),
	116: uint8(143),
	117: uint8(166),
	118: uint8(192),
	119: uint8(219),
	120: uint8(26),
	121: uint8(34),
	122: uint8(62),
	123: uint8(75),
	124: uint8(97),
	125: uint8(118),
	126: uint8(145),
	127: uint8(167),
	128: uint8(194),
	129: uint8(217),
	130: uint8(25),
	131: uint8(33),
	132: uint8(56),
	133: uint8(70),
	134: uint8(91),
	135: uint8(113),
	136: uint8(143),
	137: uint8(165),
	138: uint8(196),
	139: uint8(223),
	140: uint8(21),
	141: uint8(34),
	142: uint8(51),
	143: uint8(72),
	144: uint8(97),
	145: uint8(117),
	146: uint8(145),
	147: uint8(171),
	148: uint8(196),
	149: uint8(222),
	150: uint8(20),
	151: uint8(29),
	152: uint8(50),
	153: uint8(67),
	154: uint8(90),
	155: uint8(117),
	156: uint8(144),
	157: uint8(168),
	158: uint8(197),
	159: uint8(221),
	160: uint8(22),
	161: uint8(31),
	162: uint8(48),
	163: uint8(66),
	164: uint8(95),
	165: uint8(117),
	166: uint8(146),
	167: uint8(168),
	168: uint8(196),
	169: uint8(222),
	170: uint8(24),
	171: uint8(33),
	172: uint8(51),
	173: uint8(77),
	174: uint8(116),
	175: uint8(134),
	176: uint8(158),
	177: uint8(180),
	178: uint8(200),
	179: uint8(224),
	180: uint8(21),
	181: uint8(28),
	182: uint8(70),
	183: uint8(87),
	184: uint8(106),
	185: uint8(124),
	186: uint8(149),
	187: uint8(170),
	188: uint8(194),
	189: uint8(217),
	190: uint8(26),
	191: uint8(33),
	192: uint8(53),
	193: uint8(64),
	194: uint8(83),
	195: uint8(117),
	196: uint8(152),
	197: uint8(173),
	198: uint8(204),
	199: uint8(225),
	200: uint8(27),
	201: uint8(34),
	202: uint8(65),
	203: uint8(95),
	204: uint8(108),
	205: uint8(129),
	206: uint8(155),
	207: uint8(174),
	208: uint8(210),
	209: uint8(225),
	210: uint8(20),
	211: uint8(26),
	212: uint8(72),
	213: uint8(99),
	214: uint8(113),
	215: uint8(131),
	216: uint8(154),
	217: uint8(176),
	218: uint8(200),
	219: uint8(219),
	220: uint8(34),
	221: uint8(43),
	222: uint8(61),
	223: uint8(78),
	224: uint8(93),
	225: uint8(114),
	226: uint8(155),
	227: uint8(177),
	228: uint8(205),
	229: uint8(229),
	230: uint8(23),
	231: uint8(29),
	232: uint8(54),
	233: uint8(97),
	234: uint8(124),
	235: uint8(138),
	236: uint8(163),
	237: uint8(179),
	238: uint8(209),
	239: uint8(229),
	240: uint8(30),
	241: uint8(38),
	242: uint8(56),
	243: uint8(89),
	244: uint8(118),
	245: uint8(129),
	246: uint8(158),
	247: uint8(178),
	248: uint8(200),
	249: uint8(231),
	250: uint8(21),
	251: uint8(29),
	252: uint8(49),
	253: uint8(63),
	254: uint8(85),
	255: uint8(111),
	256: uint8(142),
	257: uint8(163),
	258: uint8(193),
	259: uint8(222),
	260: uint8(27),
	261: uint8(48),
	262: uint8(77),
	263: uint8(103),
	264: uint8(133),
	265: uint8(158),
	266: uint8(179),
	267: uint8(196),
	268: uint8(215),
	269: uint8(232),
	270: uint8(29),
	271: uint8(47),
	272: uint8(74),
	273: uint8(99),
	274: uint8(124),
	275: uint8(151),
	276: uint8(176),
	277: uint8(198),
	278: uint8(220),
	279: uint8(237),
	280: uint8(33),
	281: uint8(42),
	282: uint8(61),
	283: uint8(76),
	284: uint8(93),
	285: uint8(121),
	286: uint8(155),
	287: uint8(174),
	288: uint8(207),
	289: uint8(225),
	290: uint8(29),
	291: uint8(53),
	292: uint8(87),
	293: uint8(112),
	294: uint8(136),
	295: uint8(154),
	296: uint8(170),
	297: uint8(188),
	298: uint8(208),
	299: uint8(227),
	300: uint8(24),
	301: uint8(30),
	302: uint8(52),
	303: uint8(84),
	304: uint8(131),
	305: uint8(150),
	306: uint8(166),
	307: uint8(186),
	308: uint8(203),
	309: uint8(229),
	310: uint8(37),
	311: uint8(48),
	312: uint8(64),
	313: uint8(84),
	314: uint8(104),
	315: uint8(118),
	316: uint8(156),
	317: uint8(177),
	318: uint8(201),
	319: uint8(230),
}

var silk_NLSF_CB1_Wght_Q9 = [320]OpusT_opus_int16{
	0:   int16(2897),
	1:   int16(2314),
	2:   int16(2314),
	3:   int16(2314),
	4:   int16(2287),
	5:   int16(2287),
	6:   int16(2314),
	7:   int16(2300),
	8:   int16(2327),
	9:   int16(2287),
	10:  int16(2888),
	11:  int16(2580),
	12:  int16(2394),
	13:  int16(2367),
	14:  int16(2314),
	15:  int16(2274),
	16:  int16(2274),
	17:  int16(2274),
	18:  int16(2274),
	19:  int16(2194),
	20:  int16(2487),
	21:  int16(2340),
	22:  int16(2340),
	23:  int16(2314),
	24:  int16(2314),
	25:  int16(2314),
	26:  int16(2340),
	27:  int16(2340),
	28:  int16(2367),
	29:  int16(2354),
	30:  int16(3216),
	31:  int16(2766),
	32:  int16(2340),
	33:  int16(2340),
	34:  int16(2314),
	35:  int16(2274),
	36:  int16(2221),
	37:  int16(2207),
	38:  int16(2261),
	39:  int16(2194),
	40:  int16(2460),
	41:  int16(2474),
	42:  int16(2367),
	43:  int16(2394),
	44:  int16(2394),
	45:  int16(2394),
	46:  int16(2394),
	47:  int16(2367),
	48:  int16(2407),
	49:  int16(2314),
	50:  int16(3479),
	51:  int16(3056),
	52:  int16(2127),
	53:  int16(2207),
	54:  int16(2274),
	55:  int16(2274),
	56:  int16(2274),
	57:  int16(2287),
	58:  int16(2314),
	59:  int16(2261),
	60:  int16(3282),
	61:  int16(3141),
	62:  int16(2580),
	63:  int16(2394),
	64:  int16(2247),
	65:  int16(2221),
	66:  int16(2207),
	67:  int16(2194),
	68:  int16(2194),
	69:  int16(2114),
	70:  int16(4096),
	71:  int16(3845),
	72:  int16(2221),
	73:  int16(2620),
	74:  int16(2620),
	75:  int16(2407),
	76:  int16(2314),
	77:  int16(2394),
	78:  int16(2367),
	79:  int16(2074),
	80:  int16(3178),
	81:  int16(3244),
	82:  int16(2367),
	83:  int16(2221),
	84:  int16(2553),
	85:  int16(2434),
	86:  int16(2340),
	87:  int16(2314),
	88:  int16(2167),
	89:  int16(2221),
	90:  int16(3338),
	91:  int16(3488),
	92:  int16(2726),
	93:  int16(2194),
	94:  int16(2261),
	95:  int16(2460),
	96:  int16(2354),
	97:  int16(2367),
	98:  int16(2207),
	99:  int16(2101),
	100: int16(2354),
	101: int16(2420),
	102: int16(2327),
	103: int16(2367),
	104: int16(2394),
	105: int16(2420),
	106: int16(2420),
	107: int16(2420),
	108: int16(2460),
	109: int16(2367),
	110: int16(3779),
	111: int16(3629),
	112: int16(2434),
	113: int16(2527),
	114: int16(2367),
	115: int16(2274),
	116: int16(2274),
	117: int16(2300),
	118: int16(2207),
	119: int16(2048),
	120: int16(3254),
	121: int16(3225),
	122: int16(2713),
	123: int16(2846),
	124: int16(2447),
	125: int16(2327),
	126: int16(2300),
	127: int16(2300),
	128: int16(2274),
	129: int16(2127),
	130: int16(3263),
	131: int16(3300),
	132: int16(2753),
	133: int16(2806),
	134: int16(2447),
	135: int16(2261),
	136: int16(2261),
	137: int16(2247),
	138: int16(2127),
	139: int16(2101),
	140: int16(2873),
	141: int16(2981),
	142: int16(2633),
	143: int16(2367),
	144: int16(2407),
	145: int16(2354),
	146: int16(2194),
	147: int16(2247),
	148: int16(2247),
	149: int16(2114),
	150: int16(3225),
	151: int16(3197),
	152: int16(2633),
	153: int16(2580),
	154: int16(2274),
	155: int16(2181),
	156: int16(2247),
	157: int16(2221),
	158: int16(2221),
	159: int16(2141),
	160: int16(3178),
	161: int16(3310),
	162: int16(2740),
	163: int16(2407),
	164: int16(2274),
	165: int16(2274),
	166: int16(2274),
	167: int16(2287),
	168: int16(2194),
	169: int16(2114),
	170: int16(3141),
	171: int16(3272),
	172: int16(2460),
	173: int16(2061),
	174: int16(2287),
	175: int16(2500),
	176: int16(2367),
	177: int16(2487),
	178: int16(2434),
	179: int16(2181),
	180: int16(3507),
	181: int16(3282),
	182: int16(2314),
	183: int16(2700),
	184: int16(2647),
	185: int16(2474),
	186: int16(2367),
	187: int16(2394),
	188: int16(2340),
	189: int16(2127),
	190: int16(3423),
	191: int16(3535),
	192: int16(3038),
	193: int16(3056),
	194: int16(2300),
	195: int16(1950),
	196: int16(2221),
	197: int16(2274),
	198: int16(2274),
	199: int16(2274),
	200: int16(3404),
	201: int16(3366),
	202: int16(2087),
	203: int16(2687),
	204: int16(2873),
	205: int16(2354),
	206: int16(2420),
	207: int16(2274),
	208: int16(2474),
	209: int16(2540),
	210: int16(3760),
	211: int16(3488),
	212: int16(1950),
	213: int16(2660),
	214: int16(2897),
	215: int16(2527),
	216: int16(2394),
	217: int16(2367),
	218: int16(2460),
	219: int16(2261),
	220: int16(3028),
	221: int16(3272),
	222: int16(2740),
	223: int16(2888),
	224: int16(2740),
	225: int16(2154),
	226: int16(2127),
	227: int16(2287),
	228: int16(2234),
	229: int16(2247),
	230: int16(3695),
	231: int16(3657),
	232: int16(2025),
	233: int16(1969),
	234: int16(2660),
	235: int16(2700),
	236: int16(2580),
	237: int16(2500),
	238: int16(2327),
	239: int16(2367),
	240: int16(3207),
	241: int16(3413),
	242: int16(2354),
	243: int16(2074),
	244: int16(2888),
	245: int16(2888),
	246: int16(2340),
	247: int16(2487),
	248: int16(2247),
	249: int16(2167),
	250: int16(3338),
	251: int16(3366),
	252: int16(2846),
	253: int16(2780),
	254: int16(2327),
	255: int16(2154),
	256: int16(2274),
	257: int16(2287),
	258: int16(2114),
	259: int16(2061),
	260: int16(2327),
	261: int16(2300),
	262: int16(2181),
	263: int16(2167),
	264: int16(2181),
	265: int16(2367),
	266: int16(2633),
	267: int16(2700),
	268: int16(2700),
	269: int16(2553),
	270: int16(2407),
	271: int16(2434),
	272: int16(2221),
	273: int16(2261),
	274: int16(2221),
	275: int16(2221),
	276: int16(2340),
	277: int16(2420),
	278: int16(2607),
	279: int16(2700),
	280: int16(3038),
	281: int16(3244),
	282: int16(2806),
	283: int16(2888),
	284: int16(2474),
	285: int16(2074),
	286: int16(2300),
	287: int16(2314),
	288: int16(2354),
	289: int16(2380),
	290: int16(2221),
	291: int16(2154),
	292: int16(2127),
	293: int16(2287),
	294: int16(2500),
	295: int16(2793),
	296: int16(2793),
	297: int16(2620),
	298: int16(2580),
	299: int16(2367),
	300: int16(3676),
	301: int16(3713),
	302: int16(2234),
	303: int16(1838),
	304: int16(2181),
	305: int16(2753),
	306: int16(2726),
	307: int16(2673),
	308: int16(2513),
	309: int16(2207),
	310: int16(2793),
	311: int16(3160),
	312: int16(2726),
	313: int16(2553),
	314: int16(2846),
	315: int16(2513),
	316: int16(2181),
	317: int16(2394),
	318: int16(2221),
	319: int16(2181),
}

var silk_NLSF_CB1_iCDF_NB_MB = [64]OpusT_opus_uint8{
	0:  uint8(212),
	1:  uint8(178),
	2:  uint8(148),
	3:  uint8(129),
	4:  uint8(108),
	5:  uint8(96),
	6:  uint8(85),
	7:  uint8(82),
	8:  uint8(79),
	9:  uint8(77),
	10: uint8(61),
	11: uint8(59),
	12: uint8(57),
	13: uint8(56),
	14: uint8(51),
	15: uint8(49),
	16: uint8(48),
	17: uint8(45),
	18: uint8(42),
	19: uint8(41),
	20: uint8(40),
	21: uint8(38),
	22: uint8(36),
	23: uint8(34),
	24: uint8(31),
	25: uint8(30),
	26: uint8(21),
	27: uint8(12),
	28: uint8(10),
	29: uint8(3),
	30: uint8(1),
	32: uint8(255),
	33: uint8(245),
	34: uint8(244),
	35: uint8(236),
	36: uint8(233),
	37: uint8(225),
	38: uint8(217),
	39: uint8(203),
	40: uint8(190),
	41: uint8(176),
	42: uint8(175),
	43: uint8(161),
	44: uint8(149),
	45: uint8(136),
	46: uint8(125),
	47: uint8(114),
	48: uint8(102),
	49: uint8(91),
	50: uint8(81),
	51: uint8(71),
	52: uint8(60),
	53: uint8(52),
	54: uint8(43),
	55: uint8(35),
	56: uint8(28),
	57: uint8(20),
	58: uint8(19),
	59: uint8(18),
	60: uint8(12),
	61: uint8(11),
	62: uint8(5),
}

var silk_NLSF_CB2_SELECT_NB_MB = [160]OpusT_opus_uint8{
	0:   uint8(16),
	5:   uint8(99),
	6:   uint8(66),
	7:   uint8(36),
	8:   uint8(36),
	9:   uint8(34),
	10:  uint8(36),
	11:  uint8(34),
	12:  uint8(34),
	13:  uint8(34),
	14:  uint8(34),
	15:  uint8(83),
	16:  uint8(69),
	17:  uint8(36),
	18:  uint8(52),
	19:  uint8(34),
	20:  uint8(116),
	21:  uint8(102),
	22:  uint8(70),
	23:  uint8(68),
	24:  uint8(68),
	25:  uint8(176),
	26:  uint8(102),
	27:  uint8(68),
	28:  uint8(68),
	29:  uint8(34),
	30:  uint8(65),
	31:  uint8(85),
	32:  uint8(68),
	33:  uint8(84),
	34:  uint8(36),
	35:  uint8(116),
	36:  uint8(141),
	37:  uint8(152),
	38:  uint8(139),
	39:  uint8(170),
	40:  uint8(132),
	41:  uint8(187),
	42:  uint8(184),
	43:  uint8(216),
	44:  uint8(137),
	45:  uint8(132),
	46:  uint8(249),
	47:  uint8(168),
	48:  uint8(185),
	49:  uint8(139),
	50:  uint8(104),
	51:  uint8(102),
	52:  uint8(100),
	53:  uint8(68),
	54:  uint8(68),
	55:  uint8(178),
	56:  uint8(218),
	57:  uint8(185),
	58:  uint8(185),
	59:  uint8(170),
	60:  uint8(244),
	61:  uint8(216),
	62:  uint8(187),
	63:  uint8(187),
	64:  uint8(170),
	65:  uint8(244),
	66:  uint8(187),
	67:  uint8(187),
	68:  uint8(219),
	69:  uint8(138),
	70:  uint8(103),
	71:  uint8(155),
	72:  uint8(184),
	73:  uint8(185),
	74:  uint8(137),
	75:  uint8(116),
	76:  uint8(183),
	77:  uint8(155),
	78:  uint8(152),
	79:  uint8(136),
	80:  uint8(132),
	81:  uint8(217),
	82:  uint8(184),
	83:  uint8(184),
	84:  uint8(170),
	85:  uint8(164),
	86:  uint8(217),
	87:  uint8(171),
	88:  uint8(155),
	89:  uint8(139),
	90:  uint8(244),
	91:  uint8(169),
	92:  uint8(184),
	93:  uint8(185),
	94:  uint8(170),
	95:  uint8(164),
	96:  uint8(216),
	97:  uint8(223),
	98:  uint8(218),
	99:  uint8(138),
	100: uint8(214),
	101: uint8(143),
	102: uint8(188),
	103: uint8(218),
	104: uint8(168),
	105: uint8(244),
	106: uint8(141),
	107: uint8(136),
	108: uint8(155),
	109: uint8(170),
	110: uint8(168),
	111: uint8(138),
	112: uint8(220),
	113: uint8(219),
	114: uint8(139),
	115: uint8(164),
	116: uint8(219),
	117: uint8(202),
	118: uint8(216),
	119: uint8(137),
	120: uint8(168),
	121: uint8(186),
	122: uint8(246),
	123: uint8(185),
	124: uint8(139),
	125: uint8(116),
	126: uint8(185),
	127: uint8(219),
	128: uint8(185),
	129: uint8(138),
	130: uint8(100),
	131: uint8(100),
	132: uint8(134),
	133: uint8(100),
	134: uint8(102),
	135: uint8(34),
	136: uint8(68),
	137: uint8(68),
	138: uint8(100),
	139: uint8(68),
	140: uint8(168),
	141: uint8(203),
	142: uint8(221),
	143: uint8(218),
	144: uint8(168),
	145: uint8(167),
	146: uint8(154),
	147: uint8(136),
	148: uint8(104),
	149: uint8(70),
	150: uint8(164),
	151: uint8(246),
	152: uint8(171),
	153: uint8(137),
	154: uint8(139),
	155: uint8(137),
	156: uint8(155),
	157: uint8(218),
	158: uint8(219),
	159: uint8(139),
}

var silk_NLSF_CB2_iCDF_NB_MB = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(254),
	2:  uint8(253),
	3:  uint8(238),
	4:  uint8(14),
	5:  uint8(3),
	6:  uint8(2),
	7:  uint8(1),
	9:  uint8(255),
	10: uint8(254),
	11: uint8(252),
	12: uint8(218),
	13: uint8(35),
	14: uint8(3),
	15: uint8(2),
	16: uint8(1),
	18: uint8(255),
	19: uint8(254),
	20: uint8(250),
	21: uint8(208),
	22: uint8(59),
	23: uint8(4),
	24: uint8(2),
	25: uint8(1),
	27: uint8(255),
	28: uint8(254),
	29: uint8(246),
	30: uint8(194),
	31: uint8(71),
	32: uint8(10),
	33: uint8(2),
	34: uint8(1),
	36: uint8(255),
	37: uint8(252),
	38: uint8(236),
	39: uint8(183),
	40: uint8(82),
	41: uint8(8),
	42: uint8(2),
	43: uint8(1),
	45: uint8(255),
	46: uint8(252),
	47: uint8(235),
	48: uint8(180),
	49: uint8(90),
	50: uint8(17),
	51: uint8(2),
	52: uint8(1),
	54: uint8(255),
	55: uint8(248),
	56: uint8(224),
	57: uint8(171),
	58: uint8(97),
	59: uint8(30),
	60: uint8(4),
	61: uint8(1),
	63: uint8(255),
	64: uint8(254),
	65: uint8(236),
	66: uint8(173),
	67: uint8(95),
	68: uint8(37),
	69: uint8(7),
	70: uint8(1),
}

var silk_NLSF_CB2_BITS_NB_MB_Q5 = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(255),
	2:  uint8(255),
	3:  uint8(131),
	4:  uint8(6),
	5:  uint8(145),
	6:  uint8(255),
	7:  uint8(255),
	8:  uint8(255),
	9:  uint8(255),
	10: uint8(255),
	11: uint8(236),
	12: uint8(93),
	13: uint8(15),
	14: uint8(96),
	15: uint8(255),
	16: uint8(255),
	17: uint8(255),
	18: uint8(255),
	19: uint8(255),
	20: uint8(194),
	21: uint8(83),
	22: uint8(25),
	23: uint8(71),
	24: uint8(221),
	25: uint8(255),
	26: uint8(255),
	27: uint8(255),
	28: uint8(255),
	29: uint8(162),
	30: uint8(73),
	31: uint8(34),
	32: uint8(66),
	33: uint8(162),
	34: uint8(255),
	35: uint8(255),
	36: uint8(255),
	37: uint8(210),
	38: uint8(126),
	39: uint8(73),
	40: uint8(43),
	41: uint8(57),
	42: uint8(173),
	43: uint8(255),
	44: uint8(255),
	45: uint8(255),
	46: uint8(201),
	47: uint8(125),
	48: uint8(71),
	49: uint8(48),
	50: uint8(58),
	51: uint8(130),
	52: uint8(255),
	53: uint8(255),
	54: uint8(255),
	55: uint8(166),
	56: uint8(110),
	57: uint8(73),
	58: uint8(57),
	59: uint8(62),
	60: uint8(104),
	61: uint8(210),
	62: uint8(255),
	63: uint8(255),
	64: uint8(251),
	65: uint8(123),
	66: uint8(65),
	67: uint8(55),
	68: uint8(68),
	69: uint8(100),
	70: uint8(171),
	71: uint8(255),
}

var silk_NLSF_PRED_NB_MB_Q8 = [18]OpusT_opus_uint8{
	0:  uint8(179),
	1:  uint8(138),
	2:  uint8(140),
	3:  uint8(148),
	4:  uint8(151),
	5:  uint8(149),
	6:  uint8(153),
	7:  uint8(151),
	8:  uint8(163),
	9:  uint8(116),
	10: uint8(67),
	11: uint8(82),
	12: uint8(59),
	13: uint8(92),
	14: uint8(72),
	15: uint8(100),
	16: uint8(89),
	17: uint8(92),
}

var silk_NLSF_DELTA_MIN_NB_MB_Q15 = [11]OpusT_opus_int16{
	0:  int16(250),
	1:  int16(3),
	2:  int16(6),
	3:  int16(3),
	4:  int16(3),
	5:  int16(3),
	6:  int16(4),
	7:  int16(3),
	8:  int16(3),
	9:  int16(3),
	10: int16(461),
}

var silk_NLSF_CB1_WB_Q8 = [512]OpusT_opus_uint8{
	0:   uint8(7),
	1:   uint8(23),
	2:   uint8(38),
	3:   uint8(54),
	4:   uint8(69),
	5:   uint8(85),
	6:   uint8(100),
	7:   uint8(116),
	8:   uint8(131),
	9:   uint8(147),
	10:  uint8(162),
	11:  uint8(178),
	12:  uint8(193),
	13:  uint8(208),
	14:  uint8(223),
	15:  uint8(239),
	16:  uint8(13),
	17:  uint8(25),
	18:  uint8(41),
	19:  uint8(55),
	20:  uint8(69),
	21:  uint8(83),
	22:  uint8(98),
	23:  uint8(112),
	24:  uint8(127),
	25:  uint8(142),
	26:  uint8(157),
	27:  uint8(171),
	28:  uint8(187),
	29:  uint8(203),
	30:  uint8(220),
	31:  uint8(236),
	32:  uint8(15),
	33:  uint8(21),
	34:  uint8(34),
	35:  uint8(51),
	36:  uint8(61),
	37:  uint8(78),
	38:  uint8(92),
	39:  uint8(106),
	40:  uint8(126),
	41:  uint8(136),
	42:  uint8(152),
	43:  uint8(167),
	44:  uint8(185),
	45:  uint8(205),
	46:  uint8(225),
	47:  uint8(240),
	48:  uint8(10),
	49:  uint8(21),
	50:  uint8(36),
	51:  uint8(50),
	52:  uint8(63),
	53:  uint8(79),
	54:  uint8(95),
	55:  uint8(110),
	56:  uint8(126),
	57:  uint8(141),
	58:  uint8(157),
	59:  uint8(173),
	60:  uint8(189),
	61:  uint8(205),
	62:  uint8(221),
	63:  uint8(237),
	64:  uint8(17),
	65:  uint8(20),
	66:  uint8(37),
	67:  uint8(51),
	68:  uint8(59),
	69:  uint8(78),
	70:  uint8(89),
	71:  uint8(107),
	72:  uint8(123),
	73:  uint8(134),
	74:  uint8(150),
	75:  uint8(164),
	76:  uint8(184),
	77:  uint8(205),
	78:  uint8(224),
	79:  uint8(240),
	80:  uint8(10),
	81:  uint8(15),
	82:  uint8(32),
	83:  uint8(51),
	84:  uint8(67),
	85:  uint8(81),
	86:  uint8(96),
	87:  uint8(112),
	88:  uint8(129),
	89:  uint8(142),
	90:  uint8(158),
	91:  uint8(173),
	92:  uint8(189),
	93:  uint8(204),
	94:  uint8(220),
	95:  uint8(236),
	96:  uint8(8),
	97:  uint8(21),
	98:  uint8(37),
	99:  uint8(51),
	100: uint8(65),
	101: uint8(79),
	102: uint8(98),
	103: uint8(113),
	104: uint8(126),
	105: uint8(138),
	106: uint8(155),
	107: uint8(168),
	108: uint8(179),
	109: uint8(192),
	110: uint8(209),
	111: uint8(218),
	112: uint8(12),
	113: uint8(15),
	114: uint8(34),
	115: uint8(55),
	116: uint8(63),
	117: uint8(78),
	118: uint8(87),
	119: uint8(108),
	120: uint8(118),
	121: uint8(131),
	122: uint8(148),
	123: uint8(167),
	124: uint8(185),
	125: uint8(203),
	126: uint8(219),
	127: uint8(236),
	128: uint8(16),
	129: uint8(19),
	130: uint8(32),
	131: uint8(36),
	132: uint8(56),
	133: uint8(79),
	134: uint8(91),
	135: uint8(108),
	136: uint8(118),
	137: uint8(136),
	138: uint8(154),
	139: uint8(171),
	140: uint8(186),
	141: uint8(204),
	142: uint8(220),
	143: uint8(237),
	144: uint8(11),
	145: uint8(28),
	146: uint8(43),
	147: uint8(58),
	148: uint8(74),
	149: uint8(89),
	150: uint8(105),
	151: uint8(120),
	152: uint8(135),
	153: uint8(150),
	154: uint8(165),
	155: uint8(180),
	156: uint8(196),
	157: uint8(211),
	158: uint8(226),
	159: uint8(241),
	160: uint8(6),
	161: uint8(16),
	162: uint8(33),
	163: uint8(46),
	164: uint8(60),
	165: uint8(75),
	166: uint8(92),
	167: uint8(107),
	168: uint8(123),
	169: uint8(137),
	170: uint8(156),
	171: uint8(169),
	172: uint8(185),
	173: uint8(199),
	174: uint8(214),
	175: uint8(225),
	176: uint8(11),
	177: uint8(19),
	178: uint8(30),
	179: uint8(44),
	180: uint8(57),
	181: uint8(74),
	182: uint8(89),
	183: uint8(105),
	184: uint8(121),
	185: uint8(135),
	186: uint8(152),
	187: uint8(169),
	188: uint8(186),
	189: uint8(202),
	190: uint8(218),
	191: uint8(234),
	192: uint8(12),
	193: uint8(19),
	194: uint8(29),
	195: uint8(46),
	196: uint8(57),
	197: uint8(71),
	198: uint8(88),
	199: uint8(100),
	200: uint8(120),
	201: uint8(132),
	202: uint8(148),
	203: uint8(165),
	204: uint8(182),
	205: uint8(199),
	206: uint8(216),
	207: uint8(233),
	208: uint8(17),
	209: uint8(23),
	210: uint8(35),
	211: uint8(46),
	212: uint8(56),
	213: uint8(77),
	214: uint8(92),
	215: uint8(106),
	216: uint8(123),
	217: uint8(134),
	218: uint8(152),
	219: uint8(167),
	220: uint8(185),
	221: uint8(204),
	222: uint8(222),
	223: uint8(237),
	224: uint8(14),
	225: uint8(17),
	226: uint8(45),
	227: uint8(53),
	228: uint8(63),
	229: uint8(75),
	230: uint8(89),
	231: uint8(107),
	232: uint8(115),
	233: uint8(132),
	234: uint8(151),
	235: uint8(171),
	236: uint8(188),
	237: uint8(206),
	238: uint8(221),
	239: uint8(240),
	240: uint8(9),
	241: uint8(16),
	242: uint8(29),
	243: uint8(40),
	244: uint8(56),
	245: uint8(71),
	246: uint8(88),
	247: uint8(103),
	248: uint8(119),
	249: uint8(137),
	250: uint8(154),
	251: uint8(171),
	252: uint8(189),
	253: uint8(205),
	254: uint8(222),
	255: uint8(237),
	256: uint8(16),
	257: uint8(19),
	258: uint8(36),
	259: uint8(48),
	260: uint8(57),
	261: uint8(76),
	262: uint8(87),
	263: uint8(105),
	264: uint8(118),
	265: uint8(132),
	266: uint8(150),
	267: uint8(167),
	268: uint8(185),
	269: uint8(202),
	270: uint8(218),
	271: uint8(236),
	272: uint8(12),
	273: uint8(17),
	274: uint8(29),
	275: uint8(54),
	276: uint8(71),
	277: uint8(81),
	278: uint8(94),
	279: uint8(104),
	280: uint8(126),
	281: uint8(136),
	282: uint8(149),
	283: uint8(164),
	284: uint8(182),
	285: uint8(201),
	286: uint8(221),
	287: uint8(237),
	288: uint8(15),
	289: uint8(28),
	290: uint8(47),
	291: uint8(62),
	292: uint8(79),
	293: uint8(97),
	294: uint8(115),
	295: uint8(129),
	296: uint8(142),
	297: uint8(155),
	298: uint8(168),
	299: uint8(180),
	300: uint8(194),
	301: uint8(208),
	302: uint8(223),
	303: uint8(238),
	304: uint8(8),
	305: uint8(14),
	306: uint8(30),
	307: uint8(45),
	308: uint8(62),
	309: uint8(78),
	310: uint8(94),
	311: uint8(111),
	312: uint8(127),
	313: uint8(143),
	314: uint8(159),
	315: uint8(175),
	316: uint8(192),
	317: uint8(207),
	318: uint8(223),
	319: uint8(239),
	320: uint8(17),
	321: uint8(30),
	322: uint8(49),
	323: uint8(62),
	324: uint8(79),
	325: uint8(92),
	326: uint8(107),
	327: uint8(119),
	328: uint8(132),
	329: uint8(145),
	330: uint8(160),
	331: uint8(174),
	332: uint8(190),
	333: uint8(204),
	334: uint8(220),
	335: uint8(235),
	336: uint8(14),
	337: uint8(19),
	338: uint8(36),
	339: uint8(45),
	340: uint8(61),
	341: uint8(76),
	342: uint8(91),
	343: uint8(108),
	344: uint8(121),
	345: uint8(138),
	346: uint8(154),
	347: uint8(172),
	348: uint8(189),
	349: uint8(205),
	350: uint8(222),
	351: uint8(238),
	352: uint8(12),
	353: uint8(18),
	354: uint8(31),
	355: uint8(45),
	356: uint8(60),
	357: uint8(76),
	358: uint8(91),
	359: uint8(107),
	360: uint8(123),
	361: uint8(138),
	362: uint8(154),
	363: uint8(171),
	364: uint8(187),
	365: uint8(204),
	366: uint8(221),
	367: uint8(236),
	368: uint8(13),
	369: uint8(17),
	370: uint8(31),
	371: uint8(43),
	372: uint8(53),
	373: uint8(70),
	374: uint8(83),
	375: uint8(103),
	376: uint8(114),
	377: uint8(131),
	378: uint8(149),
	379: uint8(167),
	380: uint8(185),
	381: uint8(203),
	382: uint8(220),
	383: uint8(237),
	384: uint8(17),
	385: uint8(22),
	386: uint8(35),
	387: uint8(42),
	388: uint8(58),
	389: uint8(78),
	390: uint8(93),
	391: uint8(110),
	392: uint8(125),
	393: uint8(139),
	394: uint8(155),
	395: uint8(170),
	396: uint8(188),
	397: uint8(206),
	398: uint8(224),
	399: uint8(240),
	400: uint8(8),
	401: uint8(15),
	402: uint8(34),
	403: uint8(50),
	404: uint8(67),
	405: uint8(83),
	406: uint8(99),
	407: uint8(115),
	408: uint8(131),
	409: uint8(146),
	410: uint8(162),
	411: uint8(178),
	412: uint8(193),
	413: uint8(209),
	414: uint8(224),
	415: uint8(239),
	416: uint8(13),
	417: uint8(16),
	418: uint8(41),
	419: uint8(66),
	420: uint8(73),
	421: uint8(86),
	422: uint8(95),
	423: uint8(111),
	424: uint8(128),
	425: uint8(137),
	426: uint8(150),
	427: uint8(163),
	428: uint8(183),
	429: uint8(206),
	430: uint8(225),
	431: uint8(241),
	432: uint8(17),
	433: uint8(25),
	434: uint8(37),
	435: uint8(52),
	436: uint8(63),
	437: uint8(75),
	438: uint8(92),
	439: uint8(102),
	440: uint8(119),
	441: uint8(132),
	442: uint8(144),
	443: uint8(160),
	444: uint8(175),
	445: uint8(191),
	446: uint8(212),
	447: uint8(231),
	448: uint8(19),
	449: uint8(31),
	450: uint8(49),
	451: uint8(65),
	452: uint8(83),
	453: uint8(100),
	454: uint8(117),
	455: uint8(133),
	456: uint8(147),
	457: uint8(161),
	458: uint8(174),
	459: uint8(187),
	460: uint8(200),
	461: uint8(213),
	462: uint8(227),
	463: uint8(242),
	464: uint8(18),
	465: uint8(31),
	466: uint8(52),
	467: uint8(68),
	468: uint8(88),
	469: uint8(103),
	470: uint8(117),
	471: uint8(126),
	472: uint8(138),
	473: uint8(149),
	474: uint8(163),
	475: uint8(177),
	476: uint8(192),
	477: uint8(207),
	478: uint8(223),
	479: uint8(239),
	480: uint8(16),
	481: uint8(29),
	482: uint8(47),
	483: uint8(61),
	484: uint8(76),
	485: uint8(90),
	486: uint8(106),
	487: uint8(119),
	488: uint8(133),
	489: uint8(147),
	490: uint8(161),
	491: uint8(176),
	492: uint8(193),
	493: uint8(209),
	494: uint8(224),
	495: uint8(240),
	496: uint8(15),
	497: uint8(21),
	498: uint8(35),
	499: uint8(50),
	500: uint8(61),
	501: uint8(73),
	502: uint8(86),
	503: uint8(97),
	504: uint8(110),
	505: uint8(119),
	506: uint8(129),
	507: uint8(141),
	508: uint8(175),
	509: uint8(198),
	510: uint8(218),
	511: uint8(237),
}

var silk_NLSF_CB1_WB_Wght_Q9 = [512]OpusT_opus_int16{
	0:   int16(3657),
	1:   int16(2925),
	2:   int16(2925),
	3:   int16(2925),
	4:   int16(2925),
	5:   int16(2925),
	6:   int16(2925),
	7:   int16(2925),
	8:   int16(2925),
	9:   int16(2925),
	10:  int16(2925),
	11:  int16(2925),
	12:  int16(2963),
	13:  int16(2963),
	14:  int16(2925),
	15:  int16(2846),
	16:  int16(3216),
	17:  int16(3085),
	18:  int16(2972),
	19:  int16(3056),
	20:  int16(3056),
	21:  int16(3010),
	22:  int16(3010),
	23:  int16(3010),
	24:  int16(2963),
	25:  int16(2963),
	26:  int16(3010),
	27:  int16(2972),
	28:  int16(2888),
	29:  int16(2846),
	30:  int16(2846),
	31:  int16(2726),
	32:  int16(3920),
	33:  int16(4014),
	34:  int16(2981),
	35:  int16(3207),
	36:  int16(3207),
	37:  int16(2934),
	38:  int16(3056),
	39:  int16(2846),
	40:  int16(3122),
	41:  int16(3244),
	42:  int16(2925),
	43:  int16(2846),
	44:  int16(2620),
	45:  int16(2553),
	46:  int16(2780),
	47:  int16(2925),
	48:  int16(3516),
	49:  int16(3197),
	50:  int16(3010),
	51:  int16(3103),
	52:  int16(3019),
	53:  int16(2888),
	54:  int16(2925),
	55:  int16(2925),
	56:  int16(2925),
	57:  int16(2925),
	58:  int16(2888),
	59:  int16(2888),
	60:  int16(2888),
	61:  int16(2888),
	62:  int16(2888),
	63:  int16(2753),
	64:  int16(5054),
	65:  int16(5054),
	66:  int16(2934),
	67:  int16(3573),
	68:  int16(3385),
	69:  int16(3056),
	70:  int16(3085),
	71:  int16(2793),
	72:  int16(3160),
	73:  int16(3160),
	74:  int16(2972),
	75:  int16(2846),
	76:  int16(2513),
	77:  int16(2540),
	78:  int16(2753),
	79:  int16(2888),
	80:  int16(4428),
	81:  int16(4149),
	82:  int16(2700),
	83:  int16(2753),
	84:  int16(2972),
	85:  int16(3010),
	86:  int16(2925),
	87:  int16(2846),
	88:  int16(2981),
	89:  int16(3019),
	90:  int16(2925),
	91:  int16(2925),
	92:  int16(2925),
	93:  int16(2925),
	94:  int16(2888),
	95:  int16(2726),
	96:  int16(3620),
	97:  int16(3019),
	98:  int16(2972),
	99:  int16(3056),
	100: int16(3056),
	101: int16(2873),
	102: int16(2806),
	103: int16(3056),
	104: int16(3216),
	105: int16(3047),
	106: int16(2981),
	107: int16(3291),
	108: int16(3291),
	109: int16(2981),
	110: int16(3310),
	111: int16(2991),
	112: int16(5227),
	113: int16(5014),
	114: int16(2540),
	115: int16(3338),
	116: int16(3526),
	117: int16(3385),
	118: int16(3197),
	119: int16(3094),
	120: int16(3376),
	121: int16(2981),
	122: int16(2700),
	123: int16(2647),
	124: int16(2687),
	125: int16(2793),
	126: int16(2846),
	127: int16(2673),
	128: int16(5081),
	129: int16(5174),
	130: int16(4615),
	131: int16(4428),
	132: int16(2460),
	133: int16(2897),
	134: int16(3047),
	135: int16(3207),
	136: int16(3169),
	137: int16(2687),
	138: int16(2740),
	139: int16(2888),
	140: int16(2846),
	141: int16(2793),
	142: int16(2846),
	143: int16(2700),
	144: int16(3122),
	145: int16(2888),
	146: int16(2963),
	147: int16(2925),
	148: int16(2925),
	149: int16(2925),
	150: int16(2925),
	151: int16(2963),
	152: int16(2963),
	153: int16(2963),
	154: int16(2963),
	155: int16(2925),
	156: int16(2925),
	157: int16(2963),
	158: int16(2963),
	159: int16(2963),
	160: int16(4202),
	161: int16(3207),
	162: int16(2981),
	163: int16(3103),
	164: int16(3010),
	165: int16(2888),
	166: int16(2888),
	167: int16(2925),
	168: int16(2972),
	169: int16(2873),
	170: int16(2916),
	171: int16(3019),
	172: int16(2972),
	173: int16(3010),
	174: int16(3197),
	175: int16(2873),
	176: int16(3760),
	177: int16(3760),
	178: int16(3244),
	179: int16(3103),
	180: int16(2981),
	181: int16(2888),
	182: int16(2925),
	183: int16(2888),
	184: int16(2972),
	185: int16(2934),
	186: int16(2793),
	187: int16(2793),
	188: int16(2846),
	189: int16(2888),
	190: int16(2888),
	191: int16(2660),
	192: int16(3854),
	193: int16(4014),
	194: int16(3207),
	195: int16(3122),
	196: int16(3244),
	197: int16(2934),
	198: int16(3047),
	199: int16(2963),
	200: int16(2963),
	201: int16(3085),
	202: int16(2846),
	203: int16(2793),
	204: int16(2793),
	205: int16(2793),
	206: int16(2793),
	207: int16(2580),
	208: int16(3845),
	209: int16(4080),
	210: int16(3357),
	211: int16(3516),
	212: int16(3094),
	213: int16(2740),
	214: int16(3010),
	215: int16(2934),
	216: int16(3122),
	217: int16(3085),
	218: int16(2846),
	219: int16(2846),
	220: int16(2647),
	221: int16(2647),
	222: int16(2846),
	223: int16(2806),
	224: int16(5147),
	225: int16(4894),
	226: int16(3225),
	227: int16(3845),
	228: int16(3441),
	229: int16(3169),
	230: int16(2897),
	231: int16(3413),
	232: int16(3451),
	233: int16(2700),
	234: int16(2580),
	235: int16(2673),
	236: int16(2740),
	237: int16(2846),
	238: int16(2806),
	239: int16(2753),
	240: int16(4109),
	241: int16(3789),
	242: int16(3291),
	243: int16(3160),
	244: int16(2925),
	245: int16(2888),
	246: int16(2888),
	247: int16(2925),
	248: int16(2793),
	249: int16(2740),
	250: int16(2793),
	251: int16(2740),
	252: int16(2793),
	253: int16(2846),
	254: int16(2888),
	255: int16(2806),
	256: int16(5081),
	257: int16(5054),
	258: int16(3047),
	259: int16(3545),
	260: int16(3244),
	261: int16(3056),
	262: int16(3085),
	263: int16(2944),
	264: int16(3103),
	265: int16(2897),
	266: int16(2740),
	267: int16(2740),
	268: int16(2740),
	269: int16(2846),
	270: int16(2793),
	271: int16(2620),
	272: int16(4309),
	273: int16(4309),
	274: int16(2860),
	275: int16(2527),
	276: int16(3207),
	277: int16(3376),
	278: int16(3376),
	279: int16(3075),
	280: int16(3075),
	281: int16(3376),
	282: int16(3056),
	283: int16(2846),
	284: int16(2647),
	285: int16(2580),
	286: int16(2726),
	287: int16(2753),
	288: int16(3056),
	289: int16(2916),
	290: int16(2806),
	291: int16(2888),
	292: int16(2740),
	293: int16(2687),
	294: int16(2897),
	295: int16(3103),
	296: int16(3150),
	297: int16(3150),
	298: int16(3216),
	299: int16(3169),
	300: int16(3056),
	301: int16(3010),
	302: int16(2963),
	303: int16(2846),
	304: int16(4375),
	305: int16(3882),
	306: int16(2925),
	307: int16(2888),
	308: int16(2846),
	309: int16(2888),
	310: int16(2846),
	311: int16(2846),
	312: int16(2888),
	313: int16(2888),
	314: int16(2888),
	315: int16(2846),
	316: int16(2888),
	317: int16(2925),
	318: int16(2888),
	319: int16(2846),
	320: int16(2981),
	321: int16(2916),
	322: int16(2916),
	323: int16(2981),
	324: int16(2981),
	325: int16(3056),
	326: int16(3122),
	327: int16(3216),
	328: int16(3150),
	329: int16(3056),
	330: int16(3010),
	331: int16(2972),
	332: int16(2972),
	333: int16(2972),
	334: int16(2925),
	335: int16(2740),
	336: int16(4229),
	337: int16(4149),
	338: int16(3310),
	339: int16(3347),
	340: int16(2925),
	341: int16(2963),
	342: int16(2888),
	343: int16(2981),
	344: int16(2981),
	345: int16(2846),
	346: int16(2793),
	347: int16(2740),
	348: int16(2846),
	349: int16(2846),
	350: int16(2846),
	351: int16(2793),
	352: int16(4080),
	353: int16(4014),
	354: int16(3103),
	355: int16(3010),
	356: int16(2925),
	357: int16(2925),
	358: int16(2925),
	359: int16(2888),
	360: int16(2925),
	361: int16(2925),
	362: int16(2846),
	363: int16(2846),
	364: int16(2846),
	365: int16(2793),
	366: int16(2888),
	367: int16(2780),
	368: int16(4615),
	369: int16(4575),
	370: int16(3169),
	371: int16(3441),
	372: int16(3207),
	373: int16(2981),
	374: int16(2897),
	375: int16(3038),
	376: int16(3122),
	377: int16(2740),
	378: int16(2687),
	379: int16(2687),
	380: int16(2687),
	381: int16(2740),
	382: int16(2793),
	383: int16(2700),
	384: int16(4149),
	385: int16(4269),
	386: int16(3789),
	387: int16(3657),
	388: int16(2726),
	389: int16(2780),
	390: int16(2888),
	391: int16(2888),
	392: int16(3010),
	393: int16(2972),
	394: int16(2925),
	395: int16(2846),
	396: int16(2687),
	397: int16(2687),
	398: int16(2793),
	399: int16(2888),
	400: int16(4215),
	401: int16(3554),
	402: int16(2753),
	403: int16(2846),
	404: int16(2846),
	405: int16(2888),
	406: int16(2888),
	407: int16(2888),
	408: int16(2925),
	409: int16(2925),
	410: int16(2888),
	411: int16(2925),
	412: int16(2925),
	413: int16(2925),
	414: int16(2963),
	415: int16(2888),
	416: int16(5174),
	417: int16(4921),
	418: int16(2261),
	419: int16(3432),
	420: int16(3789),
	421: int16(3479),
	422: int16(3347),
	423: int16(2846),
	424: int16(3310),
	425: int16(3479),
	426: int16(3150),
	427: int16(2897),
	428: int16(2460),
	429: int16(2487),
	430: int16(2753),
	431: int16(2925),
	432: int16(3451),
	433: int16(3685),
	434: int16(3122),
	435: int16(3197),
	436: int16(3357),
	437: int16(3047),
	438: int16(3207),
	439: int16(3207),
	440: int16(2981),
	441: int16(3216),
	442: int16(3085),
	443: int16(2925),
	444: int16(2925),
	445: int16(2687),
	446: int16(2540),
	447: int16(2434),
	448: int16(2981),
	449: int16(3010),
	450: int16(2793),
	451: int16(2793),
	452: int16(2740),
	453: int16(2793),
	454: int16(2846),
	455: int16(2972),
	456: int16(3056),
	457: int16(3103),
	458: int16(3150),
	459: int16(3150),
	460: int16(3150),
	461: int16(3103),
	462: int16(3010),
	463: int16(3010),
	464: int16(2944),
	465: int16(2873),
	466: int16(2687),
	467: int16(2726),
	468: int16(2780),
	469: int16(3010),
	470: int16(3432),
	471: int16(3545),
	472: int16(3357),
	473: int16(3244),
	474: int16(3056),
	475: int16(3010),
	476: int16(2963),
	477: int16(2925),
	478: int16(2888),
	479: int16(2846),
	480: int16(3019),
	481: int16(2944),
	482: int16(2897),
	483: int16(3010),
	484: int16(3010),
	485: int16(2972),
	486: int16(3019),
	487: int16(3103),
	488: int16(3056),
	489: int16(3056),
	490: int16(3010),
	491: int16(2888),
	492: int16(2846),
	493: int16(2925),
	494: int16(2925),
	495: int16(2888),
	496: int16(3920),
	497: int16(3967),
	498: int16(3010),
	499: int16(3197),
	500: int16(3357),
	501: int16(3216),
	502: int16(3291),
	503: int16(3291),
	504: int16(3479),
	505: int16(3704),
	506: int16(3441),
	507: int16(2726),
	508: int16(2181),
	509: int16(2460),
	510: int16(2580),
	511: int16(2607),
}

var silk_NLSF_CB1_iCDF_WB = [64]OpusT_opus_uint8{
	0:  uint8(225),
	1:  uint8(204),
	2:  uint8(201),
	3:  uint8(184),
	4:  uint8(183),
	5:  uint8(175),
	6:  uint8(158),
	7:  uint8(154),
	8:  uint8(153),
	9:  uint8(135),
	10: uint8(119),
	11: uint8(115),
	12: uint8(113),
	13: uint8(110),
	14: uint8(109),
	15: uint8(99),
	16: uint8(98),
	17: uint8(95),
	18: uint8(79),
	19: uint8(68),
	20: uint8(52),
	21: uint8(50),
	22: uint8(48),
	23: uint8(45),
	24: uint8(43),
	25: uint8(32),
	26: uint8(31),
	27: uint8(27),
	28: uint8(18),
	29: uint8(10),
	30: uint8(3),
	32: uint8(255),
	33: uint8(251),
	34: uint8(235),
	35: uint8(230),
	36: uint8(212),
	37: uint8(201),
	38: uint8(196),
	39: uint8(182),
	40: uint8(167),
	41: uint8(166),
	42: uint8(163),
	43: uint8(151),
	44: uint8(138),
	45: uint8(124),
	46: uint8(110),
	47: uint8(104),
	48: uint8(90),
	49: uint8(78),
	50: uint8(76),
	51: uint8(70),
	52: uint8(69),
	53: uint8(57),
	54: uint8(45),
	55: uint8(34),
	56: uint8(24),
	57: uint8(21),
	58: uint8(11),
	59: uint8(6),
	60: uint8(5),
	61: uint8(4),
	62: uint8(3),
}

var silk_NLSF_CB2_SELECT_WB = [256]OpusT_opus_uint8{
	7:   uint8(1),
	8:   uint8(100),
	9:   uint8(102),
	10:  uint8(102),
	11:  uint8(68),
	12:  uint8(68),
	13:  uint8(36),
	14:  uint8(34),
	15:  uint8(96),
	16:  uint8(164),
	17:  uint8(107),
	18:  uint8(158),
	19:  uint8(185),
	20:  uint8(180),
	21:  uint8(185),
	22:  uint8(139),
	23:  uint8(102),
	24:  uint8(64),
	25:  uint8(66),
	26:  uint8(36),
	27:  uint8(34),
	28:  uint8(34),
	30:  uint8(1),
	31:  uint8(32),
	32:  uint8(208),
	33:  uint8(139),
	34:  uint8(141),
	35:  uint8(191),
	36:  uint8(152),
	37:  uint8(185),
	38:  uint8(155),
	39:  uint8(104),
	40:  uint8(96),
	41:  uint8(171),
	42:  uint8(104),
	43:  uint8(166),
	44:  uint8(102),
	45:  uint8(102),
	46:  uint8(102),
	47:  uint8(132),
	48:  uint8(1),
	53:  uint8(16),
	54:  uint8(16),
	56:  uint8(80),
	57:  uint8(109),
	58:  uint8(78),
	59:  uint8(107),
	60:  uint8(185),
	61:  uint8(139),
	62:  uint8(103),
	63:  uint8(101),
	64:  uint8(208),
	65:  uint8(212),
	66:  uint8(141),
	67:  uint8(139),
	68:  uint8(173),
	69:  uint8(153),
	70:  uint8(123),
	71:  uint8(103),
	72:  uint8(36),
	79:  uint8(1),
	80:  uint8(48),
	87:  uint8(32),
	88:  uint8(68),
	89:  uint8(135),
	90:  uint8(123),
	91:  uint8(119),
	92:  uint8(119),
	93:  uint8(103),
	94:  uint8(69),
	95:  uint8(98),
	96:  uint8(68),
	97:  uint8(103),
	98:  uint8(120),
	99:  uint8(118),
	100: uint8(118),
	101: uint8(102),
	102: uint8(71),
	103: uint8(98),
	104: uint8(134),
	105: uint8(136),
	106: uint8(157),
	107: uint8(184),
	108: uint8(182),
	109: uint8(153),
	110: uint8(139),
	111: uint8(134),
	112: uint8(208),
	113: uint8(168),
	114: uint8(248),
	115: uint8(75),
	116: uint8(189),
	117: uint8(143),
	118: uint8(121),
	119: uint8(107),
	120: uint8(32),
	121: uint8(49),
	122: uint8(34),
	123: uint8(34),
	124: uint8(34),
	126: uint8(17),
	127: uint8(2),
	128: uint8(210),
	129: uint8(235),
	130: uint8(139),
	131: uint8(123),
	132: uint8(185),
	133: uint8(137),
	134: uint8(105),
	135: uint8(134),
	136: uint8(98),
	137: uint8(135),
	138: uint8(104),
	139: uint8(182),
	140: uint8(100),
	141: uint8(183),
	142: uint8(171),
	143: uint8(134),
	144: uint8(100),
	145: uint8(70),
	146: uint8(68),
	147: uint8(70),
	148: uint8(66),
	149: uint8(66),
	150: uint8(34),
	151: uint8(131),
	152: uint8(64),
	153: uint8(166),
	154: uint8(102),
	155: uint8(68),
	156: uint8(36),
	157: uint8(2),
	158: uint8(1),
	160: uint8(134),
	161: uint8(166),
	162: uint8(102),
	163: uint8(68),
	164: uint8(34),
	165: uint8(34),
	166: uint8(66),
	167: uint8(132),
	168: uint8(212),
	169: uint8(246),
	170: uint8(158),
	171: uint8(139),
	172: uint8(107),
	173: uint8(107),
	174: uint8(87),
	175: uint8(102),
	176: uint8(100),
	177: uint8(219),
	178: uint8(125),
	179: uint8(122),
	180: uint8(137),
	181: uint8(118),
	182: uint8(103),
	183: uint8(132),
	184: uint8(114),
	185: uint8(135),
	186: uint8(137),
	187: uint8(105),
	188: uint8(171),
	189: uint8(106),
	190: uint8(50),
	191: uint8(34),
	192: uint8(164),
	193: uint8(214),
	194: uint8(141),
	195: uint8(143),
	196: uint8(185),
	197: uint8(151),
	198: uint8(121),
	199: uint8(103),
	200: uint8(192),
	201: uint8(34),
	207: uint8(1),
	208: uint8(208),
	209: uint8(109),
	210: uint8(74),
	211: uint8(187),
	212: uint8(134),
	213: uint8(249),
	214: uint8(159),
	215: uint8(137),
	216: uint8(102),
	217: uint8(110),
	218: uint8(154),
	219: uint8(118),
	220: uint8(87),
	221: uint8(101),
	222: uint8(119),
	223: uint8(101),
	225: uint8(2),
	227: uint8(36),
	228: uint8(36),
	229: uint8(66),
	230: uint8(68),
	231: uint8(35),
	232: uint8(96),
	233: uint8(164),
	234: uint8(102),
	235: uint8(100),
	236: uint8(36),
	238: uint8(2),
	239: uint8(33),
	240: uint8(167),
	241: uint8(138),
	242: uint8(174),
	243: uint8(102),
	244: uint8(100),
	245: uint8(84),
	246: uint8(2),
	247: uint8(2),
	248: uint8(100),
	249: uint8(107),
	250: uint8(120),
	251: uint8(119),
	252: uint8(36),
	253: uint8(197),
	254: uint8(24),
}

var silk_NLSF_CB2_iCDF_WB = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(254),
	2:  uint8(253),
	3:  uint8(244),
	4:  uint8(12),
	5:  uint8(3),
	6:  uint8(2),
	7:  uint8(1),
	9:  uint8(255),
	10: uint8(254),
	11: uint8(252),
	12: uint8(224),
	13: uint8(38),
	14: uint8(3),
	15: uint8(2),
	16: uint8(1),
	18: uint8(255),
	19: uint8(254),
	20: uint8(251),
	21: uint8(209),
	22: uint8(57),
	23: uint8(4),
	24: uint8(2),
	25: uint8(1),
	27: uint8(255),
	28: uint8(254),
	29: uint8(244),
	30: uint8(195),
	31: uint8(69),
	32: uint8(4),
	33: uint8(2),
	34: uint8(1),
	36: uint8(255),
	37: uint8(251),
	38: uint8(232),
	39: uint8(184),
	40: uint8(84),
	41: uint8(7),
	42: uint8(2),
	43: uint8(1),
	45: uint8(255),
	46: uint8(254),
	47: uint8(240),
	48: uint8(186),
	49: uint8(86),
	50: uint8(14),
	51: uint8(2),
	52: uint8(1),
	54: uint8(255),
	55: uint8(254),
	56: uint8(239),
	57: uint8(178),
	58: uint8(91),
	59: uint8(30),
	60: uint8(5),
	61: uint8(1),
	63: uint8(255),
	64: uint8(248),
	65: uint8(227),
	66: uint8(177),
	67: uint8(100),
	68: uint8(19),
	69: uint8(2),
	70: uint8(1),
}

var silk_NLSF_CB2_BITS_WB_Q5 = [72]OpusT_opus_uint8{
	0:  uint8(255),
	1:  uint8(255),
	2:  uint8(255),
	3:  uint8(156),
	4:  uint8(4),
	5:  uint8(154),
	6:  uint8(255),
	7:  uint8(255),
	8:  uint8(255),
	9:  uint8(255),
	10: uint8(255),
	11: uint8(227),
	12: uint8(102),
	13: uint8(15),
	14: uint8(92),
	15: uint8(255),
	16: uint8(255),
	17: uint8(255),
	18: uint8(255),
	19: uint8(255),
	20: uint8(213),
	21: uint8(83),
	22: uint8(24),
	23: uint8(72),
	24: uint8(236),
	25: uint8(255),
	26: uint8(255),
	27: uint8(255),
	28: uint8(255),
	29: uint8(150),
	30: uint8(76),
	31: uint8(33),
	32: uint8(63),
	33: uint8(214),
	34: uint8(255),
	35: uint8(255),
	36: uint8(255),
	37: uint8(190),
	38: uint8(121),
	39: uint8(77),
	40: uint8(43),
	41: uint8(55),
	42: uint8(185),
	43: uint8(255),
	44: uint8(255),
	45: uint8(255),
	46: uint8(245),
	47: uint8(137),
	48: uint8(71),
	49: uint8(43),
	50: uint8(59),
	51: uint8(139),
	52: uint8(255),
	53: uint8(255),
	54: uint8(255),
	55: uint8(255),
	56: uint8(131),
	57: uint8(66),
	58: uint8(50),
	59: uint8(66),
	60: uint8(107),
	61: uint8(194),
	62: uint8(255),
	63: uint8(255),
	64: uint8(166),
	65: uint8(116),
	66: uint8(76),
	67: uint8(55),
	68: uint8(53),
	69: uint8(125),
	70: uint8(255),
	71: uint8(255),
}

var silk_NLSF_PRED_WB_Q8 = [30]OpusT_opus_uint8{
	0:  uint8(175),
	1:  uint8(148),
	2:  uint8(160),
	3:  uint8(176),
	4:  uint8(178),
	5:  uint8(173),
	6:  uint8(174),
	7:  uint8(164),
	8:  uint8(177),
	9:  uint8(174),
	10: uint8(196),
	11: uint8(182),
	12: uint8(198),
	13: uint8(192),
	14: uint8(182),
	15: uint8(68),
	16: uint8(62),
	17: uint8(66),
	18: uint8(60),
	19: uint8(72),
	20: uint8(117),
	21: uint8(85),
	22: uint8(90),
	23: uint8(118),
	24: uint8(136),
	25: uint8(151),
	26: uint8(142),
	27: uint8(160),
	28: uint8(142),
	29: uint8(155),
}

var silk_NLSF_DELTA_MIN_WB_Q15 = [17]OpusT_opus_int16{
	0:  int16(100),
	1:  int16(3),
	2:  int16(40),
	3:  int16(3),
	4:  int16(3),
	5:  int16(3),
	6:  int16(5),
	7:  int16(14),
	8:  int16(14),
	9:  int16(10),
	10: int16(11),
	11: int16(3),
	12: int16(8),
	13: int16(9),
	14: int16(7),
	15: int16(3),
	16: int16(347),
}

// C documentation
//
//	/* Tables for LBRR flags */
var silk_LBRR_flags_2_iCDF = [3]OpusT_opus_uint8{
	0: uint8(203),
	1: uint8(150),
}
var silk_LBRR_flags_3_iCDF = [7]OpusT_opus_uint8{
	0: uint8(215),
	1: uint8(195),
	2: uint8(166),
	3: uint8(125),
	4: uint8(110),
	5: uint8(82),
}

const silk_int16_MAX11 = 32767
const silk_uint8_MAX1 = 255

// C documentation
//
//	/**********************************/
//	/* Initialization of the Silk VAD */
//	/**********************************/

func Opus_silk_shell_encoder(tls *libc.TLS, psRangeEnc uintptr, pulses0 uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* pulses1 at bp+0 */ [8]int32
	var _ /* pulses2 at bp+32 */ [4]int32
	var _ /* pulses3 at bp+48 */ [2]int32
	var _ /* pulses4 at bp+56 */ [1]int32
	/* this function operates on one shell code frame of 16 pulses */
	_ = true
	/* tree representation per pulse-subframe */
	combine_pulses(tls, bp, pulses0, int32(8))
	combine_pulses(tls, bp+32, bp, int32(4))
	combine_pulses(tls, bp+48, bp+32, int32(2))
	combine_pulses(tls, bp+56, bp+48, int32(1))
	encode_split(tls, psRangeEnc, (*(*[2]int32)(unsafe.Pointer(bp + 48)))[0], (*(*[1]int32)(unsafe.Pointer(bp + 56)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table3)))
	encode_split(tls, psRangeEnc, (*(*[4]int32)(unsafe.Pointer(bp + 32)))[0], (*(*[2]int32)(unsafe.Pointer(bp + 48)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[0], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0)), (*(*[8]int32)(unsafe.Pointer(bp)))[0], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 2*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 4*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 6*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(3)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(2)], (*(*[2]int32)(unsafe.Pointer(bp + 48)))[int32(1)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table2)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(2)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 8*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 10*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(5)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, (*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)], (*(*[4]int32)(unsafe.Pointer(bp + 32)))[int32(3)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table1)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 12*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
	encode_split(tls, psRangeEnc, *(*int32)(unsafe.Pointer(pulses0 + 14*4)), (*(*[8]int32)(unsafe.Pointer(bp)))[int32(7)], uintptr(unsafe.Pointer(&Opus_silk_shell_code_table0)))
}

// C documentation
//
//	/* Shell decoder, operates on one shell code frame of 16 pulses */

func Opus_silk_sigm_Q15(tls *libc.TLS, in_Q5 int32) (r int32) {
	var ind int32
	_ = ind
	if in_Q5 < 0 {
		/* Negative input */
		in_Q5 = -in_Q5
		if in_Q5 >= libc.Int32FromInt32(6)*libc.Int32FromInt32(32) {
			return 0 /* Clip */
		} else {
			/* Linear interpolation of look up table */
			ind = in_Q5 >> int32(5)
			return sigm_LUT_neg_Q15[ind] - int32(int16(sigm_LUT_slope_Q10[ind]))*int32(int16(in_Q5&libc.Int32FromInt32(0x1F)))
		}
	} else {
		/* Positive input */
		if in_Q5 >= libc.Int32FromInt32(6)*libc.Int32FromInt32(32) {
			return int32(32767) /* clip */
		} else {
			/* Linear interpolation of look up table */
			ind = in_Q5 >> int32(5)
			return sigm_LUT_pos_Q15[ind] + int32(int16(sigm_LUT_slope_Q10[ind]))*int32(int16(in_Q5&libc.Int32FromInt32(0x1F)))
		}
	}
	return r
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func Opus_silk_stereo_LR_to_MS(tls *libc.TLS, state uintptr, x1 uintptr, x2 uintptr, ix uintptr, mid_only_flag uintptr, mid_side_rates_bps uintptr, total_rate_bps OpusT_opus_int32, prev_speech_act_Q8 int32, toMono int32, fs_kHz int32, frame_length int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var HP_mid, HP_side, LP_mid, LP_side, _saved_stack, mid, side, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var a32_nrm, b32_inv, b32_nrm, deltaw_Q24, diff, frac_3_Q16, frac_Q16, min_mid_rate_bps, pred0_Q13, pred1_Q13, result, smooth_coef_Q16, sum, w_Q24, width_Q14, v133, v134, v137, v138, v142, v143, v146 OpusT_opus_int32
	var a_headrm, b_headrm, delta0_Q13, delta1_Q13, denom_Q16, is10msFrame, lshift, n, v130, v131, v132, v135, v136, v140, v141, v145, v30, v31 int32
	var _ /* HP_ratio_Q14 at bp+12 */ OpusT_opus_int32
	var _ /* LP_ratio_Q14 at bp+8 */ OpusT_opus_int32
	var _ /* pred_Q13 at bp+0 */ [2]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = HP_mid, HP_side, LP_mid, LP_side, _saved_stack, a32_nrm, a_headrm, b32_inv, b32_nrm, b_headrm, delta0_Q13, delta1_Q13, deltaw_Q24, denom_Q16, diff, frac_3_Q16, frac_Q16, is10msFrame, lshift, mid, min_mid_rate_bps, n, pred0_Q13, pred1_Q13, result, side, smooth_coef_Q16, st, sum, w_Q24, width_Q14, v1, v11, v13, v130, v131, v132, v133, v134, v135, v136, v137, v138, v140, v141, v142, v143, v145, v146, v15, v17, v19, v21, v23, v3, v30, v31, v5, v7, v9
	mid = x1 + uintptr(-libc.Int32FromInt32(2))*2
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_length+libc.Int32FromInt32(2))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9196, int32(61))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(frame_length+libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	side = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_length+libc.Int32FromInt32(2))*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* Convert to basic mid/side signals */
	n = 0
	for {
		if !(n < frame_length+int32(2)) {
			break
		}
		sum = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n-int32(2))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n-int32(2))*2)))
		diff = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n-int32(2))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n-int32(2))*2)))
		*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n)*2)) = int16(sum>>libc.Int32FromInt32(1) + sum&libc.Int32FromInt32(1))
		if diff>>libc.Int32FromInt32(1)+diff&int32(1) > int32(silk_int16_MAX15) {
			v30 = int32(silk_int16_MAX15)
		} else {
			if diff>>libc.Int32FromInt32(1)+diff&int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v31 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v31 = diff>>libc.Int32FromInt32(1) + diff&int32(1)
			}
			v30 = v31
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n)*2)) = int16(v30)
		goto _29
	_29:
		;
		n = n + 1
	}
	/* Buffering */
	libc.Xmemcpy(tls, mid, state+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, side, state+8, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+4, mid+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+8, side+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	/* LP and HP filter mid signal */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9196, int32(77))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(frame_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _55
_55:
	LP_mid = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _59
_59:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _61
	_61:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _63
_63:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _67
_67:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _71
_71:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9196, int32(78))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _73
	_73:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _75
_75:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(frame_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _77
	_77:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _79
_79:
	HP_mid = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	n = 0
	for {
		if !(n < frame_length) {
			break
		}
		sum = ((int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1)))>>(libc.Int32FromInt32(2)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int16)(unsafe.Pointer(LP_mid + uintptr(n)*2)) = int16(sum)
		*(*OpusT_opus_int16)(unsafe.Pointer(HP_mid + uintptr(n)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2))) - sum)
		goto _80
	_80:
		;
		n = n + 1
	}
	/* LP and HP filter side signal */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _84
_84:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _88
_88:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _92
_92:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _96
_96:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9196, int32(86))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _100
_100:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(frame_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _102
	_102:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _104
_104:
	LP_side = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _106
	_106:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _108
_108:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _110
	_110:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _112
_112:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _114
	_114:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _116
_116:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _118
	_118:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _120
_120:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9196, int32(87))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _122
	_122:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _124
_124:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(frame_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _126
	_126:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _128
_128:
	HP_side = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	n = 0
	for {
		if !(n < frame_length) {
			break
		}
		sum = ((int32(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1)))>>(libc.Int32FromInt32(2)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
		*(*OpusT_opus_int16)(unsafe.Pointer(LP_side + uintptr(n)*2)) = int16(sum)
		*(*OpusT_opus_int16)(unsafe.Pointer(HP_side + uintptr(n)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n+int32(1))*2))) - sum)
		goto _129
	_129:
		;
		n = n + 1
	}
	/* Find energies and predictors */
	is10msFrame = libc.BoolInt32(frame_length == int32(10)*fs_kHz)
	if is10msFrame != 0 {
		v30 = int32(float64(libc.Float64FromFloat64(STEREO_RATIO_SMOOTH_COEF)/libc.Float64FromInt32(2)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	} else {
		v30 = int32(float64(libc.Float64FromFloat64(STEREO_RATIO_SMOOTH_COEF)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	}
	smooth_coef_Q16 = v30
	smooth_coef_Q16 = int32(int64(int32(int16(prev_speech_act_Q8))*int32(int16(prev_speech_act_Q8))) * int64(int16(smooth_coef_Q16)) >> libc.Int32FromInt32(16))
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = Opus_silk_stereo_find_predictor(tls, bp+8, LP_mid, LP_side, state+12, frame_length, smooth_coef_Q16)
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = Opus_silk_stereo_find_predictor(tls, bp+12, HP_mid, HP_side, state+12+2*4, frame_length, smooth_coef_Q16)
	/* Ratio of the norms of residual and mid signals */
	frac_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12)) + int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 8))))*int32(int16(libc.Int32FromInt32(3)))
	if frac_Q16 < int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)) {
		v30 = frac_Q16
	} else {
		v30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
	}
	frac_Q16 = v30
	/* Determine bitrate distribution between mid and side, and possibly reduce stereo width */
	if is10msFrame != 0 {
		v30 = int32(1200)
	} else {
		v30 = int32(600)
	}
	total_rate_bps = total_rate_bps - v30 /* Subtract approximate bitrate for coding stereo parameters */
	if total_rate_bps < int32(1) {
		total_rate_bps = int32(1)
	}
	min_mid_rate_bps = libc.Int32FromInt32(2000) + int32(int16(fs_kHz))*int32(int16(libc.Int32FromInt32(600)))
	_ = min_mid_rate_bps < libc.Int32FromInt32(32767)
	/* Default bitrate distribution: 8 parts for Mid and (5+3*frac) parts for Side. so: mid_rate = ( 8 / ( 13 + 3 * frac ) ) * total_ rate */
	frac_3_Q16 = libc.Int32FromInt32(3) * frac_Q16
	v133 = total_rate_bps
	v134 = int32(float64(int64(libc.Int32FromInt32(8)+libc.Int32FromInt32(5))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)) + frac_3_Q16
	v30 = libc.Int32FromInt32(16) + libc.Int32FromInt32(3)
	_ = v134 != libc.Int32FromInt32(0)
	_ = v30 >= libc.Int32FromInt32(0)
	if v133 > 0 {
		v31 = v133
	} else {
		v31 = -v133
	}
	v137 = v31
	if v137 != 0 {
		v130 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v137)))
	} else {
		v130 = int32(32)
	}
	v138 = v130
	goto _139
_139:
	a_headrm = v138 - int32(1)
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v133) << a_headrm)
	if v134 > 0 {
		v131 = v134
	} else {
		v131 = -v134
	}
	v142 = v131
	if v142 != 0 {
		v132 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v142)))
	} else {
		v132 = int32(32)
	}
	v143 = v132
	goto _144
_144:
	b_headrm = v143 - int32(1)
	b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v134) << b_headrm)
	b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
	result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
	result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
	lshift = int32(29) + a_headrm - b_headrm - v30
	if lshift < libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
			if result > libc.Int32FromUint32(0x80000000)>>-lshift {
				v136 = libc.Int32FromUint32(0x80000000) >> -lshift
			} else {
				if result < int32(silk_int32_MAX)>>-lshift {
					v140 = int32(silk_int32_MAX) >> -lshift
				} else {
					v140 = result
				}
				v136 = v140
			}
			v135 = v136
		} else {
			if result > int32(silk_int32_MAX)>>-lshift {
				v141 = int32(silk_int32_MAX) >> -lshift
			} else {
				if result < libc.Int32FromUint32(0x80000000)>>-lshift {
					v145 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					v145 = result
				}
				v141 = v145
			}
			v135 = v141
		}
		v146 = libc.Int32FromUint32(libc.Uint32FromInt32(v135) << -lshift)
		goto _147
	} else {
		if lshift < libc.Int32FromInt32(32) {
			v146 = result >> lshift
			goto _147
		} else {
			v146 = 0
			goto _147
		}
	}
_147:
	*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps)) = v146
	/* If Mid bitrate below minimum, reduce stereo width */
	if *(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps)) < min_mid_rate_bps {
		*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps)) = min_mid_rate_bps
		*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)) = total_rate_bps - *(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps))
		/* width = 4 * ( 2 * side_rate - min_rate ) / ( ( 1 + 3 * frac ) * min_rate ) */
		v133 = libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)))<<libc.Int32FromInt32(1)) - min_mid_rate_bps
		v134 = int32(int64(int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))+frac_3_Q16) * int64(int16(min_mid_rate_bps)) >> libc.Int32FromInt32(16))
		v30 = libc.Int32FromInt32(14) + libc.Int32FromInt32(2)
		_ = v134 != libc.Int32FromInt32(0)
		_ = v30 >= libc.Int32FromInt32(0)
		if v133 > 0 {
			v31 = v133
		} else {
			v31 = -v133
		}
		v137 = v31
		if v137 != 0 {
			v130 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v137)))
		} else {
			v130 = int32(32)
		}
		v138 = v130
		goto _159
	_159:
		a_headrm = v138 - int32(1)
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v133) << a_headrm)
		if v134 > 0 {
			v131 = v134
		} else {
			v131 = -v134
		}
		v142 = v131
		if v142 != 0 {
			v132 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v142)))
		} else {
			v132 = int32(32)
		}
		v143 = v132
		goto _164
	_164:
		b_headrm = v143 - int32(1)
		b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v134) << b_headrm)
		b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
		result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
		result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
		lshift = int32(29) + a_headrm - b_headrm - v30
		if lshift < libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
				if result > libc.Int32FromUint32(0x80000000)>>-lshift {
					v136 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					if result < int32(silk_int32_MAX)>>-lshift {
						v140 = int32(silk_int32_MAX) >> -lshift
					} else {
						v140 = result
					}
					v136 = v140
				}
				v135 = v136
			} else {
				if result > int32(silk_int32_MAX)>>-lshift {
					v141 = int32(silk_int32_MAX) >> -lshift
				} else {
					if result < libc.Int32FromUint32(0x80000000)>>-lshift {
						v145 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						v145 = result
					}
					v141 = v145
				}
				v135 = v141
			}
			v146 = libc.Int32FromUint32(libc.Uint32FromInt32(v135) << -lshift)
			goto _167
		} else {
			if lshift < libc.Int32FromInt32(32) {
				v146 = result >> lshift
				goto _167
			} else {
				v146 = 0
				goto _167
			}
		}
	_167:
		width_Q14 = v146
		if 0 > int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5)) {
			if width_Q14 > 0 {
				v31 = 0
			} else {
				if width_Q14 < int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5)) {
					v130 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5))
				} else {
					v130 = width_Q14
				}
				v31 = v130
			}
			v30 = v31
		} else {
			if width_Q14 > int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5)) {
				v131 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5))
			} else {
				if width_Q14 < 0 {
					v132 = 0
				} else {
					v132 = width_Q14
				}
				v131 = v132
			}
			v30 = v131
		}
		width_Q14 = v30
	} else {
		*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)) = total_rate_bps - *(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps))
		width_Q14 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5))
	}
	/* Smoother */
	(*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14 = int16(int32(int64((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) + int64(width_Q14-int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14))*int64(int16(smooth_coef_Q16))>>libc.Int32FromInt32(16)))
	/* At very low bitrates or for inputs that are nearly amplitude panned, switch to panned-mono coding */
	*(*OpusT_opus_int8)(unsafe.Pointer(mid_only_flag)) = 0
	if toMono != 0 {
		/* Last frame before stereo->mono transition; collapse stereo width */
		width_Q14 = 0
		(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = 0
		(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = 0
		Opus_silk_stereo_quant_pred(tls, bp, ix)
	} else {
		if int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fwidth_prev_Q14) == 0 && (int32(8)*total_rate_bps < int32(13)*min_mid_rate_bps || int32(int64(frac_Q16)*int64((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14)>>libc.Int32FromInt32(16)) < int32(float64(libc.Float64FromFloat64(0.05)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5))) {
			/* Code as panned-mono; previous frame already had zero width */
			/* Scale down and quantize predictors */
			(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0])) >> libc.Int32FromInt32(14)
			(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)])) >> libc.Int32FromInt32(14)
			Opus_silk_stereo_quant_pred(tls, bp, ix)
			/* Collapse stereo width */
			width_Q14 = 0
			(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = 0
			(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = 0
			*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps)) = total_rate_bps
			*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)) = 0
			*(*OpusT_opus_int8)(unsafe.Pointer(mid_only_flag)) = int8(1)
		} else {
			if int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fwidth_prev_Q14) != 0 && (int32(8)*total_rate_bps < int32(11)*min_mid_rate_bps || int32(int64(frac_Q16)*int64((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14)>>libc.Int32FromInt32(16)) < int32(float64(libc.Float64FromFloat64(0.02)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5))) {
				/* Transition to zero-width stereo */
				/* Scale down and quantize predictors */
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0])) >> libc.Int32FromInt32(14)
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)])) >> libc.Int32FromInt32(14)
				Opus_silk_stereo_quant_pred(tls, bp, ix)
				/* Collapse stereo width */
				width_Q14 = 0
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = 0
				(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = 0
			} else {
				if int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) > int32(float64(libc.Float64FromFloat64(0.95)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14)))+libc.Float64FromFloat64(0.5)) {
					/* Full-width stereo coding */
					Opus_silk_stereo_quant_pred(tls, bp, ix)
					width_Q14 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(14))) + libc.Float64FromFloat64(0.5))
				} else {
					/* Reduced-width stereo coding; scale down and quantize predictors */
					(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0])) >> libc.Int32FromInt32(14)
					(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14) * int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)])) >> libc.Int32FromInt32(14)
					Opus_silk_stereo_quant_pred(tls, bp, ix)
					width_Q14 = int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsmth_width_Q14)
				}
			}
		}
	}
	/* Make sure to keep on encoding until the tapered output has been transmitted */
	if int32(*(*OpusT_opus_int8)(unsafe.Pointer(mid_only_flag))) == int32(1) {
		v1 = state + 32
		*(*OpusT_opus_int16)(unsafe.Pointer(v1)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v1))) + (frame_length - libc.Int32FromInt32(STEREO_INTERP_LEN_MS)*fs_kHz))
		if int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsilent_side_len) < int32(LA_SHAPE_MS)*fs_kHz {
			*(*OpusT_opus_int8)(unsafe.Pointer(mid_only_flag)) = 0
		} else {
			/* Limit to avoid wrapping around */
			(*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsilent_side_len = int16(10000)
		}
	} else {
		(*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fsilent_side_len = 0
	}
	if int32(*(*OpusT_opus_int8)(unsafe.Pointer(mid_only_flag))) == 0 && *(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)) < int32(1) {
		*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4)) = int32(1)
		v30 = int32(1)
		v31 = total_rate_bps - *(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps + 1*4))
		if v30 > v31 {
			v131 = v30
		} else {
			v131 = v31
		}
		v130 = v131
		goto _182
	_182:
		*(*OpusT_opus_int32)(unsafe.Pointer(mid_side_rates_bps)) = v130
	}
	/* Interpolate predictors and subtract prediction from side channel */
	pred0_Q13 = -int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))
	pred1_Q13 = -int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))
	w_Q24 = libc.Int32FromUint32(libc.Uint32FromInt16((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fwidth_prev_Q14) << libc.Int32FromInt32(10))
	denom_Q16 = libc.Int32FromInt32(1) << libc.Int32FromInt32(16) / (libc.Int32FromInt32(STEREO_INTERP_LEN_MS) * fs_kHz)
	delta0_Q13 = -((int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0]-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1))
	delta1_Q13 = -((int32(int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)]-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1))
	deltaw_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(width_Q14-int32((*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fwidth_prev_Q14))*int64(int16(denom_Q16))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(10))
	n = 0
	for {
		if !(n < int32(STEREO_INTERP_LEN_MS)*fs_kHz) {
			break
		}
		pred0_Q13 = pred0_Q13 + delta0_Q13
		pred1_Q13 = pred1_Q13 + delta1_Q13
		w_Q24 = w_Q24 + deltaw_Q24
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(int32(int64(w_Q24)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n+int32(1))*2)))>>libc.Int32FromInt32(16))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                                                   /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                            /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX15) {
			v30 = int32(silk_int16_MAX15)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v31 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v31 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v30 = v31
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n-int32(1))*2)) = int16(v30)
		goto _184
	_184:
		;
		n = n + 1
	}
	pred0_Q13 = -(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0]
	pred1_Q13 = -(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)]
	w_Q24 = libc.Int32FromUint32(libc.Uint32FromInt32(width_Q14) << libc.Int32FromInt32(10))
	n = int32(STEREO_INTERP_LEN_MS) * fs_kHz
	for {
		if !(n < frame_length) {
			break
		}
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(int32(int64(w_Q24)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(side + uintptr(n+int32(1))*2)))>>libc.Int32FromInt32(16))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                                                   /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(mid + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                            /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX15) {
			v30 = int32(silk_int16_MAX15)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v31 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v31 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v30 = v31
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n-int32(1))*2)) = int16(v30)
		goto _187
	_187:
		;
		n = n + 1
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(state)) = int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[0])
	*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)) = int16((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)])
	(*OpusT_stereo_enc_state)(unsafe.Pointer(state)).Fwidth_prev_Q14 = int16(width_Q14)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _191
	_191:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _193
_193:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

// C documentation
//
//	/* Convert adaptive Mid/Side representation to Left/Right stereo signal */

func Opus_silk_stereo_MS_to_LR(tls *libc.TLS, state uintptr, x1 uintptr, x2 uintptr, pred_Q13 uintptr, fs_kHz int32, frame_length int32) {
	var delta0_Q13, delta1_Q13, denom_Q16, n, v2, v3 int32
	var diff, pred0_Q13, pred1_Q13, sum OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _ = delta0_Q13, delta1_Q13, denom_Q16, diff, n, pred0_Q13, pred1_Q13, sum, v2, v3
	/* Buffering */
	libc.Xmemcpy(tls, x1, state+4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, x2, state+8, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+4, x1+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	libc.Xmemcpy(tls, state+8, x2+uintptr(frame_length)*2, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(2))
	/* Interpolate predictors and add prediction to side channel */
	pred0_Q13 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))
	pred1_Q13 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))
	denom_Q16 = libc.Int32FromInt32(1) << libc.Int32FromInt32(16) / (libc.Int32FromInt32(STEREO_INTERP_LEN_MS) * fs_kHz)
	delta0_Q13 = (int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	delta1_Q13 = (int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)))))*int32(int16(denom_Q16))>>(libc.Int32FromInt32(16)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	n = 0
	for {
		if !(n < int32(STEREO_INTERP_LEN_MS)*fs_kHz) {
			break
		}
		pred0_Q13 = pred0_Q13 + delta0_Q13
		pred1_Q13 = pred1_Q13 + delta1_Q13
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(8))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                           /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                          /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX15) {
			v2 = int32(silk_int16_MAX15)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _1
	_1:
		;
		n = n + 1
	}
	pred0_Q13 = *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13))
	pred1_Q13 = *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))
	n = int32(STEREO_INTERP_LEN_MS) * fs_kHz
	for {
		if !(n < frame_length) {
			break
		}
		sum = libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n)*2)))+int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(2))*2)))+libc.Int32FromUint32(libc.Uint32FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)))<<libc.Int32FromInt32(1))) << libc.Int32FromInt32(9)) /* Q11 */
		sum = int32(int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(8))) + int64(sum)*int64(int16(pred0_Q13))>>libc.Int32FromInt32(16))                                                                                                                           /* Q8  */
		sum = int32(int64(sum) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))))<<libc.Int32FromInt32(11)))*int64(int16(pred1_Q13))>>libc.Int32FromInt32(16))                                                                                                                          /* Q8  */
		if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX15) {
			v2 = int32(silk_int16_MAX15)
		} else {
			if (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = (sum>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _4
	_4:
		;
		n = n + 1
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(state)) = int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13)))
	*(*OpusT_opus_int16)(unsafe.Pointer(state + 1*2)) = int16(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4)))
	/* Convert to left/right signals */
	n = 0
	for {
		if !(n < frame_length) {
			break
		}
		sum = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)))
		diff = int32(*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)))
		if sum > int32(silk_int16_MAX15) {
			v2 = int32(silk_int16_MAX15)
		} else {
			if sum < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = sum
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x1 + uintptr(n+int32(1))*2)) = int16(v2)
		if diff > int32(silk_int16_MAX15) {
			v2 = int32(silk_int16_MAX15)
		} else {
			if diff < int32(libc.Int16FromInt32(0x8000)) {
				v3 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v3 = diff
			}
			v2 = v3
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(x2 + uintptr(n+int32(1))*2)) = int16(v2)
		goto _7
	_7:
		;
		n = n + 1
	}
}

const silk_int16_MAX16 = 0x7FFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

// C documentation
//
//	/* Check encoder control struct */

func Opus_silk_stereo_decode_mid_only(tls *libc.TLS, psRangeDec uintptr, decode_only_mid uintptr) {
	/* Decode flag that only mid channel is coded */
	*(*int32)(unsafe.Pointer(decode_only_mid)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_stereo_only_code_mid_iCDF)), uint32(8))
}

// C documentation
//
//	/* Entropy code the mid/side quantization indices */

func Opus_silk_stereo_decode_pred(tls *libc.TLS, psRangeDec uintptr, pred_Q13 uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var low_Q13, step_Q13 OpusT_opus_int32
	var n int32
	var _ /* ix at bp+0 */ [2][3]int32
	_, _, _ = low_Q13, n, step_Q13
	/* Entropy decoding */
	n = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_stereo_pred_joint_iCDF)), uint32(8))
	*(*int32)(unsafe.Pointer(bp + 2*4)) = n / libc.Int32FromInt32(5)
	*(*int32)(unsafe.Pointer(bp + 1*12 + 2*4)) = n - int32(5)**(*int32)(unsafe.Pointer(bp + 2*4))
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform3_iCDF)), uint32(8))
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 1*4)) = Opus_ec_dec_icdf(tls, psRangeDec, uintptr(unsafe.Pointer(&Opus_silk_uniform5_iCDF)), uint32(8))
		goto _1
	_1:
		;
		n = n + 1
	}
	/* Dequantize */
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		*(*int32)(unsafe.Pointer(bp + uintptr(n)*12)) += int32(3) * *(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 2*4))
		low_Q13 = int32(Opus_silk_stereo_pred_quant_Q13[*(*int32)(unsafe.Pointer(bp + uintptr(n)*12))])
		step_Q13 = int32(int64(int32(Opus_silk_stereo_pred_quant_Q13[*(*int32)(unsafe.Pointer(bp + uintptr(n)*12))+int32(1)])-low_Q13) * int64(int16(int32(float64(libc.Float64FromFloat64(0.5)/libc.Float64FromInt32(STEREO_QUANT_SUB_STEPS)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))) >> libc.Int32FromInt32(16))
		*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4)) = low_Q13 + int32(int16(step_Q13))*int32(int16(libc.Int32FromInt32(2)**(*int32)(unsafe.Pointer(bp + uintptr(n)*12 + 1*4))+libc.Int32FromInt32(1)))
		goto _2
	_2:
		;
		n = n + 1
	}
	/* Subtract second from first predictor (helps when actually applying these) */
	*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13)) -= *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))
}

// C documentation
//
//	/* Decode mid-only flag */

func Opus_silk_stereo_encode_mid_only(tls *libc.TLS, psRangeEnc uintptr, mid_only_flag OpusT_opus_int8) {
	/* Encode flag that only mid channel is coded */
	Opus_ec_enc_icdf(tls, psRangeEnc, int32(mid_only_flag), uintptr(unsafe.Pointer(&Opus_silk_stereo_only_code_mid_iCDF)), uint32(8))
}

// C documentation
//
//	/* Find least-squares prediction gain for one signal based on another and quantize it */

func Opus_silk_stereo_encode_pred(tls *libc.TLS, psRangeEnc uintptr, ix uintptr) {
	var n int32
	_ = n
	/* Entropy coding */
	n = int32(5)*int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + 2))) + int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + 1*3 + 2)))
	if !(n < libc.Int32FromInt32(25)) {
		Opus_celt_fatal(tls, __ccgo_ts+10652, __ccgo_ts+10677, int32(44))
	}
	Opus_ec_enc_icdf(tls, psRangeEnc, n, uintptr(unsafe.Pointer(&Opus_silk_stereo_pred_joint_iCDF)), uint32(8))
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		if !(int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3))) < libc.Int32FromInt32(3)) {
			Opus_celt_fatal(tls, __ccgo_ts+10706, __ccgo_ts+10677, int32(47))
		}
		if !(int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3 + 1))) < libc.Int32FromInt32(STEREO_QUANT_SUB_STEPS)) {
			Opus_celt_fatal(tls, __ccgo_ts+10741, __ccgo_ts+10677, int32(48))
		}
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3))), uintptr(unsafe.Pointer(&Opus_silk_uniform3_iCDF)), uint32(8))
		Opus_ec_enc_icdf(tls, psRangeEnc, int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3 + 1))), uintptr(unsafe.Pointer(&Opus_silk_uniform5_iCDF)), uint32(8))
		goto _1
	_1:
		;
		n = n + 1
	}
}

// C documentation
//
//	/* Entropy code the mid-only flag */

func Opus_silk_stereo_find_predictor(tls *libc.TLS, ratio_Q14 uintptr, x2 uintptr, y1 uintptr, mid_res_amp_Q0 uintptr, length int32, smooth_coef_Q16 int32) (r1 OpusT_opus_int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var a32_nrm, b32_inv, b32_nrm, corr, lzeros, pred2_Q10, pred_Q13, result, y, v11, v12, v15, v16, v20, v21, v24 OpusT_opus_int32
	var a_headrm, b_headrm, lshift, scale, v1, v10, v13, v14, v18, v2, v3, v5, v6, v7, v8 int32
	var m, r, x OpusT_opus_uint32
	var _ /* frac_Q7 at bp+4 */ OpusT_opus_int32
	var _ /* lz at bp+0 */ OpusT_opus_int32
	var _ /* nrgx at bp+16 */ OpusT_opus_int32
	var _ /* nrgy at bp+20 */ OpusT_opus_int32
	var _ /* scale1 at bp+8 */ int32
	var _ /* scale2 at bp+12 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a32_nrm, a_headrm, b32_inv, b32_nrm, b_headrm, corr, lshift, lzeros, m, pred2_Q10, pred_Q13, r, result, scale, x, y, v1, v10, v11, v12, v13, v14, v15, v16, v18, v2, v20, v21, v24, v3, v5, v6, v7, v8
	/* Find  predictor */
	Opus_silk_sum_sqr_shift(tls, bp+16, bp+8, x2, length)
	Opus_silk_sum_sqr_shift(tls, bp+20, bp+12, y1, length)
	v1 = *(*int32)(unsafe.Pointer(bp + 8))
	v2 = *(*int32)(unsafe.Pointer(bp + 12))
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _4
_4:
	scale = v3
	scale = scale + scale&int32(1) /* make even */
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) >> (scale - *(*int32)(unsafe.Pointer(bp + 12)))
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 16)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 16)) >> (scale - *(*int32)(unsafe.Pointer(bp + 8)))
	v1 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 16))
	v2 = int32(1)
	if v1 > v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _9
_9:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 16)) = v3
	corr = Opus_silk_inner_prod_aligned_scale(tls, x2, y1, scale, length)
	v11 = corr
	v12 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 16))
	v1 = int32(13)
	_ = v12 != libc.Int32FromInt32(0)
	_ = v1 >= libc.Int32FromInt32(0)
	if v11 > 0 {
		v2 = v11
	} else {
		v2 = -v11
	}
	v15 = v2
	if v15 != 0 {
		v3 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v15)))
	} else {
		v3 = int32(32)
	}
	v16 = v3
	goto _17
_17:
	a_headrm = v16 - int32(1)
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v11) << a_headrm)
	if v12 > 0 {
		v5 = v12
	} else {
		v5 = -v12
	}
	v20 = v5
	if v20 != 0 {
		v6 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v20)))
	} else {
		v6 = int32(32)
	}
	v21 = v6
	goto _22
_22:
	b_headrm = v21 - int32(1)
	b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v12) << b_headrm)
	b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
	result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
	result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
	lshift = int32(29) + a_headrm - b_headrm - v1
	if lshift < libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
			if result > libc.Int32FromUint32(0x80000000)>>-lshift {
				v8 = libc.Int32FromUint32(0x80000000) >> -lshift
			} else {
				if result < int32(silk_int32_MAX)>>-lshift {
					v10 = int32(silk_int32_MAX) >> -lshift
				} else {
					v10 = result
				}
				v8 = v10
			}
			v7 = v8
		} else {
			if result > int32(silk_int32_MAX)>>-lshift {
				v13 = int32(silk_int32_MAX) >> -lshift
			} else {
				if result < libc.Int32FromUint32(0x80000000)>>-lshift {
					v14 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					v14 = result
				}
				v13 = v14
			}
			v7 = v13
		}
		v24 = libc.Int32FromUint32(libc.Uint32FromInt32(v7) << -lshift)
		goto _25
	} else {
		if lshift < libc.Int32FromInt32(32) {
			v24 = result >> lshift
			goto _25
		} else {
			v24 = 0
			goto _25
		}
	}
_25:
	pred_Q13 = v24
	if pred_Q13 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) {
		v1 = libc.Int32FromInt32(1) << libc.Int32FromInt32(14)
	} else {
		if pred_Q13 < -(libc.Int32FromInt32(1) << libc.Int32FromInt32(14)) {
			v2 = -(libc.Int32FromInt32(1) << libc.Int32FromInt32(14))
		} else {
			v2 = pred_Q13
		}
		v1 = v2
	}
	pred_Q13 = v1
	pred2_Q10 = int32(int64(pred_Q13) * int64(int16(pred_Q13)) >> libc.Int32FromInt32(16))
	/* Faster update for signals with large prediction parameters */
	if pred2_Q10 > 0 {
		v1 = pred2_Q10
	} else {
		v1 = -pred2_Q10
	}
	v2 = smooth_coef_Q16
	v3 = v1
	if v2 > v3 {
		v6 = v2
	} else {
		v6 = v3
	}
	v5 = v6
	goto _37
_37:
	smooth_coef_Q16 = v5
	/* Smoothed mid and residual norms */
	_ = smooth_coef_Q16 < libc.Int32FromInt32(32768)
	scale = scale >> int32(1)
	v11 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 16))
	if v11 <= libc.Int32FromInt32(0) {
		v12 = 0
		goto _41
	}
	v15 = v11
	v16 = v15
	if v16 != 0 {
		v1 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v16)))
	} else {
		v1 = int32(32)
	}
	v20 = v1
	goto _45
_45:
	lzeros = v20
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v21 = v15
	v2 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v21)
	r = libc.Uint32FromInt32(v2)
	m = libc.Uint32FromInt32(-v2)
	if v2 == libc.Int32FromInt32(0) {
		v24 = v21
		goto _50
	} else {
		if v2 < libc.Int32FromInt32(0) {
			v24 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _50
		} else {
			v24 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _50
		}
	}
_50:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v24 & int32(0x7f)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
		y = int32(32768)
	} else {
		y = int32(46214)
	}
	y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
	y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
	v12 = y
	goto _41
_41:
	*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0))) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(v12)<<scale)-*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0)))*int64(int16(smooth_coef_Q16))>>libc.Int32FromInt32(16))
	/* Residual energy = nrgy - 2 * pred * corr + pred^2 * nrgx */
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) - libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(corr)*int64(int16(pred_Q13))>>libc.Int32FromInt32(16)))<<(libc.Int32FromInt32(3)+libc.Int32FromInt32(1)))
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 20)) + libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 16)))*int64(int16(pred2_Q10))>>libc.Int32FromInt32(16)))<<libc.Int32FromInt32(6))
	v11 = *(*OpusT_opus_int32)(unsafe.Pointer(bp + 20))
	if v11 <= libc.Int32FromInt32(0) {
		v12 = 0
		goto _53
	}
	v15 = v11
	v16 = v15
	if v16 != 0 {
		v1 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v16)))
	} else {
		v1 = int32(32)
	}
	v20 = v1
	goto _57
_57:
	lzeros = v20
	*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = lzeros
	v21 = v15
	v2 = int32(24) - lzeros
	x = libc.Uint32FromInt32(v21)
	r = libc.Uint32FromInt32(v2)
	m = libc.Uint32FromInt32(-v2)
	if v2 == libc.Int32FromInt32(0) {
		v24 = v21
		goto _62
	} else {
		if v2 < libc.Int32FromInt32(0) {
			v24 = libc.Int32FromUint32(x<<m | x>>(libc.Uint32FromInt32(32)-m))
			goto _62
		} else {
			v24 = libc.Int32FromUint32(x<<(libc.Uint32FromInt32(32)-r) | x>>r)
			goto _62
		}
	}
_62:
	*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = v24 & int32(0x7f)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp))&libc.Int32FromInt32(1) != 0 {
		y = int32(32768)
	} else {
		y = int32(46214)
	}
	y = y >> (*(*OpusT_opus_int32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(1))
	y = int32(int64(y) + int64(y)*int64(int16(int32(int16(libc.Int32FromInt32(213)))*int32(int16(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))))))>>libc.Int32FromInt32(16))
	v12 = y
	goto _53
_53:
	*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0 + 1*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0 + 1*4))) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(v12)<<scale)-*(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0 + 1*4)))*int64(int16(smooth_coef_Q16))>>libc.Int32FromInt32(16))
	/* Ratio of smoothed residual and mid norms */
	if *(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0)) > int32(1) {
		v1 = *(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0))
	} else {
		v1 = int32(1)
	}
	v11 = *(*OpusT_opus_int32)(unsafe.Pointer(mid_res_amp_Q0 + 1*4))
	v12 = v1
	v2 = int32(14)
	_ = v12 != libc.Int32FromInt32(0)
	_ = v2 >= libc.Int32FromInt32(0)
	if v11 > 0 {
		v3 = v11
	} else {
		v3 = -v11
	}
	v15 = v3
	if v15 != 0 {
		v5 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v15)))
	} else {
		v5 = int32(32)
	}
	v16 = v5
	goto _70
_70:
	a_headrm = v16 - int32(1)
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v11) << a_headrm)
	if v12 > 0 {
		v6 = v12
	} else {
		v6 = -v12
	}
	v20 = v6
	if v20 != 0 {
		v7 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v20)))
	} else {
		v7 = int32(32)
	}
	v21 = v7
	goto _75
_75:
	b_headrm = v21 - int32(1)
	b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v12) << b_headrm)
	b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
	result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
	a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
	result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
	lshift = int32(29) + a_headrm - b_headrm - v2
	if lshift < libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
			if result > libc.Int32FromUint32(0x80000000)>>-lshift {
				v10 = libc.Int32FromUint32(0x80000000) >> -lshift
			} else {
				if result < int32(silk_int32_MAX)>>-lshift {
					v13 = int32(silk_int32_MAX) >> -lshift
				} else {
					v13 = result
				}
				v10 = v13
			}
			v8 = v10
		} else {
			if result > int32(silk_int32_MAX)>>-lshift {
				v14 = int32(silk_int32_MAX) >> -lshift
			} else {
				if result < libc.Int32FromUint32(0x80000000)>>-lshift {
					v18 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					v18 = result
				}
				v14 = v18
			}
			v8 = v14
		}
		v24 = libc.Int32FromUint32(libc.Uint32FromInt32(v8) << -lshift)
		goto _78
	} else {
		if lshift < libc.Int32FromInt32(32) {
			v24 = result >> lshift
			goto _78
		} else {
			v24 = 0
			goto _78
		}
	}
_78:
	*(*OpusT_opus_int32)(unsafe.Pointer(ratio_Q14)) = v24
	if *(*OpusT_opus_int32)(unsafe.Pointer(ratio_Q14)) > int32(32767) {
		v1 = int32(32767)
	} else {
		if *(*OpusT_opus_int32)(unsafe.Pointer(ratio_Q14)) < 0 {
			v2 = 0
		} else {
			v2 = *(*OpusT_opus_int32)(unsafe.Pointer(ratio_Q14))
		}
		v1 = v2
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(ratio_Q14)) = v1
	return pred_Q13
}

// C documentation
//
//	/* Quantize mid/side predictors */

func Opus_silk_stereo_quant_pred(tls *libc.TLS, pred_Q13 uintptr, ix uintptr) {
	var err_Q13, err_min_Q13, low_Q13, lvl_Q13, quant_pred_Q13, step_Q13 OpusT_opus_int32
	var i, j, n, v4 int32
	var v5 uintptr
	_, _, _, _, _, _, _, _, _, _, _ = err_Q13, err_min_Q13, i, j, low_Q13, lvl_Q13, n, quant_pred_Q13, step_Q13, v4, v5
	quant_pred_Q13 = 0
	/* Quantize */
	n = 0
	for {
		if !(n < int32(2)) {
			break
		}
		/* Brute-force search over quantization levels */
		err_min_Q13 = int32(silk_int32_MAX)
		i = 0
		for {
			if !(i < libc.Int32FromInt32(STEREO_QUANT_TAB_SIZE)-libc.Int32FromInt32(1)) {
				break
			}
			low_Q13 = int32(Opus_silk_stereo_pred_quant_Q13[i])
			step_Q13 = int32(int64(int32(Opus_silk_stereo_pred_quant_Q13[i+int32(1)])-low_Q13) * int64(int16(int32(float64(libc.Float64FromFloat64(0.5)/libc.Float64FromInt32(STEREO_QUANT_SUB_STEPS)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))) >> libc.Int32FromInt32(16))
			j = 0
			for {
				if !(j < int32(STEREO_QUANT_SUB_STEPS)) {
					break
				}
				lvl_Q13 = low_Q13 + int32(int16(step_Q13))*int32(int16(libc.Int32FromInt32(2)*j+libc.Int32FromInt32(1)))
				if *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4))-lvl_Q13 > 0 {
					v4 = *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4)) - lvl_Q13
				} else {
					v4 = -(*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4)) - lvl_Q13)
				}
				err_Q13 = v4
				if err_Q13 < err_min_Q13 {
					err_min_Q13 = err_Q13
					quant_pred_Q13 = lvl_Q13
					*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3)) = int8(i)
					*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3 + 1)) = int8(j)
				} else {
					/* Error increasing, so we're past the optimum */
					goto done
				}
				goto _3
			_3:
				;
				j = j + 1
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		goto done
	done:
		;
		*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3 + 2)) = int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3))) / libc.Int32FromInt32(3))
		v5 = ix + uintptr(n)*3
		*(*OpusT_opus_int8)(unsafe.Pointer(v5)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v5))) - int32(*(*OpusT_opus_int8)(unsafe.Pointer(ix + uintptr(n)*3 + 2)))*libc.Int32FromInt32(3))
		*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + uintptr(n)*4)) = quant_pred_Q13
		goto _1
	_1:
		;
		n = n + 1
	}
	/* Subtract second from first predictor (helps when actually applying these) */
	*(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13)) -= *(*OpusT_opus_int32)(unsafe.Pointer(pred_Q13 + 1*4))
}

const silk_int16_MAX27 = 32767

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

// C documentation
//
//	/* Convert int32 coefficients to int16 coefs and make sure there's no wrap-around.
//	   This logic is reused in _celt_lpc(). Any bug fixes should also be applied there. */

func Opus_silk_sum_sqr_shift(tls *libc.TLS, energy uintptr, shift uintptr, x uintptr, len1 int32) {
	var i, shft, v4, v9 int32
	var nrg, v1, v10, v2, v6, v7 OpusT_opus_int32
	var nrg_tmp OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _ = i, nrg, nrg_tmp, shft, v1, v10, v2, v4, v6, v7, v9
	/* Do a first run with the maximum shift we could have. */
	v1 = len1
	if v1 != 0 {
		v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
	} else {
		v4 = int32(32)
	}
	v2 = v4
	goto _3
_3:
	shft = int32(31) - v2
	/* Let's be conservative with rounding and start with nrg=len. */
	nrg = len1
	i = 0
	for {
		if !(i < len1-int32(1)) {
			break
		}
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg_tmp = libc.Uint32FromInt32(libc.Int32FromUint32(nrg_tmp + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2))))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
		goto _5
	_5:
		;
		i = i + int32(2)
	}
	if i < len1 {
		/* One sample left to process */
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
	}
	_ = nrg >= libc.Int32FromInt32(0)
	/* Make sure the result will fit in a 32-bit signed integer with two bits
	   of headroom. */
	v1 = nrg
	if v1 != 0 {
		v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v1)))
	} else {
		v4 = int32(32)
	}
	v2 = v4
	goto _8
_8:
	v6 = 0
	v7 = shft + int32(3) - v2
	if v6 > v7 {
		v9 = v6
	} else {
		v9 = v7
	}
	v10 = v9
	goto _13
_13:
	shft = v10
	nrg = 0
	i = 0
	for {
		if !(i < len1-int32(1)) {
			break
		}
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg_tmp = libc.Uint32FromInt32(libc.Int32FromUint32(nrg_tmp + libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i+int32(1))*2))))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
		goto _15
	_15:
		;
		i = i + int32(2)
	}
	if i < len1 {
		/* One sample left to process */
		nrg_tmp = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr(i)*2))))
		nrg = libc.Int32FromUint32(libc.Uint32FromInt32(nrg) + nrg_tmp>>shft)
	}
	_ = nrg >= libc.Int32FromInt32(0)
	/* Output arguments */
	*(*int32)(unsafe.Pointer(shift)) = shft
	*(*OpusT_opus_int32)(unsafe.Pointer(energy)) = nrg
}

// C documentation
//
//	/* Decode mid/side predictors */

func Opus_silk_warped_autocorrelation_FLP(tls *libc.TLS, corr uintptr, input uintptr, warping float32, length int32, order int32) {
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var i, n int32
	var state [25]float64
	var tmp1, tmp2 float64
	var _ /* C at bp+0 */ [25]float64
	_, _, _, _, _ = i, n, state, tmp1, tmp2
	state = [25]float64{}
	*(*[25]float64)(unsafe.Pointer(bp)) = [25]float64{}
	/* Order must be even */
	if !(order&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+11625, __ccgo_ts+11662, int32(49))
	}
	/* Loop over samples */
	n = 0
	for {
		if !(n < length) {
			break
		}
		tmp1 = float64(*(*float32)(unsafe.Pointer(input + uintptr(n)*4)))
		/* Loop over allpass sections */
		i = 0
		for {
			if !(i < order) {
				break
			}
			/* Output of allpass section */
			/* We voluntarily use two multiples instead of factoring the expression to
			   reduce the length of the dependency chain (tmp1->tmp2->tmp1... ). */
			tmp2 = state[i] + float64(float64(warping)*state[i+int32(1)]) - float64(float64(warping)*tmp1)
			state[i] = tmp1
			*(*float64)(unsafe.Pointer(bp + uintptr(i)*8)) += float64(state[0] * tmp1)
			/* Output of allpass section */
			tmp1 = state[i+int32(1)] + float64(float64(warping)*state[i+int32(2)]) - float64(float64(warping)*tmp2)
			state[i+int32(1)] = tmp2
			*(*float64)(unsafe.Pointer(bp + uintptr(i+int32(1))*8)) += float64(state[0] * tmp2)
			goto _2
		_2:
			;
			i = i + int32(2)
		}
		state[order] = tmp1
		*(*float64)(unsafe.Pointer(bp + uintptr(order)*8)) += float64(state[0] * tmp1)
		goto _1
	_1:
		;
		n = n + 1
	}
	/* Copy correlations in silk_float output format */
	i = 0
	for {
		if !(i < order+int32(1)) {
			break
		}
		*(*float32)(unsafe.Pointer(corr + uintptr(i)*4)) = float32((*(*[25]float64)(unsafe.Pointer(bp)))[i])
		goto _3
	_3:
		;
		i = i + 1
	}
}

/* Wrappers. Calls flp / fix code */

// C documentation
//
//	/* Convert AR filter coefficients to NLSF parameters */

func compute_silk_rate_for_hybrid(tls *libc.TLS, rate int32, bandwidth int32, frame20ms int32, vbr int32, fec int32, channels int32) (r int32) {
	var N, entry, i, silk_rate int32
	var hi, lo, x0, x1 OpusT_opus_int32
	_, _, _, _, _, _, _, _ = N, entry, hi, i, lo, silk_rate, x0, x1
	/* Do the allocation per-channel. */
	rate = rate / channels
	entry = int32(1) + frame20ms + int32(2)*fec
	N = libc.Int32FromUint64(libc.Uint64FromInt64(140) / libc.Uint64FromInt64(20))
	i = int32(1)
	for {
		if !(i < N) {
			break
		}
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i)*20)) > rate {
			break
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if i == N {
		silk_rate = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i-int32(1))*20 + uintptr(entry)*4))
		/* For now, just give 50% of the extra bits to SILK. */
		silk_rate = silk_rate + (rate-*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i-int32(1))*20)))/int32(2)
	} else {
		lo = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i-int32(1))*20 + uintptr(entry)*4))
		hi = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i)*20 + uintptr(entry)*4))
		x0 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i-int32(1))*20))
		x1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rate_table)) + uintptr(i)*20))
		silk_rate = (lo*(x1-rate) + hi*(rate-x0)) / (x1 - x0)
	}
	if !(vbr != 0) {
		/* Tiny boost to SILK for CBR. We should probably tune this better. */
		silk_rate = silk_rate + int32(100)
	}
	if bandwidth == int32(OPUS_BANDWIDTH_SUPERWIDEBAND) {
		silk_rate = silk_rate + int32(300)
	}
	silk_rate = silk_rate * channels
	/* Small adjustment for stereo (calibrated for 32 kb/s, haven't tried other bitrates). */
	if channels == int32(2) && rate >= int32(12000) {
		silk_rate = silk_rate - int32(1000)
	}
	return silk_rate
}

var rate_table = [7][5]int32{
	0: {},
	1: {
		0: int32(12000),
		1: int32(10000),
		2: int32(10000),
		3: int32(11000),
		4: int32(11000),
	},
	2: {
		0: int32(16000),
		1: int32(13500),
		2: int32(13500),
		3: int32(15000),
		4: int32(15000),
	},
	3: {
		0: int32(20000),
		1: int32(16000),
		2: int32(16000),
		3: int32(18000),
		4: int32(18000),
	},
	4: {
		0: int32(24000),
		1: int32(18000),
		2: int32(18000),
		3: int32(21000),
		4: int32(21000),
	},
	5: {
		0: int32(32000),
		1: int32(22000),
		2: int32(22000),
		3: int32(28000),
		4: int32(28000),
	},
	6: {
		0: int32(64000),
		1: int32(38000),
		2: int32(38000),
		3: int32(50000),
		4: int32(50000),
	},
}

// C documentation
//
//	/* Returns the equivalent bitrate corresponding to 20 ms frames,
//	   complexity 10 VBR operation. */

func silk_A2NLSF_eval_poly(tls *libc.TLS, p uintptr, x OpusT_opus_int32, dd int32) (r OpusT_opus_int32) {
	var n int32
	var x_Q16, y32 OpusT_opus_int32
	_, _, _ = n, x_Q16, y32
	y32 = *(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(dd)*4)) /* Q16 */
	x_Q16 = libc.Int32FromUint32(libc.Uint32FromInt32(x) << libc.Int32FromInt32(4))
	if libc.BoolInt64(!!(libc.Int32FromInt32(8) == dd)) != 0 {
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 7*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 6*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 5*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 4*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 3*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 2*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + 1*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
		y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16))
	} else {
		n = dd - int32(1)
		for {
			if !(n >= 0) {
				break
			}
			y32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(n)*4))) + int64(y32)*int64(x_Q16)>>libc.Int32FromInt32(16)) /* Q16 */
			goto _1
		_1:
			;
			n = n - 1
		}
	}
	return y32
}

func silk_A2NLSF_init(tls *libc.TLS, a_Q16 uintptr, P uintptr, Q uintptr, dd int32) {
	var k int32
	_ = k
	/* Convert filter coefs to even and odd polynomials */
	*(*OpusT_opus_int32)(unsafe.Pointer(P + uintptr(dd)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << libc.Int32FromInt32(16))
	*(*OpusT_opus_int32)(unsafe.Pointer(Q + uintptr(dd)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << libc.Int32FromInt32(16))
	k = 0
	for {
		if !(k < dd) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(P + uintptr(k)*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(a_Q16 + uintptr(dd-k-int32(1))*4)) - *(*OpusT_opus_int32)(unsafe.Pointer(a_Q16 + uintptr(dd+k)*4)) /* Q16 */
		*(*OpusT_opus_int32)(unsafe.Pointer(Q + uintptr(k)*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(a_Q16 + uintptr(dd-k-int32(1))*4)) + *(*OpusT_opus_int32)(unsafe.Pointer(a_Q16 + uintptr(dd+k)*4)) /* Q16 */
		goto _1
	_1:
		;
		k = k + 1
	}
	/* Divide out zeros as we have that for even filter orders, */
	/* z =  1 is always a root in Q, and                        */
	/* z = -1 is always a root in P                             */
	k = dd
	for {
		if !(k > 0) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(P + uintptr(k-int32(1))*4)) -= *(*OpusT_opus_int32)(unsafe.Pointer(P + uintptr(k)*4))
		*(*OpusT_opus_int32)(unsafe.Pointer(Q + uintptr(k-int32(1))*4)) += *(*OpusT_opus_int32)(unsafe.Pointer(Q + uintptr(k)*4))
		goto _2
	_2:
		;
		k = k - 1
	}
	/* Transform polynomials from cos(n*f) to cos(f)^n */
	silk_A2NLSF_trans_poly(tls, P, dd)
	silk_A2NLSF_trans_poly(tls, Q, dd)
}

// C documentation
//
//	/* Compute Normalized Line Spectral Frequencies (NLSFs) from whitening filter coefficients      */
//	/* If not all roots are found, the a_Q16 coefficients are bandwidth expanded until convergence. */

func silk_A2NLSF_trans_poly(tls *libc.TLS, p uintptr, dd int32) {
	var k, n int32
	_, _ = k, n
	k = int32(2)
	for {
		if !(k <= dd) {
			break
		}
		n = dd
		for {
			if !(n > k) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(n-int32(2))*4)) -= *(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(n)*4))
			goto _2
		_2:
			;
			n = n - 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(k-int32(2))*4)) -= libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(p + uintptr(k)*4))) << libc.Int32FromInt32(1))
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* Helper function for A2NLSF(..) */
//	/* Polynomial evaluation          */

func silk_CNG_exc(tls *libc.TLS, exc_Q14 uintptr, exc_buf_Q14 uintptr, length int32, rand_seed uintptr) {
	var exc_mask, i, idx int32
	var seed OpusT_opus_int32
	_, _, _, _ = exc_mask, i, idx, seed
	exc_mask = int32(CNG_BUF_MASK_MAX)
	for exc_mask > length {
		exc_mask = exc_mask >> int32(1)
	}
	seed = *(*OpusT_opus_int32)(unsafe.Pointer(rand_seed))
	i = 0
	for {
		if !(i < length) {
			break
		}
		seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
		idx = seed >> libc.Int32FromInt32(24) & exc_mask
		_ = idx >= libc.Int32FromInt32(0)
		_ = idx <= libc.Int32FromInt32(CNG_BUF_MASK_MAX)
		*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(exc_buf_Q14 + uintptr(idx)*4))
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(rand_seed)) = seed
}

func silk_LBRR_encode_FLP(tls *libc.TLS, psEnc uintptr, psEncCtrl uintptr, xfw uintptr, condCoding int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _saved_stack, psIndices_LBRR, sNSQ_LBRR, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var k, v30, v31, v32, v34 int32
	var _ /* Gains_Q16 at bp+0 */ [4]OpusT_opus_int32
	var _ /* TempGains at bp+16 */ [4]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, k, psIndices_LBRR, sNSQ_LBRR, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v30, v31, v32, v34, v5, v7, v9
	psIndices_LBRR = psEnc + 6216 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded)*36
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/*******************************************/
	/* Control use of inband LBRR              */
	/*******************************************/
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FLBRR_enabled != 0 && (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fspeech_activity_Q8 > int32(float64(libc.Float32FromFloat32(0.3)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(8)))+libc.Float64FromFloat64(0.5)) {
		/* Using ALLOC() instead of a regular stack allocation to minimize real stack use when using the pseudostack.
		   This is useful on some embedded systems. */
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _6
		_6:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _8
	_8:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _10
		_10:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v7 = st
		goto _12
	_12:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v9 = libc.Xmalloc(tls, uint64(16))
			goto _14
		_14:
			st = v9
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v11 = st
		goto _16
	_16:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v13 = libc.Xmalloc(tls, uint64(16))
			goto _18
		_18:
			st = v13
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v15 = st
		goto _20
	_20:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4352)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+10922, int32(408))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v17 = libc.Xmalloc(tls, uint64(16))
			goto _22
		_22:
			st = v17
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v19 = st
		goto _24
	_24:
		*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4352) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v21 = libc.Xmalloc(tls, uint64(16))
			goto _26
		_26:
			st = v21
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v23 = st
		goto _28
	_28:
		sNSQ_LBRR = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4352)/libc.Uint64FromInt64(1)))
		*(*int32)(unsafe.Pointer(psEnc + 4740 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded)*4)) = int32(1)
		/* Copy noise shaping quantizer state and quantization indices from regular encoding */
		libc.Xmemcpy(tls, sNSQ_LBRR, psEnc+148, libc.Uint64FromInt64(4352))
		libc.Xmemcpy(tls, psIndices_LBRR, psEnc+4752, libc.Uint64FromInt64(36))
		/* Save original gains */
		libc.Xmemcpy(tls, bp+16, psEncCtrl, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)*libc.Uint64FromInt64(4))
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded == 0 || *(*int32)(unsafe.Pointer(psEnc + 4740 + uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded-int32(1))*4)) == 0 {
			/* First frame in packet or previous frame not LBRR coded */
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FLBRRprevLastGainIndex = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex
			/* Increase Gains to get target LBRR rate */
			v1 = psIndices_LBRR
			*(*OpusT_opus_int8)(unsafe.Pointer(v1)) = OpusT_opus_int8(int32(*(*OpusT_opus_int8)(unsafe.Pointer(v1))) + (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FLBRR_GainIncreases)
			v30 = int32(*(*OpusT_opus_int8)(unsafe.Pointer(psIndices_LBRR)))
			v31 = libc.Int32FromInt32(N_LEVELS_QGAIN) - libc.Int32FromInt32(1)
			if v30 < v31 {
				v34 = v30
			} else {
				v34 = v31
			}
			v32 = v34
			goto _33
		_33:
			*(*OpusT_opus_int8)(unsafe.Pointer(psIndices_LBRR)) = int8(v32)
		}
		/* Decode to get gains in sync with decoder */
		Opus_silk_gains_dequant(tls, bp, psIndices_LBRR, psEnc+4540, libc.BoolInt32(condCoding == int32(CODE_CONDITIONALLY)), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)
		/* Overwrite unquantized gains with quantized gains and convert back to Q0 from Q16 */
		k = 0
		for {
			if !(k < (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr) {
				break
			}
			*(*float32)(unsafe.Pointer(psEncCtrl + uintptr(k)*4)) = float32(float32((*(*[4]OpusT_opus_int32)(unsafe.Pointer(bp)))[k]) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(65536)))
			goto _35
		_35:
			;
			k = k + 1
		}
		/*****************************************/
		/* Noise shaping quantization            */
		/*****************************************/
		Opus_silk_NSQ_wrapper_FLP(tls, psEnc, psEncCtrl, psIndices_LBRR, sNSQ_LBRR, psEnc+6324+uintptr((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded)*320, xfw)
		/* Restore original gains */
		libc.Xmemcpy(tls, psEncCtrl, bp+16, libc.Uint64FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr)*libc.Uint64FromInt64(4))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _39
_39:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

const LBRR_SPEECH_ACTIVITY_THRES2 = "0.3f"
const SPEECH_ACTIVITY_DTX_THRES4 = "0.05f"
const __FLT_MAX__1 = 3.4028234663852886e+38

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* LPC analysis */

func silk_LPC_analysis_filter10_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32) {
	var LPC_pred float32
	var ix int32
	var s_ptr uintptr
	_, _, _ = LPC_pred, ix, s_ptr
	ix = int32(10)
	for {
		if !(ix < length) {
			break
		}
		s_ptr = s + uintptr(ix-int32(1))*4
		/* short-term prediction */
		LPC_pred = float32(*(*float32)(unsafe.Pointer(s_ptr))**(*float32)(unsafe.Pointer(PredCoef))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(1))*4))**(*float32)(unsafe.Pointer(PredCoef + 1*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(2))*4))**(*float32)(unsafe.Pointer(PredCoef + 2*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(3))*4))**(*float32)(unsafe.Pointer(PredCoef + 3*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(4))*4))**(*float32)(unsafe.Pointer(PredCoef + 4*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(5))*4))**(*float32)(unsafe.Pointer(PredCoef + 5*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(6))*4))**(*float32)(unsafe.Pointer(PredCoef + 6*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(7))*4))**(*float32)(unsafe.Pointer(PredCoef + 7*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(8))*4))**(*float32)(unsafe.Pointer(PredCoef + 8*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(9))*4))**(*float32)(unsafe.Pointer(PredCoef + 9*4)))
		/* prediction error */
		*(*float32)(unsafe.Pointer(r_LPC + uintptr(ix)*4)) = *(*float32)(unsafe.Pointer(s_ptr + 1*4)) - LPC_pred
		goto _1
	_1:
		;
		ix = ix + 1
	}
}

// C documentation
//
//	/* 8th order LPC analysis filter, does not write first 8 samples */

func silk_LPC_analysis_filter12_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32) {
	var LPC_pred float32
	var ix int32
	var s_ptr uintptr
	_, _, _ = LPC_pred, ix, s_ptr
	ix = int32(12)
	for {
		if !(ix < length) {
			break
		}
		s_ptr = s + uintptr(ix-int32(1))*4
		/* short-term prediction */
		LPC_pred = float32(*(*float32)(unsafe.Pointer(s_ptr))**(*float32)(unsafe.Pointer(PredCoef))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(1))*4))**(*float32)(unsafe.Pointer(PredCoef + 1*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(2))*4))**(*float32)(unsafe.Pointer(PredCoef + 2*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(3))*4))**(*float32)(unsafe.Pointer(PredCoef + 3*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(4))*4))**(*float32)(unsafe.Pointer(PredCoef + 4*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(5))*4))**(*float32)(unsafe.Pointer(PredCoef + 5*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(6))*4))**(*float32)(unsafe.Pointer(PredCoef + 6*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(7))*4))**(*float32)(unsafe.Pointer(PredCoef + 7*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(8))*4))**(*float32)(unsafe.Pointer(PredCoef + 8*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(9))*4))**(*float32)(unsafe.Pointer(PredCoef + 9*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(10))*4))**(*float32)(unsafe.Pointer(PredCoef + 10*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(11))*4))**(*float32)(unsafe.Pointer(PredCoef + 11*4)))
		/* prediction error */
		*(*float32)(unsafe.Pointer(r_LPC + uintptr(ix)*4)) = *(*float32)(unsafe.Pointer(s_ptr + 1*4)) - LPC_pred
		goto _1
	_1:
		;
		ix = ix + 1
	}
}

// C documentation
//
//	/* 10th order LPC analysis filter, does not write first 10 samples */

func silk_LPC_analysis_filter16_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32) {
	var LPC_pred float32
	var ix int32
	var s_ptr uintptr
	_, _, _ = LPC_pred, ix, s_ptr
	ix = int32(16)
	for {
		if !(ix < length) {
			break
		}
		s_ptr = s + uintptr(ix-int32(1))*4
		/* short-term prediction */
		LPC_pred = float32(*(*float32)(unsafe.Pointer(s_ptr))**(*float32)(unsafe.Pointer(PredCoef))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(1))*4))**(*float32)(unsafe.Pointer(PredCoef + 1*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(2))*4))**(*float32)(unsafe.Pointer(PredCoef + 2*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(3))*4))**(*float32)(unsafe.Pointer(PredCoef + 3*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(4))*4))**(*float32)(unsafe.Pointer(PredCoef + 4*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(5))*4))**(*float32)(unsafe.Pointer(PredCoef + 5*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(6))*4))**(*float32)(unsafe.Pointer(PredCoef + 6*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(7))*4))**(*float32)(unsafe.Pointer(PredCoef + 7*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(8))*4))**(*float32)(unsafe.Pointer(PredCoef + 8*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(9))*4))**(*float32)(unsafe.Pointer(PredCoef + 9*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(10))*4))**(*float32)(unsafe.Pointer(PredCoef + 10*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(11))*4))**(*float32)(unsafe.Pointer(PredCoef + 11*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(12))*4))**(*float32)(unsafe.Pointer(PredCoef + 12*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(13))*4))**(*float32)(unsafe.Pointer(PredCoef + 13*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(14))*4))**(*float32)(unsafe.Pointer(PredCoef + 14*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(15))*4))**(*float32)(unsafe.Pointer(PredCoef + 15*4)))
		/* prediction error */
		*(*float32)(unsafe.Pointer(r_LPC + uintptr(ix)*4)) = *(*float32)(unsafe.Pointer(s_ptr + 1*4)) - LPC_pred
		goto _1
	_1:
		;
		ix = ix + 1
	}
}

// C documentation
//
//	/* 12th order LPC analysis filter, does not write first 12 samples */

func silk_LPC_analysis_filter6_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32) {
	var LPC_pred float32
	var ix int32
	var s_ptr uintptr
	_, _, _ = LPC_pred, ix, s_ptr
	ix = int32(6)
	for {
		if !(ix < length) {
			break
		}
		s_ptr = s + uintptr(ix-int32(1))*4
		/* short-term prediction */
		LPC_pred = float32(*(*float32)(unsafe.Pointer(s_ptr))**(*float32)(unsafe.Pointer(PredCoef))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(1))*4))**(*float32)(unsafe.Pointer(PredCoef + 1*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(2))*4))**(*float32)(unsafe.Pointer(PredCoef + 2*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(3))*4))**(*float32)(unsafe.Pointer(PredCoef + 3*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(4))*4))**(*float32)(unsafe.Pointer(PredCoef + 4*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(5))*4))**(*float32)(unsafe.Pointer(PredCoef + 5*4)))
		/* prediction error */
		*(*float32)(unsafe.Pointer(r_LPC + uintptr(ix)*4)) = *(*float32)(unsafe.Pointer(s_ptr + 1*4)) - LPC_pred
		goto _1
	_1:
		;
		ix = ix + 1
	}
}

// C documentation
//
//	/************************************************/
//	/* LPC analysis filter                          */
//	/* NB! State is kept internally and the         */
//	/* filter always starts with zero state         */
//	/* first Order output samples are set to zero   */
//	/************************************************/

func silk_LPC_analysis_filter8_FLP(tls *libc.TLS, r_LPC uintptr, PredCoef uintptr, s uintptr, length int32) {
	var LPC_pred float32
	var ix int32
	var s_ptr uintptr
	_, _, _ = LPC_pred, ix, s_ptr
	ix = int32(8)
	for {
		if !(ix < length) {
			break
		}
		s_ptr = s + uintptr(ix-int32(1))*4
		/* short-term prediction */
		LPC_pred = float32(*(*float32)(unsafe.Pointer(s_ptr))**(*float32)(unsafe.Pointer(PredCoef))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(1))*4))**(*float32)(unsafe.Pointer(PredCoef + 1*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(2))*4))**(*float32)(unsafe.Pointer(PredCoef + 2*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(3))*4))**(*float32)(unsafe.Pointer(PredCoef + 3*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(4))*4))**(*float32)(unsafe.Pointer(PredCoef + 4*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(5))*4))**(*float32)(unsafe.Pointer(PredCoef + 5*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(6))*4))**(*float32)(unsafe.Pointer(PredCoef + 6*4))) + float32(*(*float32)(unsafe.Pointer(s_ptr + uintptr(-libc.Int32FromInt32(7))*4))**(*float32)(unsafe.Pointer(PredCoef + 7*4)))
		/* prediction error */
		*(*float32)(unsafe.Pointer(r_LPC + uintptr(ix)*4)) = *(*float32)(unsafe.Pointer(s_ptr + 1*4)) - LPC_pred
		goto _1
	_1:
		;
		ix = ix + 1
	}
}

// C documentation
//
//	/* 6th order LPC analysis filter, does not write first 6 samples */

func silk_LP_interpolate_filter_taps(tls *libc.TLS, B_Q28 uintptr, A_Q28 uintptr, ind int32, fac_Q16 OpusT_opus_int32) {
	var na, nb, v3, v4 int32
	_, _, _, _ = na, nb, v3, v4
	if ind < libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1) {
		if fac_Q16 > 0 {
			if fac_Q16 < int32(32768) { /* fac_Q16 is in range of a 16-bit int */
				/* Piece-wise linear interpolation of B and A */
				nb = 0
				for {
					if !(nb < int32(TRANSITION_NB)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + uintptr(nb)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4)))*int64(int16(fac_Q16))>>libc.Int32FromInt32(16))
					goto _1
				_1:
					;
					nb = nb + 1
				}
				na = 0
				for {
					if !(na < int32(TRANSITION_NA)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + uintptr(na)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4)))*int64(int16(fac_Q16))>>libc.Int32FromInt32(16))
					goto _2
				_2:
					;
					na = na + 1
				}
			} else { /* ( fac_Q16 - ( 1 << 16 ) ) is in range of a 16-bit int */
				if fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) > int32(silk_int16_MAX7) {
					v3 = int32(silk_int16_MAX7)
				} else {
					if fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) < int32(libc.Int16FromInt32(0x8000)) {
						v4 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v4 = fac_Q16 - libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)
					}
					v3 = v4
				}
				_ = fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16) == v3
				/* Piece-wise linear interpolation of B and A */
				nb = 0
				for {
					if !(nb < int32(TRANSITION_NB)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + uintptr(nb)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind+int32(1))*12 + uintptr(nb)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28)) + uintptr(ind)*12 + uintptr(nb)*4)))*int64(int16(fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)))>>libc.Int32FromInt32(16))
					goto _5
				_5:
					;
					nb = nb + 1
				}
				na = 0
				for {
					if !(na < int32(TRANSITION_NA)) {
						break
					}
					*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + uintptr(na)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind+int32(1))*8 + uintptr(na)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28)) + uintptr(ind)*8 + uintptr(na)*4)))*int64(int16(fac_Q16-libc.Int32FromInt32(1)<<libc.Int32FromInt32(16)))>>libc.Int32FromInt32(16))
					goto _6
				_6:
					;
					na = na + 1
				}
			}
		} else {
			libc.Xmemcpy(tls, B_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28))+uintptr(ind)*12, libc.Uint64FromInt32(TRANSITION_NB)*libc.Uint64FromInt64(4))
			libc.Xmemcpy(tls, A_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28))+uintptr(ind)*8, libc.Uint64FromInt32(TRANSITION_NA)*libc.Uint64FromInt64(4))
		}
	} else {
		libc.Xmemcpy(tls, B_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_B_Q28))+uintptr(libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1))*12, libc.Uint64FromInt32(TRANSITION_NB)*libc.Uint64FromInt64(4))
		libc.Xmemcpy(tls, A_Q28, uintptr(unsafe.Pointer(&Opus_silk_Transition_LP_A_Q28))+uintptr(libc.Int32FromInt32(TRANSITION_INT_NUM)-libc.Int32FromInt32(1))*8, libc.Uint64FromInt32(TRANSITION_NA)*libc.Uint64FromInt64(4))
	}
}

// C documentation
//
//	/* Low-pass filter with variable cutoff frequency based on  */
//	/* piece-wise linear interpolation between elliptic filters */
//	/* Start by setting psEncC->mode <> 0;                      */
//	/* Deactivate by setting psEncC->mode = 0;                  */

func silk_NLSF2A_find_poly(tls *libc.TLS, out uintptr, cLSF uintptr, dd int32) {
	var ftmp OpusT_opus_int32
	var k, n int32
	_, _, _ = ftmp, k, n
	*(*OpusT_opus_int32)(unsafe.Pointer(out)) = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)) << libc.Int32FromInt32(QA1))
	*(*OpusT_opus_int32)(unsafe.Pointer(out + 1*4)) = -*(*OpusT_opus_int32)(unsafe.Pointer(cLSF))
	k = int32(1)
	for {
		if !(k < dd) {
			break
		}
		ftmp = *(*OpusT_opus_int32)(unsafe.Pointer(cLSF + uintptr(int32(2)*k)*4)) /* QA*/
		*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k+int32(1))*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k-int32(1))*4)))<<libc.Int32FromInt32(1)) - int32((int64(ftmp)*int64(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(k)*4)))>>(libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
		n = k
		for {
			if !(n > int32(1)) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n)*4)) += *(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n-int32(2))*4)) - int32((int64(ftmp)*int64(*(*OpusT_opus_int32)(unsafe.Pointer(out + uintptr(n-int32(1))*4)))>>(libc.Int32FromInt32(QA1)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
			goto _2
		_2:
			;
			n = n - 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(out + 1*4)) -= ftmp
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* compute whitening filter coefficients from normalized line spectral frequencies */

func silk_NLSF_residual_dequant(tls *libc.TLS, x_Q10 uintptr, indices uintptr, pred_coef_Q8 uintptr, quant_step_size_Q16 int32, order OpusT_opus_int16) {
	var i, out_Q10, pred_Q10 int32
	_, _, _ = i, out_Q10, pred_Q10
	out_Q10 = 0
	i = int32(order) - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		pred_Q10 = int32(int16(out_Q10)) * int32(libc.Int16FromUint8(*(*OpusT_opus_uint8)(unsafe.Pointer(pred_coef_Q8 + uintptr(i))))) >> int32(8)
		out_Q10 = libc.Int32FromUint32(libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(indices + uintptr(i)))) << libc.Int32FromInt32(10))
		if out_Q10 > 0 {
			out_Q10 = out_Q10 - int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5))
		} else {
			if out_Q10 < 0 {
				out_Q10 = out_Q10 + int32(float64(libc.Float64FromFloat64(NLSF_QUANT_LEVEL_ADJ)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(10)))+libc.Float64FromFloat64(0.5))
			}
		}
		out_Q10 = int32(int64(pred_Q10) + int64(out_Q10)*int64(int16(quant_step_size_Q16))>>libc.Int32FromInt32(16))
		*(*OpusT_opus_int16)(unsafe.Pointer(x_Q10 + uintptr(i)*2)) = int16(out_Q10)
		goto _1
	_1:
		;
		i = i - 1
	}
}

// C documentation
//
//	/***********************/
//	/* NLSF vector decoder */
//	/***********************/

func silk_PLC_conceal(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr, frame uintptr, arch int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var B_Q14, _saved_stack, pred_lag_ptr, psPLC, rand_ptr, sLPC_Q14_ptr, sLTP, sLTP_Q14, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var LPC_pred_Q10, LTP_pred_Q12, b32_inv, b32_nrm, down_scale_Q30, err_Q32, harm_Gain_Q15, invGain_Q30, inv_gain_Q30, rand_Gain_Q15, rand_seed, result, v84, v85, v86, v89 OpusT_opus_int32
	var b_headrm, i, idx, j, k, lag, lshift, sLTP_buf_idx, v53, v54, v55, v57, v58, v59, v60, v62, v63, v64, v65, v67, v68 int32
	var rand_scale_Q14, v79, v80, v81 OpusT_opus_int16
	var _ /* A_Q12 at bp+16 */ [16]OpusT_opus_int16
	var _ /* energy1 at bp+8 */ OpusT_opus_int32
	var _ /* energy2 at bp+12 */ OpusT_opus_int32
	var _ /* prevGain_Q10 at bp+48 */ [2]OpusT_opus_int32
	var _ /* shift1 at bp+0 */ int32
	var _ /* shift2 at bp+4 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B_Q14, LPC_pred_Q10, LTP_pred_Q12, _saved_stack, b32_inv, b32_nrm, b_headrm, down_scale_Q30, err_Q32, harm_Gain_Q15, i, idx, invGain_Q30, inv_gain_Q30, j, k, lag, lshift, pred_lag_ptr, psPLC, rand_Gain_Q15, rand_ptr, rand_scale_Q14, rand_seed, result, sLPC_Q14_ptr, sLTP, sLTP_Q14, sLTP_buf_idx, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v53, v54, v55, v57, v58, v59, v60, v62, v63, v64, v65, v67, v68, v7, v79, v80, v81, v84, v85, v86, v89, v9
	psPLC = psDec + 4292
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8557, int32(245))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	sLTP_Q14 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length+(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8557, int32(250))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	sLTP = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[0] = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72)) >> int32(6)
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)] = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72 + 1*4)) >> int32(6)
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffirst_frame_after_reset != 0 {
		libc.Xmemset(tls, psPLC+14, 0, libc.Uint64FromInt64(32))
	}
	silk_PLC_energy(tls, bp+8, bp, bp+12, bp+4, psDec+4, bp+48, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr)
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 8))>>*(*int32)(unsafe.Pointer(bp + 4)) < *(*OpusT_opus_int32)(unsafe.Pointer(bp + 12))>>*(*int32)(unsafe.Pointer(bp)) {
		/* First sub-frame has lowest energy */
		v53 = 0
		v54 = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr-int32(1))*(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length - int32(RAND_BUF_SIZE)
		if v53 > v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _56
	_56:
		rand_ptr = psDec + 4 + uintptr(v55)*4
	} else {
		/* Second sub-frame has lowest energy */
		v53 = 0
		v54 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr*(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length - int32(RAND_BUF_SIZE)
		if v53 > v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _61
	_61:
		rand_ptr = psDec + 4 + uintptr(v55)*4
	}
	/* Set up Gain to random noise component */
	B_Q14 = psPLC + 4
	rand_scale_Q14 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FrandScale_Q14
	/* Set up attenuation gains */
	v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
	v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
	if v53 < v54 {
		v57 = v53
	} else {
		v57 = v54
	}
	v55 = v57
	goto _66
_66:
	harm_Gain_Q15 = int32(HARM_ATT_Q15[v55])
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) {
		v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
		v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
		if v53 < v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _71
	_71:
		rand_Gain_Q15 = int32(PLC_RAND_ATTENUATE_V_Q15[v55])
	} else {
		v53 = libc.Int32FromInt32(NB_ATT) - libc.Int32FromInt32(1)
		v54 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt
		if v53 < v54 {
			v57 = v53
		} else {
			v57 = v54
		}
		v55 = v57
		goto _76
	_76:
		rand_Gain_Q15 = int32(PLC_RAND_ATTENUATE_UV_Q15[v55])
	}
	/* LPC concealment. Apply BWE to previous LPC */
	Opus_silk_bwexpander(tls, psPLC+14, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, int32(float64(libc.Float64FromFloat64(BWE_COEF)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))
	/* Preload LPC coefficients to array on stack. Gives small performance gain */
	libc.Xmemcpy(tls, bp+16, psPLC+14, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	/* First Lost frame */
	if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FlossCnt == 0 {
		rand_scale_Q14 = int16(libc.Int32FromInt32(1) << libc.Int32FromInt32(14))
		/* Reduce random noise Gain for voiced frames */
		if (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType == int32(TYPE_VOICED) {
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				rand_scale_Q14 = int16(int32(rand_scale_Q14) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(i)*2))))
				goto _78
			_78:
				;
				i = i + 1
			}
			v79 = int16(3277)
			v80 = rand_scale_Q14
			if int32(v79) > int32(v80) {
				v53 = int32(v79)
			} else {
				v53 = int32(v80)
			}
			v81 = int16(v53)
			goto _82
		_82:
			rand_scale_Q14 = v81 /* 0.2 */
			rand_scale_Q14 = int16(int32(rand_scale_Q14) * int32((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FprevLTP_scale_Q14) >> libc.Int32FromInt32(14))
		} else {
			_ = arch
			invGain_Q30 = Opus_silk_LPC_inverse_pred_gain_c(tls, psPLC+14, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)
			v84 = libc.Int32FromInt32(1) << libc.Int32FromInt32(30) >> libc.Int32FromInt32(LOG2_INV_LPC_GAIN_HIGH_THRES)
			v85 = invGain_Q30
			if v84 < v85 {
				v53 = v84
			} else {
				v53 = v85
			}
			v86 = v53
			goto _87
		_87:
			down_scale_Q30 = v86
			v84 = libc.Int32FromInt32(1) << libc.Int32FromInt32(30) >> libc.Int32FromInt32(LOG2_INV_LPC_GAIN_LOW_THRES)
			v85 = down_scale_Q30
			if v84 > v85 {
				v53 = v84
			} else {
				v53 = v85
			}
			v86 = v53
			goto _92
		_92:
			down_scale_Q30 = v86
			down_scale_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(down_scale_Q30) << libc.Int32FromInt32(LOG2_INV_LPC_GAIN_HIGH_THRES))
			rand_Gain_Q15 = int32(int64(down_scale_Q30)*int64(int16(rand_Gain_Q15))>>libc.Int32FromInt32(16)) >> int32(14)
		}
	}
	rand_seed = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Frand_seed
	lag = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
	sLTP_buf_idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length
	/* Rewhiten LTP state */
	idx = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length - lag - (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
	if !(idx > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+8571, __ccgo_ts+8557, int32(319))
	}
	Opus_silk_LPC_analysis_filter(tls, sLTP+uintptr(idx)*2, psDec+1348+uintptr(idx)*2, bp+16, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-idx, (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order, arch)
	/* Scale LTP state */
	v84 = *(*OpusT_opus_int32)(unsafe.Pointer(psPLC + 72 + 1*4))
	v53 = int32(46)
	_ = v84 != libc.Int32FromInt32(0)
	_ = v53 > libc.Int32FromInt32(0)
	if v84 > 0 {
		v54 = v84
	} else {
		v54 = -v84
	}
	v85 = v54
	if v85 != 0 {
		v55 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v85)))
	} else {
		v55 = int32(32)
	}
	v86 = v55
	goto _99
_99:
	b_headrm = v86 - int32(1)
	b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v84) << b_headrm)
	b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
	result = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv) << libc.Int32FromInt32(16))
	err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
	result = int32(int64(result) + int64(err_Q32)*int64(b32_inv)>>libc.Int32FromInt32(16))
	lshift = int32(61) - b_headrm - v53
	if lshift <= libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
			if result > libc.Int32FromUint32(0x80000000)>>-lshift {
				v58 = libc.Int32FromUint32(0x80000000) >> -lshift
			} else {
				if result < int32(silk_int32_MAX)>>-lshift {
					v59 = int32(silk_int32_MAX) >> -lshift
				} else {
					v59 = result
				}
				v58 = v59
			}
			v57 = v58
		} else {
			if result > int32(silk_int32_MAX)>>-lshift {
				v60 = int32(silk_int32_MAX) >> -lshift
			} else {
				if result < libc.Int32FromUint32(0x80000000)>>-lshift {
					v62 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					v62 = result
				}
				v60 = v62
			}
			v57 = v60
		}
		v89 = libc.Int32FromUint32(libc.Uint32FromInt32(v57) << -lshift)
		goto _102
	} else {
		if lshift < libc.Int32FromInt32(32) {
			v89 = result >> lshift
			goto _102
		} else {
			v89 = 0
			goto _102
		}
	}
_102:
	inv_gain_Q30 = v89
	if inv_gain_Q30 < libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(1) {
		v53 = inv_gain_Q30
	} else {
		v53 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(1)
	}
	inv_gain_Q30 = v53
	i = idx + (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q14 + uintptr(i)*4)) = int32(int64(inv_gain_Q30) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr(i)*2))) >> libc.Int32FromInt32(16))
		goto _109
	_109:
		;
		i = i + 1
	}
	/***************************/
	/* LTP synthesis filtering */
	/***************************/
	k = 0
	for {
		if !(k < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr) {
			break
		}
		/* Set up pointer */
		pred_lag_ptr = sLTP_Q14 + uintptr(sLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
		i = 0
		for {
			if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length) {
				break
			}
			/* Unrolled loop */
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LTP_pred_Q12 = int32(2)
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 1*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 2*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 3*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q12 = int32(int64(LTP_pred_Q12) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + 4*2)))>>libc.Int32FromInt32(16))
			pred_lag_ptr += 4
			/* Generate LPC excitation */
			rand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32(rand_seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
			idx = rand_seed >> libc.Int32FromInt32(25) & (libc.Int32FromInt32(RAND_BUF_SIZE) - libc.Int32FromInt32(1))
			*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q14 + uintptr(sLTP_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(LTP_pred_Q12)+int64(*(*OpusT_opus_int32)(unsafe.Pointer(rand_ptr + uintptr(idx)*4)))*int64(rand_scale_Q14)>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
			sLTP_buf_idx = sLTP_buf_idx + 1
			goto _111
		_111:
			;
			i = i + 1
		}
		/* Gradually reduce LTP gain */
		j = 0
		for {
			if !(j < int32(LTP_ORDER)) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(j)*2)) = int16(int32(int16(harm_Gain_Q15)) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(B_Q14 + uintptr(j)*2))) >> libc.Int32FromInt32(15))
			goto _112
		_112:
			;
			j = j + 1
		}
		/* Gradually reduce excitation gain */
		rand_scale_Q14 = int16(int32(rand_scale_Q14) * int32(int16(rand_Gain_Q15)) >> libc.Int32FromInt32(15))
		/* Slowly increase pitch lag */
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = int32(int64((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8) + int64((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8)*int64(int16(libc.Int32FromInt32(PITCH_DRIFT_FAC_Q16)))>>libc.Int32FromInt32(16))
		v84 = (*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8
		v85 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int16(libc.Int32FromInt32(MAX_PITCH_LAG_MS)))*int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz))) << libc.Int32FromInt32(8))
		if v84 < v85 {
			v53 = v84
		} else {
			v53 = v85
		}
		v86 = v53
		goto _116
	_116:
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = v86
		lag = ((*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		goto _110
	_110:
		;
		k = k + 1
	}
	/***************************/
	/* LPC synthesis filtering */
	/***************************/
	sLPC_Q14_ptr = sLTP_Q14 + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fltp_mem_length-int32(MAX_LPC_ORDER))*4
	/* Copy LPC state */
	libc.Xmemcpy(tls, sLPC_Q14_ptr, psDec+1284, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	if !((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >= libc.Int32FromInt32(10)) {
		Opus_celt_fatal(tls, __ccgo_ts+8597, __ccgo_ts+8557, int32(373))
	} /* check that unrolling works */
	i = 0
	for {
		if !(i < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length) {
			break
		}
		/* partly unrolled */
		/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
		LPC_pred_Q10 = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order >> libc.Int32FromInt32(1)
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[0])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(2))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(1)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(3))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(2)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(4))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(3)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(5))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(4)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(6))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(5)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(7))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(6)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(8))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(7)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(9))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(8)])>>libc.Int32FromInt32(16))
		LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-int32(10))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[int32(9)])>>libc.Int32FromInt32(16))
		j = int32(10)
		for {
			if !(j < (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order) {
				break
			}
			LPC_pred_Q10 = int32(int64(LPC_pred_Q10) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i-j-int32(1))*4)))*int64((*(*[16]OpusT_opus_int16)(unsafe.Pointer(bp + 16)))[j])>>libc.Int32FromInt32(16))
			goto _119
		_119:
			;
			j = j + 1
		}
		/* Add prediction to LPC excitation */
		if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
			v54 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
		} else {
			if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
				v55 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
			} else {
				v55 = LPC_pred_Q10
			}
			v54 = v55
		}
		if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))+libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(v54)<<libc.Int32FromInt32(4))))&uint32(0x80000000) == uint32(0) {
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v58 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v59 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v59 = LPC_pred_Q10
				}
				v58 = v59
			}
			if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4))&libc.Int32FromUint32(libc.Uint32FromInt32(v58)<<libc.Int32FromInt32(4)))&uint32(0x80000000) != uint32(0) {
				v57 = libc.Int32FromUint32(0x80000000)
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v60 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v62 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v62 = LPC_pred_Q10
					}
					v60 = v62
				}
				v57 = *(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v60)<<libc.Int32FromInt32(4))
			}
			v53 = v57
		} else {
			if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
				v64 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
			} else {
				if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
					v65 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
				} else {
					v65 = LPC_pred_Q10
				}
				v64 = v65
			}
			if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4))|libc.Int32FromUint32(libc.Uint32FromInt32(v64)<<libc.Int32FromInt32(4)))&uint32(0x80000000) == uint32(0) {
				v63 = int32(silk_int32_MAX)
			} else {
				if LPC_pred_Q10 > libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4) {
					v67 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(4)
				} else {
					if LPC_pred_Q10 < libc.Int32FromUint32(0x80000000)>>libc.Int32FromInt32(4) {
						v68 = libc.Int32FromUint32(0x80000000) >> libc.Int32FromInt32(4)
					} else {
						v68 = LPC_pred_Q10
					}
					v67 = v68
				}
				v63 = *(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) + libc.Int32FromUint32(libc.Uint32FromInt32(v67)<<libc.Int32FromInt32(4))
			}
			v53 = v63
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = v53
		/* Scale with Gain */
		if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
			v54 = int32(silk_int16_MAX9)
		} else {
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v55 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v55 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v54 = v55
		}
		if v54 > int32(silk_int16_MAX9) {
			v53 = int32(silk_int16_MAX9)
		} else {
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
				v58 = int32(silk_int16_MAX9)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v59 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v59 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v58 = v59
			}
			if v58 < int32(libc.Int16FromInt32(0x8000)) {
				v57 = int32(libc.Int16FromInt32(0x8000))
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
					v60 = int32(silk_int16_MAX9)
				} else {
					if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
						v62 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v62 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLPC_Q14_ptr + uintptr(int32(MAX_LPC_ORDER)+i)*4)))*int64((*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 48)))[int32(1)])>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
					}
					v60 = v62
				}
				v57 = v60
			}
			v53 = v57
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(frame + uintptr(i)*2)) = int16(v53)
		goto _118
	_118:
		;
		i = i + 1
	}
	/* Save LPC state */
	libc.Xmemcpy(tls, psDec+1284, sLPC_Q14_ptr+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fframe_length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
	/**************************************/
	/* Update states                      */
	/**************************************/
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Frand_seed = rand_seed
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FrandScale_Q14 = rand_scale_Q14
	i = 0
	for {
		if !(i < int32(MAX_NB_SUBFR)) {
			break
		}
		*(*int32)(unsafe.Pointer(psDecCtrl + uintptr(i)*4)) = lag
		goto _141
	_141:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _143
	_143:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _145
_145:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

// C documentation
//
//	/* Glues concealed frames with new good received frames */

func silk_PLC_energy(tls *libc.TLS, energy1 uintptr, shift1 uintptr, energy2 uintptr, shift2 uintptr, exc_Q14 uintptr, prevGain_Q10 uintptr, subfr_length int32, nb_subfr int32) {
	var _saved_stack, exc_buf, exc_buf_ptr, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var i, k, v31, v32 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, exc_buf, exc_buf_ptr, i, k, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v31, v32, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8557, int32(199))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	exc_buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*subfr_length)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	/* Find random noise component */
	/* Scale previous excitation signal */
	exc_buf_ptr = exc_buf
	k = 0
	for {
		if !(k < int32(2)) {
			break
		}
		i = 0
		for {
			if !(i < subfr_length) {
				break
			}
			if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(8) > int32(silk_int16_MAX9) {
				v31 = int32(silk_int16_MAX9)
			} else {
				if int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(8) < int32(libc.Int16FromInt32(0x8000)) {
					v32 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v32 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(exc_Q14 + uintptr(i+(k+nb_subfr-int32(2))*subfr_length)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(prevGain_Q10 + uintptr(k)*4)))>>libc.Int32FromInt32(16)) >> libc.Int32FromInt32(8)
				}
				v31 = v32
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(exc_buf_ptr + uintptr(i)*2)) = int16(v31)
			goto _30
		_30:
			;
			i = i + 1
		}
		exc_buf_ptr = exc_buf_ptr + uintptr(subfr_length)*2
		goto _29
	_29:
		;
		k = k + 1
	}
	/* Find the subframe with lowest energy of the last two and use that as random noise generator */
	Opus_silk_sum_sqr_shift(tls, energy1, shift1, exc_buf, subfr_length)
	Opus_silk_sum_sqr_shift(tls, energy2, shift2, exc_buf+uintptr(subfr_length)*2, subfr_length)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func silk_PLC_update(tls *libc.TLS, psDec uintptr, psDecCtrl uintptr) {
	var LTP_Gain_Q14, temp_LTP_Gain_Q14, tmp, tmp1 OpusT_opus_int32
	var i, j, scale_Q10, scale_Q14, v3 int32
	var psPLC uintptr
	_, _, _, _, _, _, _, _, _, _ = LTP_Gain_Q14, i, j, psPLC, scale_Q10, scale_Q14, temp_LTP_Gain_Q14, tmp, tmp1, v3
	psPLC = psDec + 4292
	/* Update parameters used in case of packet loss */
	(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FprevSignalType = int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType)
	LTP_Gain_Q14 = 0
	if int32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Findices.FsignalType) == int32(TYPE_VOICED) {
		/* Find the parameters for the last subframe which contains a pitch pulse */
		j = 0
		for {
			if !(j*(*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length < *(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1))*4))) {
				break
			}
			if j == (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr {
				break
			}
			temp_LTP_Gain_Q14 = 0
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				temp_LTP_Gain_Q14 = temp_LTP_Gain_Q14 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(psDecCtrl + 96 + uintptr(((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1)-j)*int32(LTP_ORDER)+i)*2)))
				goto _2
			_2:
				;
				i = i + 1
			}
			if temp_LTP_Gain_Q14 > LTP_Gain_Q14 {
				LTP_Gain_Q14 = temp_LTP_Gain_Q14
				libc.Xmemcpy(tls, psPLC+4, psDecCtrl+96+uintptr(int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-libc.Int32FromInt32(1)-j))*int32(int16(libc.Int32FromInt32(LTP_ORDER))))*2, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
				(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(psDecCtrl + uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(1)-j)*4))) << libc.Int32FromInt32(8))
			}
			goto _1
		_1:
			;
			j = j + 1
		}
		libc.Xmemset(tls, psPLC+4, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
		*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*2)) = int16(LTP_Gain_Q14)
		/* Limit LT coefs */
		if LTP_Gain_Q14 < int32(V_PITCH_GAIN_START_MIN_Q14) {
			tmp = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(V_PITCH_GAIN_START_MIN_Q14)) << libc.Int32FromInt32(10))
			if LTP_Gain_Q14 > int32(1) {
				v3 = LTP_Gain_Q14
			} else {
				v3 = int32(1)
			}
			scale_Q10 = tmp / v3
			i = 0
			for {
				if !(i < int32(LTP_ORDER)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2))) * int32(int16(scale_Q10)) >> libc.Int32FromInt32(10))
				goto _4
			_4:
				;
				i = i + 1
			}
		} else {
			if LTP_Gain_Q14 > int32(V_PITCH_GAIN_START_MAX_Q14) {
				tmp1 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(V_PITCH_GAIN_START_MAX_Q14)) << libc.Int32FromInt32(14))
				if LTP_Gain_Q14 > int32(1) {
					v3 = LTP_Gain_Q14
				} else {
					v3 = int32(1)
				}
				scale_Q14 = tmp1 / v3
				i = 0
				for {
					if !(i < int32(LTP_ORDER)) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2)) = int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(psPLC + 4 + uintptr(i)*2))) * int32(int16(scale_Q14)) >> libc.Int32FromInt32(14))
					goto _6
				_6:
					;
					i = i + 1
				}
			}
		}
	} else {
		(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FpitchL_Q8 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int16((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Ffs_kHz))*int32(int16(libc.Int32FromInt32(18)))) << libc.Int32FromInt32(8))
		libc.Xmemset(tls, psPLC+4, 0, libc.Uint64FromInt32(LTP_ORDER)*libc.Uint64FromInt64(2))
	}
	/* Save LPC coefficients */
	libc.Xmemcpy(tls, psPLC+14, psDecCtrl+32+1*32, libc.Uint64FromInt32((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).FLPC_order)*libc.Uint64FromInt64(2))
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).FprevLTP_scale_Q14 = int16((*OpusT_silk_decoder_control)(unsafe.Pointer(psDecCtrl)).FLTP_scale_Q14)
	/* Save last two gains */
	libc.Xmemcpy(tls, psPLC+72, psDecCtrl+16+uintptr((*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr-int32(2))*4, libc.Uint64FromInt32(2)*libc.Uint64FromInt64(4))
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fsubfr_length = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fsubfr_length
	(*OpusT_silk_PLC_struct)(unsafe.Pointer(psPLC)).Fnb_subfr = (*OpusT_silk_decoder_state)(unsafe.Pointer(psDec)).Fnb_subfr
}

func silk_P_Ana_calc_corr_st3(tls *libc.TLS, cross_corr_st3 uintptr, frame uintptr, start_lag int32, sf_length int32, nb_subfr int32, complexity int32, arch int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var Lag_CB_ptr, Lag_range_ptr, target_ptr uintptr
	var cbk_size, delta, i, idx, j, k, lag_counter, lag_high, lag_low, nb_cbk_search int32
	var scratch_mem [22]float32
	var _ /* xcorr at bp+0 */ [22]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = Lag_CB_ptr, Lag_range_ptr, cbk_size, delta, i, idx, j, k, lag_counter, lag_high, lag_low, nb_cbk_search, scratch_mem, target_ptr
	if !(complexity >= libc.Int32FromInt32(SILK_PE_MIN_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11901, __ccgo_ts+11861, int32(509))
	}
	if !(complexity <= libc.Int32FromInt32(SILK_PE_MAX_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11953, __ccgo_ts+11861, int32(510))
	}
	if nb_subfr == int32(PE_MAX_NB_SUBFR) {
		Lag_range_ptr = uintptr(unsafe.Pointer(&Opus_silk_Lag_range_stage3)) + uintptr(complexity)*8
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3))
		nb_cbk_search = int32(Opus_silk_nb_cbk_searchs_stage3[complexity])
		cbk_size = int32(PE_NB_CBKS_STAGE3_MAX)
	} else {
		if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
			Opus_celt_fatal(tls, __ccgo_ts+9912, __ccgo_ts+11861, int32(518))
		}
		Lag_range_ptr = uintptr(unsafe.Pointer(&Opus_silk_Lag_range_stage3_10_ms))
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3_10_ms))
		nb_cbk_search = int32(PE_NB_CBKS_STAGE3_10MS)
		cbk_size = int32(PE_NB_CBKS_STAGE3_10MS)
	}
	target_ptr = frame + uintptr(libc.Int32FromUint32(libc.Uint32FromInt32(sf_length)<<libc.Int32FromInt32(2)))*4 /* Pointer to middle of frame */
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		lag_counter = 0
		/* Calculate the correlations for each subframe */
		lag_low = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(0)))))
		lag_high = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(1)))))
		_ = lag_high-lag_low+libc.Int32FromInt32(1) <= libc.Int32FromInt32(SCRATCH_SIZE)
		Opus_celt_pitch_xcorr_c(tls, target_ptr, target_ptr-uintptr(start_lag)*4-uintptr(lag_high)*4, bp, sf_length, lag_high-lag_low+int32(1), arch)
		j = lag_low
		for {
			if !(j <= lag_high) {
				break
			}
			_ = lag_counter < libc.Int32FromInt32(SCRATCH_SIZE)
			scratch_mem[lag_counter] = (*(*[22]OpusT_opus_val32)(unsafe.Pointer(bp)))[lag_high-j]
			lag_counter = lag_counter + 1
			goto _2
		_2:
			;
			j = j + 1
		}
		delta = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(0)))))
		i = 0
		for {
			if !(i < nb_cbk_search) {
				break
			}
			/* Fill out the 3 dim array that stores the correlations for */
			/* each code_book vector for each start lag */
			idx = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k*cbk_size+i)))) - delta
			j = 0
			for {
				if !(j < int32(PE_NB_STAGE3_LAGS)) {
					break
				}
				_ = idx+j < libc.Int32FromInt32(SCRATCH_SIZE)
				_ = idx+j < lag_counter
				*(*float32)(unsafe.Pointer(cross_corr_st3 + uintptr(k)*680 + uintptr(i)*20 + uintptr(j)*4)) = scratch_mem[idx+j]
				goto _4
			_4:
				;
				j = j + 1
			}
			goto _3
		_3:
			;
			i = i + 1
		}
		target_ptr = target_ptr + uintptr(sf_length)*4
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/********************************************************************/
//	/* Calculate the energies for first two subframes. The energies are */
//	/* calculated recursively.                                          */
//	/********************************************************************/

func silk_P_Ana_calc_energy_st3(tls *libc.TLS, energies_st3 uintptr, frame uintptr, start_lag int32, sf_length int32, nb_subfr int32, complexity int32) {
	var Lag_CB_ptr, Lag_range_ptr, basis_ptr, target_ptr uintptr
	var cbk_size, delta, i, idx, j, k, lag_counter, lag_diff, nb_cbk_search int32
	var energy float64
	var scratch_mem [22]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Lag_CB_ptr, Lag_range_ptr, basis_ptr, cbk_size, delta, energy, i, idx, j, k, lag_counter, lag_diff, nb_cbk_search, scratch_mem, target_ptr
	if !(complexity >= libc.Int32FromInt32(SILK_PE_MIN_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11901, __ccgo_ts+11861, int32(575))
	}
	if !(complexity <= libc.Int32FromInt32(SILK_PE_MAX_COMPLEX)) {
		Opus_celt_fatal(tls, __ccgo_ts+11953, __ccgo_ts+11861, int32(576))
	}
	if nb_subfr == int32(PE_MAX_NB_SUBFR) {
		Lag_range_ptr = uintptr(unsafe.Pointer(&Opus_silk_Lag_range_stage3)) + uintptr(complexity)*8
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3))
		nb_cbk_search = int32(Opus_silk_nb_cbk_searchs_stage3[complexity])
		cbk_size = int32(PE_NB_CBKS_STAGE3_MAX)
	} else {
		if !(nb_subfr == libc.Int32FromInt32(PE_MAX_NB_SUBFR)>>libc.Int32FromInt32(1)) {
			Opus_celt_fatal(tls, __ccgo_ts+9912, __ccgo_ts+11861, int32(584))
		}
		Lag_range_ptr = uintptr(unsafe.Pointer(&Opus_silk_Lag_range_stage3_10_ms))
		Lag_CB_ptr = uintptr(unsafe.Pointer(&Opus_silk_CB_lags_stage3_10_ms))
		nb_cbk_search = int32(PE_NB_CBKS_STAGE3_10MS)
		cbk_size = int32(PE_NB_CBKS_STAGE3_10MS)
	}
	target_ptr = frame + uintptr(libc.Int32FromUint32(libc.Uint32FromInt32(sf_length)<<libc.Int32FromInt32(2)))*4
	k = 0
	for {
		if !(k < nb_subfr) {
			break
		}
		lag_counter = 0
		/* Calculate the energy for first lag */
		basis_ptr = target_ptr - uintptr(start_lag+int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(0))))))*4
		energy = Opus_silk_energy_FLP(tls, basis_ptr, sf_length) + float64(0.001)
		_ = energy >= libc.Float64FromFloat64(0)
		scratch_mem[lag_counter] = float32(energy)
		lag_counter = lag_counter + 1
		lag_diff = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(1))))) - int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(0))))) + int32(1)
		i = int32(1)
		for {
			if !(i < lag_diff) {
				break
			}
			/* remove part outside new window */
			energy = energy - float64(float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(sf_length-i)*4)))*float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(sf_length-i)*4))))
			_ = energy >= libc.Float64FromFloat64(0)
			/* add part that comes into window */
			energy = energy + float64(float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(-i)*4)))*float64(*(*float32)(unsafe.Pointer(basis_ptr + uintptr(-i)*4))))
			_ = energy >= libc.Float64FromFloat64(0)
			_ = lag_counter < libc.Int32FromInt32(SCRATCH_SIZE)
			scratch_mem[lag_counter] = float32(energy)
			lag_counter = lag_counter + 1
			goto _2
		_2:
			;
			i = i + 1
		}
		delta = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_range_ptr + uintptr(k*libc.Int32FromInt32(2)+libc.Int32FromInt32(0)))))
		i = 0
		for {
			if !(i < nb_cbk_search) {
				break
			}
			/* Fill out the 3 dim array that stores the correlations for    */
			/* each code_book vector for each start lag                     */
			idx = int32(*(*OpusT_opus_int8)(unsafe.Pointer(Lag_CB_ptr + uintptr(k*cbk_size+i)))) - delta
			j = 0
			for {
				if !(j < int32(PE_NB_STAGE3_LAGS)) {
					break
				}
				_ = idx+j < libc.Int32FromInt32(SCRATCH_SIZE)
				_ = idx+j < lag_counter
				*(*float32)(unsafe.Pointer(energies_st3 + uintptr(k)*680 + uintptr(i)*20 + uintptr(j)*4)) = scratch_mem[idx+j]
				_ = *(*float32)(unsafe.Pointer(energies_st3 + uintptr(k)*680 + uintptr(i)*20 + uintptr(j)*4)) >= libc.Float32FromFloat32(0)
				goto _4
			_4:
				;
				j = j + 1
			}
			goto _3
		_3:
			;
			i = i + 1
		}
		target_ptr = target_ptr + uintptr(sf_length)*4
		goto _1
	_1:
		;
		k = k + 1
	}
}

// C documentation
//
//	/* copy and multiply a vector by a constant */

func silk_QueryEncoder(tls *libc.TLS, encState uintptr, encStatus uintptr) (r int32) {
	var psEnc, state_Fxx uintptr
	var ret int32
	_, _, _ = psEnc, ret, state_Fxx
	ret = SILK_NO_ERROR
	psEnc = encState
	state_Fxx = psEnc + 88
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FnChannelsAPI = (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsAPI
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FnChannelsInternal = (*OpusT_silk_encoder)(unsafe.Pointer(psEnc)).FnChannelsInternal
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FAPI_sampleRate = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FAPI_fs_Hz
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FmaxInternalSampleRate = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FmaxInternal_fs_Hz
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FminInternalSampleRate = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FminInternal_fs_Hz
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FdesiredInternalSampleRate = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FdesiredInternal_fs_Hz
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FpayloadSize_ms = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FPacketSize_ms
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FbitRate = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FTargetRate_bps
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FpacketLossPercentage = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FPacketLoss_perc
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).Fcomplexity = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FComplexity
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FuseInBandFEC = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FuseInBandFEC
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FuseDTX = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FuseDTX
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FuseCBR = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FuseCBR
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FinternalSampleRate = int32(int16((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.Ffs_kHz)) * int32(int16(libc.Int32FromInt32(1000)))
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FallowBandwidthSwitch = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.Fallow_bandwidth_switch
	(*OpusT_silk_EncControlStruct)(unsafe.Pointer(encStatus)).FinWBmodeWithoutVariableLP = libc.BoolInt32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.Ffs_kHz == int32(16) && (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(state_Fxx))).FsCmn.FsLP.Fmode == 0)
	return ret
}

// C documentation
//
//	/**************************/
//	/* Encode frame with Silk */
//	/**************************/
//	/* Note: if prefillFlag is set, the input must contain 10 ms of audio, irrespective of what                     */
//	/* encControl->payloadSize_ms is set to                                                                         */

func silk_VAD_GetNoiseLevels(tls *libc.TLS, pX uintptr, psSilk_VAD uintptr) {
	var coef, k, min_coef, v2, v3, v4, v5 int32
	var inv_nrg, nl, nrg OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _ = coef, inv_nrg, k, min_coef, nl, nrg, v2, v3, v4, v5
	/* Initially faster smoothing */
	if (*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter < int32(1000) { /* 1000 = 20 sec */
		min_coef = libc.Int32FromInt32(silk_int16_MAX11) / ((*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter>>libc.Int32FromInt32(4) + libc.Int32FromInt32(1))
		/* Increment frame counter */
		(*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter = (*OpusT_silk_VAD_state)(unsafe.Pointer(psSilk_VAD)).Fcounter + 1
	} else {
		min_coef = 0
	}
	k = 0
	for {
		if !(k < int32(VAD_N_BANDS)) {
			break
		}
		/* Get old noise level estimate for current band */
		nl = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(k)*4))
		_ = nl >= libc.Int32FromInt32(0)
		/* Add bias */
		if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(pX + uintptr(k)*4)))+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(k)*4))))&uint32(0x80000000) != 0 {
			v2 = int32(silk_int32_MAX)
		} else {
			v2 = *(*OpusT_opus_int32)(unsafe.Pointer(pX + uintptr(k)*4)) + *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 92 + uintptr(k)*4))
		}
		nrg = v2
		_ = nrg > libc.Int32FromInt32(0)
		/* Invert energies */
		inv_nrg = libc.Int32FromInt32(silk_int32_MAX) / nrg
		_ = inv_nrg >= libc.Int32FromInt32(0)
		/* Less update when subband energy is high */
		if nrg > libc.Int32FromUint32(libc.Uint32FromInt32(nl)<<libc.Int32FromInt32(3)) {
			coef = libc.Int32FromInt32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16) >> libc.Int32FromInt32(3)
		} else {
			if nrg < nl {
				coef = int32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16)
			} else {
				coef = int32(int64(int32(int64(inv_nrg)*int64(nl)>>libc.Int32FromInt32(16))) * int64(int16(libc.Int32FromInt32(VAD_NOISE_LEVEL_SMOOTH_COEF_Q16)<<libc.Int32FromInt32(1))) >> libc.Int32FromInt32(16))
			}
		}
		/* Initially faster smoothing */
		v2 = coef
		v3 = min_coef
		if v2 > v3 {
			v5 = v2
		} else {
			v5 = v3
		}
		v4 = v5
		goto _6
	_6:
		coef = v4
		/* Smooth inverse energies */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)) = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4))) + int64(inv_nrg-*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)))*int64(int16(coef))>>libc.Int32FromInt32(16))
		_ = *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4)) >= libc.Int32FromInt32(0)
		/* Compute noise level by inverting again */
		nl = libc.Int32FromInt32(silk_int32_MAX) / *(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 76 + uintptr(k)*4))
		_ = nl >= libc.Int32FromInt32(0)
		/* Limit noise levels (guarantee 7 bits of head room) */
		if nl < int32(0x00FFFFFF) {
			v2 = nl
		} else {
			v2 = int32(0x00FFFFFF)
		}
		nl = v2
		/* Store as part of state */
		*(*OpusT_opus_int32)(unsafe.Pointer(psSilk_VAD + 60 + uintptr(k)*4)) = nl
		goto _1
	_1:
		;
		k = k + 1
	}
}

const SPEECH_ACTIVITY_DTX_THRES2 = "0.05f"
const silk_int16_MAX12 = 0x7FFF
const silk_uint8_MAX2 = 0xFF

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* Control internal sampling rate */

func silk_biquad_res(tls *libc.TLS, in uintptr, B_Q28 uintptr, A_Q28 uintptr, S uintptr, out uintptr, len1 OpusT_opus_int32, stride int32) {
	var A [2]OpusT_opus_val32
	var B [3]OpusT_opus_val32
	var inval, vout OpusT_opus_val32
	var k int32
	_, _, _, _, _ = A, B, inval, k, vout
	A[0] = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28))) * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(28))))
	A[int32(1)] = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(A_Q28 + 1*4))) * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(28))))
	B[0] = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28))) * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(28))))
	B[int32(1)] = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 1*4))) * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(28))))
	B[int32(2)] = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(B_Q28 + 2*4))) * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(28))))
	/* Negate A_Q28 values and split in two parts */
	k = 0
	for {
		if !(k < len1) {
			break
		}
		/* S[ 0 ], S[ 1 ]: Q12 */
		inval = *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(k*stride)*4))
		vout = *(*OpusT_opus_val32)(unsafe.Pointer(S)) + OpusT_opus_val32(B[0]*inval)
		*(*OpusT_opus_val32)(unsafe.Pointer(S)) = *(*OpusT_opus_val32)(unsafe.Pointer(S + 1*4)) - OpusT_opus_val32(vout*A[0]) + OpusT_opus_val32(B[int32(1)]*inval)
		*(*OpusT_opus_val32)(unsafe.Pointer(S + 1*4)) = OpusT_opus_val32(-vout*A[int32(1)]) + OpusT_opus_val32(B[int32(2)]*inval) + libc.Float32FromFloat32(1e-30)
		/* Scale back to Q0 and saturate */
		*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(k*stride)*4)) = vout
		goto _1
	_1:
		;
		k = k + 1
	}
}

func silk_noise_shape_quantizer(tls *libc.TLS, NSQ uintptr, signalType int32, x_sc_Q10 uintptr, pulses uintptr, xq uintptr, sLTP_Q15 uintptr, a_Q12 uintptr, b_Q14 uintptr, AR_shp_Q13 uintptr, lag int32, HarmShapeFIRPacked_Q14 OpusT_opus_int32, Tilt_Q14 int32, LF_shp_Q14 OpusT_opus_int32, Gain_Q16 OpusT_opus_int32, Lambda_Q10 int32, offset_Q10 int32, length int32, shapingLPCOrder int32, predictLPCOrder int32, arch int32) {
	var Gain_Q10, LPC_exc_Q14, LPC_pred_Q10, LTP_pred_Q13, exc_Q14, n_AR_Q12, n_LF_Q12, n_LTP_Q13, out, out1, q1_Q0, q1_Q10, q2_Q10, r_Q10, rd1_Q20, rd2_Q20, rr_Q10, sLF_AR_shp_Q14, tmp1, tmp11, tmp2, tmp21, xq_Q14, v5 OpusT_opus_int32
	var i, j, rdo_offset, v13, v4, v9 int32
	var pred_lag_ptr, psLPC_Q14, shp_lag_ptr, v2, v3 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Gain_Q10, LPC_exc_Q14, LPC_pred_Q10, LTP_pred_Q13, exc_Q14, i, j, n_AR_Q12, n_LF_Q12, n_LTP_Q13, out, out1, pred_lag_ptr, psLPC_Q14, q1_Q0, q1_Q10, q2_Q10, r_Q10, rd1_Q20, rd2_Q20, rdo_offset, rr_Q10, sLF_AR_shp_Q14, shp_lag_ptr, tmp1, tmp11, tmp2, tmp21, xq_Q14, v13, v2, v3, v4, v5, v9
	shp_lag_ptr = NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-lag+libc.Int32FromInt32(HARM_SHAPE_FIR_TAPS)/libc.Int32FromInt32(2))*4
	pred_lag_ptr = sLTP_Q15 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
	Gain_Q10 = Gain_Q16 >> int32(6)
	/* Set up short term AR state */
	psLPC_Q14 = NSQ + 3840 + uintptr(libc.Int32FromInt32(MAX_LPC_ORDER)-libc.Int32FromInt32(1))*4
	i = 0
	for {
		if !(i < length) {
			break
		}
		/* Generate dither */
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
		/* Short-term prediction */
		_ = arch
		v2 = psLPC_Q14
		v3 = a_Q12
		v4 = predictLPCOrder
		_ = v4 == int32(10) || v4 == int32(16)
		out = v4 >> libc.Int32FromInt32(1)
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 1*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 2*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 3*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 4*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(5))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 5*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(6))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 6*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(7))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 7*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(8))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 8*2)))>>libc.Int32FromInt32(16))
		out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(9))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 9*2)))>>libc.Int32FromInt32(16))
		if v4 == libc.Int32FromInt32(16) {
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(10))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 10*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(11))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 11*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(12))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 12*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(13))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 13*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(14))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 14*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(-libc.Int32FromInt32(15))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 15*2)))>>libc.Int32FromInt32(16))
		}
		v5 = out
		goto _6
	_6:
		LPC_pred_Q10 = v5
		/* Long-term prediction */
		if signalType == int32(TYPE_VOICED) {
			/* Unrolled loop */
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LTP_pred_Q13 = int32(2)
			LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14)))>>libc.Int32FromInt32(16))
			LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 1*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 2*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 3*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q13 = int32(int64(LTP_pred_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 4*2)))>>libc.Int32FromInt32(16))
			pred_lag_ptr += 4
		} else {
			LTP_pred_Q13 = 0
		}
		/* Noise shape feedback */
		if !(shapingLPCOrder&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+8388, __ccgo_ts+8374, int32(250))
		} /* check that order is even */
		_ = arch
		v2 = NSQ + 4224
		v3 = AR_shp_Q13
		v4 = shapingLPCOrder
		tmp2 = *(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 4324))
		tmp1 = *(*OpusT_opus_int32)(unsafe.Pointer(v2))
		*(*OpusT_opus_int32)(unsafe.Pointer(v2)) = tmp2
		out1 = v4 >> libc.Int32FromInt32(1)
		out1 = int32(int64(out1) + int64(tmp2)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3)))>>libc.Int32FromInt32(16))
		j = libc.Int32FromInt32(2)
		for {
			if !(j < v4) {
				break
			}
			tmp2 = *(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(j-int32(1))*4))
			*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(j-int32(1))*4)) = tmp1
			out1 = int32(int64(out1) + int64(tmp1)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + uintptr(j-int32(1))*2)))>>libc.Int32FromInt32(16))
			tmp1 = *(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(j+0)*4))
			*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(j+0)*4)) = tmp2
			out1 = int32(int64(out1) + int64(tmp2)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + uintptr(j)*2)))>>libc.Int32FromInt32(16))
			goto _10
		_10:
			;
			j = j + int32(2)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(v2 + uintptr(v4-int32(1))*4)) = tmp1
		out1 = int32(int64(out1) + int64(tmp1)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + uintptr(v4-int32(1))*2)))>>libc.Int32FromInt32(16))
		out1 = libc.Int32FromUint32(libc.Uint32FromInt32(out1) << libc.Int32FromInt32(1))
		v5 = out1
		goto _12
	_12:
		n_AR_Q12 = v5
		n_AR_Q12 = int32(int64(n_AR_Q12) + int64((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14)*int64(int16(Tilt_Q14))>>libc.Int32FromInt32(16))
		n_LF_Q12 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-int32(1))*4))) * int64(int16(LF_shp_Q14)) >> libc.Int32FromInt32(16))
		n_LF_Q12 = int32(int64(n_LF_Q12) + int64((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14)*(int64(LF_shp_Q14)>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(16))
		if !(lag > 0 || signalType != int32(TYPE_VOICED)) {
			Opus_celt_fatal(tls, __ccgo_ts+8435, __ccgo_ts+8374, int32(258))
		}
		/* Combine prediction and noise shaping signals */
		tmp11 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(LPC_pred_Q10)<<libc.Int32FromInt32(2))) - libc.Uint32FromInt32(n_AR_Q12)) /* Q12 */
		tmp11 = libc.Int32FromUint32(libc.Uint32FromInt32(tmp11) - libc.Uint32FromInt32(n_LF_Q12))                                                                            /* Q12 */
		if lag > 0 {
			/* Symmetric, packed FIR coefficients */
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)))+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr))&*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))&uint32(0x80000000) != uint32(0) {
					v9 = libc.Int32FromUint32(0x80000000)
				} else {
					v9 = *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)) + *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))
				}
				v4 = v9
			} else {
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr))|*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))&uint32(0x80000000) == uint32(0) {
					v13 = int32(silk_int32_MAX)
				} else {
					v13 = *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)) + *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))
				}
				v4 = v13
			}
			n_LTP_Q13 = int32(int64(v4) * int64(int16(HarmShapeFIRPacked_Q14)) >> libc.Int32FromInt32(16))
			n_LTP_Q13 = int32(int64(n_LTP_Q13) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*(int64(HarmShapeFIRPacked_Q14)>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(16))
			n_LTP_Q13 = libc.Int32FromUint32(libc.Uint32FromInt32(n_LTP_Q13) << libc.Int32FromInt32(1))
			shp_lag_ptr += 4
			tmp21 = LTP_pred_Q13 - n_LTP_Q13                                                                                                                            /* Q13 */
			tmp11 = libc.Int32FromUint32(libc.Uint32FromInt32(tmp21) + libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(tmp11)<<libc.Int32FromInt32(1)))) /* Q13 */
			tmp11 = (tmp11>>(libc.Int32FromInt32(3)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)                                         /* Q10 */
		} else {
			tmp11 = (tmp11>>(libc.Int32FromInt32(2)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1) /* Q10 */
		}
		r_Q10 = *(*OpusT_opus_int32)(unsafe.Pointer(x_sc_Q10 + uintptr(i)*4)) - tmp11 /* residual error Q10 */
		/* Flip sign depending on dither */
		if (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed < 0 {
			r_Q10 = -r_Q10
		}
		if r_Q10 > libc.Int32FromInt32(30)<<libc.Int32FromInt32(10) {
			v4 = libc.Int32FromInt32(30) << libc.Int32FromInt32(10)
		} else {
			if r_Q10 < -(libc.Int32FromInt32(31) << libc.Int32FromInt32(10)) {
				v9 = -(libc.Int32FromInt32(31) << libc.Int32FromInt32(10))
			} else {
				v9 = r_Q10
			}
			v4 = v9
		}
		r_Q10 = v4
		/* Find two quantization level candidates and measure their rate-distortion */
		q1_Q10 = r_Q10 - offset_Q10
		q1_Q0 = q1_Q10 >> int32(10)
		if Lambda_Q10 > int32(2048) {
			/* For aggressive RDO, the bias becomes more than one pulse. */
			rdo_offset = Lambda_Q10/int32(2) - int32(512)
			if q1_Q10 > rdo_offset {
				q1_Q0 = (q1_Q10 - rdo_offset) >> libc.Int32FromInt32(10)
			} else {
				if q1_Q10 < -rdo_offset {
					q1_Q0 = (q1_Q10 + rdo_offset) >> libc.Int32FromInt32(10)
				} else {
					if q1_Q10 < 0 {
						q1_Q0 = -int32(1)
					} else {
						q1_Q0 = 0
					}
				}
			}
		}
		if q1_Q0 > 0 {
			q1_Q10 = libc.Int32FromUint32(libc.Uint32FromInt32(q1_Q0)<<libc.Int32FromInt32(10)) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10)
			q1_Q10 = q1_Q10 + offset_Q10
			q2_Q10 = q1_Q10 + libc.Int32FromInt32(1024)
			rd1_Q20 = int32(int16(q1_Q10)) * int32(int16(Lambda_Q10))
			rd2_Q20 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
		} else {
			if q1_Q0 == 0 {
				q1_Q10 = offset_Q10
				q2_Q10 = q1_Q10 + (libc.Int32FromInt32(1024) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10))
				rd1_Q20 = int32(int16(q1_Q10)) * int32(int16(Lambda_Q10))
				rd2_Q20 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
			} else {
				if q1_Q0 == -int32(1) {
					q2_Q10 = offset_Q10
					q1_Q10 = q2_Q10 - (libc.Int32FromInt32(1024) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10))
					rd1_Q20 = int32(int16(-q1_Q10)) * int32(int16(Lambda_Q10))
					rd2_Q20 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
				} else { /* Q1_Q0 < -1 */
					q1_Q10 = libc.Int32FromUint32(libc.Uint32FromInt32(q1_Q0)<<libc.Int32FromInt32(10)) + libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10)
					q1_Q10 = q1_Q10 + offset_Q10
					q2_Q10 = q1_Q10 + libc.Int32FromInt32(1024)
					rd1_Q20 = int32(int16(-q1_Q10)) * int32(int16(Lambda_Q10))
					rd2_Q20 = int32(int16(-q2_Q10)) * int32(int16(Lambda_Q10))
				}
			}
		}
		rr_Q10 = r_Q10 - q1_Q10
		rd1_Q20 = rd1_Q20 + int32(int16(rr_Q10))*int32(int16(rr_Q10))
		rr_Q10 = r_Q10 - q2_Q10
		rd2_Q20 = rd2_Q20 + int32(int16(rr_Q10))*int32(int16(rr_Q10))
		if rd2_Q20 < rd1_Q20 {
			q1_Q10 = q2_Q10
		}
		*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i))) = int8((q1_Q10>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
		/* Excitation */
		exc_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(q1_Q10) << libc.Int32FromInt32(4))
		if (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed < 0 {
			exc_Q14 = -exc_Q14
		}
		/* Add predictions */
		LPC_exc_Q14 = exc_Q14 + libc.Int32FromUint32(libc.Uint32FromInt32(LTP_pred_Q13)<<libc.Int32FromInt32(1))
		xq_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(LPC_exc_Q14) + libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(LPC_pred_Q10)<<libc.Int32FromInt32(4))))
		/* Scale XQ back to normal level before saving */
		if (int32(int64(xq_Q14)*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
			v4 = int32(silk_int16_MAX9)
		} else {
			if (int32(int64(xq_Q14)*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v9 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v9 = (int32(int64(xq_Q14)*int64(Gain_Q10)>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v4 = v9
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(xq + uintptr(i)*2)) = int16(v4)
		/* Update states */
		psLPC_Q14 += 4
		*(*OpusT_opus_int32)(unsafe.Pointer(psLPC_Q14)) = xq_Q14
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(xq_Q14) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(x_sc_Q10 + uintptr(i)*4)))<<libc.Int32FromInt32(4))))
		sLF_AR_shp_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(n_AR_Q12)<<libc.Int32FromInt32(2))))
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14 = sLF_AR_shp_Q14
		*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(sLF_AR_shp_Q14) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(n_LF_Q12)<<libc.Int32FromInt32(2))))
		*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx)*4)) = libc.Int32FromUint32(libc.Uint32FromInt32(LPC_exc_Q14) << libc.Int32FromInt32(1))
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx + 1
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx + 1
		/* Make dither dependent on quantized signal */
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frand_seed) + libc.Uint32FromInt8(*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i)))))
		goto _1
	_1:
		;
		i = i + 1
	}
	/* Update LPC synth buffer */
	libc.Xmemcpy(tls, NSQ+3840, NSQ+3840+uintptr(length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
}

func silk_noise_shape_quantizer_del_dec(tls *libc.TLS, NSQ uintptr, psDelDec uintptr, signalType int32, x_Q10 uintptr, pulses uintptr, xq uintptr, sLTP_Q15 uintptr, delayedGain_Q10 uintptr, a_Q12 uintptr, b_Q14 uintptr, AR_shp_Q13 uintptr, lag int32, HarmShapeFIRPacked_Q14 OpusT_opus_int32, Tilt_Q14 int32, LF_shp_Q14 OpusT_opus_int32, Gain_Q16 OpusT_opus_int32, Lambda_Q10 int32, offset_Q10 int32, length int32, subfr int32, shapingLPCOrder int32, predictLPCOrder int32, warping_Q16 int32, nStatesDelayedDecision int32, smpl_buf_idx uintptr, decisionDelay int32, arch int32) {
	var Gain_Q10, LPC_exc_Q14, LPC_pred_Q14, LTP_pred_Q14, RDmax_Q10, RDmin_Q10, Winner_rand_state, exc_Q14, n_AR_Q14, n_LF_Q14, n_LTP_Q14, out, q1_Q0, q1_Q10, q2_Q10, r_Q10, rd1_Q10, rd2_Q10, rr_Q10, sLF_AR_shp_Q14, tmp1, tmp2, xq_Q14, v37 OpusT_opus_int32
	var RDmax_ind, RDmin_ind, Winner_ind, i, j, k, last_smple_idx, rdo_offset, v30, v31, v32 int32
	var _saved_stack, pred_lag_ptr, psDD, psLPC_Q14, psSS, psSampleState, shp_lag_ptr, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Gain_Q10, LPC_exc_Q14, LPC_pred_Q14, LTP_pred_Q14, RDmax_Q10, RDmax_ind, RDmin_Q10, RDmin_ind, Winner_ind, Winner_rand_state, _saved_stack, exc_Q14, i, j, k, last_smple_idx, n_AR_Q14, n_LF_Q14, n_LTP_Q14, out, pred_lag_ptr, psDD, psLPC_Q14, psSS, psSampleState, q1_Q0, q1_Q10, q2_Q10, r_Q10, rd1_Q10, rd2_Q10, rdo_offset, rr_Q10, sLF_AR_shp_Q14, shp_lag_ptr, st, tmp1, tmp2, xq_Q14, v1, v11, v13, v15, v17, v19, v21, v23, v3, v30, v31, v32, v37, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(nStatesDelayedDecision > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+8512, __ccgo_ts+8490, int32(361))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nStatesDelayedDecision)*(libc.Uint64FromInt64(56)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+8490, int32(362))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nStatesDelayedDecision) * (libc.Uint64FromInt64(56) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	psSampleState = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nStatesDelayedDecision)*(libc.Uint64FromInt64(56)/libc.Uint64FromInt64(1)))
	shp_lag_ptr = NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-lag+libc.Int32FromInt32(HARM_SHAPE_FIR_TAPS)/libc.Int32FromInt32(2))*4
	pred_lag_ptr = sLTP_Q15 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx-lag+libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2))*4
	Gain_Q10 = Gain_Q16 >> int32(6)
	i = 0
	for {
		if !(i < length) {
			break
		}
		/* Perform common calculations used in all states */
		/* Long-term prediction */
		if signalType == int32(TYPE_VOICED) {
			/* Unrolled loop */
			/* Avoids introducing a bias because silk_SMLAWB() always rounds to -inf */
			LTP_pred_Q14 = int32(2)
			LTP_pred_Q14 = int32(int64(LTP_pred_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14)))>>libc.Int32FromInt32(16))
			LTP_pred_Q14 = int32(int64(LTP_pred_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 1*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q14 = int32(int64(LTP_pred_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 2*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q14 = int32(int64(LTP_pred_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 3*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q14 = int32(int64(LTP_pred_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(pred_lag_ptr + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(b_Q14 + 4*2)))>>libc.Int32FromInt32(16))
			LTP_pred_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(LTP_pred_Q14) << libc.Int32FromInt32(1)) /* Q13 -> Q14 */
			pred_lag_ptr += 4
		} else {
			LTP_pred_Q14 = 0
		}
		/* Long-term shaping */
		if lag > 0 {
			/* Symmetric, packed FIR coefficients */
			if (libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)))+libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr))&*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))&uint32(0x80000000) != uint32(0) {
					v31 = libc.Int32FromUint32(0x80000000)
				} else {
					v31 = *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)) + *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))
				}
				v30 = v31
			} else {
				if libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr))|*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4)))&uint32(0x80000000) == uint32(0) {
					v32 = int32(silk_int32_MAX)
				} else {
					v32 = *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr)) + *(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(2))*4))
				}
				v30 = v32
			}
			n_LTP_Q14 = int32(int64(v30) * int64(int16(HarmShapeFIRPacked_Q14)) >> libc.Int32FromInt32(16))
			n_LTP_Q14 = int32(int64(n_LTP_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(shp_lag_ptr + uintptr(-libc.Int32FromInt32(1))*4)))*(int64(HarmShapeFIRPacked_Q14)>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(16))
			n_LTP_Q14 = LTP_pred_Q14 - libc.Int32FromUint32(libc.Uint32FromInt32(n_LTP_Q14)<<libc.Int32FromInt32(2)) /* Q12 -> Q14 */
			shp_lag_ptr += 4
		} else {
			n_LTP_Q14 = 0
		}
		k = 0
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			/* Delayed decision state */
			psDD = psDelDec + uintptr(k)*1300
			/* Sample state */
			psSS = psSampleState + uintptr(k)*56
			/* Generate dither */
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(RAND_INCREMENT)) + libc.Uint32FromInt32((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed)*libc.Uint32FromInt32(libc.Int32FromInt32(RAND_MULTIPLIER)))
			/* Pointer used in short term prediction and shaping */
			psLPC_Q14 = psDD + uintptr(libc.Int32FromInt32(MAX_LPC_ORDER)-libc.Int32FromInt32(1)+i)*4
			/* Short-term prediction */
			_ = arch
			v1 = psLPC_Q14
			v3 = a_Q12
			v30 = predictLPCOrder
			_ = v30 == int32(10) || v30 == int32(16)
			out = v30 >> libc.Int32FromInt32(1)
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(1))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 1*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(2))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 2*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(3))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 3*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(4))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 4*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(5))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 5*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(6))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 6*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(7))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 7*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(8))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 8*2)))>>libc.Int32FromInt32(16))
			out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(9))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 9*2)))>>libc.Int32FromInt32(16))
			if v30 == libc.Int32FromInt32(16) {
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(10))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 10*2)))>>libc.Int32FromInt32(16))
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(11))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 11*2)))>>libc.Int32FromInt32(16))
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(12))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 12*2)))>>libc.Int32FromInt32(16))
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(13))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 13*2)))>>libc.Int32FromInt32(16))
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(14))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 14*2)))>>libc.Int32FromInt32(16))
				out = int32(int64(out) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(v1 + uintptr(-libc.Int32FromInt32(15))*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(v3 + 15*2)))>>libc.Int32FromInt32(16))
			}
			v37 = out
			goto _38
		_38:
			LPC_pred_Q14 = v37
			LPC_pred_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(LPC_pred_Q14) << libc.Int32FromInt32(4)) /* Q10 -> Q14 */
			/* Noise shape feedback */
			if !(shapingLPCOrder&libc.Int32FromInt32(1) == libc.Int32FromInt32(0)) {
				Opus_celt_fatal(tls, __ccgo_ts+8388, __ccgo_ts+8490, int32(419))
			} /* check that order is even */
			/* Output of lowpass section */
			tmp2 = int32(int64((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184)))*int64(int16(warping_Q16))>>libc.Int32FromInt32(16))
			/* Output of allpass section */
			tmp1 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184))) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + 1*4)))-libc.Uint32FromInt32(tmp2)))*int64(int16(warping_Q16))>>libc.Int32FromInt32(16))
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184)) = tmp2
			n_AR_Q14 = shapingLPCOrder >> libc.Int32FromInt32(1)
			n_AR_Q14 = int32(int64(n_AR_Q14) + int64(tmp2)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(AR_shp_Q13)))>>libc.Int32FromInt32(16))
			/* Loop over allpass sections */
			j = int32(2)
			for {
				if !(j < shapingLPCOrder) {
					break
				}
				/* Output of allpass section */
				tmp2 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j-int32(1))*4))) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j+0)*4)))-libc.Uint32FromInt32(tmp1)))*int64(int16(warping_Q16))>>libc.Int32FromInt32(16))
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j-int32(1))*4)) = tmp1
				n_AR_Q14 = int32(int64(n_AR_Q14) + int64(tmp1)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(AR_shp_Q13 + uintptr(j-int32(1))*2)))>>libc.Int32FromInt32(16))
				/* Output of allpass section */
				tmp1 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j+0)*4))) + int64(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j+int32(1))*4)))-libc.Uint32FromInt32(tmp2)))*int64(int16(warping_Q16))>>libc.Int32FromInt32(16))
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(j+0)*4)) = tmp2
				n_AR_Q14 = int32(int64(n_AR_Q14) + int64(tmp2)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(AR_shp_Q13 + uintptr(j)*2)))>>libc.Int32FromInt32(16))
				goto _39
			_39:
				;
				j = j + int32(2)
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(shapingLPCOrder-int32(1))*4)) = tmp1
			n_AR_Q14 = int32(int64(n_AR_Q14) + int64(tmp1)*int64(*(*OpusT_opus_int16)(unsafe.Pointer(AR_shp_Q13 + uintptr(shapingLPCOrder-int32(1))*2)))>>libc.Int32FromInt32(16))
			n_AR_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(n_AR_Q14) << libc.Int32FromInt32(1))                                                                                             /* Q11 -> Q12 */
			n_AR_Q14 = int32(int64(n_AR_Q14) + int64((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14)*int64(int16(Tilt_Q14))>>libc.Int32FromInt32(16))                               /* Q12 */
			n_AR_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(n_AR_Q14) << libc.Int32FromInt32(2))                                                                                             /* Q12 -> Q14 */
			n_LF_Q14 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4))) * int64(int16(LF_shp_Q14)) >> libc.Int32FromInt32(16)) /* Q12 */
			n_LF_Q14 = int32(int64(n_LF_Q14) + int64((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14)*(int64(LF_shp_Q14)>>libc.Int32FromInt32(16))>>libc.Int32FromInt32(16))         /* Q12 */
			n_LF_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(n_LF_Q14) << libc.Int32FromInt32(2))                                                                                             /* Q12 -> Q14 */
			/* Input minus prediction plus noise feedback                       */
			/* r = x[ i ] - LTP_pred - LPC_pred + n_AR + n_Tilt + n_LF + n_LTP  */
			if (libc.Uint32FromInt32(n_AR_Q14)+libc.Uint32FromInt32(n_LF_Q14))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(n_AR_Q14&n_LF_Q14)&uint32(0x80000000) != uint32(0) {
					v31 = libc.Int32FromUint32(0x80000000)
				} else {
					v31 = n_AR_Q14 + n_LF_Q14
				}
				v30 = v31
			} else {
				if libc.Uint32FromInt32(n_AR_Q14|n_LF_Q14)&uint32(0x80000000) == uint32(0) {
					v32 = int32(silk_int32_MAX)
				} else {
					v32 = n_AR_Q14 + n_LF_Q14
				}
				v30 = v32
			}
			tmp1 = v30                                                                                        /* Q14 */
			tmp2 = libc.Int32FromUint32(libc.Uint32FromInt32(n_LTP_Q14) + libc.Uint32FromInt32(LPC_pred_Q14)) /* Q13 */
			if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(tmp1))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&uint32(0x80000000) != 0 {
					v31 = libc.Int32FromUint32(0x80000000)
				} else {
					v31 = tmp2 - tmp1
				}
				v30 = v31
			} else {
				if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(tmp1)&uint32(0x80000000) != 0 {
					v32 = int32(silk_int32_MAX)
				} else {
					v32 = tmp2 - tmp1
				}
				v30 = v32
			}
			tmp1 = v30                                                                                                        /* Q13 */
			tmp1 = (tmp1>>(libc.Int32FromInt32(4)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1) /* Q10 */
			r_Q10 = *(*OpusT_opus_int32)(unsafe.Pointer(x_Q10 + uintptr(i)*4)) - tmp1                                         /* residual error Q10 */
			/* Flip sign depending on dither */
			if (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed < 0 {
				r_Q10 = -r_Q10
			}
			if r_Q10 > libc.Int32FromInt32(30)<<libc.Int32FromInt32(10) {
				v30 = libc.Int32FromInt32(30) << libc.Int32FromInt32(10)
			} else {
				if r_Q10 < -(libc.Int32FromInt32(31) << libc.Int32FromInt32(10)) {
					v31 = -(libc.Int32FromInt32(31) << libc.Int32FromInt32(10))
				} else {
					v31 = r_Q10
				}
				v30 = v31
			}
			r_Q10 = v30
			/* Find two quantization level candidates and measure their rate-distortion */
			q1_Q10 = r_Q10 - offset_Q10
			q1_Q0 = q1_Q10 >> int32(10)
			if Lambda_Q10 > int32(2048) {
				/* For aggressive RDO, the bias becomes more than one pulse. */
				rdo_offset = Lambda_Q10/int32(2) - int32(512)
				if q1_Q10 > rdo_offset {
					q1_Q0 = (q1_Q10 - rdo_offset) >> libc.Int32FromInt32(10)
				} else {
					if q1_Q10 < -rdo_offset {
						q1_Q0 = (q1_Q10 + rdo_offset) >> libc.Int32FromInt32(10)
					} else {
						if q1_Q10 < 0 {
							q1_Q0 = -int32(1)
						} else {
							q1_Q0 = 0
						}
					}
				}
			}
			if q1_Q0 > 0 {
				q1_Q10 = libc.Int32FromUint32(libc.Uint32FromInt32(q1_Q0)<<libc.Int32FromInt32(10)) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10)
				q1_Q10 = q1_Q10 + offset_Q10
				q2_Q10 = q1_Q10 + libc.Int32FromInt32(1024)
				rd1_Q10 = int32(int16(q1_Q10)) * int32(int16(Lambda_Q10))
				rd2_Q10 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
			} else {
				if q1_Q0 == 0 {
					q1_Q10 = offset_Q10
					q2_Q10 = q1_Q10 + (libc.Int32FromInt32(1024) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10))
					rd1_Q10 = int32(int16(q1_Q10)) * int32(int16(Lambda_Q10))
					rd2_Q10 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
				} else {
					if q1_Q0 == -int32(1) {
						q2_Q10 = offset_Q10
						q1_Q10 = q2_Q10 - (libc.Int32FromInt32(1024) - libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10))
						rd1_Q10 = int32(int16(-q1_Q10)) * int32(int16(Lambda_Q10))
						rd2_Q10 = int32(int16(q2_Q10)) * int32(int16(Lambda_Q10))
					} else { /* q1_Q0 < -1 */
						q1_Q10 = libc.Int32FromUint32(libc.Uint32FromInt32(q1_Q0)<<libc.Int32FromInt32(10)) + libc.Int32FromInt32(QUANT_LEVEL_ADJUST_Q10)
						q1_Q10 = q1_Q10 + offset_Q10
						q2_Q10 = q1_Q10 + libc.Int32FromInt32(1024)
						rd1_Q10 = int32(int16(-q1_Q10)) * int32(int16(Lambda_Q10))
						rd2_Q10 = int32(int16(-q2_Q10)) * int32(int16(Lambda_Q10))
					}
				}
			}
			rr_Q10 = r_Q10 - q1_Q10
			rd1_Q10 = (rd1_Q10 + int32(int16(rr_Q10))*int32(int16(rr_Q10))) >> libc.Int32FromInt32(10)
			rr_Q10 = r_Q10 - q2_Q10
			rd2_Q10 = (rd2_Q10 + int32(int16(rr_Q10))*int32(int16(rr_Q10))) >> libc.Int32FromInt32(10)
			if rd1_Q10 < rd2_Q10 {
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FRD_Q10 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 + rd1_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FRD_Q10 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 + rd2_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FQ_Q10 = q1_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FQ_Q10 = q2_Q10
			} else {
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FRD_Q10 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 + rd2_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FRD_Q10 = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 + rd1_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FQ_Q10 = q2_Q10
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FQ_Q10 = q1_Q10
			}
			/* Update states for best quantization */
			/* Quantized excitation */
			exc_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32((*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FQ_Q10) << libc.Int32FromInt32(4))
			if (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed < 0 {
				exc_Q14 = -exc_Q14
			}
			/* Add predictions */
			LPC_exc_Q14 = exc_Q14 + LTP_pred_Q14
			xq_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(LPC_exc_Q14) + libc.Uint32FromInt32(LPC_pred_Q14))
			/* Update states */
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FDiff_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(xq_Q14) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(x_Q10 + uintptr(i)*4)))<<libc.Int32FromInt32(4))))
			sLF_AR_shp_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32((*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FDiff_Q14) - libc.Uint32FromInt32(n_AR_Q14))
			if (libc.Uint32FromInt32(sLF_AR_shp_Q14)-libc.Uint32FromInt32(n_LF_Q14))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(sLF_AR_shp_Q14)&(libc.Uint32FromInt32(n_LF_Q14)^uint32(0x80000000))&uint32(0x80000000) != 0 {
					v31 = libc.Int32FromUint32(0x80000000)
				} else {
					v31 = sLF_AR_shp_Q14 - n_LF_Q14
				}
				v30 = v31
			} else {
				if (libc.Uint32FromInt32(sLF_AR_shp_Q14)^uint32(0x80000000))&libc.Uint32FromInt32(n_LF_Q14)&uint32(0x80000000) != 0 {
					v32 = int32(silk_int32_MAX)
				} else {
					v32 = sLF_AR_shp_Q14 - n_LF_Q14
				}
				v30 = v32
			}
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FsLTP_shp_Q14 = v30
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FLF_AR_Q14 = sLF_AR_shp_Q14
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).FLPC_exc_Q14 = LPC_exc_Q14
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS))).Fxq_Q14 = xq_Q14
			/* Update states for second best quantization */
			/* Quantized excitation */
			exc_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32((*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FQ_Q10) << libc.Int32FromInt32(4))
			if (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed < 0 {
				exc_Q14 = -exc_Q14
			}
			/* Add predictions */
			LPC_exc_Q14 = exc_Q14 + LTP_pred_Q14
			xq_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(LPC_exc_Q14) + libc.Uint32FromInt32(LPC_pred_Q14))
			/* Update states */
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FDiff_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32(xq_Q14) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(x_Q10 + uintptr(i)*4)))<<libc.Int32FromInt32(4))))
			sLF_AR_shp_Q14 = libc.Int32FromUint32(libc.Uint32FromInt32((*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FDiff_Q14) - libc.Uint32FromInt32(n_AR_Q14))
			if (libc.Uint32FromInt32(sLF_AR_shp_Q14)-libc.Uint32FromInt32(n_LF_Q14))&uint32(0x80000000) == uint32(0) {
				if libc.Uint32FromInt32(sLF_AR_shp_Q14)&(libc.Uint32FromInt32(n_LF_Q14)^uint32(0x80000000))&uint32(0x80000000) != 0 {
					v31 = libc.Int32FromUint32(0x80000000)
				} else {
					v31 = sLF_AR_shp_Q14 - n_LF_Q14
				}
				v30 = v31
			} else {
				if (libc.Uint32FromInt32(sLF_AR_shp_Q14)^uint32(0x80000000))&libc.Uint32FromInt32(n_LF_Q14)&uint32(0x80000000) != 0 {
					v32 = int32(silk_int32_MAX)
				} else {
					v32 = sLF_AR_shp_Q14 - n_LF_Q14
				}
				v30 = v32
			}
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FsLTP_shp_Q14 = v30
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FLF_AR_Q14 = sLF_AR_shp_Q14
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).FLPC_exc_Q14 = LPC_exc_Q14
			(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS + 1*28))).Fxq_Q14 = xq_Q14
			goto _33
		_33:
			;
			k = k + 1
		}
		*(*int32)(unsafe.Pointer(smpl_buf_idx)) = (*(*int32)(unsafe.Pointer(smpl_buf_idx)) - int32(1)) % int32(DECISION_DELAY)
		if *(*int32)(unsafe.Pointer(smpl_buf_idx)) < 0 {
			*(*int32)(unsafe.Pointer(smpl_buf_idx)) += int32(DECISION_DELAY)
		}
		last_smple_idx = (*(*int32)(unsafe.Pointer(smpl_buf_idx)) + decisionDelay) % int32(DECISION_DELAY)
		/* Find winner */
		RDmin_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState))).FRD_Q10
		Winner_ind = 0
		k = int32(1)
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			if (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10 < RDmin_Q10 {
				RDmin_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10
				Winner_ind = k
			}
			goto _54
		_54:
			;
			k = k + 1
		}
		/* Increase RD values of expired states */
		Winner_rand_state = *(*OpusT_opus_int32)(unsafe.Pointer(psDelDec + uintptr(Winner_ind)*1300 + 384 + uintptr(last_smple_idx)*4))
		k = 0
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			if *(*OpusT_opus_int32)(unsafe.Pointer(psDelDec + uintptr(k)*1300 + 384 + uintptr(last_smple_idx)*4)) != Winner_rand_state {
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10 + libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4)
				(*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56 + 1*28))).FRD_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56 + 1*28))).FRD_Q10 + libc.Int32FromInt32(silk_int32_MAX)>>libc.Int32FromInt32(4)
				_ = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10 >= libc.Int32FromInt32(0)
			}
			goto _55
		_55:
			;
			k = k + 1
		}
		/* Find worst in first set and best in second set */
		RDmax_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState))).FRD_Q10
		RDmin_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + 1*28))).FRD_Q10
		RDmax_ind = 0
		RDmin_ind = 0
		k = int32(1)
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			/* find worst in first set */
			if (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10 > RDmax_Q10 {
				RDmax_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56))).FRD_Q10
				RDmax_ind = k
			}
			/* find best in second set */
			if (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56 + 1*28))).FRD_Q10 < RDmin_Q10 {
				RDmin_Q10 = (*(*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSampleState + uintptr(k)*56 + 1*28))).FRD_Q10
				RDmin_ind = k
			}
			goto _56
		_56:
			;
			k = k + 1
		}
		/* Replace a state if best from second set outperforms worst in first set */
		if RDmin_Q10 < RDmax_Q10 {
			libc.Xmemcpy(tls, psDelDec+uintptr(RDmax_ind)*1300+uintptr(i)*4, psDelDec+uintptr(RDmin_ind)*1300+uintptr(i)*4, libc.Uint64FromInt64(1300)-libc.Uint64FromInt32(i)*libc.Uint64FromInt64(4))
			libc.Xmemcpy(tls, psSampleState+uintptr(RDmax_ind)*56, psSampleState+uintptr(RDmin_ind)*56+1*28, libc.Uint64FromInt64(28))
		}
		/* Write samples from winner to output and long-term filter states */
		psDD = psDelDec + uintptr(Winner_ind)*1300
		if subfr > 0 || i >= decisionDelay {
			*(*OpusT_opus_int8)(unsafe.Pointer(pulses + uintptr(i-decisionDelay))) = int8((*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 544 + uintptr(last_smple_idx)*4))>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1))
			if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(delayedGain_Q10 + uintptr(last_smple_idx)*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX9) {
				v30 = int32(silk_int16_MAX9)
			} else {
				if (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(delayedGain_Q10 + uintptr(last_smple_idx)*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
					v31 = int32(libc.Int16FromInt32(0x8000))
				} else {
					v31 = (int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(last_smple_idx)*4)))*int64(*(*OpusT_opus_int32)(unsafe.Pointer(delayedGain_Q10 + uintptr(last_smple_idx)*4)))>>libc.Int32FromInt32(16))>>(libc.Int32FromInt32(8)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
				}
				v30 = v31
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(xq + uintptr(i-decisionDelay)*2)) = int16(v30)
			*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx-decisionDelay)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(last_smple_idx)*4))
			*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx-decisionDelay)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(psDD + 864 + uintptr(last_smple_idx)*4))
		}
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx + 1
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx + 1
		/* Update states */
		k = 0
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			psDD = psDelDec + uintptr(k)*1300
			psSS = psSampleState + uintptr(k)*56
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14 = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FLF_AR_Q14
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14 = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FDiff_Q14
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + uintptr(int32(MAX_LPC_ORDER)+i)*4)) = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).Fxq_Q14
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 704 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).Fxq_Q14
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 544 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FQ_Q10
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 864 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FLPC_exc_Q14) << libc.Int32FromInt32(1))
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FsLTP_shp_Q14
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed) + libc.Uint32FromInt32(((*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FQ_Q10>>(libc.Int32FromInt32(10)-libc.Int32FromInt32(1))+libc.Int32FromInt32(1))>>libc.Int32FromInt32(1)))
			*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 384 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = (*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FSeed
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FRD_Q10 = (*OpusT_NSQ_sample_struct)(unsafe.Pointer(psSS)).FRD_Q10
			goto _59
		_59:
			;
			k = k + 1
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(delayedGain_Q10 + uintptr(*(*int32)(unsafe.Pointer(smpl_buf_idx)))*4)) = Gain_Q10
		goto _29
	_29:
		;
		i = i + 1
	}
	/* Update LPC states */
	k = 0
	for {
		if !(k < nStatesDelayedDecision) {
			break
		}
		psDD = psDelDec + uintptr(k)*1300
		libc.Xmemcpy(tls, psDD, psDD+uintptr(length)*4, libc.Uint64FromInt32(MAX_LPC_ORDER)*libc.Uint64FromInt64(4))
		goto _60
	_60:
		;
		k = k + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _64
_64:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func silk_nsq_del_dec_scale_states(tls *libc.TLS, psEncC uintptr, NSQ uintptr, psDelDec uintptr, x16 uintptr, x_sc_Q10 uintptr, sLTP uintptr, sLTP_Q15 uintptr, subfr int32, nStatesDelayedDecision int32, LTP_scale_Q14 int32, Gains_Q16 uintptr, pitchL uintptr, signal_type int32, decisionDelay int32) {
	var a32_nrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, err_Q32, gain_adj_Q16, inv_gain_Q26, inv_gain_Q31, result, result1, v18, v19, v2, v22, v5, v6, v9 OpusT_opus_int32
	var a_headrm, b_headrm, b_headrm1, i, k, lag, lshift, lshift1, v1, v11, v12, v13, v14, v15, v20, v3, v4, v8 int32
	var psDD uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a32_nrm, a_headrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, b_headrm, b_headrm1, err_Q32, gain_adj_Q16, i, inv_gain_Q26, inv_gain_Q31, k, lag, lshift, lshift1, psDD, result, result1, v1, v11, v12, v13, v14, v15, v18, v19, v2, v20, v22, v3, v4, v5, v6, v8, v9
	lag = *(*int32)(unsafe.Pointer(pitchL + uintptr(subfr)*4))
	if *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4)) > int32(1) {
		v1 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
	} else {
		v1 = int32(1)
	}
	v2 = v1
	v3 = int32(47)
	_ = v2 != libc.Int32FromInt32(0)
	_ = v3 > libc.Int32FromInt32(0)
	if v2 > 0 {
		v4 = v2
	} else {
		v4 = -v2
	}
	v5 = v4
	if v5 != 0 {
		v8 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v5)))
	} else {
		v8 = int32(32)
	}
	v6 = v8
	goto _7
_7:
	b_headrm1 = v6 - int32(1)
	b32_nrm1 = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << b_headrm1)
	b32_inv1 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm1 >> libc.Int32FromInt32(16))
	result1 = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv1) << libc.Int32FromInt32(16))
	err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm1)*int64(int16(b32_inv1))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
	result1 = int32(int64(result1) + int64(err_Q32)*int64(b32_inv1)>>libc.Int32FromInt32(16))
	lshift1 = int32(61) - b_headrm1 - v3
	if lshift1 <= libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift1 > int32(silk_int32_MAX)>>-lshift1 {
			if result1 > libc.Int32FromUint32(0x80000000)>>-lshift1 {
				v12 = libc.Int32FromUint32(0x80000000) >> -lshift1
			} else {
				if result1 < int32(silk_int32_MAX)>>-lshift1 {
					v13 = int32(silk_int32_MAX) >> -lshift1
				} else {
					v13 = result1
				}
				v12 = v13
			}
			v11 = v12
		} else {
			if result1 > int32(silk_int32_MAX)>>-lshift1 {
				v14 = int32(silk_int32_MAX) >> -lshift1
			} else {
				if result1 < libc.Int32FromUint32(0x80000000)>>-lshift1 {
					v15 = libc.Int32FromUint32(0x80000000) >> -lshift1
				} else {
					v15 = result1
				}
				v14 = v15
			}
			v11 = v14
		}
		v9 = libc.Int32FromUint32(libc.Uint32FromInt32(v11) << -lshift1)
		goto _10
	} else {
		if lshift1 < libc.Int32FromInt32(32) {
			v9 = result1 >> lshift1
			goto _10
		} else {
			v9 = 0
			goto _10
		}
	}
_10:
	inv_gain_Q31 = v9
	_ = inv_gain_Q31 != libc.Int32FromInt32(0)
	/* Scale input */
	inv_gain_Q26 = (inv_gain_Q31>>(libc.Int32FromInt32(5)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(x_sc_Q10 + uintptr(i)*4)) = int32(int64(*(*OpusT_opus_int16)(unsafe.Pointer(x16 + uintptr(i)*2))) * int64(inv_gain_Q26) >> libc.Int32FromInt32(16))
		goto _16
	_16:
		;
		i = i + 1
	}
	/* After rewhitening the LTP state is un-scaled, so scale with inv_gain_Q16 */
	if (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag != 0 {
		if subfr == 0 {
			/* Do LTP downscaling */
			inv_gain_Q31 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(inv_gain_Q31)*int64(int16(LTP_scale_Q14))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		}
		i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx - lag - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
		for {
			if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx) {
				break
			}
			_ = i < libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)
			*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4)) = int32(int64(inv_gain_Q31) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr(i)*2))) >> libc.Int32FromInt32(16))
			goto _17
		_17:
			;
			i = i + 1
		}
	}
	/* Adjust for changing gain */
	if *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4)) != (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 {
		v2 = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16
		v5 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
		v1 = int32(16)
		_ = v5 != libc.Int32FromInt32(0)
		_ = v1 >= libc.Int32FromInt32(0)
		if v2 > 0 {
			v3 = v2
		} else {
			v3 = -v2
		}
		v6 = v3
		if v6 != 0 {
			v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v6)))
		} else {
			v4 = int32(32)
		}
		v9 = v4
		goto _24
	_24:
		a_headrm = v9 - int32(1)
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << a_headrm)
		if v5 > 0 {
			v8 = v5
		} else {
			v8 = -v5
		}
		v18 = v8
		if v18 != 0 {
			v11 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v18)))
		} else {
			v11 = int32(32)
		}
		v19 = v11
		goto _29
	_29:
		b_headrm = v19 - int32(1)
		b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v5) << b_headrm)
		b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
		result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
		result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
		lshift = int32(29) + a_headrm - b_headrm - v1
		if lshift < libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
				if result > libc.Int32FromUint32(0x80000000)>>-lshift {
					v13 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					if result < int32(silk_int32_MAX)>>-lshift {
						v14 = int32(silk_int32_MAX) >> -lshift
					} else {
						v14 = result
					}
					v13 = v14
				}
				v12 = v13
			} else {
				if result > int32(silk_int32_MAX)>>-lshift {
					v15 = int32(silk_int32_MAX) >> -lshift
				} else {
					if result < libc.Int32FromUint32(0x80000000)>>-lshift {
						v20 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						v20 = result
					}
					v15 = v20
				}
				v12 = v15
			}
			v22 = libc.Int32FromUint32(libc.Uint32FromInt32(v12) << -lshift)
			goto _32
		} else {
			if lshift < libc.Int32FromInt32(32) {
				v22 = result >> lshift
				goto _32
			} else {
				v22 = 0
				goto _32
			}
		}
	_32:
		gain_adj_Q16 = v22
		/* Scale long-term shaping state */
		i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx - (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
		for {
			if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
			goto _38
		_38:
			;
			i = i + 1
		}
		/* Scale long-term prediction state */
		if signal_type == int32(TYPE_VOICED) && (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag == 0 {
			i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx - lag - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
			for {
				if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx-decisionDelay) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _39
			_39:
				;
				i = i + 1
			}
		}
		k = 0
		for {
			if !(k < nStatesDelayedDecision) {
				break
			}
			psDD = psDelDec + uintptr(k)*1300
			/* Scale scalar states */
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14 = int32(int64(gain_adj_Q16) * int64((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FLF_AR_Q14) >> libc.Int32FromInt32(16))
			(*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14 = int32(int64(gain_adj_Q16) * int64((*OpusT_NSQ_del_dec_struct)(unsafe.Pointer(psDD)).FDiff_Q14) >> libc.Int32FromInt32(16))
			/* Scale short-term prediction and shaping states */
			i = 0
			for {
				if !(i < int32(MAX_LPC_ORDER)) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _41
			_41:
				;
				i = i + 1
			}
			i = 0
			for {
				if !(i < int32(MAX_SHAPE_LPC_ORDER)) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1184 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _42
			_42:
				;
				i = i + 1
			}
			i = 0
			for {
				if !(i < int32(DECISION_DELAY)) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 864 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 864 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(psDD + 1024 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _43
			_43:
				;
				i = i + 1
			}
			goto _40
		_40:
			;
			k = k + 1
		}
		/* Save inverse gain */
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
	}
}

const NB_ATT = 2

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

var HARM_ATT_Q15 = [2]OpusT_opus_int16{
	0: int16(32440),
	1: int16(31130),
} /* 0.99, 0.95 */
var PLC_RAND_ATTENUATE_V_Q15 = [2]OpusT_opus_int16{
	0: int16(31130),
	1: int16(26214),
} /* 0.95, 0.8 */
var PLC_RAND_ATTENUATE_UV_Q15 = [2]OpusT_opus_int16{
	0: int16(32440),
	1: int16(29491),
}

func silk_nsq_scale_states(tls *libc.TLS, psEncC uintptr, NSQ uintptr, x16 uintptr, x_sc_Q10 uintptr, sLTP uintptr, sLTP_Q15 uintptr, subfr int32, LTP_scale_Q14 int32, Gains_Q16 uintptr, pitchL uintptr, signal_type int32) {
	var a32_nrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, err_Q32, gain_adj_Q16, inv_gain_Q26, inv_gain_Q31, result, result1, v18, v19, v2, v22, v5, v6, v9 OpusT_opus_int32
	var a_headrm, b_headrm, b_headrm1, i, lag, lshift, lshift1, v1, v11, v12, v13, v14, v15, v20, v3, v4, v8 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a32_nrm, a_headrm, b32_inv, b32_inv1, b32_nrm, b32_nrm1, b_headrm, b_headrm1, err_Q32, gain_adj_Q16, i, inv_gain_Q26, inv_gain_Q31, lag, lshift, lshift1, result, result1, v1, v11, v12, v13, v14, v15, v18, v19, v2, v20, v22, v3, v4, v5, v6, v8, v9
	lag = *(*int32)(unsafe.Pointer(pitchL + uintptr(subfr)*4))
	if *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4)) > int32(1) {
		v1 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
	} else {
		v1 = int32(1)
	}
	v2 = v1
	v3 = int32(47)
	_ = v2 != libc.Int32FromInt32(0)
	_ = v3 > libc.Int32FromInt32(0)
	if v2 > 0 {
		v4 = v2
	} else {
		v4 = -v2
	}
	v5 = v4
	if v5 != 0 {
		v8 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v5)))
	} else {
		v8 = int32(32)
	}
	v6 = v8
	goto _7
_7:
	b_headrm1 = v6 - int32(1)
	b32_nrm1 = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << b_headrm1)
	b32_inv1 = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm1 >> libc.Int32FromInt32(16))
	result1 = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv1) << libc.Int32FromInt32(16))
	err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm1)*int64(int16(b32_inv1))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
	result1 = int32(int64(result1) + int64(err_Q32)*int64(b32_inv1)>>libc.Int32FromInt32(16))
	lshift1 = int32(61) - b_headrm1 - v3
	if lshift1 <= libc.Int32FromInt32(0) {
		if libc.Int32FromUint32(0x80000000)>>-lshift1 > int32(silk_int32_MAX)>>-lshift1 {
			if result1 > libc.Int32FromUint32(0x80000000)>>-lshift1 {
				v12 = libc.Int32FromUint32(0x80000000) >> -lshift1
			} else {
				if result1 < int32(silk_int32_MAX)>>-lshift1 {
					v13 = int32(silk_int32_MAX) >> -lshift1
				} else {
					v13 = result1
				}
				v12 = v13
			}
			v11 = v12
		} else {
			if result1 > int32(silk_int32_MAX)>>-lshift1 {
				v14 = int32(silk_int32_MAX) >> -lshift1
			} else {
				if result1 < libc.Int32FromUint32(0x80000000)>>-lshift1 {
					v15 = libc.Int32FromUint32(0x80000000) >> -lshift1
				} else {
					v15 = result1
				}
				v14 = v15
			}
			v11 = v14
		}
		v9 = libc.Int32FromUint32(libc.Uint32FromInt32(v11) << -lshift1)
		goto _10
	} else {
		if lshift1 < libc.Int32FromInt32(32) {
			v9 = result1 >> lshift1
			goto _10
		} else {
			v9 = 0
			goto _10
		}
	}
_10:
	inv_gain_Q31 = v9
	_ = inv_gain_Q31 != libc.Int32FromInt32(0)
	/* Scale input */
	inv_gain_Q26 = (inv_gain_Q31>>(libc.Int32FromInt32(5)-libc.Int32FromInt32(1)) + libc.Int32FromInt32(1)) >> libc.Int32FromInt32(1)
	i = 0
	for {
		if !(i < (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fsubfr_length) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(x_sc_Q10 + uintptr(i)*4)) = int32(int64(*(*OpusT_opus_int16)(unsafe.Pointer(x16 + uintptr(i)*2))) * int64(inv_gain_Q26) >> libc.Int32FromInt32(16))
		goto _16
	_16:
		;
		i = i + 1
	}
	/* After rewhitening the LTP state is un-scaled, so scale with inv_gain_Q16 */
	if (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag != 0 {
		if subfr == 0 {
			/* Do LTP downscaling */
			inv_gain_Q31 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(inv_gain_Q31)*int64(int16(LTP_scale_Q14))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(2))
		}
		i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx - lag - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
		for {
			if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx) {
				break
			}
			_ = i < libc.Int32FromInt32(SUB_FRAME_LENGTH_MS)*libc.Int32FromInt32(MAX_NB_SUBFR)*libc.Int32FromInt32(MAX_FS_KHZ)
			*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4)) = int32(int64(inv_gain_Q31) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(sLTP + uintptr(i)*2))) >> libc.Int32FromInt32(16))
			goto _17
		_17:
			;
			i = i + 1
		}
	}
	/* Adjust for changing gain */
	if *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4)) != (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 {
		v2 = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16
		v5 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
		v1 = int32(16)
		_ = v5 != libc.Int32FromInt32(0)
		_ = v1 >= libc.Int32FromInt32(0)
		if v2 > 0 {
			v3 = v2
		} else {
			v3 = -v2
		}
		v6 = v3
		if v6 != 0 {
			v4 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v6)))
		} else {
			v4 = int32(32)
		}
		v9 = v4
		goto _24
	_24:
		a_headrm = v9 - int32(1)
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v2) << a_headrm)
		if v5 > 0 {
			v8 = v5
		} else {
			v8 = -v5
		}
		v18 = v8
		if v18 != 0 {
			v11 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v18)))
		} else {
			v11 = int32(32)
		}
		v19 = v11
		goto _29
	_29:
		b_headrm = v19 - int32(1)
		b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v5) << b_headrm)
		b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
		result = int32(int64(a32_nrm) * int64(int16(b32_inv)) >> libc.Int32FromInt32(16))
		a32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(a32_nrm) - libc.Uint32FromInt32(libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(b32_nrm)*int64(result)>>libc.Int32FromInt32(32)))<<libc.Int32FromInt32(3))))
		result = int32(int64(result) + int64(a32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))
		lshift = int32(29) + a_headrm - b_headrm - v1
		if lshift < libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
				if result > libc.Int32FromUint32(0x80000000)>>-lshift {
					v13 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					if result < int32(silk_int32_MAX)>>-lshift {
						v14 = int32(silk_int32_MAX) >> -lshift
					} else {
						v14 = result
					}
					v13 = v14
				}
				v12 = v13
			} else {
				if result > int32(silk_int32_MAX)>>-lshift {
					v15 = int32(silk_int32_MAX) >> -lshift
				} else {
					if result < libc.Int32FromUint32(0x80000000)>>-lshift {
						v20 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						v20 = result
					}
					v15 = v20
				}
				v12 = v15
			}
			v22 = libc.Int32FromUint32(libc.Uint32FromInt32(v12) << -lshift)
			goto _32
		} else {
			if lshift < libc.Int32FromInt32(32) {
				v22 = result >> lshift
				goto _32
			} else {
				v22 = 0
				goto _32
			}
		}
	_32:
		gain_adj_Q16 = v22
		/* Scale long-term shaping state */
		i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx - (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fltp_mem_length
		for {
			if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_shp_buf_idx) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 1280 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
			goto _38
		_38:
			;
			i = i + 1
		}
		/* Scale long-term prediction state */
		if signal_type == int32(TYPE_VOICED) && (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Frewhite_flag == 0 {
			i = (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx - lag - libc.Int32FromInt32(LTP_ORDER)/libc.Int32FromInt32(2)
			for {
				if !(i < (*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLTP_buf_idx) {
					break
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(sLTP_Q15 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
				goto _39
			_39:
				;
				i = i + 1
			}
		}
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14 = int32(int64(gain_adj_Q16) * int64((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsLF_AR_shp_Q14) >> libc.Int32FromInt32(16))
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14 = int32(int64(gain_adj_Q16) * int64((*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).FsDiff_shp_Q14) >> libc.Int32FromInt32(16))
		/* Scale short-term prediction and shaping states */
		i = 0
		for {
			if !(i < int32(MAX_LPC_ORDER)) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 3840 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 3840 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
			goto _40
		_40:
			;
			i = i + 1
		}
		i = 0
		for {
			if !(i < int32(MAX_SHAPE_LPC_ORDER)) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 4224 + uintptr(i)*4)) = int32(int64(gain_adj_Q16) * int64(*(*OpusT_opus_int32)(unsafe.Pointer(NSQ + 4224 + uintptr(i)*4))) >> libc.Int32FromInt32(16))
			goto _41
		_41:
			;
			i = i + 1
		}
		/* Save inverse gain */
		(*OpusT_silk_nsq_state)(unsafe.Pointer(NSQ)).Fprev_gain_Q16 = *(*OpusT_opus_int32)(unsafe.Pointer(Gains_Q16 + uintptr(subfr)*4))
	}
}

type OpusT_NSQ_del_dec_struct = struct {
	FsLPC_Q14  [96]OpusT_opus_int32
	FRandState [40]OpusT_opus_int32
	FQ_Q10     [40]OpusT_opus_int32
	FXq_Q14    [40]OpusT_opus_int32
	FPred_Q15  [40]OpusT_opus_int32
	FShape_Q14 [40]OpusT_opus_int32
	FsAR2_Q14  [24]OpusT_opus_int32
	FLF_AR_Q14 OpusT_opus_int32
	FDiff_Q14  OpusT_opus_int32
	FSeed      OpusT_opus_int32
	FSeedInit  OpusT_opus_int32
	FRD_Q10    OpusT_opus_int32
}

type OpusT_NSQ_sample_struct = struct {
	FQ_Q10        OpusT_opus_int32
	FRD_Q10       OpusT_opus_int32
	Fxq_Q14       OpusT_opus_int32
	FLF_AR_Q14    OpusT_opus_int32
	FDiff_Q14     OpusT_opus_int32
	FsLTP_shp_Q14 OpusT_opus_int32
	FLPC_exc_Q14  OpusT_opus_int32
}

type OpusT_NSQ_sample_pair = [2]OpusT_NSQ_sample_struct

func silk_resampler_down2_hp(tls *libc.TLS, S uintptr, out uintptr, in uintptr, inLen int32) (r OpusT_opus_val32) {
	var X, Y, in32, out32, out32_hp OpusT_opus_val32
	var hp_ener OpusT_opus_val64
	var k, len2 int32
	_, _, _, _, _, _, _, _ = X, Y, hp_ener, in32, k, len2, out32, out32_hp
	len2 = inLen / int32(2)
	hp_ener = libc.Float32FromInt32(0)
	/* Internal variables and state are in Q10 format */
	k = 0
	for {
		if !(k < len2) {
			break
		}
		/* Convert to Q10 */
		in32 = *(*OpusT_opus_val32)(unsafe.Pointer(in + uintptr(int32(2)*k)*4))
		/* All-pass section for even input sample */
		Y = in32 - *(*OpusT_opus_val32)(unsafe.Pointer(S))
		X = float32(libc.Float32FromFloat32(0.6074371) * Y)
		out32 = *(*OpusT_opus_val32)(unsafe.Pointer(S)) + X
		*(*OpusT_opus_val32)(unsafe.Pointer(S)) = in32 + X
		out32_hp = out32
		/* Convert to Q10 */
		in32 = *(*OpusT_opus_val32)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*4))
		/* All-pass section for odd input sample, and add to output of previous section */
		Y = in32 - *(*OpusT_opus_val32)(unsafe.Pointer(S + 1*4))
		X = float32(libc.Float32FromFloat32(0.15063) * Y)
		out32 = out32 + *(*OpusT_opus_val32)(unsafe.Pointer(S + 1*4))
		out32 = out32 + X
		*(*OpusT_opus_val32)(unsafe.Pointer(S + 1*4)) = in32 + X
		Y = -in32 - *(*OpusT_opus_val32)(unsafe.Pointer(S + 2*4))
		X = float32(libc.Float32FromFloat32(0.15063) * Y)
		out32_hp = out32_hp + *(*OpusT_opus_val32)(unsafe.Pointer(S + 2*4))
		out32_hp = out32_hp + X
		*(*OpusT_opus_val32)(unsafe.Pointer(S + 2*4)) = -in32 + X
		/* len2 can be up to 480, so we shift by 8 to make it fit. */
		hp_ener = hp_ener + OpusT_opus_val32(out32_hp*out32_hp)
		/* Add, convert back to int16 and store to output */
		*(*OpusT_opus_val32)(unsafe.Pointer(out + uintptr(k)*4)) = float32(libc.Float32FromFloat32(0.5) * out32)
		goto _1
	_1:
		;
		k = k + 1
	}
	return hp_ener
}

func silk_resampler_private_IIR_FIR_INTERPOL(tls *libc.TLS, out uintptr, buf uintptr, max_index_Q16 OpusT_opus_int32, index_increment_Q16 OpusT_opus_int32) (r uintptr) {
	var buf_ptr, v2 uintptr
	var index_Q16, res_Q15, table_index OpusT_opus_int32
	var v3, v4 int32
	_, _, _, _, _, _, _ = buf_ptr, index_Q16, res_Q15, table_index, v2, v3, v4
	/* Interpolate upsampled signal and store in output array */
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		table_index = int32(int64(index_Q16&libc.Int32FromInt32(0xFFFF)) * int64(int16(libc.Int32FromInt32(12))) >> libc.Int32FromInt32(16))
		buf_ptr = buf + uintptr(index_Q16>>int32(16))*2
		res_Q15 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr))) * int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 1*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 1*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 2*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 2*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 3*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(table_index)*8 + 3*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 4*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 3*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 5*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 2*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 6*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8 + 1*2)))
		res_Q15 = res_Q15 + int32(*(*OpusT_opus_int16)(unsafe.Pointer(buf_ptr + 7*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_silk_resampler_frac_FIR_12)) + uintptr(int32(11)-table_index)*8)))
		v2 = out
		out += 2
		if (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
			v3 = int32(silk_int16_MAX25)
		} else {
			if (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v4 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v4 = (res_Q15>>(libc.Int32FromInt32(15)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v3 = v4
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v2)) = int16(v3)
		goto _1
	_1:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	return out
}

// C documentation
//
//	/* Upsample using a combination of allpass-based 2x upsampling and FIR interpolation */

func silk_resampler_private_down_FIR_INTERPOL(tls *libc.TLS, out uintptr, buf uintptr, FIR_Coefs uintptr, FIR_Order int32, FIR_Fracs int32, max_index_Q16 OpusT_opus_int32, index_increment_Q16 OpusT_opus_int32) (r uintptr) {
	var buf_ptr, interpol_ptr, v9 uintptr
	var index_Q16, interpol_ind, res_Q6 OpusT_opus_int32
	var v10, v11 int32
	_, _, _, _, _, _, _, _ = buf_ptr, index_Q16, interpol_ind, interpol_ptr, res_Q6, v10, v11, v9
	switch FIR_Order {
	case int32(RESAMPLER_DOWN_ORDER_FIR0):
		goto _1
	case int32(RESAMPLER_DOWN_ORDER_FIR1):
		goto _2
	case int32(RESAMPLER_DOWN_ORDER_FIR2):
		goto _3
	default:
		goto _4
	}
	goto _5
_1:
	;
	index_Q16 = 0
_8:
	;
	if !(index_Q16 < max_index_Q16) {
		goto _6
	}
	/* Integer part gives pointer to buffered input */
	buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
	/* Fractional part gives interpolation coefficients */
	interpol_ind = int32(int64(index_Q16&libc.Int32FromInt32(0xFFFF)) * int64(int16(FIR_Fracs)) >> libc.Int32FromInt32(16))
	/* Inner product */
	interpol_ptr = FIR_Coefs + uintptr(libc.Int32FromInt32(RESAMPLER_DOWN_ORDER_FIR0)/libc.Int32FromInt32(2)*interpol_ind)*2
	res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr))) >> libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 1*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 2*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 3*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 4*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 5*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 6*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 7*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 8*2)))>>libc.Int32FromInt32(16))
	interpol_ptr = FIR_Coefs + uintptr(libc.Int32FromInt32(RESAMPLER_DOWN_ORDER_FIR0)/libc.Int32FromInt32(2)*(FIR_Fracs-int32(1)-interpol_ind))*2
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 1*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 2*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 3*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 4*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 5*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 6*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 7*2)))>>libc.Int32FromInt32(16))
	res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(interpol_ptr + 8*2)))>>libc.Int32FromInt32(16))
	/* Scale down, saturate and store in output array */
	v9 = out
	out += 2
	if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
		v10 = int32(silk_int16_MAX25)
	} else {
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
			v11 = int32(libc.Int16FromInt32(0x8000))
		} else {
			v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
		}
		v10 = v11
	}
	*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
	goto _7
_7:
	;
	index_Q16 = index_Q16 + index_increment_Q16
	goto _8
	goto _6
_6:
	;
	goto _5
_2:
	;
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		/* Integer part gives pointer to buffered input */
		buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
		/* Inner product */
		res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 23*4))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs))) >> libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 22*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 1*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 21*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 2*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 20*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 3*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 19*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 4*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 18*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 5*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 6*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 7*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 8*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 9*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 10*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 11*2)))>>libc.Int32FromInt32(16))
		/* Scale down, saturate and store in output array */
		v9 = out
		out += 2
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
			v10 = int32(silk_int16_MAX25)
		} else {
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v11 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v10 = v11
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
		goto _12
	_12:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	goto _5
_3:
	;
	index_Q16 = 0
	for {
		if !(index_Q16 < max_index_Q16) {
			break
		}
		/* Integer part gives pointer to buffered input */
		buf_ptr = buf + uintptr(index_Q16>>libc.Int32FromInt32(16))*4
		/* Inner product */
		res_Q6 = int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 35*4))) * int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs))) >> libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 1*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 34*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 1*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 2*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 33*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 2*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 3*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 32*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 3*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 4*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 31*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 4*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 5*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 30*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 5*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 6*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 29*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 6*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 7*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 28*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 7*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 8*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 27*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 8*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 9*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 26*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 9*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 10*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 25*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 10*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 11*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 24*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 11*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 12*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 23*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 12*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 13*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 22*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 13*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 14*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 21*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 14*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 15*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 20*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 15*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 16*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 19*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 16*2)))>>libc.Int32FromInt32(16))
		res_Q6 = int32(int64(res_Q6) + int64(*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 17*4))+*(*OpusT_opus_int32)(unsafe.Pointer(buf_ptr + 18*4)))*int64(*(*OpusT_opus_int16)(unsafe.Pointer(FIR_Coefs + 17*2)))>>libc.Int32FromInt32(16))
		/* Scale down, saturate and store in output array */
		v9 = out
		out += 2
		if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) > int32(silk_int16_MAX25) {
			v10 = int32(silk_int16_MAX25)
		} else {
			if (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1))+int32(1))>>int32(1) < int32(libc.Int16FromInt32(0x8000)) {
				v11 = int32(libc.Int16FromInt32(0x8000))
			} else {
				v11 = (res_Q6>>(libc.Int32FromInt32(6)-libc.Int32FromInt32(1)) + int32(1)) >> int32(1)
			}
			v10 = v11
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(v9)) = int16(v10)
		goto _16
	_16:
		;
		index_Q16 = index_Q16 + index_increment_Q16
	}
	goto _5
_4:
	;
	if !(libc.Int32FromInt32(0) != 0) {
		Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+10491, int32(139))
	}
_5:
	;
	return out
}

// C documentation
//
//	/* Resample with a 2nd order AR filter followed by FIR interpolation */

func silk_setup_LBRR(tls *libc.TLS, psEncC uintptr, encControl uintptr) (r int32) {
	var LBRR_in_previous_packet, ret, v1, v2, v3, v5 int32
	_, _, _, _, _, _ = LBRR_in_previous_packet, ret, v1, v2, v3, v5
	ret = SILK_NO_ERROR
	LBRR_in_previous_packet = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FLBRR_enabled
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FLBRR_enabled = (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FLBRR_coded
	if (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FLBRR_enabled != 0 {
		/* Set gain increase for coding LBRR excitation */
		if LBRR_in_previous_packet == 0 {
			/* Previous packet did not have LBRR, and was therefore coded at a higher bitrate */
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FLBRR_GainIncreases = int32(7)
		} else {
			v1 = int32(7) - int32(int64((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FPacketLoss_perc)*int64(int16(int32(float64(libc.Float64FromFloat64(0.2)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))))>>libc.Int32FromInt32(16))
			v2 = int32(3)
			if v1 > v2 {
				v5 = v1
			} else {
				v5 = v2
			}
			v3 = v5
			goto _4
		_4:
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FLBRR_GainIncreases = v3
		}
	}
	return ret
}

const BIN_DIV_STEPS_A2NLSF_FIX = 3
const CELT_SIG_SCALE16 = "32768.f"
const MAX_ITERATIONS_A2NLSF_FIX = 16

/* Number of binary divisions, when not in low complexity mode */

// C documentation
//
//	/* Helper function for A2NLSF(..)                    */
//	/* Transforms polynomials from cos(n*f) to cos(f)^n  */

func silk_setup_complexity(tls *libc.TLS, psEncC uintptr, Complexity int32) (r int32) {
	var ret, v1, v2, v3, v5 int32
	_, _, _, _, _ = ret, v1, v2, v3, v5
	ret = 0
	/* Set encoding complexity */
	if !(Complexity >= 0 && Complexity <= int32(10)) {
		Opus_celt_fatal(tls, __ccgo_ts+9484, __ccgo_ts+9289, int32(315))
	}
	if Complexity < int32(1) {
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = SILK_PE_MIN_COMPLEX
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.8)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(6)
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(12)
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(3) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(1)
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = 0
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(2)
		(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = 0
	} else {
		if Complexity < int32(2) {
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = int32(SILK_PE_MID_COMPLEX)
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.76)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(8)
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(14)
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(5) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(1)
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = 0
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(3)
			(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = 0
		} else {
			if Complexity < int32(3) {
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = SILK_PE_MIN_COMPLEX
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.8)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(6)
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(12)
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(3) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(2)
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = 0
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(2)
				(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = 0
			} else {
				if Complexity < int32(4) {
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = int32(SILK_PE_MID_COMPLEX)
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.76)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(8)
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(14)
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(5) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(2)
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = 0
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(4)
					(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = 0
				} else {
					if Complexity < int32(6) {
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = int32(SILK_PE_MID_COMPLEX)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.74)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(10)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(16)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(5) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(2)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = int32(1)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(6)
						(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz * int32(float64(libc.Float32FromFloat32(0.015)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))
					} else {
						if Complexity < int32(8) {
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = int32(SILK_PE_MID_COMPLEX)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.72)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(12)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(20)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(5) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(3)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = int32(1)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(8)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz * int32(float64(libc.Float32FromFloat32(0.015)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))
						} else {
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationComplexity = int32(SILK_PE_MAX_COMPLEX)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationThreshold_Q16 = int32(float64(libc.Float64FromFloat64(0.7)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = int32(16)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder = int32(24)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape = int32(5) * (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision = int32(MAX_DEL_DEC_STATES)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FuseInterpolatedNLSFs = int32(1)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FNLSF_MSVQ_Survivors = int32(16)
							(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz * int32(float64(libc.Float32FromFloat32(0.015)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))
						}
					}
				}
			}
		}
	}
	/* Do not allow higher pitch estimation LPC order than predict LPC order */
	v1 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder
	v2 = (*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpredictLPCOrder
	if v1 < v2 {
		v5 = v1
	} else {
		v5 = v2
	}
	v3 = v5
	goto _4
_4:
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder = v3
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapeWinLength = int32(SUB_FRAME_LENGTH_MS)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Ffs_kHz + int32(2)*(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape
	(*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FComplexity = Complexity
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FpitchEstimationLPCOrder <= libc.Int32FromInt32(MAX_FIND_PITCH_LPC_ORDER)) {
		Opus_celt_fatal(tls, __ccgo_ts+9538, __ccgo_ts+9289, int32(393))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapingLPCOrder <= libc.Int32FromInt32(MAX_SHAPE_LPC_ORDER)) {
		Opus_celt_fatal(tls, __ccgo_ts+9616, __ccgo_ts+9289, int32(394))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FnStatesDelayedDecision <= libc.Int32FromInt32(MAX_DEL_DEC_STATES)) {
		Opus_celt_fatal(tls, __ccgo_ts+9681, __ccgo_ts+9289, int32(395))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fwarping_Q16 <= libc.Int32FromInt32(32767)) {
		Opus_celt_fatal(tls, __ccgo_ts+9752, __ccgo_ts+9289, int32(396))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).Fla_shape <= libc.Int32FromInt32(LA_SHAPE_MS)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+9799, __ccgo_ts+9289, int32(397))
	}
	if !((*OpusT_silk_encoder_state)(unsafe.Pointer(psEncC)).FshapeWinLength <= libc.Int32FromInt32(15)*libc.Int32FromInt32(MAX_FS_KHZ)) {
		Opus_celt_fatal(tls, __ccgo_ts+9850, __ccgo_ts+9289, int32(398))
	}
	return ret
}

func silk_setup_fs(tls *libc.TLS, psEnc uintptr, fs_kHz int32, PacketSize_ms int32) (r int32) {
	var ret, v1 int32
	_, _ = ret, v1
	ret = SILK_NO_ERROR
	/* Set packet size */
	if PacketSize_ms != (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FPacketSize_ms {
		if PacketSize_ms != int32(10) && PacketSize_ms != int32(20) && PacketSize_ms != int32(40) && PacketSize_ms != int32(60) {
			ret = -int32(103)
		}
		if PacketSize_ms <= int32(10) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesPerPacket = int32(1)
			if PacketSize_ms == int32(10) {
				v1 = int32(2)
			} else {
				v1 = int32(1)
			}
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr = v1
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length = int32(int16(PacketSize_ms)) * int32(int16(fs_kHz))
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length = int32(int16(libc.Int32FromInt32(10)+libc.Int32FromInt32(LA_PITCH_MS)<<libc.Int32FromInt32(1))) * int32(int16(fs_kHz))
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(8) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_NB_iCDF))
			} else {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_iCDF))
			}
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesPerPacket = PacketSize_ms / (libc.Int32FromInt32(SUB_FRAME_LENGTH_MS) * libc.Int32FromInt32(MAX_NB_SUBFR))
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr = int32(MAX_NB_SUBFR)
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length = int32(int16(libc.Int32FromInt32(20))) * int32(int16(fs_kHz))
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length = int32(int16(libc.Int32FromInt32(20)+libc.Int32FromInt32(LA_PITCH_MS)<<libc.Int32FromInt32(1))) * int32(int16(fs_kHz))
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(8) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_NB_iCDF))
			} else {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_iCDF))
			}
		}
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FPacketSize_ms = PacketSize_ms
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FTargetRate_bps = 0 /* trigger new SNR computation */
	}
	/* Set internal sampling frequency */
	if !(fs_kHz == int32(8) || fs_kHz == int32(12) || fs_kHz == int32(16)) {
		Opus_celt_fatal(tls, __ccgo_ts+7073, __ccgo_ts+9289, int32(241))
	}
	if !((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == int32(2) || (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == int32(4)) {
		Opus_celt_fatal(tls, __ccgo_ts+9313, __ccgo_ts+9289, int32(242))
	}
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz != fs_kHz {
		/* reset part of the state */
		libc.Xmemset(tls, psEnc+7288, 0, libc.Uint64FromInt64(12))
		libc.Xmemset(tls, psEnc+148, 0, libc.Uint64FromInt64(4352))
		libc.Xmemset(tls, psEnc+4500, 0, libc.Uint64FromInt64(32))
		libc.Xmemset(tls, psEnc+16, 0, libc.Uint64FromInt64(8))
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FinputBufIx = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FnFramesEncoded = 0
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FTargetRate_bps = 0 /* trigger new SNR computation */
		/* Initialize non-zero parameters */
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevLag = int32(100)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffirst_frame_after_reset = int32(1)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsShape.FLastGainIndex = int8(10)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FsNSQ.FlagPrev = int32(100)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FsNSQ.Fprev_gain_Q16 = int32(65536)
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FprevSignalType = TYPE_NO_VOICE_ACTIVITY
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz = fs_kHz
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(8) {
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_NB_iCDF))
			} else {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_NB_iCDF))
			}
		} else {
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == int32(MAX_NB_SUBFR) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_iCDF))
			} else {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_contour_iCDF = uintptr(unsafe.Pointer(&Opus_silk_pitch_contour_10_ms_iCDF))
			}
		}
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(8) || (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(12) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder = int32(MIN_LPC_ORDER)
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_NB_MB))
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpredictLPCOrder = int32(MAX_LPC_ORDER)
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FpsNLSF_CB = uintptr(unsafe.Pointer(&Opus_silk_NLSF_CB_WB))
		}
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length = int32(SUB_FRAME_LENGTH_MS) * fs_kHz
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length = int32(int16((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length)) * int32(int16((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr))
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fltp_mem_length = int32(int16(libc.Int32FromInt32(LTP_MEM_LENGTH_MS))) * int32(int16(fs_kHz))
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fla_pitch = int32(int16(libc.Int32FromInt32(LA_PITCH_MS))) * int32(int16(fs_kHz))
		(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fmax_pitch_lag = int32(int16(libc.Int32FromInt32(18))) * int32(int16(fs_kHz))
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == int32(MAX_NB_SUBFR) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length = int32(int16(libc.Int32FromInt32(20)+libc.Int32FromInt32(LA_PITCH_MS)<<libc.Int32FromInt32(1))) * int32(int16(fs_kHz))
		} else {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_LPC_win_length = int32(int16(libc.Int32FromInt32(10)+libc.Int32FromInt32(LA_PITCH_MS)<<libc.Int32FromInt32(1))) * int32(int16(fs_kHz))
		}
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(16) {
			(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform8_iCDF))
		} else {
			if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == int32(12) {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform6_iCDF))
			} else {
				(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fpitch_lag_low_bits_iCDF = uintptr(unsafe.Pointer(&Opus_silk_uniform4_iCDF))
			}
		}
	}
	/* Check that settings are valid */
	if !((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fsubfr_length*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr == (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fframe_length) {
		Opus_celt_fatal(tls, __ccgo_ts+9386, __ccgo_ts+9289, int32(302))
	}
	return ret
}

func silk_setup_resamplers(tls *libc.TLS, psEnc uintptr, fs_kHz int32) (r int32) {
	var _saved_stack, st, temp_resampler_state, x_bufFIX, x_buf_API_fs_Hz, v1, v11, v14, v16, v18, v20, v22, v24, v3, v5, v7, v9 uintptr
	var api_buf_samples, buf_length_ms, k, k1, new_buf_samples, old_buf_samples OpusT_opus_int32
	var ret, v13, v26, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, api_buf_samples, buf_length_ms, k, k1, new_buf_samples, old_buf_samples, ret, st, temp_resampler_state, x_bufFIX, x_buf_API_fs_Hz, v1, v11, v13, v14, v16, v18, v20, v22, v24, v26, v3, v31, v5, v7, v9
	ret = SILK_NO_ERROR
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz != fs_kHz || (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fprev_API_fs_Hz != (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz {
		if (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz == 0 {
			/* Initialize the resampler for enc_API.c preparing resampling from API_fs_Hz to fs_kHz */
			ret = ret + Opus_silk_resampler_init(tls, psEnc+5792, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz, fs_kHz*int32(1000), int32(1))
		} else {
			buf_length_ms = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fnb_subfr*libc.Int32FromInt32(5))<<libc.Int32FromInt32(1)) + int32(LA_SHAPE_MS)
			old_buf_samples = buf_length_ms * (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz
			new_buf_samples = buf_length_ms * fs_kHz
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _6
			_6:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _8
		_8:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v5 = libc.Xmalloc(tls, uint64(16))
				goto _10
			_10:
				st = v5
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v7 = st
			goto _12
		_12:
			*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
			if old_buf_samples > new_buf_samples {
				v13 = old_buf_samples
			} else {
				v13 = new_buf_samples
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v9 = libc.Xmalloc(tls, uint64(16))
				goto _15
			_15:
				st = v9
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v11 = st
			goto _17
		_17:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v14 = libc.Xmalloc(tls, uint64(16))
				goto _19
			_19:
				st = v14
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v16 = st
			goto _21
		_21:
			if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(v13)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
				Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9289, int32(165))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v18 = libc.Xmalloc(tls, uint64(16))
				goto _23
			_23:
				st = v18
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v20 = st
			goto _25
		_25:
			if old_buf_samples > new_buf_samples {
				v26 = old_buf_samples
			} else {
				v26 = new_buf_samples
			}
			*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(v26) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v22 = libc.Xmalloc(tls, uint64(16))
				goto _28
			_28:
				st = v22
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v24 = st
			goto _30
		_30:
			if old_buf_samples > new_buf_samples {
				v31 = old_buf_samples
			} else {
				v31 = new_buf_samples
			}
			x_bufFIX = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(v31)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
			v1 = psEnc + 7300
			k = old_buf_samples - libc.Int32FromInt32(1)
			for {
				if !(k >= libc.Int32FromInt32(0)) {
					break
				}
				if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) > int32(silk_int16_MAX17) {
					v13 = int32(silk_int16_MAX17)
				} else {
					if int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4)))) < int32(libc.Int16FromInt32(0x8000)) {
						v26 = int32(libc.Int16FromInt32(0x8000))
					} else {
						v26 = int32(Opus_lrintf(tls, *(*float32)(unsafe.Pointer(v1 + uintptr(k)*4))))
					}
					v13 = v26
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(x_bufFIX + uintptr(k)*2)) = int16(v13)
				goto _33
			_33:
				;
				k = k - 1
			}
			/* Initialize resampler for temporary resampling of x_buf data to API_fs_Hz */
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _37
			_37:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _39
		_39:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v5 = libc.Xmalloc(tls, uint64(16))
				goto _41
			_41:
				st = v5
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v7 = st
			goto _43
		_43:
			*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(8) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(8) - libc.Uint64FromInt32(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v9 = libc.Xmalloc(tls, uint64(16))
				goto _45
			_45:
				st = v9
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v11 = st
			goto _47
		_47:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v14 = libc.Xmalloc(tls, uint64(16))
				goto _49
			_49:
				st = v14
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v16 = st
			goto _51
		_51:
			if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(400)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
				Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9289, int32(171))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v18 = libc.Xmalloc(tls, uint64(16))
				goto _53
			_53:
				st = v18
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v20 = st
			goto _55
		_55:
			*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(400) / libc.Uint64FromInt64(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v22 = libc.Xmalloc(tls, uint64(16))
				goto _57
			_57:
				st = v22
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v24 = st
			goto _59
		_59:
			temp_resampler_state = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(400)/libc.Uint64FromInt64(1)))
			ret = ret + Opus_silk_resampler_init(tls, temp_resampler_state, int32(int16((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Ffs_kHz))*int32(int16(libc.Int32FromInt32(1000))), (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz, 0)
			/* Calculate number of samples to temporarily upsample */
			api_buf_samples = buf_length_ms * ((*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz / libc.Int32FromInt32(1000))
			/* Temporary resampling of x_buf data to API_fs_Hz */
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _61
			_61:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _63
		_63:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v5 = libc.Xmalloc(tls, uint64(16))
				goto _65
			_65:
				st = v5
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v7 = st
			goto _67
		_67:
			*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v9 = libc.Xmalloc(tls, uint64(16))
				goto _69
			_69:
				st = v9
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v11 = st
			goto _71
		_71:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v14 = libc.Xmalloc(tls, uint64(16))
				goto _73
			_73:
				st = v14
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v16 = st
			goto _75
		_75:
			if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(api_buf_samples)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
				Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+9289, int32(178))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v18 = libc.Xmalloc(tls, uint64(16))
				goto _77
			_77:
				st = v18
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v20 = st
			goto _79
		_79:
			*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(api_buf_samples) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v22 = libc.Xmalloc(tls, uint64(16))
				goto _81
			_81:
				st = v22
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v24 = st
			goto _83
		_83:
			x_buf_API_fs_Hz = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(api_buf_samples)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
			ret = ret + Opus_silk_resampler(tls, temp_resampler_state, x_buf_API_fs_Hz, x_bufFIX, old_buf_samples)
			/* Initialize the resampler for enc_API.c preparing resampling from API_fs_Hz to fs_kHz */
			ret = ret + Opus_silk_resampler_init(tls, psEnc+5792, (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz, int32(int16(fs_kHz))*int32(int16(libc.Int32FromInt32(1000))), int32(1))
			/* Correct resampler state by resampling buffered data from API_fs_Hz to fs_kHz */
			ret = ret + Opus_silk_resampler(tls, psEnc+5792, x_bufFIX, x_buf_API_fs_Hz, api_buf_samples)
			k1 = new_buf_samples - libc.Int32FromInt32(1)
			for {
				if !(k1 >= libc.Int32FromInt32(0)) {
					break
				}
				*(*float32)(unsafe.Pointer(psEnc + 7300 + uintptr(k1)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(x_bufFIX + uintptr(k1)*2)))
				goto _84
			_84:
				;
				k1 = k1 - 1
			}
		}
	}
	(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.Fprev_API_fs_Hz = (*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(psEnc)).FsCmn.FAPI_fs_Hz
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _88
_88:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}
