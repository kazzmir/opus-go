// Code generated for linux/amd64 by 'ccgo --package-name opusccenc --prefix-external Opus_ --prefix-typename OpusT_ -o opusccenc/libopus_enc.go -I .. -I ../include -I ../src -I ../celt -I ../silk -I ../silk/float -include config_ccgo.h -DOPUS_BUILD -DOPUS_DISABLE_INTRINSICS -DNONTHREADSAFE_PSEUDOSTACK -UVAR_ARRAYS -UUSE_ALLOCA -U__SSE__ -U__SSE2__ -U__SSE3__ -U__SSSE3__ -U__AVX__ -U__AVX2__ -std=c99 -O2 -fno-builtin -ignore-asm-errors -ignore-vector-functions ccgo_support/math_lrint.c ../src/opus.c ../src/opus_decoder.c ../src/opus_encoder.c ../src/extensions.c ../src/opus_multistream.c ../src/opus_multistream_encoder.c ../src/opus_multistream_decoder.c ../src/repacketizer.c ../src/opus_projection_encoder.c ../src/opus_projection_decoder.c ../src/mapping_matrix.c ../src/analysis.c ../src/mlp.c ../src/mlp_data.c ../celt/bands.c ../celt/celt.c ../celt/celt_encoder.c ../celt/celt_decoder.c ../celt/cwrs.c ../celt/entcode.c ../celt/entdec.c ../celt/entenc.c ../celt/kiss_fft.c ../celt/laplace.c ../celt/mathops.c ../celt/mdct.c ../celt/modes.c ../celt/pitch.c ../celt/celt_lpc.c ../celt/quant_bands.c ../celt/rate.c ../celt/vq.c ../celt/mini_kfft.c ../silk/CNG.c ../silk/code_signs.c ../silk/init_decoder.c ../silk/decode_core.c ../silk/decode_frame.c ../silk/decode_parameters.c ../silk/decode_indices.c ../silk/decode_pulses.c ../silk/decoder_set_fs.c ../silk/dec_API.c ../silk/enc_API.c ../silk/encode_indices.c ../silk/encode_pulses.c ../silk/gain_quant.c ../silk/interpolate.c ../silk/LP_variable_cutoff.c ../silk/NLSF_decode.c ../silk/NSQ.c ../silk/NSQ_del_dec.c ../silk/PLC.c ../silk/shell_coder.c ../silk/tables_gain.c ../silk/tables_LTP.c ../silk/tables_NLSF_CB_NB_MB.c ../silk/tables_NLSF_CB_WB.c ../silk/tables_other.c ../silk/tables_pitch_lag.c ../silk/tables_pulses_per_block.c ../silk/VAD.c ../silk/control_audio_bandwidth.c ../silk/quant_LTP_gains.c ../silk/VQ_WMat_EC.c ../silk/HP_variable_cutoff.c ../silk/NLSF_encode.c ../silk/NLSF_VQ.c ../silk/NLSF_unpack.c ../silk/NLSF_del_dec_quant.c ../silk/process_NLSFs.c ../silk/stereo_LR_to_MS.c ../silk/stereo_MS_to_LR.c ../silk/check_control_input.c ../silk/control_SNR.c ../silk/init_encoder.c ../silk/control_codec.c ../silk/A2NLSF.c ../silk/ana_filt_bank_1.c ../silk/biquad_alt.c ../silk/bwexpander_32.c ../silk/bwexpander.c ../silk/debug.c ../silk/decode_pitch.c ../silk/inner_prod_aligned.c ../silk/lin2log.c ../silk/log2lin.c ../silk/LPC_analysis_filter.c ../silk/LPC_inv_pred_gain.c ../silk/table_LSF_cos.c ../silk/NLSF2A.c ../silk/NLSF_stabilize.c ../silk/NLSF_VQ_weights_laroia.c ../silk/pitch_est_tables.c ../silk/resampler.c ../silk/resampler_down2_3.c ../silk/resampler_down2.c ../silk/resampler_private_AR2.c ../silk/resampler_private_down_FIR.c ../silk/resampler_private_IIR_FIR.c ../silk/resampler_private_up2_HQ.c ../silk/resampler_rom.c ../silk/sigm_Q15.c ../silk/sort.c ../silk/sum_sqr_shift.c ../silk/stereo_decode_pred.c ../silk/stereo_encode_pred.c ../silk/stereo_find_predictor.c ../silk/stereo_quant_pred.c ../silk/LPC_fit.c ../silk/float/apply_sine_window_FLP.c ../silk/float/corrMatrix_FLP.c ../silk/float/encode_frame_FLP.c ../silk/float/find_LPC_FLP.c ../silk/float/find_LTP_FLP.c ../silk/float/find_pitch_lags_FLP.c ../silk/float/find_pred_coefs_FLP.c ../silk/float/LPC_analysis_filter_FLP.c ../silk/float/LTP_analysis_filter_FLP.c ../silk/float/LTP_scale_ctrl_FLP.c ../silk/float/noise_shape_analysis_FLP.c ../silk/float/process_gains_FLP.c ../silk/float/regularize_correlations_FLP.c ../silk/float/residual_energy_FLP.c ../silk/float/warped_autocorrelation_FLP.c ../silk/float/wrappers_FLP.c ../silk/float/autocorrelation_FLP.c ../silk/float/burg_modified_FLP.c ../silk/float/bwexpander_FLP.c ../silk/float/energy_FLP.c ../silk/float/inner_product_FLP.c ../silk/float/k2a_FLP.c ../silk/float/LPC_inv_pred_gain_FLP.c ../silk/float/pitch_analysis_core_FLP.c ../silk/float/scale_copy_vector_FLP.c ../silk/float/scale_vector_FLP.c ../silk/float/schur_FLP.c ../silk/float/sort_FLP.c', DO NOT EDIT.

package opusccenc

import (
	"reflect"
	"unsafe"

	libc "github.com/kazzmir/opus-go/libcshim"
)

var _ reflect.Type
var _ unsafe.Pointer

func LPC_inverse_pred_gain_QA_c(tls *libc.TLS, A_QA uintptr, order int32) (r OpusT_opus_int32) {
	var b32_inv, b32_nrm, err_Q32, invGain_Q30, rc_Q31, rc_mult1_Q30, rc_mult2, result, tmp1, tmp2, v10, v3, v4, v7 OpusT_opus_int32
	var b_headrm, k, lshift, mult2Q, n, v13, v16, v17, v18, v19, v2, v6, v8, v9 int32
	var tmp64 OpusT_opus_int64
	var v22 int64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = b32_inv, b32_nrm, b_headrm, err_Q32, invGain_Q30, k, lshift, mult2Q, n, rc_Q31, rc_mult1_Q30, rc_mult2, result, tmp1, tmp2, tmp64, v10, v13, v16, v17, v18, v19, v2, v22, v3, v4, v6, v7, v8, v9
	invGain_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30))) + libc.Float64FromFloat64(0.5))
	k = order - int32(1)
	for {
		if !(k > 0) {
			break
		}
		/* Check for stability */
		if *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) > int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) || *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) < -int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) {
			return 0
		}
		/* Set RC equal to negated AR coef */
		rc_Q31 = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4))) << (libc.Int32FromInt32(31) - libc.Int32FromInt32(QA)))
		/* rc_mult1_Q30 range: [ 1 : 2^30 ] */
		rc_mult1_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) - int32(int64(rc_Q31)*int64(rc_Q31)>>libc.Int32FromInt32(32))
		_ = rc_mult1_Q30 > libc.Int32FromInt32(1)<<libc.Int32FromInt32(15) /* reduce A_LIMIT if fails */
		_ = rc_mult1_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
		/* Update inverse gain */
		/* invGain_Q30 range: [ 0 : 2^30 ] */
		invGain_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(invGain_Q30)*int64(rc_mult1_Q30)>>libc.Int32FromInt32(32))) << libc.Int32FromInt32(2))
		_ = invGain_Q30 >= libc.Int32FromInt32(0)
		_ = invGain_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
		if invGain_Q30 < int32(float64(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(10000)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) {
			return 0
		}
		/* rc_mult2 range: [ 2^30 : silk_int32_MAX ] */
		if rc_mult1_Q30 > 0 {
			v2 = rc_mult1_Q30
		} else {
			v2 = -rc_mult1_Q30
		}
		v3 = v2
		if v3 != 0 {
			v6 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v3)))
		} else {
			v6 = int32(32)
		}
		v4 = v6
		goto _5
	_5:
		mult2Q = int32(32) - v4
		v3 = rc_mult1_Q30
		v2 = mult2Q + int32(30)
		_ = v3 != libc.Int32FromInt32(0)
		_ = v2 > libc.Int32FromInt32(0)
		if v3 > 0 {
			v6 = v3
		} else {
			v6 = -v3
		}
		v4 = v6
		if v4 != 0 {
			v8 = int32(32) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(v4)))
		} else {
			v8 = int32(32)
		}
		v7 = v8
		goto _12
	_12:
		b_headrm = v7 - int32(1)
		b32_nrm = libc.Int32FromUint32(libc.Uint32FromInt32(v3) << b_headrm)
		b32_inv = libc.Int32FromInt32(silk_int32_MAX) >> libc.Int32FromInt32(2) / (b32_nrm >> libc.Int32FromInt32(16))
		result = libc.Int32FromUint32(libc.Uint32FromInt32(b32_inv) << libc.Int32FromInt32(16))
		err_Q32 = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(29)-int32(int64(b32_nrm)*int64(int16(b32_inv))>>libc.Int32FromInt32(16))) << libc.Int32FromInt32(3))
		result = int32(int64(result) + int64(err_Q32)*int64(b32_inv)>>libc.Int32FromInt32(16))
		lshift = int32(61) - b_headrm - v2
		if lshift <= libc.Int32FromInt32(0) {
			if libc.Int32FromUint32(0x80000000)>>-lshift > int32(silk_int32_MAX)>>-lshift {
				if result > libc.Int32FromUint32(0x80000000)>>-lshift {
					v13 = libc.Int32FromUint32(0x80000000) >> -lshift
				} else {
					if result < int32(silk_int32_MAX)>>-lshift {
						v16 = int32(silk_int32_MAX) >> -lshift
					} else {
						v16 = result
					}
					v13 = v16
				}
				v9 = v13
			} else {
				if result > int32(silk_int32_MAX)>>-lshift {
					v17 = int32(silk_int32_MAX) >> -lshift
				} else {
					if result < libc.Int32FromUint32(0x80000000)>>-lshift {
						v18 = libc.Int32FromUint32(0x80000000) >> -lshift
					} else {
						v18 = result
					}
					v17 = v18
				}
				v9 = v17
			}
			v10 = libc.Int32FromUint32(libc.Uint32FromInt32(v9) << -lshift)
			goto _15
		} else {
			if lshift < libc.Int32FromInt32(32) {
				v10 = result >> lshift
				goto _15
			} else {
				v10 = 0
				goto _15
			}
		}
	_15:
		rc_mult2 = v10
		/* Update AR coefficient */
		n = 0
		for {
			if !(n < (k+int32(1))>>int32(1)) {
				break
			}
			tmp1 = *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(n)*4))
			tmp2 = *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k-n-int32(1))*4))
			if mult2Q == int32(1) {
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v6 = libc.Int32FromUint32(0x80000000)
					} else {
						v6 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v6
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v8 = int32(silk_int32_MAX)
					} else {
						v8 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v8
				}
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v13 = libc.Int32FromUint32(0x80000000)
					} else {
						v13 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v13
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v16 = int32(silk_int32_MAX)
					} else {
						v16 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v16
				}
				v22 = int64(v2)*int64(rc_mult2)>>int32(1) + int64(v9)*int64(rc_mult2)&int64(1)
			} else {
				if (libc.Uint32FromInt32(tmp1)-libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp1)&(libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v18 = libc.Int32FromUint32(0x80000000)
					} else {
						v18 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v18
				} else {
					if (libc.Uint32FromInt32(tmp1)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v19 = int32(silk_int32_MAX)
					} else {
						v19 = tmp1 - int32((int64(tmp2)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v19
				}
				v22 = (int64(v17)*int64(rc_mult2)>>(mult2Q-int32(1)) + int64(1)) >> int32(1)
			}
			tmp64 = v22
			if tmp64 > int64(silk_int32_MAX) || tmp64 < int64(libc.Int32FromUint32(0x80000000)) {
				return 0
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(n)*4)) = int32(tmp64)
			if mult2Q == int32(1) {
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v6 = libc.Int32FromUint32(0x80000000)
					} else {
						v6 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v6
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v8 = int32(silk_int32_MAX)
					} else {
						v8 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v2 = v8
				}
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v13 = libc.Int32FromUint32(0x80000000)
					} else {
						v13 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v13
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v16 = int32(silk_int32_MAX)
					} else {
						v16 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v9 = v16
				}
				v22 = int64(v2)*int64(rc_mult2)>>int32(1) + int64(v9)*int64(rc_mult2)&int64(1)
			} else {
				if (libc.Uint32FromInt32(tmp2)-libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))))&uint32(0x80000000) == uint32(0) {
					if libc.Uint32FromInt32(tmp2)&(libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))^uint32(0x80000000))&uint32(0x80000000) != 0 {
						v18 = libc.Int32FromUint32(0x80000000)
					} else {
						v18 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v18
				} else {
					if (libc.Uint32FromInt32(tmp2)^uint32(0x80000000))&libc.Uint32FromInt32(int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1)))&uint32(0x80000000) != 0 {
						v19 = int32(silk_int32_MAX)
					} else {
						v19 = tmp2 - int32((int64(tmp1)*int64(rc_Q31)>>(libc.Int32FromInt32(31)-libc.Int32FromInt32(1))+libc.Int64FromInt32(1))>>libc.Int32FromInt32(1))
					}
					v17 = v19
				}
				v22 = (int64(v17)*int64(rc_mult2)>>(mult2Q-int32(1)) + int64(1)) >> int32(1)
			}
			tmp64 = v22
			if tmp64 > int64(silk_int32_MAX) || tmp64 < int64(libc.Int32FromUint32(0x80000000)) {
				return 0
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k-n-int32(1))*4)) = int32(tmp64)
			goto _21
		_21:
			;
			n = n + 1
		}
		goto _1
	_1:
		;
		k = k - 1
	}
	/* Check for stability */
	if *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) > int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) || *(*OpusT_opus_int32)(unsafe.Pointer(A_QA + uintptr(k)*4)) < -int32(float64(libc.Float64FromFloat64(0.99975)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(QA)))+libc.Float64FromFloat64(0.5)) {
		return 0
	}
	/* Set RC equal to negated AR coef */
	rc_Q31 = -libc.Int32FromUint32(libc.Uint32FromInt32(*(*OpusT_opus_int32)(unsafe.Pointer(A_QA))) << (libc.Int32FromInt32(31) - libc.Int32FromInt32(QA)))
	/* Range: [ 1 : 2^30 ] */
	rc_mult1_Q30 = int32(float64(int64(libc.Int32FromInt32(1))*(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) - int32(int64(rc_Q31)*int64(rc_Q31)>>libc.Int32FromInt32(32))
	/* Update inverse gain */
	/* Range: [ 0 : 2^30 ] */
	invGain_Q30 = libc.Int32FromUint32(libc.Uint32FromInt32(int32(int64(invGain_Q30)*int64(rc_mult1_Q30)>>libc.Int32FromInt32(32))) << libc.Int32FromInt32(2))
	_ = invGain_Q30 >= libc.Int32FromInt32(0)
	_ = invGain_Q30 <= libc.Int32FromInt32(1)<<libc.Int32FromInt32(30)
	if invGain_Q30 < int32(float64(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(10000)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(30)))+libc.Float64FromFloat64(0.5)) {
		return 0
	}
	return invGain_Q30
}

// C documentation
//
//	/* For input in Q12 domain */

func Opus_alg_quant(tls *libc.TLS, X uintptr, N int32, K int32, spread int32, B int32, enc uintptr, gain OpusT_opus_val32, resynth int32, arch int32) (r uint32) {
	var _saved_stack, iy, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var collapse_mask uint32
	var yy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, collapse_mask, iy, st, yy, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+6252, __ccgo_ts+6239, int32(562))
	}
	if !(N > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+6311, __ccgo_ts+6239, int32(563))
	}
	/* Covers vectorization by up to 4. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N+libc.Int32FromInt32(3))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6239, int32(566))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N+libc.Int32FromInt32(3)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	iy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N+libc.Int32FromInt32(3))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Opus_exp_rotation(tls, X, N, int32(1), B, K, spread)
	yy = Opus_op_pvq_search_c(tls, X, iy, K, N, arch)
	collapse_mask = extract_collapse_mask(tls, iy, N, B)
	Opus_encode_pulses(tls, iy, N, K, enc)
	if resynth != 0 {
		normalise_residual(tls, iy, X, N, yy, gain, 0)
	}
	if resynth != 0 {
		Opus_exp_rotation(tls, X, N, -int32(1), B, K, spread)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return collapse_mask
}

// C documentation
//
//	/** Decode pulse vector and combine the result with the pitch vector to produce
//	    the final normalised signal in the current band. */

func Opus_alg_unquant(tls *libc.TLS, X uintptr, N int32, K int32, spread int32, B int32, dec uintptr, gain OpusT_opus_val32) (r uint32) {
	var Ryy OpusT_opus_val32
	var _saved_stack, iy, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var collapse_mask uint32
	var yy_shift int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Ryy, _saved_stack, collapse_mask, iy, st, yy_shift, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	yy_shift = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(K > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+6375, __ccgo_ts+6239, int32(629))
	}
	if !(N > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+6436, __ccgo_ts+6239, int32(630))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6239, int32(631))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	iy = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	Ryy = Opus_decode_pulses(tls, iy, N, K, dec)
	normalise_residual(tls, iy, X, N, Ryy, gain, yy_shift)
	Opus_exp_rotation(tls, X, N, -int32(1), B, K, spread)
	collapse_mask = extract_collapse_mask(tls, iy, N, B)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return collapse_mask
}

func Opus_amp2Log2(tls *libc.TLS, m uintptr, effEnd int32, end int32, bandE uintptr, bandLogE uintptr, C int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, i, v1 int32
	var integer, range_idx OpusT_opus_int32
	var v4 float32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _ = c, i, integer, range_idx, v1, v4
	c = 0
	for {
		i = 0
		for {
			if !(i < effEnd) {
				break
			}
			*(*float32)(unsafe.Pointer(bp)) = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)) - int32(127)
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
			range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(20) & uint32(0x7))
			*(*float32)(unsafe.Pointer(bp)) = float32(*(*float32)(unsafe.Pointer(bp))*log2_x_norm_coeff19[range_idx]) - libc.Float32FromFloat32(1.0625)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp))*-libc.Float32FromFloat32(0.2841544449329376))))))))
			v4 = float32(integer) + *(*float32)(unsafe.Pointer(bp)) + log2_y_norm_coeff19[range_idx]
			goto _5
		_5:
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = v4 - Opus_eMeans[i]
			goto _3
		_3:
			;
			i = i + 1
		}
		i = effEnd
		for {
			if !(i < end) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) = -libc.Float32FromFloat32(14)
			goto _6
		_6:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
}

const ALLOC_STEPS = 6

var trim_icdf20 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf20 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf20 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff20 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff20 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var LOG2_FRAC_TABLE = [24]uint8{
	1:  uint8(8),
	2:  uint8(13),
	3:  uint8(16),
	4:  uint8(19),
	5:  uint8(21),
	6:  uint8(23),
	7:  uint8(24),
	8:  uint8(26),
	9:  uint8(27),
	10: uint8(28),
	11: uint8(29),
	12: uint8(30),
	13: uint8(31),
	14: uint8(32),
	15: uint8(32),
	16: uint8(33),
	17: uint8(34),
	18: uint8(34),
	19: uint8(35),
	20: uint8(36),
	21: uint8(36),
	22: uint8(37),
	23: uint8(37),
}

func Opus_analysis_compute_dense(tls *libc.TLS, layer uintptr, output uintptr, input uintptr) {
	var M, N, i, stride int32
	_, _, _, _ = M, N, i, stride
	M = (*OpusT_AnalysisDenseLayer)(unsafe.Pointer(layer)).Fnb_inputs
	N = (*OpusT_AnalysisDenseLayer)(unsafe.Pointer(layer)).Fnb_neurons
	stride = N
	i = 0
	for {
		if !(i < N) {
			break
		}
		*(*float32)(unsafe.Pointer(output + uintptr(i)*4)) = float32(*(*OpusT_opus_int8)(unsafe.Pointer((*OpusT_AnalysisDenseLayer)(unsafe.Pointer(layer)).Fbias + uintptr(i))))
		goto _1
	_1:
		;
		i = i + 1
	}
	gemm_accum(tls, output, (*OpusT_AnalysisDenseLayer)(unsafe.Pointer(layer)).Finput_weights, N, M, stride, input)
	i = 0
	for {
		if !(i < N) {
			break
		}
		*(*float32)(unsafe.Pointer(output + uintptr(i)*4)) *= libc.Float32FromFloat32(1) / libc.Float32FromInt32(128)
		goto _2
	_2:
		;
		i = i + 1
	}
	if (*OpusT_AnalysisDenseLayer)(unsafe.Pointer(layer)).Fsigmoid != 0 {
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*float32)(unsafe.Pointer(output + uintptr(i)*4)) = sigmoid_approx(tls, *(*float32)(unsafe.Pointer(output + uintptr(i)*4)))
			goto _3
		_3:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*float32)(unsafe.Pointer(output + uintptr(i)*4)) = tansig_approx(tls, *(*float32)(unsafe.Pointer(output + uintptr(i)*4)))
			goto _4
		_4:
			;
			i = i + 1
		}
	}
}

func Opus_analysis_compute_gru(tls *libc.TLS, gru uintptr, state uintptr, input uintptr) {
	bp := tls.Alloc(512)
	defer tls.Free(512)
	var M, N, i, stride int32
	var _ /* h at bp+384 */ [32]float32
	var _ /* r at bp+256 */ [32]float32
	var _ /* tmp at bp+0 */ [32]float32
	var _ /* z at bp+128 */ [32]float32
	_, _, _, _ = M, N, i, stride
	M = (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Fnb_inputs
	N = (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Fnb_neurons
	stride = int32(3) * N
	/* Compute update gate. */
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 128)))[i] = float32(*(*OpusT_opus_int8)(unsafe.Pointer((*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Fbias + uintptr(i))))
		goto _1
	_1:
		;
		i = i + 1
	}
	gemm_accum(tls, bp+128, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Finput_weights, N, M, stride, input)
	gemm_accum(tls, bp+128, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Frecurrent_weights, N, N, stride, state)
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 128)))[i] = sigmoid_approx(tls, float32(libc.Float32FromFloat32(1)/libc.Float32FromInt32(128)*(*(*[32]float32)(unsafe.Pointer(bp + 128)))[i]))
		goto _2
	_2:
		;
		i = i + 1
	}
	/* Compute reset gate. */
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 256)))[i] = float32(*(*OpusT_opus_int8)(unsafe.Pointer((*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Fbias + uintptr(N+i))))
		goto _3
	_3:
		;
		i = i + 1
	}
	gemm_accum(tls, bp+256, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Finput_weights+uintptr(N), N, M, stride, input)
	gemm_accum(tls, bp+256, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Frecurrent_weights+uintptr(N), N, N, stride, state)
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 256)))[i] = sigmoid_approx(tls, float32(libc.Float32FromFloat32(1)/libc.Float32FromInt32(128)*(*(*[32]float32)(unsafe.Pointer(bp + 256)))[i]))
		goto _4
	_4:
		;
		i = i + 1
	}
	/* Compute output. */
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 384)))[i] = float32(*(*OpusT_opus_int8)(unsafe.Pointer((*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Fbias + uintptr(int32(2)*N+i))))
		goto _5
	_5:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp)))[i] = float32(*(*float32)(unsafe.Pointer(state + uintptr(i)*4)) * (*(*[32]float32)(unsafe.Pointer(bp + 256)))[i])
		goto _6
	_6:
		;
		i = i + 1
	}
	gemm_accum(tls, bp+384, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Finput_weights+uintptr(int32(2)*N), N, M, stride, input)
	gemm_accum(tls, bp+384, (*OpusT_AnalysisGRULayer)(unsafe.Pointer(gru)).Frecurrent_weights+uintptr(int32(2)*N), N, N, stride, bp)
	i = 0
	for {
		if !(i < N) {
			break
		}
		(*(*[32]float32)(unsafe.Pointer(bp + 384)))[i] = float32((*(*[32]float32)(unsafe.Pointer(bp + 128)))[i]**(*float32)(unsafe.Pointer(state + uintptr(i)*4))) + float32((libc.Float32FromInt32(1)-(*(*[32]float32)(unsafe.Pointer(bp + 128)))[i])*tansig_approx(tls, float32(libc.Float32FromFloat32(1)/libc.Float32FromInt32(128)*(*(*[32]float32)(unsafe.Pointer(bp + 384)))[i])))
		goto _7
	_7:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < N) {
			break
		}
		*(*float32)(unsafe.Pointer(state + uintptr(i)*4)) = (*(*[32]float32)(unsafe.Pointer(bp + 384)))[i]
		goto _8
	_8:
		;
		i = i + 1
	}
}

var layer0_weights = [800]OpusT_opus_int8{
	0:   int8(-int32(30)),
	1:   int8(-int32(9)),
	2:   int8(2),
	3:   int8(-int32(12)),
	4:   int8(5),
	5:   int8(-int32(1)),
	6:   int8(8),
	7:   int8(9),
	8:   int8(9),
	9:   int8(8),
	10:  int8(-int32(13)),
	11:  int8(18),
	12:  int8(-int32(17)),
	13:  int8(-int32(34)),
	14:  int8(-int32(5)),
	15:  int8(17),
	16:  int8(-int32(11)),
	18:  int8(-int32(4)),
	19:  int8(10),
	20:  int8(2),
	21:  int8(10),
	22:  int8(15),
	23:  int8(-int32(8)),
	24:  int8(2),
	25:  int8(-int32(1)),
	27:  int8(5),
	28:  int8(13),
	29:  int8(-int32(3)),
	30:  int8(-int32(16)),
	31:  int8(1),
	32:  int8(-int32(5)),
	33:  int8(3),
	34:  int8(7),
	35:  int8(-int32(28)),
	36:  int8(-int32(13)),
	37:  int8(6),
	38:  int8(36),
	39:  int8(-int32(3)),
	40:  int8(19),
	41:  int8(-int32(60)),
	42:  int8(-int32(17)),
	43:  int8(-int32(28)),
	44:  int8(7),
	45:  int8(-int32(11)),
	46:  int8(-int32(30)),
	47:  int8(-int32(7)),
	48:  int8(2),
	49:  int8(-int32(42)),
	50:  int8(-int32(21)),
	51:  int8(-int32(3)),
	52:  int8(6),
	53:  int8(-int32(22)),
	54:  int8(33),
	55:  int8(-int32(9)),
	56:  int8(7),
	57:  int8(-int32(30)),
	58:  int8(21),
	59:  int8(-int32(14)),
	60:  int8(24),
	61:  int8(-int32(11)),
	62:  int8(-int32(20)),
	63:  int8(-int32(18)),
	64:  int8(-int32(5)),
	65:  int8(-int32(12)),
	66:  int8(12),
	67:  int8(-int32(49)),
	68:  int8(-int32(50)),
	69:  int8(-int32(49)),
	70:  int8(16),
	71:  int8(9),
	72:  int8(-int32(37)),
	73:  int8(-int32(1)),
	74:  int8(9),
	75:  int8(34),
	76:  int8(-int32(13)),
	77:  int8(-int32(31)),
	78:  int8(-int32(31)),
	79:  int8(12),
	80:  int8(16),
	81:  int8(44),
	82:  int8(-int32(42)),
	83:  int8(2),
	84:  int8(-int32(9)),
	85:  int8(8),
	86:  int8(-int32(18)),
	87:  int8(-int32(6)),
	88:  int8(9),
	89:  int8(36),
	90:  int8(19),
	91:  int8(11),
	92:  int8(13),
	93:  int8(12),
	94:  int8(-int32(21)),
	95:  int8(3),
	96:  int8(-int32(28)),
	97:  int8(-int32(12)),
	98:  int8(3),
	99:  int8(33),
	100: int8(25),
	101: int8(-int32(14)),
	102: int8(11),
	103: int8(1),
	104: int8(-int32(94)),
	105: int8(-int32(39)),
	106: int8(18),
	107: int8(-int32(12)),
	108: int8(-int32(11)),
	109: int8(-int32(15)),
	110: int8(-int32(7)),
	111: int8(49),
	112: int8(52),
	113: int8(10),
	114: int8(-int32(43)),
	115: int8(9),
	116: int8(57),
	117: int8(8),
	118: int8(21),
	119: int8(-int32(6)),
	120: int8(14),
	121: int8(-int32(15)),
	122: int8(44),
	123: int8(-int32(8)),
	124: int8(7),
	125: int8(-int32(30)),
	126: int8(-int32(13)),
	127: int8(-int32(2)),
	128: int8(-int32(9)),
	129: int8(25),
	130: int8(-int32(2)),
	131: int8(-int32(127)),
	132: int8(18),
	133: int8(-int32(11)),
	134: int8(-int32(52)),
	135: int8(26),
	136: int8(-int32(27)),
	137: int8(27),
	138: int8(10),
	139: int8(-int32(10)),
	140: int8(7),
	141: int8(43),
	142: int8(6),
	143: int8(-int32(24)),
	144: int8(41),
	145: int8(10),
	146: int8(-int32(18)),
	147: int8(-int32(27)),
	148: int8(10),
	149: int8(17),
	150: int8(9),
	151: int8(10),
	152: int8(-int32(17)),
	153: int8(-int32(10)),
	154: int8(20),
	155: int8(-int32(6)),
	156: int8(22),
	157: int8(55),
	158: int8(35),
	159: int8(-int32(80)),
	160: int8(36),
	161: int8(25),
	162: int8(-int32(24)),
	163: int8(-int32(36)),
	164: int8(15),
	165: int8(9),
	166: int8(-int32(19)),
	167: int8(88),
	168: int8(19),
	169: int8(64),
	170: int8(-int32(51)),
	171: int8(-int32(35)),
	172: int8(17),
	174: int8(-int32(7)),
	175: int8(41),
	176: int8(-int32(16)),
	177: int8(27),
	178: int8(4),
	179: int8(15),
	180: int8(-int32(1)),
	181: int8(18),
	182: int8(-int32(16)),
	183: int8(47),
	184: int8(-int32(39)),
	185: int8(-int32(54)),
	186: int8(-int32(8)),
	187: int8(13),
	188: int8(-int32(25)),
	189: int8(-int32(20)),
	190: int8(102),
	191: int8(-int32(18)),
	192: int8(-int32(5)),
	193: int8(44),
	194: int8(11),
	195: int8(-int32(28)),
	196: int8(71),
	197: int8(2),
	198: int8(-int32(51)),
	199: int8(-int32(5)),
	200: int8(5),
	201: int8(2),
	202: int8(-int32(83)),
	203: int8(-int32(9)),
	204: int8(-int32(29)),
	205: int8(8),
	206: int8(21),
	207: int8(-int32(53)),
	208: int8(58),
	209: int8(-int32(37)),
	210: int8(-int32(7)),
	211: int8(13),
	212: int8(38),
	213: int8(9),
	214: int8(34),
	215: int8(-int32(1)),
	216: int8(-int32(41)),
	217: int8(21),
	218: int8(4),
	219: int8(-int32(24)),
	220: int8(-int32(36)),
	221: int8(-int32(33)),
	222: int8(-int32(21)),
	223: int8(32),
	224: int8(75),
	225: int8(-int32(2)),
	226: int8(1),
	227: int8(-int32(68)),
	228: int8(-int32(1)),
	229: int8(47),
	230: int8(-int32(29)),
	231: int8(32),
	232: int8(20),
	233: int8(12),
	234: int8(-int32(65)),
	235: int8(-int32(87)),
	236: int8(5),
	237: int8(16),
	238: int8(-int32(12)),
	239: int8(24),
	240: int8(40),
	241: int8(15),
	242: int8(7),
	243: int8(19),
	244: int8(-int32(26)),
	245: int8(-int32(17)),
	246: int8(17),
	247: int8(6),
	248: int8(-int32(2)),
	249: int8(-int32(37)),
	250: int8(-int32(30)),
	251: int8(-int32(9)),
	252: int8(32),
	253: int8(-int32(127)),
	254: int8(-int32(39)),
	256: int8(-int32(31)),
	257: int8(-int32(27)),
	258: int8(4),
	259: int8(-int32(22)),
	260: int8(23),
	261: int8(-int32(6)),
	262: int8(-int32(77)),
	263: int8(35),
	264: int8(-int32(61)),
	265: int8(32),
	266: int8(-int32(37)),
	267: int8(-int32(24)),
	268: int8(13),
	269: int8(-int32(11)),
	270: int8(-int32(1)),
	271: int8(-int32(40)),
	272: int8(-int32(3)),
	273: int8(17),
	274: int8(-int32(7)),
	275: int8(13),
	276: int8(11),
	277: int8(59),
	278: int8(-int32(19)),
	279: int8(10),
	280: int8(6),
	281: int8(-int32(18)),
	283: int8(13),
	284: int8(3),
	285: int8(-int32(6)),
	286: int8(-int32(23)),
	287: int8(19),
	288: int8(11),
	289: int8(-int32(17)),
	290: int8(13),
	291: int8(-int32(1)),
	292: int8(-int32(80)),
	293: int8(40),
	294: int8(-int32(53)),
	295: int8(69),
	296: int8(-int32(29)),
	297: int8(-int32(54)),
	299: int8(-int32(4)),
	300: int8(33),
	301: int8(-int32(25)),
	302: int8(-int32(2)),
	303: int8(38),
	304: int8(35),
	305: int8(36),
	306: int8(-int32(15)),
	307: int8(46),
	308: int8(2),
	309: int8(-int32(13)),
	310: int8(-int32(16)),
	311: int8(-int32(8)),
	312: int8(-int32(8)),
	313: int8(12),
	314: int8(-int32(24)),
	315: int8(-int32(9)),
	316: int8(-int32(55)),
	317: int8(-int32(5)),
	318: int8(-int32(9)),
	319: int8(32),
	320: int8(11),
	321: int8(7),
	322: int8(12),
	323: int8(-int32(18)),
	324: int8(-int32(10)),
	325: int8(-int32(86)),
	326: int8(-int32(38)),
	327: int8(54),
	328: int8(37),
	329: int8(-int32(25)),
	330: int8(18),
	331: int8(-int32(43)),
	332: int8(7),
	333: int8(-int32(27)),
	334: int8(-int32(27)),
	335: int8(-int32(54)),
	336: int8(13),
	337: int8(9),
	338: int8(22),
	339: int8(70),
	340: int8(6),
	341: int8(35),
	342: int8(-int32(7)),
	343: int8(23),
	344: int8(-int32(15)),
	345: int8(-int32(44)),
	346: int8(-int32(6)),
	347: int8(7),
	348: int8(-int32(66)),
	349: int8(-int32(85)),
	350: int8(32),
	351: int8(40),
	352: int8(-int32(19)),
	353: int8(-int32(9)),
	354: int8(-int32(7)),
	355: int8(12),
	356: int8(-int32(15)),
	357: int8(7),
	358: int8(2),
	359: int8(6),
	360: int8(-int32(35)),
	361: int8(11),
	362: int8(28),
	364: int8(26),
	365: int8(14),
	366: int8(1),
	367: int8(1),
	368: int8(4),
	369: int8(12),
	370: int8(18),
	371: int8(35),
	372: int8(22),
	373: int8(-int32(18)),
	374: int8(-int32(3)),
	375: int8(14),
	376: int8(-int32(1)),
	377: int8(7),
	378: int8(14),
	379: int8(-int32(8)),
	380: int8(-int32(14)),
	381: int8(-int32(3)),
	382: int8(4),
	383: int8(-int32(3)),
	384: int8(-int32(19)),
	385: int8(-int32(7)),
	386: int8(-int32(1)),
	387: int8(-int32(25)),
	388: int8(-int32(27)),
	389: int8(25),
	390: int8(-int32(26)),
	391: int8(-int32(2)),
	392: int8(33),
	393: int8(-int32(22)),
	394: int8(-int32(27)),
	395: int8(-int32(25)),
	396: int8(4),
	397: int8(-int32(9)),
	398: int8(7),
	399: int8(21),
	400: int8(26),
	401: int8(-int32(30)),
	402: int8(10),
	403: int8(-int32(9)),
	404: int8(-int32(20)),
	405: int8(11),
	406: int8(27),
	407: int8(10),
	408: int8(5),
	409: int8(-int32(18)),
	410: int8(14),
	411: int8(-int32(4)),
	412: int8(2),
	413: int8(-int32(17)),
	414: int8(-int32(5)),
	415: int8(-int32(7)),
	416: int8(-int32(9)),
	417: int8(-int32(13)),
	418: int8(15),
	419: int8(29),
	420: int8(1),
	421: int8(-int32(10)),
	422: int8(-int32(16)),
	423: int8(-int32(10)),
	424: int8(35),
	425: int8(36),
	426: int8(-int32(7)),
	427: int8(-int32(22)),
	428: int8(-int32(44)),
	429: int8(17),
	430: int8(30),
	431: int8(22),
	432: int8(21),
	433: int8(-int32(1)),
	434: int8(22),
	435: int8(-int32(11)),
	436: int8(32),
	437: int8(-int32(8)),
	438: int8(-int32(7)),
	439: int8(5),
	440: int8(-int32(10)),
	441: int8(5),
	442: int8(30),
	443: int8(-int32(20)),
	444: int8(29),
	445: int8(-int32(20)),
	446: int8(-int32(34)),
	447: int8(12),
	448: int8(-int32(4)),
	449: int8(-int32(6)),
	450: int8(6),
	451: int8(-int32(13)),
	452: int8(10),
	453: int8(-int32(5)),
	454: int8(-int32(68)),
	455: int8(-int32(1)),
	456: int8(24),
	457: int8(9),
	458: int8(19),
	459: int8(-int32(24)),
	460: int8(-int32(64)),
	461: int8(31),
	462: int8(19),
	463: int8(27),
	464: int8(-int32(26)),
	465: int8(75),
	466: int8(-int32(45)),
	467: int8(41),
	468: int8(39),
	469: int8(-int32(42)),
	470: int8(8),
	471: int8(6),
	472: int8(23),
	473: int8(-int32(30)),
	474: int8(16),
	475: int8(-int32(25)),
	476: int8(30),
	477: int8(34),
	478: int8(8),
	479: int8(-int32(38)),
	480: int8(-int32(3)),
	481: int8(18),
	482: int8(16),
	483: int8(-int32(31)),
	484: int8(22),
	485: int8(-int32(4)),
	486: int8(-int32(9)),
	487: int8(1),
	488: int8(20),
	489: int8(9),
	490: int8(38),
	491: int8(-int32(32)),
	493: int8(-int32(45)),
	495: int8(-int32(6)),
	496: int8(-int32(13)),
	497: int8(11),
	498: int8(-int32(25)),
	499: int8(-int32(32)),
	500: int8(-int32(22)),
	501: int8(31),
	502: int8(-int32(24)),
	503: int8(-int32(11)),
	504: int8(-int32(11)),
	505: int8(-int32(4)),
	506: int8(-int32(4)),
	507: int8(20),
	508: int8(-int32(34)),
	509: int8(22),
	510: int8(20),
	511: int8(9),
	512: int8(-int32(25)),
	513: int8(27),
	514: int8(-int32(5)),
	515: int8(28),
	516: int8(-int32(29)),
	517: int8(29),
	518: int8(6),
	519: int8(21),
	520: int8(-int32(6)),
	521: int8(-int32(18)),
	522: int8(54),
	523: int8(4),
	524: int8(-int32(46)),
	525: int8(23),
	526: int8(21),
	527: int8(-int32(14)),
	528: int8(-int32(31)),
	529: int8(36),
	530: int8(-int32(41)),
	531: int8(-int32(24)),
	532: int8(4),
	533: int8(22),
	534: int8(10),
	535: int8(11),
	536: int8(7),
	537: int8(36),
	538: int8(-int32(32)),
	539: int8(-int32(13)),
	540: int8(-int32(52)),
	541: int8(-int32(17)),
	542: int8(24),
	543: int8(28),
	544: int8(-int32(37)),
	545: int8(-int32(36)),
	546: int8(-int32(1)),
	547: int8(24),
	548: int8(9),
	549: int8(-int32(38)),
	550: int8(35),
	551: int8(48),
	552: int8(18),
	553: int8(2),
	554: int8(-int32(1)),
	555: int8(45),
	556: int8(10),
	557: int8(39),
	558: int8(24),
	559: int8(-int32(38)),
	560: int8(13),
	561: int8(8),
	562: int8(-int32(16)),
	563: int8(8),
	564: int8(25),
	565: int8(11),
	566: int8(7),
	567: int8(-int32(29)),
	568: int8(-int32(11)),
	569: int8(7),
	570: int8(20),
	571: int8(-int32(30)),
	572: int8(-int32(38)),
	573: int8(-int32(45)),
	574: int8(14),
	575: int8(-int32(18)),
	576: int8(-int32(28)),
	577: int8(-int32(9)),
	578: int8(65),
	579: int8(61),
	580: int8(22),
	581: int8(-int32(53)),
	582: int8(-int32(38)),
	583: int8(-int32(16)),
	584: int8(36),
	585: int8(46),
	586: int8(20),
	587: int8(-int32(39)),
	588: int8(32),
	589: int8(-int32(61)),
	590: int8(-int32(6)),
	591: int8(-int32(6)),
	592: int8(-int32(36)),
	593: int8(-int32(33)),
	594: int8(-int32(18)),
	595: int8(-int32(28)),
	596: int8(56),
	597: int8(101),
	598: int8(45),
	599: int8(11),
	600: int8(-int32(28)),
	601: int8(-int32(23)),
	602: int8(-int32(29)),
	603: int8(-int32(61)),
	604: int8(20),
	605: int8(-int32(47)),
	606: int8(2),
	607: int8(48),
	608: int8(27),
	609: int8(-int32(17)),
	610: int8(1),
	611: int8(40),
	612: int8(1),
	613: int8(3),
	614: int8(-int32(51)),
	615: int8(15),
	616: int8(35),
	617: int8(28),
	618: int8(22),
	619: int8(35),
	620: int8(53),
	621: int8(-int32(61)),
	622: int8(-int32(29)),
	623: int8(12),
	624: int8(-int32(6)),
	625: int8(-int32(21)),
	626: int8(10),
	627: int8(3),
	628: int8(-int32(20)),
	629: int8(2),
	630: int8(-int32(25)),
	631: int8(1),
	632: int8(-int32(6)),
	633: int8(31),
	634: int8(11),
	635: int8(-int32(3)),
	636: int8(1),
	637: int8(-int32(10)),
	638: int8(-int32(52)),
	639: int8(6),
	640: int8(126),
	641: int8(-int32(105)),
	642: int8(122),
	643: int8(127),
	644: int8(-int32(128)),
	645: int8(127),
	646: int8(127),
	647: int8(-int32(128)),
	648: int8(127),
	649: int8(108),
	650: int8(12),
	651: int8(127),
	652: int8(48),
	653: int8(-int32(128)),
	654: int8(-int32(36)),
	655: int8(-int32(128)),
	656: int8(127),
	657: int8(127),
	658: int8(-int32(128)),
	659: int8(-int32(128)),
	660: int8(127),
	661: int8(89),
	662: int8(-int32(128)),
	663: int8(127),
	664: int8(-int32(128)),
	665: int8(-int32(128)),
	666: int8(-int32(128)),
	667: int8(127),
	668: int8(127),
	669: int8(-int32(128)),
	670: int8(-int32(128)),
	671: int8(-int32(93)),
	672: int8(-int32(82)),
	673: int8(20),
	674: int8(125),
	675: int8(65),
	676: int8(-int32(82)),
	677: int8(127),
	678: int8(38),
	679: int8(-int32(74)),
	680: int8(81),
	681: int8(88),
	682: int8(-int32(88)),
	683: int8(79),
	684: int8(51),
	685: int8(-int32(47)),
	686: int8(-int32(111)),
	687: int8(-int32(26)),
	688: int8(14),
	689: int8(83),
	690: int8(-int32(88)),
	691: int8(-int32(112)),
	692: int8(24),
	693: int8(35),
	694: int8(-int32(101)),
	695: int8(98),
	696: int8(-int32(99)),
	697: int8(-int32(48)),
	698: int8(-int32(45)),
	699: int8(46),
	700: int8(83),
	701: int8(-int32(60)),
	702: int8(-int32(79)),
	703: int8(45),
	704: int8(-int32(20)),
	705: int8(-int32(41)),
	706: int8(9),
	707: int8(4),
	708: int8(52),
	709: int8(54),
	710: int8(93),
	711: int8(-int32(10)),
	712: int8(4),
	713: int8(13),
	714: int8(3),
	715: int8(123),
	716: int8(6),
	717: int8(94),
	718: int8(-int32(111)),
	719: int8(-int32(69)),
	720: int8(-int32(14)),
	721: int8(-int32(31)),
	722: int8(10),
	723: int8(12),
	724: int8(53),
	725: int8(-int32(79)),
	726: int8(-int32(11)),
	727: int8(-int32(21)),
	728: int8(-int32(2)),
	729: int8(-int32(44)),
	730: int8(-int32(72)),
	731: int8(92),
	732: int8(65),
	733: int8(-int32(57)),
	734: int8(56),
	735: int8(-int32(38)),
	736: int8(127),
	737: int8(-int32(56)),
	738: int8(-int32(128)),
	739: int8(127),
	740: int8(127),
	741: int8(-int32(128)),
	742: int8(86),
	743: int8(117),
	744: int8(-int32(75)),
	745: int8(-int32(128)),
	746: int8(127),
	747: int8(-int32(19)),
	748: int8(-int32(99)),
	749: int8(-int32(112)),
	750: int8(127),
	751: int8(-int32(128)),
	752: int8(127),
	753: int8(-int32(48)),
	754: int8(114),
	755: int8(118),
	756: int8(-int32(128)),
	757: int8(-int32(128)),
	758: int8(117),
	759: int8(-int32(17)),
	760: int8(-int32(6)),
	761: int8(121),
	762: int8(-int32(128)),
	763: int8(127),
	764: int8(-int32(128)),
	765: int8(82),
	766: int8(54),
	767: int8(-int32(106)),
	768: int8(127),
	769: int8(127),
	770: int8(-int32(33)),
	771: int8(100),
	772: int8(-int32(39)),
	773: int8(-int32(23)),
	774: int8(18),
	775: int8(-int32(78)),
	776: int8(-int32(34)),
	777: int8(-int32(29)),
	778: int8(-int32(1)),
	779: int8(-int32(30)),
	780: int8(127),
	781: int8(-int32(26)),
	782: int8(127),
	783: int8(-int32(128)),
	784: int8(126),
	785: int8(-int32(128)),
	786: int8(27),
	787: int8(-int32(23)),
	788: int8(-int32(79)),
	789: int8(-int32(120)),
	790: int8(-int32(127)),
	791: int8(127),
	792: int8(72),
	793: int8(66),
	794: int8(29),
	795: int8(7),
	796: int8(-int32(66)),
	797: int8(-int32(56)),
	798: int8(-int32(117)),
	799: int8(-int32(128)),
}

var layer0_bias = [32]OpusT_opus_int8{
	0:  int8(51),
	1:  int8(-int32(16)),
	2:  int8(1),
	3:  int8(13),
	4:  int8(-int32(5)),
	5:  int8(-int32(6)),
	6:  int8(-int32(16)),
	7:  int8(-int32(7)),
	8:  int8(11),
	9:  int8(-int32(6)),
	10: int8(106),
	11: int8(26),
	12: int8(28),
	13: int8(-int32(14)),
	14: int8(21),
	15: int8(-int32(29)),
	16: int8(7),
	17: int8(18),
	18: int8(-int32(18)),
	19: int8(-int32(17)),
	20: int8(21),
	21: int8(-int32(17)),
	22: int8(-int32(9)),
	23: int8(20),
	24: int8(-int32(25)),
	25: int8(-int32(3)),
	26: int8(-int32(34)),
	27: int8(48),
	28: int8(11),
	29: int8(-int32(13)),
	30: int8(-int32(31)),
	31: int8(-int32(20)),
}

var layer1_weights = [2304]OpusT_opus_int8{
	0:    int8(22),
	1:    int8(-int32(1)),
	2:    int8(-int32(7)),
	3:    int8(7),
	4:    int8(29),
	5:    int8(-int32(27)),
	6:    int8(-int32(31)),
	7:    int8(-int32(17)),
	8:    int8(-int32(13)),
	9:    int8(33),
	10:   int8(44),
	11:   int8(-int32(8)),
	12:   int8(11),
	13:   int8(33),
	14:   int8(24),
	15:   int8(78),
	16:   int8(15),
	17:   int8(19),
	18:   int8(30),
	19:   int8(-int32(2)),
	20:   int8(-int32(24)),
	21:   int8(5),
	22:   int8(49),
	23:   int8(5),
	24:   int8(36),
	25:   int8(29),
	26:   int8(-int32(14)),
	27:   int8(-int32(11)),
	28:   int8(-int32(48)),
	29:   int8(-int32(33)),
	30:   int8(21),
	31:   int8(-int32(42)),
	32:   int8(-int32(38)),
	33:   int8(-int32(12)),
	34:   int8(55),
	35:   int8(-int32(37)),
	36:   int8(54),
	37:   int8(-int32(8)),
	38:   int8(1),
	39:   int8(36),
	40:   int8(17),
	42:   int8(51),
	43:   int8(31),
	44:   int8(59),
	45:   int8(7),
	46:   int8(-int32(12)),
	47:   int8(53),
	48:   int8(4),
	49:   int8(32),
	50:   int8(-int32(14)),
	51:   int8(48),
	52:   int8(5),
	53:   int8(-int32(10)),
	54:   int8(-int32(16)),
	55:   int8(-int32(8)),
	56:   int8(1),
	57:   int8(-int32(16)),
	58:   int8(-int32(56)),
	59:   int8(-int32(24)),
	60:   int8(-int32(6)),
	61:   int8(18),
	62:   int8(-int32(2)),
	63:   int8(23),
	64:   int8(6),
	65:   int8(46),
	66:   int8(-int32(6)),
	67:   int8(-int32(10)),
	68:   int8(20),
	69:   int8(35),
	70:   int8(-int32(44)),
	71:   int8(-int32(15)),
	72:   int8(-int32(49)),
	73:   int8(36),
	74:   int8(16),
	75:   int8(5),
	76:   int8(-int32(7)),
	77:   int8(-int32(79)),
	78:   int8(-int32(67)),
	79:   int8(12),
	80:   int8(70),
	81:   int8(-int32(3)),
	82:   int8(-int32(79)),
	83:   int8(-int32(54)),
	84:   int8(-int32(85)),
	85:   int8(-int32(24)),
	86:   int8(47),
	87:   int8(-int32(22)),
	88:   int8(33),
	89:   int8(21),
	90:   int8(69),
	91:   int8(-int32(1)),
	92:   int8(11),
	93:   int8(22),
	94:   int8(14),
	95:   int8(-int32(16)),
	96:   int8(-int32(16)),
	97:   int8(-int32(22)),
	98:   int8(-int32(28)),
	99:   int8(-int32(11)),
	100:  int8(11),
	101:  int8(-int32(41)),
	102:  int8(31),
	103:  int8(-int32(26)),
	104:  int8(-int32(33)),
	105:  int8(-int32(19)),
	106:  int8(-int32(4)),
	107:  int8(27),
	108:  int8(32),
	109:  int8(-int32(50)),
	110:  int8(5),
	111:  int8(-int32(10)),
	112:  int8(-int32(38)),
	113:  int8(-int32(22)),
	114:  int8(-int32(8)),
	115:  int8(35),
	116:  int8(-int32(31)),
	117:  int8(1),
	118:  int8(-int32(41)),
	119:  int8(-int32(15)),
	120:  int8(-int32(11)),
	121:  int8(44),
	122:  int8(28),
	123:  int8(-int32(17)),
	124:  int8(-int32(41)),
	125:  int8(-int32(23)),
	126:  int8(17),
	127:  int8(2),
	128:  int8(-int32(23)),
	129:  int8(-int32(26)),
	130:  int8(-int32(13)),
	131:  int8(-int32(13)),
	132:  int8(-int32(17)),
	133:  int8(6),
	134:  int8(14),
	135:  int8(-int32(31)),
	136:  int8(-int32(25)),
	137:  int8(9),
	138:  int8(-int32(19)),
	139:  int8(39),
	140:  int8(-int32(8)),
	141:  int8(4),
	142:  int8(31),
	143:  int8(-int32(1)),
	144:  int8(-int32(45)),
	145:  int8(-int32(11)),
	146:  int8(-int32(28)),
	147:  int8(-int32(92)),
	148:  int8(-int32(46)),
	149:  int8(-int32(15)),
	150:  int8(21),
	151:  int8(118),
	152:  int8(-int32(22)),
	153:  int8(45),
	154:  int8(-int32(51)),
	155:  int8(11),
	156:  int8(-int32(20)),
	157:  int8(-int32(20)),
	158:  int8(-int32(15)),
	159:  int8(13),
	160:  int8(-int32(21)),
	161:  int8(-int32(97)),
	162:  int8(-int32(29)),
	163:  int8(-int32(32)),
	164:  int8(-int32(23)),
	165:  int8(-int32(42)),
	166:  int8(94),
	167:  int8(1),
	168:  int8(23),
	169:  int8(-int32(8)),
	170:  int8(63),
	171:  int8(-int32(3)),
	172:  int8(-int32(46)),
	173:  int8(19),
	174:  int8(-int32(26)),
	175:  int8(32),
	176:  int8(-int32(40)),
	177:  int8(-int32(74)),
	178:  int8(-int32(26)),
	179:  int8(26),
	180:  int8(-int32(4)),
	181:  int8(-int32(13)),
	182:  int8(30),
	183:  int8(-int32(20)),
	184:  int8(-int32(30)),
	185:  int8(-int32(25)),
	186:  int8(-int32(14)),
	187:  int8(-int32(31)),
	188:  int8(-int32(45)),
	189:  int8(-int32(43)),
	190:  int8(4),
	191:  int8(-int32(60)),
	192:  int8(-int32(48)),
	193:  int8(-int32(12)),
	194:  int8(-int32(34)),
	195:  int8(2),
	196:  int8(2),
	197:  int8(3),
	198:  int8(13),
	199:  int8(15),
	200:  int8(11),
	201:  int8(16),
	202:  int8(5),
	203:  int8(46),
	204:  int8(-int32(9)),
	205:  int8(-int32(55)),
	206:  int8(-int32(16)),
	207:  int8(-int32(57)),
	208:  int8(29),
	209:  int8(14),
	210:  int8(38),
	211:  int8(-int32(50)),
	212:  int8(-int32(2)),
	213:  int8(-int32(44)),
	214:  int8(-int32(11)),
	215:  int8(-int32(8)),
	216:  int8(52),
	217:  int8(-int32(27)),
	218:  int8(-int32(38)),
	219:  int8(-int32(7)),
	220:  int8(20),
	221:  int8(47),
	222:  int8(17),
	223:  int8(-int32(59)),
	225:  int8(47),
	226:  int8(46),
	227:  int8(-int32(63)),
	228:  int8(35),
	229:  int8(-int32(17)),
	230:  int8(19),
	231:  int8(33),
	232:  int8(68),
	233:  int8(-int32(19)),
	234:  int8(2),
	235:  int8(15),
	236:  int8(-int32(16)),
	237:  int8(28),
	238:  int8(-int32(16)),
	239:  int8(-int32(103)),
	240:  int8(26),
	241:  int8(-int32(35)),
	242:  int8(47),
	243:  int8(-int32(39)),
	244:  int8(-int32(60)),
	245:  int8(30),
	246:  int8(31),
	247:  int8(-int32(23)),
	248:  int8(-int32(52)),
	249:  int8(-int32(13)),
	250:  int8(116),
	251:  int8(47),
	252:  int8(-int32(25)),
	253:  int8(30),
	254:  int8(40),
	255:  int8(30),
	256:  int8(-int32(22)),
	257:  int8(2),
	258:  int8(12),
	259:  int8(-int32(27)),
	260:  int8(-int32(18)),
	261:  int8(31),
	262:  int8(-int32(10)),
	263:  int8(27),
	264:  int8(-int32(8)),
	265:  int8(-int32(66)),
	266:  int8(12),
	267:  int8(14),
	268:  int8(4),
	269:  int8(-int32(26)),
	270:  int8(-int32(28)),
	271:  int8(-int32(13)),
	272:  int8(3),
	273:  int8(13),
	274:  int8(-int32(26)),
	275:  int8(-int32(51)),
	276:  int8(37),
	277:  int8(5),
	278:  int8(2),
	279:  int8(-int32(21)),
	280:  int8(47),
	281:  int8(3),
	282:  int8(13),
	283:  int8(25),
	284:  int8(-int32(41)),
	285:  int8(-int32(27)),
	286:  int8(-int32(8)),
	287:  int8(-int32(4)),
	288:  int8(5),
	289:  int8(-int32(76)),
	290:  int8(-int32(33)),
	291:  int8(28),
	292:  int8(10),
	293:  int8(9),
	294:  int8(-int32(46)),
	295:  int8(-int32(74)),
	296:  int8(19),
	297:  int8(28),
	298:  int8(25),
	299:  int8(31),
	300:  int8(54),
	301:  int8(-int32(55)),
	302:  int8(68),
	303:  int8(38),
	304:  int8(-int32(24)),
	305:  int8(-int32(32)),
	306:  int8(2),
	307:  int8(4),
	308:  int8(68),
	309:  int8(11),
	310:  int8(-int32(1)),
	311:  int8(99),
	312:  int8(5),
	313:  int8(16),
	314:  int8(-int32(2)),
	315:  int8(-int32(74)),
	316:  int8(40),
	317:  int8(26),
	318:  int8(-int32(26)),
	319:  int8(33),
	320:  int8(31),
	321:  int8(-int32(1)),
	322:  int8(-int32(68)),
	323:  int8(14),
	324:  int8(-int32(6)),
	325:  int8(25),
	326:  int8(9),
	327:  int8(29),
	328:  int8(60),
	329:  int8(61),
	330:  int8(7),
	331:  int8(-int32(7)),
	333:  int8(-int32(24)),
	334:  int8(7),
	335:  int8(77),
	336:  int8(4),
	337:  int8(-int32(1)),
	338:  int8(16),
	339:  int8(-int32(7)),
	340:  int8(13),
	341:  int8(-int32(15)),
	342:  int8(-int32(19)),
	343:  int8(28),
	344:  int8(-int32(31)),
	345:  int8(-int32(24)),
	346:  int8(-int32(16)),
	347:  int8(37),
	348:  int8(24),
	349:  int8(13),
	350:  int8(30),
	351:  int8(10),
	352:  int8(-int32(30)),
	353:  int8(11),
	354:  int8(11),
	355:  int8(-int32(10)),
	356:  int8(22),
	357:  int8(60),
	358:  int8(28),
	359:  int8(45),
	360:  int8(-int32(3)),
	361:  int8(-int32(40)),
	362:  int8(-int32(62)),
	363:  int8(-int32(5)),
	364:  int8(-int32(102)),
	365:  int8(9),
	366:  int8(-int32(32)),
	367:  int8(-int32(27)),
	368:  int8(-int32(54)),
	369:  int8(21),
	370:  int8(15),
	371:  int8(-int32(5)),
	372:  int8(37),
	373:  int8(-int32(43)),
	374:  int8(-int32(11)),
	375:  int8(37),
	376:  int8(-int32(19)),
	377:  int8(47),
	378:  int8(-int32(64)),
	379:  int8(-int32(128)),
	380:  int8(-int32(27)),
	381:  int8(-int32(114)),
	382:  int8(21),
	383:  int8(-int32(66)),
	384:  int8(59),
	385:  int8(46),
	386:  int8(-int32(3)),
	387:  int8(-int32(12)),
	388:  int8(-int32(87)),
	389:  int8(-int32(9)),
	390:  int8(4),
	391:  int8(19),
	392:  int8(-int32(113)),
	393:  int8(-int32(36)),
	394:  int8(78),
	395:  int8(57),
	396:  int8(-int32(26)),
	397:  int8(-int32(38)),
	398:  int8(-int32(77)),
	399:  int8(-int32(10)),
	400:  int8(6),
	401:  int8(6),
	402:  int8(-int32(75)),
	403:  int8(25),
	404:  int8(-int32(97)),
	405:  int8(-int32(11)),
	406:  int8(33),
	407:  int8(-int32(46)),
	408:  int8(1),
	409:  int8(13),
	410:  int8(-int32(21)),
	411:  int8(-int32(33)),
	412:  int8(-int32(20)),
	413:  int8(16),
	414:  int8(-int32(6)),
	415:  int8(-int32(3)),
	416:  int8(-int32(11)),
	417:  int8(-int32(4)),
	418:  int8(-int32(27)),
	419:  int8(38),
	420:  int8(8),
	421:  int8(-int32(41)),
	422:  int8(-int32(2)),
	423:  int8(-int32(33)),
	424:  int8(18),
	425:  int8(19),
	426:  int8(-int32(26)),
	427:  int8(1),
	428:  int8(-int32(29)),
	429:  int8(-int32(22)),
	430:  int8(-int32(4)),
	431:  int8(-int32(14)),
	432:  int8(-int32(55)),
	433:  int8(-int32(11)),
	434:  int8(-int32(80)),
	435:  int8(-int32(3)),
	436:  int8(11),
	437:  int8(34),
	438:  int8(90),
	439:  int8(51),
	440:  int8(11),
	441:  int8(17),
	442:  int8(43),
	443:  int8(36),
	444:  int8(127),
	445:  int8(-int32(32)),
	446:  int8(29),
	447:  int8(103),
	448:  int8(9),
	449:  int8(27),
	450:  int8(13),
	451:  int8(64),
	452:  int8(56),
	453:  int8(70),
	454:  int8(-int32(14)),
	455:  int8(3),
	456:  int8(-int32(12)),
	457:  int8(10),
	458:  int8(37),
	459:  int8(3),
	460:  int8(12),
	461:  int8(-int32(22)),
	462:  int8(-int32(10)),
	463:  int8(46),
	464:  int8(28),
	465:  int8(10),
	466:  int8(20),
	467:  int8(26),
	468:  int8(-int32(24)),
	469:  int8(18),
	470:  int8(9),
	471:  int8(7),
	472:  int8(14),
	473:  int8(34),
	474:  int8(-int32(5)),
	475:  int8(-int32(7)),
	476:  int8(31),
	477:  int8(-int32(14)),
	478:  int8(-int32(56)),
	479:  int8(11),
	480:  int8(-int32(18)),
	481:  int8(-int32(8)),
	482:  int8(-int32(17)),
	483:  int8(-int32(7)),
	484:  int8(-int32(10)),
	485:  int8(-int32(40)),
	486:  int8(10),
	487:  int8(-int32(33)),
	488:  int8(-int32(32)),
	489:  int8(-int32(43)),
	490:  int8(5),
	491:  int8(9),
	492:  int8(11),
	493:  int8(-int32(4)),
	494:  int8(10),
	495:  int8(50),
	496:  int8(-int32(12)),
	497:  int8(-int32(5)),
	498:  int8(46),
	499:  int8(9),
	500:  int8(7),
	501:  int8(1),
	502:  int8(11),
	503:  int8(15),
	504:  int8(91),
	505:  int8(-int32(17)),
	506:  int8(7),
	507:  int8(-int32(50)),
	508:  int8(23),
	509:  int8(6),
	510:  int8(-int32(30)),
	511:  int8(-int32(99)),
	513:  int8(-int32(17)),
	514:  int8(14),
	515:  int8(8),
	516:  int8(-int32(10)),
	517:  int8(-int32(25)),
	518:  int8(-int32(30)),
	519:  int8(-int32(69)),
	520:  int8(-int32(62)),
	521:  int8(31),
	522:  int8(127),
	523:  int8(114),
	524:  int8(-int32(23)),
	525:  int8(101),
	526:  int8(-int32(5)),
	527:  int8(-int32(54)),
	528:  int8(-int32(6)),
	529:  int8(-int32(22)),
	530:  int8(7),
	531:  int8(-int32(56)),
	532:  int8(39),
	533:  int8(18),
	534:  int8(-int32(29)),
	536:  int8(46),
	537:  int8(8),
	538:  int8(-int32(79)),
	539:  int8(4),
	540:  int8(-int32(21)),
	541:  int8(18),
	542:  int8(-int32(32)),
	543:  int8(62),
	544:  int8(-int32(12)),
	545:  int8(-int32(8)),
	546:  int8(-int32(12)),
	547:  int8(-int32(58)),
	548:  int8(31),
	549:  int8(-int32(32)),
	550:  int8(17),
	551:  int8(6),
	552:  int8(-int32(24)),
	553:  int8(25),
	554:  int8(24),
	555:  int8(9),
	556:  int8(-int32(4)),
	557:  int8(-int32(19)),
	558:  int8(45),
	559:  int8(6),
	560:  int8(17),
	561:  int8(-int32(14)),
	562:  int8(5),
	563:  int8(-int32(27)),
	564:  int8(16),
	565:  int8(-int32(4)),
	566:  int8(-int32(41)),
	567:  int8(25),
	568:  int8(-int32(36)),
	569:  int8(5),
	570:  int8(15),
	571:  int8(12),
	572:  int8(50),
	573:  int8(27),
	574:  int8(25),
	575:  int8(23),
	576:  int8(-int32(44)),
	577:  int8(-int32(69)),
	578:  int8(-int32(9)),
	579:  int8(-int32(19)),
	580:  int8(-int32(48)),
	581:  int8(-int32(8)),
	582:  int8(4),
	583:  int8(12),
	584:  int8(-int32(6)),
	585:  int8(13),
	586:  int8(-int32(19)),
	587:  int8(-int32(30)),
	588:  int8(-int32(36)),
	589:  int8(26),
	590:  int8(37),
	591:  int8(-int32(1)),
	592:  int8(-int32(3)),
	593:  int8(-int32(30)),
	594:  int8(-int32(42)),
	595:  int8(-int32(14)),
	596:  int8(-int32(10)),
	597:  int8(-int32(20)),
	598:  int8(26),
	599:  int8(-int32(54)),
	600:  int8(-int32(27)),
	601:  int8(-int32(44)),
	602:  int8(4),
	603:  int8(73),
	604:  int8(-int32(26)),
	605:  int8(90),
	606:  int8(32),
	607:  int8(-int32(69)),
	608:  int8(-int32(29)),
	609:  int8(-int32(16)),
	610:  int8(3),
	611:  int8(103),
	612:  int8(15),
	613:  int8(-int32(17)),
	614:  int8(37),
	615:  int8(24),
	616:  int8(-int32(23)),
	617:  int8(-int32(31)),
	618:  int8(33),
	619:  int8(-int32(37)),
	620:  int8(-int32(64)),
	621:  int8(25),
	622:  int8(13),
	623:  int8(-int32(81)),
	624:  int8(-int32(28)),
	625:  int8(-int32(32)),
	626:  int8(27),
	627:  int8(5),
	628:  int8(-int32(35)),
	629:  int8(-int32(23)),
	630:  int8(15),
	631:  int8(-int32(22)),
	632:  int8(19),
	633:  int8(-int32(7)),
	634:  int8(9),
	635:  int8(30),
	636:  int8(19),
	637:  int8(-int32(23)),
	638:  int8(27),
	639:  int8(-int32(13)),
	640:  int8(43),
	641:  int8(29),
	642:  int8(-int32(29)),
	643:  int8(-int32(6)),
	644:  int8(9),
	645:  int8(-int32(40)),
	646:  int8(-int32(33)),
	647:  int8(-int32(33)),
	648:  int8(-int32(32)),
	649:  int8(9),
	650:  int8(11),
	651:  int8(-int32(48)),
	652:  int8(-int32(8)),
	653:  int8(-int32(23)),
	654:  int8(-int32(52)),
	655:  int8(46),
	656:  int8(17),
	657:  int8(-int32(22)),
	658:  int8(-int32(42)),
	659:  int8(35),
	660:  int8(-int32(15)),
	661:  int8(-int32(41)),
	662:  int8(16),
	663:  int8(34),
	664:  int8(31),
	665:  int8(-int32(42)),
	666:  int8(-int32(19)),
	667:  int8(-int32(11)),
	668:  int8(55),
	669:  int8(7),
	670:  int8(-int32(39)),
	671:  int8(89),
	672:  int8(-int32(11)),
	673:  int8(-int32(33)),
	674:  int8(20),
	675:  int8(-int32(14)),
	676:  int8(22),
	677:  int8(32),
	678:  int8(3),
	679:  int8(-int32(17)),
	680:  int8(-int32(6)),
	681:  int8(14),
	682:  int8(34),
	683:  int8(1),
	684:  int8(55),
	685:  int8(-int32(21)),
	686:  int8(-int32(90)),
	687:  int8(-int32(8)),
	688:  int8(18),
	689:  int8(27),
	690:  int8(13),
	691:  int8(-int32(29)),
	692:  int8(21),
	693:  int8(15),
	694:  int8(-int32(33)),
	695:  int8(-int32(51)),
	696:  int8(-int32(9)),
	697:  int8(-int32(11)),
	698:  int8(4),
	699:  int8(-int32(16)),
	700:  int8(-int32(18)),
	701:  int8(23),
	702:  int8(-int32(4)),
	703:  int8(-int32(4)),
	704:  int8(48),
	705:  int8(1),
	706:  int8(7),
	707:  int8(29),
	708:  int8(-int32(14)),
	709:  int8(-int32(12)),
	710:  int8(-int32(16)),
	711:  int8(17),
	712:  int8(35),
	713:  int8(8),
	715:  int8(-int32(7)),
	716:  int8(-int32(2)),
	717:  int8(9),
	718:  int8(8),
	719:  int8(17),
	720:  int8(-int32(6)),
	721:  int8(53),
	722:  int8(-int32(32)),
	723:  int8(-int32(21)),
	724:  int8(-int32(50)),
	725:  int8(5),
	726:  int8(99),
	727:  int8(-int32(60)),
	728:  int8(-int32(5)),
	729:  int8(-int32(53)),
	730:  int8(10),
	731:  int8(-int32(31)),
	732:  int8(12),
	733:  int8(-int32(5)),
	734:  int8(7),
	735:  int8(80),
	736:  int8(36),
	737:  int8(18),
	738:  int8(-int32(31)),
	739:  int8(9),
	740:  int8(98),
	741:  int8(36),
	742:  int8(-int32(63)),
	743:  int8(-int32(35)),
	744:  int8(4),
	745:  int8(-int32(13)),
	746:  int8(-int32(28)),
	747:  int8(-int32(24)),
	748:  int8(28),
	749:  int8(-int32(13)),
	750:  int8(18),
	751:  int8(16),
	752:  int8(-int32(1)),
	753:  int8(-int32(18)),
	754:  int8(-int32(34)),
	755:  int8(10),
	756:  int8(20),
	757:  int8(7),
	758:  int8(4),
	759:  int8(29),
	760:  int8(11),
	761:  int8(25),
	762:  int8(-int32(7)),
	763:  int8(36),
	764:  int8(14),
	765:  int8(45),
	766:  int8(24),
	767:  int8(1),
	768:  int8(-int32(16)),
	769:  int8(30),
	770:  int8(6),
	771:  int8(35),
	772:  int8(-int32(6)),
	773:  int8(-int32(11)),
	774:  int8(-int32(24)),
	775:  int8(13),
	776:  int8(-int32(1)),
	777:  int8(27),
	778:  int8(39),
	779:  int8(20),
	780:  int8(48),
	781:  int8(-int32(11)),
	782:  int8(-int32(4)),
	783:  int8(-int32(13)),
	784:  int8(28),
	785:  int8(11),
	786:  int8(-int32(31)),
	787:  int8(-int32(18)),
	788:  int8(31),
	789:  int8(-int32(29)),
	790:  int8(22),
	791:  int8(-int32(2)),
	792:  int8(-int32(20)),
	793:  int8(-int32(16)),
	794:  int8(5),
	795:  int8(30),
	796:  int8(-int32(12)),
	797:  int8(-int32(28)),
	798:  int8(-int32(3)),
	799:  int8(93),
	800:  int8(-int32(16)),
	801:  int8(23),
	802:  int8(18),
	803:  int8(-int32(29)),
	804:  int8(6),
	805:  int8(-int32(54)),
	806:  int8(-int32(37)),
	807:  int8(28),
	808:  int8(-int32(3)),
	809:  int8(-int32(3)),
	810:  int8(-int32(47)),
	811:  int8(-int32(3)),
	812:  int8(-int32(36)),
	813:  int8(-int32(55)),
	814:  int8(-int32(3)),
	815:  int8(41),
	816:  int8(-int32(10)),
	817:  int8(47),
	818:  int8(-int32(2)),
	819:  int8(23),
	820:  int8(42),
	821:  int8(-int32(7)),
	822:  int8(-int32(71)),
	823:  int8(-int32(27)),
	824:  int8(83),
	825:  int8(-int32(64)),
	826:  int8(7),
	827:  int8(-int32(24)),
	828:  int8(8),
	829:  int8(26),
	830:  int8(-int32(17)),
	831:  int8(15),
	832:  int8(12),
	833:  int8(31),
	834:  int8(-int32(30)),
	835:  int8(-int32(38)),
	836:  int8(-int32(13)),
	837:  int8(-int32(33)),
	838:  int8(-int32(56)),
	839:  int8(4),
	840:  int8(-int32(17)),
	841:  int8(20),
	842:  int8(18),
	843:  int8(1),
	844:  int8(-int32(30)),
	845:  int8(-int32(5)),
	846:  int8(-int32(6)),
	847:  int8(-int32(31)),
	848:  int8(-int32(14)),
	849:  int8(-int32(37)),
	851:  int8(22),
	852:  int8(10),
	853:  int8(-int32(30)),
	854:  int8(37),
	855:  int8(-int32(17)),
	856:  int8(18),
	857:  int8(6),
	858:  int8(5),
	859:  int8(23),
	860:  int8(-int32(36)),
	861:  int8(-int32(32)),
	862:  int8(14),
	863:  int8(18),
	864:  int8(-int32(13)),
	865:  int8(-int32(61)),
	866:  int8(-int32(52)),
	867:  int8(-int32(69)),
	868:  int8(44),
	869:  int8(-int32(30)),
	870:  int8(16),
	871:  int8(18),
	872:  int8(-int32(4)),
	873:  int8(-int32(25)),
	874:  int8(14),
	875:  int8(81),
	876:  int8(26),
	877:  int8(-int32(8)),
	878:  int8(-int32(23)),
	879:  int8(-int32(59)),
	880:  int8(52),
	881:  int8(-int32(104)),
	882:  int8(17),
	883:  int8(119),
	884:  int8(-int32(32)),
	885:  int8(26),
	886:  int8(17),
	887:  int8(1),
	888:  int8(23),
	889:  int8(45),
	890:  int8(29),
	891:  int8(-int32(64)),
	892:  int8(-int32(57)),
	893:  int8(-int32(14)),
	894:  int8(73),
	895:  int8(21),
	896:  int8(-int32(13)),
	897:  int8(-int32(13)),
	898:  int8(9),
	899:  int8(-int32(68)),
	900:  int8(-int32(7)),
	901:  int8(-int32(52)),
	902:  int8(3),
	903:  int8(24),
	904:  int8(-int32(39)),
	905:  int8(44),
	906:  int8(-int32(15)),
	907:  int8(27),
	908:  int8(14),
	909:  int8(19),
	910:  int8(-int32(9)),
	911:  int8(-int32(28)),
	912:  int8(-int32(11)),
	913:  int8(5),
	914:  int8(3),
	915:  int8(-int32(34)),
	916:  int8(-int32(2)),
	917:  int8(2),
	918:  int8(22),
	919:  int8(-int32(6)),
	920:  int8(-int32(23)),
	921:  int8(4),
	922:  int8(3),
	923:  int8(13),
	924:  int8(-int32(22)),
	925:  int8(-int32(13)),
	926:  int8(-int32(10)),
	927:  int8(-int32(18)),
	928:  int8(29),
	929:  int8(6),
	930:  int8(44),
	931:  int8(-int32(13)),
	932:  int8(-int32(24)),
	933:  int8(-int32(8)),
	934:  int8(2),
	935:  int8(30),
	936:  int8(14),
	937:  int8(43),
	938:  int8(6),
	939:  int8(17),
	940:  int8(-int32(73)),
	941:  int8(-int32(6)),
	942:  int8(-int32(7)),
	943:  int8(20),
	944:  int8(-int32(80)),
	945:  int8(-int32(7)),
	946:  int8(-int32(7)),
	947:  int8(-int32(28)),
	948:  int8(15),
	949:  int8(-int32(69)),
	950:  int8(-int32(38)),
	951:  int8(-int32(5)),
	952:  int8(-int32(100)),
	953:  int8(-int32(35)),
	954:  int8(15),
	955:  int8(-int32(79)),
	956:  int8(23),
	957:  int8(29),
	958:  int8(-int32(18)),
	959:  int8(-int32(27)),
	960:  int8(21),
	961:  int8(-int32(66)),
	962:  int8(-int32(37)),
	963:  int8(8),
	964:  int8(-int32(22)),
	965:  int8(-int32(39)),
	966:  int8(48),
	967:  int8(4),
	968:  int8(-int32(13)),
	969:  int8(1),
	970:  int8(-int32(9)),
	971:  int8(11),
	972:  int8(-int32(29)),
	973:  int8(22),
	974:  int8(6),
	975:  int8(-int32(49)),
	976:  int8(32),
	977:  int8(-int32(14)),
	978:  int8(47),
	979:  int8(-int32(18)),
	980:  int8(-int32(4)),
	981:  int8(44),
	982:  int8(-int32(52)),
	983:  int8(-int32(74)),
	984:  int8(43),
	985:  int8(30),
	986:  int8(23),
	987:  int8(-int32(14)),
	988:  int8(5),
	990:  int8(-int32(27)),
	991:  int8(4),
	992:  int8(-int32(7)),
	993:  int8(10),
	994:  int8(-int32(4)),
	995:  int8(10),
	996:  int8(1),
	997:  int8(-int32(16)),
	998:  int8(11),
	999:  int8(-int32(18)),
	1000: int8(-int32(2)),
	1001: int8(-int32(5)),
	1002: int8(2),
	1003: int8(-int32(11)),
	1005: int8(-int32(20)),
	1006: int8(-int32(4)),
	1007: int8(38),
	1008: int8(74),
	1009: int8(59),
	1010: int8(39),
	1011: int8(64),
	1012: int8(-int32(10)),
	1013: int8(26),
	1014: int8(-int32(3)),
	1015: int8(-int32(40)),
	1016: int8(-int32(68)),
	1017: int8(3),
	1018: int8(-int32(30)),
	1019: int8(-int32(51)),
	1020: int8(8),
	1021: int8(-int32(19)),
	1022: int8(-int32(27)),
	1023: int8(-int32(46)),
	1024: int8(51),
	1025: int8(52),
	1026: int8(54),
	1027: int8(36),
	1028: int8(90),
	1029: int8(92),
	1030: int8(14),
	1031: int8(13),
	1032: int8(-int32(5)),
	1034: int8(16),
	1035: int8(-int32(62)),
	1036: int8(16),
	1037: int8(11),
	1038: int8(-int32(47)),
	1039: int8(-int32(37)),
	1040: int8(-int32(6)),
	1041: int8(-int32(5)),
	1042: int8(21),
	1043: int8(54),
	1044: int8(-int32(57)),
	1045: int8(32),
	1046: int8(42),
	1047: int8(-int32(6)),
	1048: int8(62),
	1049: int8(-int32(9)),
	1050: int8(16),
	1051: int8(21),
	1052: int8(24),
	1053: int8(9),
	1054: int8(-int32(10)),
	1055: int8(-int32(4)),
	1056: int8(33),
	1057: int8(50),
	1058: int8(13),
	1059: int8(-int32(15)),
	1060: int8(1),
	1061: int8(-int32(35)),
	1062: int8(-int32(48)),
	1063: int8(18),
	1064: int8(-int32(11)),
	1065: int8(-int32(17)),
	1066: int8(-int32(67)),
	1067: int8(-int32(13)),
	1068: int8(21),
	1069: int8(38),
	1070: int8(-int32(44)),
	1071: int8(36),
	1072: int8(-int32(16)),
	1073: int8(29),
	1074: int8(17),
	1075: int8(5),
	1076: int8(-int32(10)),
	1077: int8(18),
	1078: int8(17),
	1079: int8(-int32(32)),
	1080: int8(2),
	1081: int8(8),
	1082: int8(22),
	1083: int8(-int32(56)),
	1084: int8(-int32(15)),
	1085: int8(-int32(32)),
	1086: int8(40),
	1087: int8(43),
	1088: int8(19),
	1089: int8(46),
	1090: int8(-int32(7)),
	1091: int8(-int32(100)),
	1092: int8(-int32(96)),
	1093: int8(19),
	1094: int8(53),
	1095: int8(24),
	1096: int8(21),
	1097: int8(-int32(26)),
	1098: int8(-int32(48)),
	1099: int8(-int32(101)),
	1100: int8(-int32(82)),
	1101: int8(61),
	1102: int8(38),
	1103: int8(-int32(85)),
	1104: int8(-int32(28)),
	1105: int8(-int32(34)),
	1106: int8(-int32(1)),
	1107: int8(63),
	1108: int8(-int32(5)),
	1109: int8(-int32(5)),
	1110: int8(39),
	1111: int8(39),
	1112: int8(-int32(38)),
	1113: int8(32),
	1114: int8(-int32(12)),
	1115: int8(-int32(28)),
	1116: int8(20),
	1117: int8(40),
	1118: int8(-int32(8)),
	1119: int8(2),
	1120: int8(31),
	1121: int8(12),
	1122: int8(-int32(35)),
	1123: int8(-int32(13)),
	1124: int8(20),
	1125: int8(-int32(25)),
	1126: int8(30),
	1127: int8(8),
	1128: int8(3),
	1129: int8(-int32(13)),
	1130: int8(-int32(9)),
	1131: int8(-int32(20)),
	1132: int8(2),
	1133: int8(-int32(13)),
	1134: int8(24),
	1135: int8(37),
	1136: int8(-int32(10)),
	1137: int8(33),
	1138: int8(6),
	1139: int8(20),
	1140: int8(-int32(16)),
	1141: int8(-int32(24)),
	1142: int8(-int32(6)),
	1143: int8(-int32(6)),
	1144: int8(-int32(19)),
	1145: int8(-int32(5)),
	1146: int8(22),
	1147: int8(21),
	1148: int8(10),
	1149: int8(11),
	1150: int8(-int32(4)),
	1151: int8(-int32(39)),
	1152: int8(-int32(1)),
	1153: int8(6),
	1154: int8(49),
	1155: int8(41),
	1156: int8(-int32(15)),
	1157: int8(-int32(57)),
	1158: int8(21),
	1159: int8(-int32(62)),
	1160: int8(77),
	1161: int8(-int32(69)),
	1162: int8(-int32(13)),
	1164: int8(-int32(74)),
	1165: int8(1),
	1166: int8(-int32(7)),
	1167: int8(-int32(38)),
	1168: int8(-int32(8)),
	1169: int8(6),
	1170: int8(63),
	1171: int8(28),
	1172: int8(4),
	1173: int8(26),
	1174: int8(-int32(52)),
	1175: int8(82),
	1176: int8(63),
	1177: int8(13),
	1178: int8(45),
	1179: int8(-int32(33)),
	1180: int8(44),
	1181: int8(-int32(52)),
	1182: int8(-int32(65)),
	1183: int8(-int32(21)),
	1184: int8(-int32(46)),
	1185: int8(-int32(49)),
	1186: int8(64),
	1187: int8(-int32(17)),
	1188: int8(32),
	1189: int8(24),
	1190: int8(68),
	1191: int8(-int32(39)),
	1192: int8(-int32(16)),
	1193: int8(-int32(5)),
	1194: int8(-int32(26)),
	1195: int8(28),
	1196: int8(5),
	1197: int8(-int32(61)),
	1198: int8(-int32(28)),
	1199: int8(2),
	1200: int8(24),
	1201: int8(11),
	1202: int8(-int32(12)),
	1203: int8(-int32(33)),
	1204: int8(9),
	1205: int8(-int32(37)),
	1206: int8(-int32(3)),
	1207: int8(-int32(28)),
	1208: int8(22),
	1209: int8(-int32(37)),
	1210: int8(-int32(12)),
	1211: int8(19),
	1213: int8(-int32(18)),
	1214: int8(-int32(2)),
	1215: int8(14),
	1216: int8(1),
	1217: int8(4),
	1218: int8(8),
	1219: int8(-int32(9)),
	1220: int8(-int32(2)),
	1221: int8(43),
	1222: int8(-int32(17)),
	1223: int8(-int32(2)),
	1224: int8(-int32(66)),
	1225: int8(-int32(31)),
	1226: int8(56),
	1227: int8(-int32(40)),
	1228: int8(-int32(87)),
	1229: int8(-int32(36)),
	1230: int8(-int32(2)),
	1231: int8(-int32(4)),
	1232: int8(-int32(42)),
	1233: int8(-int32(45)),
	1234: int8(-int32(1)),
	1235: int8(31),
	1236: int8(-int32(43)),
	1237: int8(-int32(15)),
	1238: int8(27),
	1239: int8(63),
	1240: int8(-int32(11)),
	1241: int8(32),
	1242: int8(-int32(10)),
	1243: int8(-int32(33)),
	1244: int8(27),
	1245: int8(-int32(19)),
	1246: int8(4),
	1247: int8(15),
	1248: int8(-int32(26)),
	1249: int8(-int32(34)),
	1250: int8(29),
	1251: int8(-int32(4)),
	1252: int8(-int32(39)),
	1253: int8(-int32(65)),
	1254: int8(14),
	1255: int8(-int32(20)),
	1256: int8(-int32(21)),
	1257: int8(-int32(17)),
	1258: int8(-int32(36)),
	1259: int8(13),
	1260: int8(59),
	1261: int8(47),
	1262: int8(-int32(38)),
	1263: int8(-int32(33)),
	1264: int8(13),
	1265: int8(-int32(37)),
	1266: int8(-int32(8)),
	1267: int8(-int32(37)),
	1268: int8(-int32(7)),
	1269: int8(-int32(6)),
	1270: int8(-int32(76)),
	1271: int8(-int32(31)),
	1272: int8(-int32(12)),
	1273: int8(-int32(46)),
	1274: int8(7),
	1275: int8(24),
	1276: int8(-int32(21)),
	1277: int8(-int32(30)),
	1278: int8(-int32(14)),
	1279: int8(9),
	1280: int8(15),
	1281: int8(-int32(12)),
	1282: int8(-int32(13)),
	1283: int8(47),
	1284: int8(-int32(27)),
	1285: int8(-int32(25)),
	1286: int8(-int32(1)),
	1287: int8(-int32(39)),
	1289: int8(20),
	1290: int8(-int32(9)),
	1291: int8(6),
	1292: int8(7),
	1293: int8(4),
	1294: int8(3),
	1295: int8(7),
	1296: int8(39),
	1297: int8(50),
	1298: int8(22),
	1299: int8(-int32(7)),
	1300: int8(14),
	1301: int8(-int32(20)),
	1302: int8(1),
	1303: int8(70),
	1304: int8(-int32(28)),
	1305: int8(29),
	1306: int8(-int32(41)),
	1307: int8(10),
	1308: int8(-int32(16)),
	1309: int8(-int32(5)),
	1310: int8(-int32(28)),
	1311: int8(-int32(2)),
	1312: int8(-int32(37)),
	1313: int8(32),
	1314: int8(-int32(18)),
	1315: int8(17),
	1316: int8(62),
	1317: int8(-int32(11)),
	1318: int8(-int32(20)),
	1319: int8(-int32(50)),
	1320: int8(36),
	1321: int8(21),
	1322: int8(-int32(62)),
	1323: int8(-int32(12)),
	1324: int8(-int32(56)),
	1325: int8(52),
	1326: int8(50),
	1327: int8(17),
	1328: int8(3),
	1329: int8(48),
	1330: int8(44),
	1331: int8(-int32(41)),
	1332: int8(-int32(25)),
	1333: int8(3),
	1334: int8(16),
	1335: int8(-int32(3)),
	1337: int8(33),
	1338: int8(-int32(6)),
	1339: int8(15),
	1340: int8(27),
	1341: int8(34),
	1342: int8(-int32(25)),
	1343: int8(22),
	1344: int8(9),
	1345: int8(17),
	1346: int8(-int32(11)),
	1347: int8(36),
	1348: int8(16),
	1349: int8(-int32(2)),
	1350: int8(12),
	1351: int8(21),
	1352: int8(-int32(52)),
	1353: int8(45),
	1354: int8(-int32(2)),
	1355: int8(-int32(10)),
	1356: int8(46),
	1357: int8(21),
	1358: int8(-int32(18)),
	1359: int8(67),
	1360: int8(-int32(28)),
	1361: int8(-int32(13)),
	1362: int8(30),
	1363: int8(37),
	1364: int8(42),
	1365: int8(16),
	1366: int8(-int32(9)),
	1367: int8(11),
	1368: int8(75),
	1369: int8(7),
	1370: int8(-int32(64)),
	1371: int8(-int32(40)),
	1372: int8(-int32(10)),
	1373: int8(29),
	1374: int8(57),
	1375: int8(-int32(23)),
	1376: int8(5),
	1377: int8(53),
	1378: int8(-int32(77)),
	1379: int8(3),
	1380: int8(-int32(17)),
	1381: int8(-int32(5)),
	1382: int8(47),
	1383: int8(-int32(55)),
	1384: int8(-int32(35)),
	1385: int8(-int32(36)),
	1386: int8(-int32(13)),
	1387: int8(52),
	1388: int8(-int32(53)),
	1389: int8(-int32(71)),
	1390: int8(52),
	1391: int8(-int32(111)),
	1392: int8(-int32(23)),
	1393: int8(-int32(26)),
	1394: int8(-int32(28)),
	1395: int8(29),
	1396: int8(-int32(43)),
	1397: int8(55),
	1398: int8(-int32(19)),
	1399: int8(43),
	1400: int8(-int32(19)),
	1401: int8(54),
	1402: int8(-int32(12)),
	1403: int8(-int32(33)),
	1404: int8(-int32(44)),
	1405: int8(-int32(39)),
	1406: int8(-int32(19)),
	1407: int8(-int32(10)),
	1408: int8(-int32(31)),
	1409: int8(-int32(10)),
	1410: int8(21),
	1411: int8(38),
	1412: int8(-int32(57)),
	1413: int8(-int32(20)),
	1414: int8(2),
	1415: int8(-int32(25)),
	1416: int8(8),
	1417: int8(-int32(6)),
	1418: int8(50),
	1419: int8(12),
	1420: int8(15),
	1421: int8(25),
	1422: int8(-int32(25)),
	1423: int8(15),
	1424: int8(-int32(30)),
	1425: int8(-int32(6)),
	1426: int8(9),
	1427: int8(25),
	1428: int8(37),
	1429: int8(19),
	1430: int8(-int32(4)),
	1431: int8(31),
	1432: int8(-int32(22)),
	1433: int8(2),
	1434: int8(4),
	1435: int8(2),
	1436: int8(36),
	1437: int8(7),
	1438: int8(3),
	1439: int8(-int32(34)),
	1440: int8(-int32(80)),
	1441: int8(36),
	1442: int8(-int32(10)),
	1443: int8(-int32(2)),
	1444: int8(-int32(5)),
	1445: int8(31),
	1446: int8(-int32(36)),
	1447: int8(49),
	1448: int8(-int32(70)),
	1449: int8(20),
	1450: int8(-int32(36)),
	1451: int8(21),
	1452: int8(24),
	1453: int8(25),
	1454: int8(-int32(46)),
	1455: int8(-int32(51)),
	1456: int8(36),
	1457: int8(-int32(58)),
	1458: int8(-int32(48)),
	1459: int8(-int32(40)),
	1460: int8(-int32(10)),
	1461: int8(55),
	1462: int8(71),
	1463: int8(47),
	1464: int8(10),
	1465: int8(-int32(1)),
	1466: int8(1),
	1467: int8(2),
	1468: int8(-int32(46)),
	1469: int8(-int32(68)),
	1470: int8(16),
	1471: int8(13),
	1473: int8(-int32(74)),
	1474: int8(-int32(29)),
	1475: int8(73),
	1476: int8(-int32(52)),
	1477: int8(-int32(18)),
	1478: int8(-int32(11)),
	1479: int8(7),
	1480: int8(-int32(44)),
	1481: int8(-int32(82)),
	1482: int8(-int32(32)),
	1483: int8(-int32(70)),
	1484: int8(-int32(28)),
	1485: int8(-int32(1)),
	1486: int8(-int32(39)),
	1487: int8(-int32(68)),
	1488: int8(-int32(6)),
	1489: int8(-int32(41)),
	1490: int8(12),
	1491: int8(-int32(22)),
	1492: int8(-int32(16)),
	1493: int8(40),
	1494: int8(-int32(11)),
	1495: int8(-int32(25)),
	1496: int8(51),
	1497: int8(-int32(9)),
	1498: int8(21),
	1499: int8(4),
	1500: int8(4),
	1501: int8(-int32(34)),
	1502: int8(7),
	1503: int8(-int32(78)),
	1504: int8(16),
	1505: int8(6),
	1506: int8(-int32(38)),
	1507: int8(-int32(30)),
	1508: int8(-int32(2)),
	1509: int8(-int32(44)),
	1510: int8(32),
	1512: int8(22),
	1513: int8(64),
	1514: int8(5),
	1515: int8(-int32(72)),
	1516: int8(-int32(2)),
	1517: int8(-int32(14)),
	1518: int8(-int32(10)),
	1519: int8(-int32(16)),
	1520: int8(-int32(8)),
	1521: int8(-int32(25)),
	1522: int8(12),
	1523: int8(102),
	1524: int8(-int32(58)),
	1525: int8(37),
	1526: int8(-int32(10)),
	1527: int8(-int32(23)),
	1528: int8(15),
	1529: int8(49),
	1530: int8(7),
	1531: int8(-int32(7)),
	1532: int8(2),
	1533: int8(-int32(20)),
	1534: int8(-int32(32)),
	1535: int8(45),
	1536: int8(-int32(6)),
	1537: int8(48),
	1538: int8(28),
	1539: int8(30),
	1540: int8(33),
	1541: int8(-int32(1)),
	1542: int8(22),
	1543: int8(-int32(6)),
	1544: int8(30),
	1545: int8(65),
	1546: int8(-int32(17)),
	1547: int8(29),
	1548: int8(74),
	1549: int8(37),
	1550: int8(-int32(26)),
	1551: int8(-int32(10)),
	1552: int8(15),
	1553: int8(-int32(24)),
	1554: int8(19),
	1555: int8(-int32(66)),
	1556: int8(22),
	1557: int8(-int32(10)),
	1558: int8(-int32(31)),
	1559: int8(-int32(1)),
	1560: int8(-int32(18)),
	1561: int8(-int32(9)),
	1562: int8(11),
	1563: int8(37),
	1564: int8(-int32(4)),
	1565: int8(45),
	1566: int8(5),
	1567: int8(41),
	1568: int8(17),
	1569: int8(1),
	1570: int8(1),
	1571: int8(24),
	1572: int8(-int32(58)),
	1573: int8(41),
	1574: int8(5),
	1575: int8(-int32(51)),
	1576: int8(14),
	1577: int8(8),
	1578: int8(43),
	1579: int8(16),
	1580: int8(-int32(10)),
	1581: int8(-int32(1)),
	1582: int8(45),
	1583: int8(32),
	1584: int8(-int32(64)),
	1585: int8(3),
	1586: int8(-int32(33)),
	1587: int8(-int32(25)),
	1588: int8(-int32(3)),
	1589: int8(-int32(27)),
	1590: int8(-int32(68)),
	1591: int8(12),
	1592: int8(23),
	1593: int8(-int32(11)),
	1594: int8(-int32(13)),
	1595: int8(-int32(37)),
	1596: int8(-int32(40)),
	1597: int8(4),
	1598: int8(-int32(21)),
	1599: int8(-int32(12)),
	1600: int8(32),
	1601: int8(-int32(23)),
	1602: int8(-int32(19)),
	1603: int8(76),
	1604: int8(41),
	1605: int8(-int32(23)),
	1606: int8(-int32(24)),
	1607: int8(-int32(44)),
	1608: int8(-int32(65)),
	1609: int8(-int32(1)),
	1610: int8(-int32(15)),
	1611: int8(1),
	1612: int8(71),
	1613: int8(63),
	1614: int8(5),
	1615: int8(20),
	1616: int8(-int32(3)),
	1617: int8(21),
	1618: int8(-int32(23)),
	1619: int8(31),
	1620: int8(-int32(32)),
	1621: int8(18),
	1622: int8(-int32(2)),
	1623: int8(27),
	1624: int8(31),
	1625: int8(46),
	1626: int8(-int32(5)),
	1627: int8(-int32(39)),
	1628: int8(-int32(5)),
	1629: int8(-int32(35)),
	1630: int8(18),
	1631: int8(-int32(18)),
	1632: int8(-int32(40)),
	1633: int8(-int32(10)),
	1634: int8(3),
	1635: int8(12),
	1636: int8(2),
	1637: int8(-int32(2)),
	1638: int8(-int32(22)),
	1639: int8(40),
	1640: int8(5),
	1641: int8(-int32(6)),
	1642: int8(60),
	1643: int8(36),
	1644: int8(3),
	1645: int8(29),
	1646: int8(-int32(27)),
	1647: int8(10),
	1648: int8(25),
	1649: int8(-int32(54)),
	1650: int8(5),
	1651: int8(26),
	1652: int8(39),
	1653: int8(35),
	1654: int8(-int32(24)),
	1655: int8(-int32(37)),
	1656: int8(30),
	1657: int8(-int32(91)),
	1658: int8(28),
	1659: int8(-int32(4)),
	1660: int8(-int32(21)),
	1661: int8(-int32(27)),
	1662: int8(-int32(39)),
	1663: int8(-int32(6)),
	1664: int8(5),
	1665: int8(12),
	1666: int8(-int32(128)),
	1667: int8(38),
	1668: int8(-int32(16)),
	1669: int8(29),
	1670: int8(-int32(95)),
	1671: int8(-int32(29)),
	1672: int8(82),
	1673: int8(-int32(2)),
	1674: int8(35),
	1675: int8(2),
	1676: int8(12),
	1677: int8(8),
	1678: int8(-int32(22)),
	1679: int8(10),
	1680: int8(80),
	1681: int8(-int32(47)),
	1682: int8(2),
	1683: int8(-int32(25)),
	1684: int8(-int32(73)),
	1685: int8(-int32(79)),
	1686: int8(16),
	1687: int8(-int32(30)),
	1688: int8(-int32(32)),
	1689: int8(-int32(66)),
	1690: int8(48),
	1691: int8(21),
	1692: int8(-int32(45)),
	1693: int8(-int32(11)),
	1694: int8(-int32(47)),
	1695: int8(14),
	1696: int8(-int32(27)),
	1697: int8(-int32(17)),
	1698: int8(-int32(7)),
	1699: int8(15),
	1700: int8(-int32(44)),
	1701: int8(-int32(14)),
	1702: int8(-int32(44)),
	1703: int8(-int32(26)),
	1704: int8(-int32(32)),
	1705: int8(26),
	1706: int8(-int32(23)),
	1707: int8(17),
	1708: int8(-int32(7)),
	1709: int8(-int32(28)),
	1710: int8(26),
	1711: int8(-int32(6)),
	1712: int8(28),
	1713: int8(6),
	1714: int8(-int32(26)),
	1715: int8(2),
	1716: int8(13),
	1717: int8(-int32(14)),
	1718: int8(-int32(23)),
	1719: int8(-int32(14)),
	1720: int8(19),
	1721: int8(46),
	1722: int8(16),
	1723: int8(2),
	1724: int8(-int32(33)),
	1725: int8(-int32(21)),
	1726: int8(28),
	1727: int8(-int32(17)),
	1728: int8(-int32(42)),
	1729: int8(44),
	1730: int8(-int32(37)),
	1731: int8(1),
	1732: int8(-int32(39)),
	1733: int8(28),
	1734: int8(84),
	1735: int8(-int32(46)),
	1736: int8(15),
	1737: int8(10),
	1738: int8(13),
	1739: int8(-int32(44)),
	1740: int8(72),
	1741: int8(-int32(26)),
	1742: int8(26),
	1743: int8(32),
	1744: int8(-int32(28)),
	1745: int8(-int32(12)),
	1746: int8(-int32(83)),
	1747: int8(2),
	1748: int8(10),
	1749: int8(-int32(30)),
	1750: int8(-int32(44)),
	1751: int8(-int32(10)),
	1752: int8(-int32(28)),
	1753: int8(53),
	1754: int8(45),
	1755: int8(65),
	1757: int8(-int32(25)),
	1758: int8(57),
	1759: int8(36),
	1760: int8(-int32(33)),
	1761: int8(6),
	1762: int8(29),
	1763: int8(44),
	1764: int8(-int32(53)),
	1765: int8(11),
	1766: int8(19),
	1767: int8(-int32(2)),
	1768: int8(-int32(27)),
	1769: int8(35),
	1770: int8(32),
	1771: int8(49),
	1772: int8(4),
	1773: int8(23),
	1774: int8(38),
	1775: int8(36),
	1776: int8(24),
	1777: int8(10),
	1778: int8(51),
	1779: int8(-int32(39)),
	1780: int8(4),
	1781: int8(-int32(7)),
	1782: int8(26),
	1783: int8(37),
	1784: int8(-int32(35)),
	1785: int8(11),
	1786: int8(-int32(47)),
	1787: int8(-int32(18)),
	1788: int8(28),
	1789: int8(16),
	1790: int8(-int32(35)),
	1791: int8(42),
	1792: int8(17),
	1793: int8(-int32(21)),
	1794: int8(-int32(41)),
	1795: int8(28),
	1796: int8(14),
	1797: int8(-int32(12)),
	1798: int8(11),
	1799: int8(-int32(45)),
	1800: int8(7),
	1801: int8(-int32(43)),
	1802: int8(-int32(15)),
	1803: int8(18),
	1804: int8(-int32(5)),
	1805: int8(38),
	1806: int8(-int32(40)),
	1807: int8(-int32(50)),
	1808: int8(-int32(30)),
	1809: int8(-int32(21)),
	1810: int8(9),
	1811: int8(-int32(98)),
	1812: int8(13),
	1813: int8(12),
	1814: int8(23),
	1815: int8(75),
	1816: int8(-int32(56)),
	1817: int8(-int32(7)),
	1818: int8(-int32(3)),
	1819: int8(-int32(4)),
	1820: int8(-int32(1)),
	1821: int8(-int32(34)),
	1822: int8(12),
	1823: int8(-int32(49)),
	1824: int8(11),
	1825: int8(26),
	1826: int8(-int32(18)),
	1827: int8(-int32(28)),
	1828: int8(-int32(17)),
	1829: int8(33),
	1830: int8(13),
	1831: int8(-int32(14)),
	1832: int8(40),
	1833: int8(24),
	1834: int8(-int32(72)),
	1835: int8(-int32(37)),
	1836: int8(10),
	1837: int8(17),
	1838: int8(-int32(6)),
	1839: int8(22),
	1840: int8(16),
	1841: int8(16),
	1842: int8(-int32(6)),
	1843: int8(-int32(12)),
	1844: int8(-int32(30)),
	1845: int8(-int32(14)),
	1846: int8(10),
	1847: int8(40),
	1848: int8(-int32(23)),
	1849: int8(12),
	1850: int8(15),
	1851: int8(-int32(3)),
	1852: int8(-int32(15)),
	1853: int8(13),
	1854: int8(-int32(56)),
	1855: int8(-int32(4)),
	1856: int8(-int32(30)),
	1857: int8(1),
	1858: int8(-int32(3)),
	1859: int8(-int32(17)),
	1860: int8(27),
	1861: int8(50),
	1862: int8(-int32(5)),
	1863: int8(64),
	1864: int8(-int32(36)),
	1865: int8(-int32(19)),
	1866: int8(7),
	1867: int8(29),
	1868: int8(22),
	1869: int8(25),
	1870: int8(9),
	1871: int8(-int32(16)),
	1872: int8(-int32(58)),
	1873: int8(-int32(69)),
	1874: int8(-int32(40)),
	1875: int8(-int32(61)),
	1876: int8(-int32(71)),
	1877: int8(-int32(14)),
	1878: int8(42),
	1879: int8(93),
	1880: int8(26),
	1881: int8(11),
	1882: int8(-int32(6)),
	1883: int8(-int32(58)),
	1884: int8(-int32(11)),
	1885: int8(70),
	1886: int8(-int32(52)),
	1887: int8(19),
	1888: int8(9),
	1889: int8(-int32(30)),
	1890: int8(-int32(33)),
	1891: int8(11),
	1892: int8(-int32(37)),
	1893: int8(-int32(47)),
	1894: int8(-int32(21)),
	1895: int8(-int32(22)),
	1896: int8(-int32(40)),
	1897: int8(10),
	1898: int8(47),
	1899: int8(4),
	1900: int8(-int32(23)),
	1901: int8(17),
	1902: int8(48),
	1903: int8(41),
	1904: int8(-int32(48)),
	1905: int8(14),
	1906: int8(10),
	1907: int8(15),
	1908: int8(34),
	1909: int8(-int32(23)),
	1910: int8(-int32(2)),
	1911: int8(-int32(47)),
	1912: int8(23),
	1913: int8(-int32(32)),
	1914: int8(-int32(13)),
	1915: int8(-int32(10)),
	1916: int8(-int32(26)),
	1917: int8(-int32(26)),
	1918: int8(-int32(4)),
	1919: int8(16),
	1920: int8(38),
	1921: int8(-int32(14)),
	1923: int8(-int32(12)),
	1924: int8(-int32(7)),
	1925: int8(-int32(7)),
	1926: int8(20),
	1927: int8(44),
	1928: int8(-int32(1)),
	1929: int8(-int32(32)),
	1930: int8(-int32(27)),
	1931: int8(-int32(16)),
	1932: int8(4),
	1933: int8(-int32(6)),
	1934: int8(-int32(18)),
	1935: int8(14),
	1936: int8(5),
	1937: int8(4),
	1938: int8(-int32(29)),
	1939: int8(28),
	1940: int8(7),
	1941: int8(-int32(7)),
	1942: int8(15),
	1943: int8(-int32(11)),
	1944: int8(-int32(20)),
	1945: int8(-int32(45)),
	1946: int8(-int32(36)),
	1947: int8(16),
	1948: int8(84),
	1949: int8(34),
	1950: int8(-int32(59)),
	1951: int8(-int32(30)),
	1952: int8(22),
	1953: int8(126),
	1954: int8(8),
	1955: int8(68),
	1956: int8(79),
	1957: int8(-int32(17)),
	1958: int8(21),
	1959: int8(-int32(68)),
	1960: int8(37),
	1961: int8(5),
	1962: int8(15),
	1963: int8(63),
	1964: int8(49),
	1965: int8(127),
	1966: int8(-int32(90)),
	1967: int8(85),
	1968: int8(43),
	1969: int8(7),
	1970: int8(16),
	1971: int8(9),
	1972: int8(6),
	1973: int8(-int32(45)),
	1974: int8(-int32(57)),
	1975: int8(-int32(43)),
	1976: int8(57),
	1977: int8(11),
	1978: int8(-int32(23)),
	1979: int8(-int32(11)),
	1980: int8(-int32(29)),
	1981: int8(60),
	1982: int8(-int32(26)),
	1984: int8(7),
	1985: int8(42),
	1986: int8(-int32(24)),
	1987: int8(10),
	1988: int8(23),
	1989: int8(-int32(25)),
	1990: int8(8),
	1991: int8(-int32(7)),
	1992: int8(-int32(40)),
	1993: int8(19),
	1994: int8(-int32(17)),
	1995: int8(35),
	1996: int8(4),
	1997: int8(27),
	1998: int8(-int32(39)),
	1999: int8(-int32(91)),
	2000: int8(27),
	2001: int8(-int32(36)),
	2002: int8(34),
	2003: int8(2),
	2004: int8(16),
	2005: int8(-int32(24)),
	2006: int8(25),
	2007: int8(7),
	2008: int8(-int32(21)),
	2009: int8(5),
	2010: int8(17),
	2011: int8(10),
	2012: int8(-int32(22)),
	2013: int8(-int32(30)),
	2014: int8(9),
	2015: int8(-int32(17)),
	2016: int8(-int32(61)),
	2017: int8(-int32(26)),
	2018: int8(33),
	2019: int8(21),
	2020: int8(58),
	2021: int8(-int32(51)),
	2022: int8(-int32(14)),
	2023: int8(69),
	2024: int8(-int32(38)),
	2025: int8(20),
	2026: int8(7),
	2027: int8(80),
	2028: int8(-int32(4)),
	2029: int8(-int32(65)),
	2030: int8(-int32(6)),
	2031: int8(-int32(27)),
	2032: int8(53),
	2033: int8(-int32(12)),
	2034: int8(47),
	2035: int8(-int32(1)),
	2036: int8(-int32(15)),
	2037: int8(1),
	2038: int8(60),
	2039: int8(102),
	2040: int8(-int32(79)),
	2041: int8(-int32(4)),
	2042: int8(12),
	2043: int8(9),
	2044: int8(22),
	2045: int8(37),
	2046: int8(-int32(8)),
	2047: int8(-int32(4)),
	2048: int8(37),
	2049: int8(2),
	2050: int8(-int32(3)),
	2051: int8(-int32(15)),
	2052: int8(-int32(16)),
	2053: int8(-int32(11)),
	2054: int8(-int32(5)),
	2055: int8(19),
	2056: int8(-int32(6)),
	2057: int8(-int32(43)),
	2058: int8(20),
	2059: int8(-int32(25)),
	2060: int8(-int32(18)),
	2061: int8(10),
	2062: int8(-int32(27)),
	2064: int8(-int32(28)),
	2065: int8(-int32(27)),
	2066: int8(-int32(11)),
	2067: int8(10),
	2068: int8(-int32(18)),
	2069: int8(-int32(2)),
	2070: int8(-int32(4)),
	2071: int8(-int32(16)),
	2072: int8(26),
	2073: int8(14),
	2074: int8(-int32(6)),
	2075: int8(7),
	2076: int8(-int32(6)),
	2077: int8(1),
	2078: int8(53),
	2079: int8(-int32(2)),
	2080: int8(-int32(29)),
	2081: int8(23),
	2082: int8(9),
	2083: int8(-int32(30)),
	2084: int8(-int32(6)),
	2085: int8(-int32(4)),
	2086: int8(-int32(6)),
	2087: int8(56),
	2088: int8(70),
	2090: int8(-int32(33)),
	2091: int8(-int32(20)),
	2092: int8(-int32(17)),
	2093: int8(-int32(9)),
	2094: int8(-int32(24)),
	2095: int8(46),
	2096: int8(-int32(5)),
	2097: int8(-int32(105)),
	2098: int8(47),
	2099: int8(-int32(46)),
	2100: int8(-int32(51)),
	2101: int8(20),
	2102: int8(20),
	2103: int8(-int32(53)),
	2104: int8(-int32(81)),
	2105: int8(-int32(1)),
	2106: int8(-int32(7)),
	2107: int8(75),
	2108: int8(-int32(5)),
	2109: int8(-int32(21)),
	2110: int8(-int32(65)),
	2111: int8(12),
	2112: int8(-int32(52)),
	2113: int8(22),
	2114: int8(-int32(50)),
	2115: int8(-int32(12)),
	2116: int8(49),
	2117: int8(54),
	2118: int8(76),
	2119: int8(-int32(81)),
	2120: int8(10),
	2121: int8(45),
	2122: int8(-int32(41)),
	2123: int8(-int32(59)),
	2124: int8(18),
	2125: int8(-int32(19)),
	2126: int8(25),
	2127: int8(14),
	2128: int8(-int32(31)),
	2129: int8(-int32(53)),
	2130: int8(-int32(5)),
	2131: int8(12),
	2132: int8(31),
	2133: int8(84),
	2134: int8(-int32(23)),
	2135: int8(2),
	2136: int8(7),
	2137: int8(2),
	2138: int8(10),
	2139: int8(-int32(32)),
	2140: int8(39),
	2141: int8(-int32(2)),
	2142: int8(-int32(12)),
	2143: int8(1),
	2144: int8(-int32(9)),
	2146: int8(-int32(10)),
	2147: int8(-int32(11)),
	2148: int8(9),
	2149: int8(15),
	2150: int8(-int32(8)),
	2151: int8(-int32(2)),
	2152: int8(2),
	2153: int8(-int32(1)),
	2154: int8(10),
	2155: int8(14),
	2156: int8(-int32(5)),
	2157: int8(-int32(40)),
	2158: int8(19),
	2159: int8(-int32(7)),
	2160: int8(-int32(7)),
	2161: int8(26),
	2162: int8(-int32(4)),
	2163: int8(2),
	2164: int8(1),
	2165: int8(-int32(27)),
	2166: int8(35),
	2167: int8(32),
	2168: int8(21),
	2169: int8(-int32(31)),
	2170: int8(26),
	2171: int8(43),
	2172: int8(-int32(9)),
	2173: int8(4),
	2174: int8(-int32(32)),
	2175: int8(40),
	2176: int8(-int32(62)),
	2177: int8(-int32(52)),
	2178: int8(36),
	2179: int8(22),
	2180: int8(38),
	2181: int8(22),
	2182: int8(36),
	2183: int8(-int32(96)),
	2184: int8(6),
	2185: int8(-int32(10)),
	2186: int8(-int32(23)),
	2187: int8(-int32(49)),
	2188: int8(15),
	2189: int8(-int32(33)),
	2190: int8(-int32(18)),
	2191: int8(-int32(3)),
	2193: int8(41),
	2194: int8(21),
	2195: int8(-int32(19)),
	2196: int8(21),
	2197: int8(23),
	2198: int8(-int32(39)),
	2199: int8(-int32(23)),
	2200: int8(-int32(6)),
	2201: int8(6),
	2202: int8(47),
	2203: int8(56),
	2204: int8(4),
	2205: int8(74),
	2207: int8(-int32(98)),
	2208: int8(29),
	2209: int8(-int32(47)),
	2210: int8(-int32(14)),
	2211: int8(-int32(36)),
	2212: int8(21),
	2213: int8(-int32(22)),
	2214: int8(22),
	2215: int8(16),
	2216: int8(13),
	2217: int8(12),
	2218: int8(16),
	2219: int8(-int32(5)),
	2220: int8(13),
	2221: int8(17),
	2222: int8(-int32(13)),
	2223: int8(-int32(15)),
	2224: int8(1),
	2225: int8(-int32(34)),
	2226: int8(-int32(26)),
	2227: int8(26),
	2228: int8(12),
	2229: int8(32),
	2230: int8(27),
	2231: int8(13),
	2232: int8(-int32(67)),
	2233: int8(27),
	2234: int8(2),
	2235: int8(8),
	2236: int8(10),
	2237: int8(18),
	2238: int8(16),
	2239: int8(20),
	2240: int8(-int32(17)),
	2241: int8(-int32(17)),
	2242: int8(57),
	2243: int8(-int32(64)),
	2244: int8(5),
	2245: int8(14),
	2246: int8(19),
	2247: int8(31),
	2248: int8(-int32(18)),
	2249: int8(-int32(44)),
	2250: int8(-int32(46)),
	2251: int8(-int32(16)),
	2252: int8(4),
	2253: int8(-int32(25)),
	2254: int8(17),
	2255: int8(-int32(126)),
	2256: int8(-int32(24)),
	2257: int8(39),
	2258: int8(4),
	2259: int8(8),
	2260: int8(55),
	2261: int8(-int32(25)),
	2262: int8(-int32(34)),
	2263: int8(39),
	2264: int8(-int32(16)),
	2265: int8(3),
	2266: int8(9),
	2267: int8(71),
	2268: int8(72),
	2269: int8(-int32(31)),
	2270: int8(-int32(55)),
	2271: int8(6),
	2272: int8(10),
	2273: int8(-int32(25)),
	2274: int8(32),
	2275: int8(-int32(85)),
	2276: int8(-int32(21)),
	2277: int8(18),
	2278: int8(-int32(8)),
	2279: int8(15),
	2280: int8(12),
	2281: int8(-int32(27)),
	2282: int8(-int32(7)),
	2283: int8(1),
	2284: int8(-int32(21)),
	2285: int8(-int32(2)),
	2286: int8(-int32(5)),
	2287: int8(48),
	2288: int8(-int32(16)),
	2289: int8(18),
	2290: int8(1),
	2291: int8(-int32(22)),
	2292: int8(-int32(26)),
	2293: int8(16),
	2294: int8(14),
	2295: int8(-int32(31)),
	2296: int8(27),
	2297: int8(-int32(6)),
	2298: int8(-int32(15)),
	2299: int8(-int32(21)),
	2300: int8(4),
	2301: int8(-int32(14)),
	2302: int8(18),
	2303: int8(-int32(36)),
}

var layer1_recur_weights = [1728]OpusT_opus_int8{
	0:    int8(20),
	1:    int8(67),
	2:    int8(-int32(99)),
	3:    int8(12),
	4:    int8(41),
	5:    int8(-int32(25)),
	6:    int8(49),
	7:    int8(-int32(44)),
	8:    int8(35),
	9:    int8(81),
	10:   int8(110),
	11:   int8(47),
	12:   int8(34),
	13:   int8(-int32(66)),
	14:   int8(-int32(14)),
	15:   int8(14),
	16:   int8(-int32(60)),
	17:   int8(34),
	18:   int8(29),
	19:   int8(-int32(73)),
	20:   int8(10),
	21:   int8(41),
	22:   int8(35),
	23:   int8(89),
	24:   int8(7),
	25:   int8(-int32(35)),
	26:   int8(22),
	27:   int8(7),
	28:   int8(27),
	29:   int8(-int32(20)),
	30:   int8(-int32(6)),
	31:   int8(56),
	32:   int8(26),
	33:   int8(66),
	34:   int8(6),
	35:   int8(33),
	36:   int8(-int32(55)),
	37:   int8(53),
	38:   int8(1),
	39:   int8(-int32(21)),
	40:   int8(14),
	41:   int8(17),
	42:   int8(68),
	43:   int8(55),
	44:   int8(59),
	46:   int8(18),
	47:   int8(-int32(9)),
	48:   int8(5),
	49:   int8(-int32(41)),
	50:   int8(6),
	51:   int8(-int32(5)),
	52:   int8(-int32(114)),
	53:   int8(-int32(12)),
	54:   int8(29),
	55:   int8(42),
	56:   int8(-int32(23)),
	57:   int8(10),
	58:   int8(81),
	59:   int8(-int32(27)),
	60:   int8(20),
	61:   int8(-int32(53)),
	62:   int8(-int32(30)),
	63:   int8(-int32(62)),
	64:   int8(40),
	65:   int8(95),
	66:   int8(25),
	67:   int8(-int32(4)),
	68:   int8(3),
	69:   int8(18),
	70:   int8(-int32(8)),
	71:   int8(-int32(15)),
	72:   int8(-int32(29)),
	73:   int8(-int32(82)),
	74:   int8(2),
	75:   int8(-int32(57)),
	76:   int8(-int32(3)),
	77:   int8(-int32(61)),
	78:   int8(-int32(29)),
	79:   int8(-int32(29)),
	80:   int8(49),
	81:   int8(2),
	82:   int8(-int32(55)),
	83:   int8(5),
	84:   int8(-int32(69)),
	85:   int8(-int32(99)),
	86:   int8(-int32(49)),
	87:   int8(-int32(51)),
	88:   int8(6),
	89:   int8(-int32(25)),
	90:   int8(12),
	91:   int8(89),
	92:   int8(44),
	93:   int8(-int32(33)),
	94:   int8(5),
	95:   int8(41),
	96:   int8(1),
	97:   int8(23),
	98:   int8(-int32(37)),
	99:   int8(-int32(37)),
	100:  int8(-int32(28)),
	101:  int8(-int32(48)),
	102:  int8(3),
	103:  int8(4),
	104:  int8(-int32(41)),
	105:  int8(-int32(30)),
	106:  int8(-int32(57)),
	107:  int8(-int32(35)),
	108:  int8(-int32(39)),
	109:  int8(-int32(1)),
	110:  int8(-int32(13)),
	111:  int8(-int32(56)),
	112:  int8(-int32(5)),
	113:  int8(50),
	114:  int8(49),
	115:  int8(41),
	116:  int8(-int32(4)),
	117:  int8(-int32(4)),
	118:  int8(33),
	119:  int8(-int32(22)),
	120:  int8(-int32(1)),
	121:  int8(33),
	122:  int8(34),
	123:  int8(18),
	124:  int8(40),
	125:  int8(-int32(42)),
	126:  int8(12),
	127:  int8(1),
	128:  int8(-int32(6)),
	129:  int8(-int32(2)),
	130:  int8(18),
	131:  int8(17),
	132:  int8(39),
	133:  int8(44),
	134:  int8(11),
	135:  int8(65),
	136:  int8(-int32(60)),
	137:  int8(-int32(45)),
	138:  int8(10),
	139:  int8(91),
	140:  int8(21),
	141:  int8(9),
	142:  int8(-int32(62)),
	143:  int8(-int32(11)),
	144:  int8(8),
	145:  int8(69),
	146:  int8(37),
	147:  int8(24),
	148:  int8(-int32(30)),
	149:  int8(21),
	150:  int8(26),
	151:  int8(-int32(27)),
	152:  int8(1),
	153:  int8(-int32(28)),
	154:  int8(24),
	155:  int8(66),
	156:  int8(-int32(8)),
	157:  int8(6),
	158:  int8(-int32(71)),
	159:  int8(34),
	160:  int8(24),
	161:  int8(44),
	162:  int8(58),
	163:  int8(-int32(78)),
	164:  int8(-int32(19)),
	165:  int8(57),
	166:  int8(17),
	167:  int8(-int32(60)),
	168:  int8(1),
	169:  int8(12),
	170:  int8(-int32(3)),
	171:  int8(-int32(1)),
	172:  int8(-int32(40)),
	173:  int8(22),
	174:  int8(11),
	175:  int8(-int32(5)),
	176:  int8(25),
	177:  int8(12),
	178:  int8(1),
	179:  int8(72),
	180:  int8(79),
	181:  int8(7),
	182:  int8(-int32(50)),
	183:  int8(23),
	184:  int8(18),
	185:  int8(13),
	186:  int8(21),
	187:  int8(-int32(11)),
	188:  int8(-int32(20)),
	189:  int8(5),
	190:  int8(77),
	191:  int8(-int32(94)),
	192:  int8(24),
	193:  int8(15),
	194:  int8(57),
	195:  int8(-int32(51)),
	196:  int8(3),
	197:  int8(36),
	198:  int8(53),
	199:  int8(-int32(1)),
	200:  int8(4),
	201:  int8(14),
	202:  int8(30),
	203:  int8(-int32(31)),
	204:  int8(22),
	205:  int8(40),
	206:  int8(32),
	207:  int8(-int32(11)),
	208:  int8(-int32(34)),
	209:  int8(-int32(36)),
	210:  int8(-int32(59)),
	211:  int8(58),
	212:  int8(25),
	213:  int8(21),
	214:  int8(-int32(54)),
	215:  int8(-int32(23)),
	216:  int8(40),
	217:  int8(46),
	218:  int8(18),
	220:  int8(12),
	221:  int8(54),
	222:  int8(-int32(96)),
	223:  int8(-int32(99)),
	224:  int8(-int32(59)),
	225:  int8(5),
	226:  int8(119),
	227:  int8(-int32(38)),
	228:  int8(50),
	229:  int8(55),
	230:  int8(12),
	231:  int8(-int32(16)),
	232:  int8(67),
	234:  int8(34),
	235:  int8(35),
	236:  int8(39),
	237:  int8(35),
	238:  int8(-int32(1)),
	239:  int8(69),
	240:  int8(24),
	241:  int8(27),
	242:  int8(-int32(30)),
	243:  int8(-int32(35)),
	244:  int8(-int32(4)),
	245:  int8(-int32(70)),
	246:  int8(2),
	247:  int8(-int32(44)),
	248:  int8(-int32(7)),
	249:  int8(-int32(6)),
	250:  int8(19),
	251:  int8(-int32(9)),
	252:  int8(60),
	253:  int8(44),
	254:  int8(-int32(21)),
	255:  int8(-int32(10)),
	256:  int8(37),
	257:  int8(43),
	258:  int8(-int32(16)),
	259:  int8(-int32(3)),
	260:  int8(30),
	261:  int8(-int32(15)),
	262:  int8(-int32(65)),
	263:  int8(31),
	264:  int8(-int32(55)),
	265:  int8(18),
	266:  int8(-int32(98)),
	267:  int8(76),
	268:  int8(64),
	269:  int8(25),
	270:  int8(24),
	271:  int8(-int32(18)),
	272:  int8(-int32(7)),
	273:  int8(-int32(68)),
	274:  int8(-int32(10)),
	275:  int8(38),
	276:  int8(27),
	277:  int8(-int32(60)),
	278:  int8(36),
	279:  int8(33),
	280:  int8(16),
	281:  int8(30),
	282:  int8(34),
	283:  int8(-int32(39)),
	284:  int8(-int32(37)),
	285:  int8(31),
	286:  int8(12),
	287:  int8(53),
	288:  int8(-int32(54)),
	289:  int8(14),
	290:  int8(-int32(26)),
	291:  int8(-int32(49)),
	292:  int8(-int32(128)),
	293:  int8(-int32(13)),
	294:  int8(-int32(5)),
	295:  int8(-int32(22)),
	296:  int8(-int32(11)),
	297:  int8(-int32(85)),
	298:  int8(55),
	299:  int8(-int32(8)),
	300:  int8(-int32(51)),
	301:  int8(-int32(11)),
	302:  int8(-int32(33)),
	303:  int8(-int32(10)),
	304:  int8(-int32(31)),
	305:  int8(-int32(76)),
	306:  int8(-int32(41)),
	307:  int8(23),
	308:  int8(44),
	309:  int8(-int32(40)),
	310:  int8(-int32(54)),
	311:  int8(-int32(127)),
	312:  int8(-int32(101)),
	313:  int8(19),
	314:  int8(-int32(23)),
	315:  int8(-int32(15)),
	316:  int8(15),
	317:  int8(27),
	318:  int8(58),
	319:  int8(-int32(60)),
	320:  int8(8),
	321:  int8(14),
	322:  int8(-int32(33)),
	323:  int8(1),
	324:  int8(48),
	325:  int8(-int32(9)),
	326:  int8(-int32(11)),
	327:  int8(-int32(123)),
	328:  int8(3),
	329:  int8(53),
	330:  int8(23),
	331:  int8(4),
	332:  int8(-int32(28)),
	333:  int8(22),
	334:  int8(2),
	335:  int8(-int32(29)),
	336:  int8(-int32(67)),
	337:  int8(36),
	338:  int8(12),
	339:  int8(7),
	340:  int8(55),
	341:  int8(-int32(21)),
	342:  int8(88),
	343:  int8(20),
	344:  int8(-int32(1)),
	345:  int8(-int32(21)),
	346:  int8(-int32(17)),
	347:  int8(3),
	348:  int8(41),
	349:  int8(32),
	350:  int8(-int32(10)),
	351:  int8(-int32(14)),
	352:  int8(-int32(5)),
	353:  int8(-int32(57)),
	354:  int8(67),
	355:  int8(57),
	356:  int8(21),
	357:  int8(23),
	358:  int8(-int32(2)),
	359:  int8(-int32(27)),
	360:  int8(-int32(73)),
	361:  int8(-int32(24)),
	362:  int8(120),
	363:  int8(21),
	364:  int8(18),
	365:  int8(-int32(35)),
	366:  int8(42),
	367:  int8(-int32(7)),
	368:  int8(3),
	369:  int8(-int32(45)),
	370:  int8(-int32(25)),
	371:  int8(76),
	372:  int8(-int32(34)),
	373:  int8(50),
	374:  int8(11),
	375:  int8(-int32(54)),
	376:  int8(-int32(91)),
	377:  int8(3),
	378:  int8(-int32(113)),
	379:  int8(-int32(20)),
	380:  int8(-int32(5)),
	381:  int8(47),
	382:  int8(15),
	383:  int8(-int32(47)),
	384:  int8(17),
	385:  int8(27),
	386:  int8(-int32(3)),
	387:  int8(-int32(26)),
	388:  int8(-int32(7)),
	389:  int8(10),
	390:  int8(7),
	391:  int8(74),
	392:  int8(-int32(40)),
	393:  int8(64),
	394:  int8(-int32(7)),
	395:  int8(-int32(5)),
	396:  int8(-int32(24)),
	397:  int8(-int32(49)),
	398:  int8(-int32(24)),
	399:  int8(-int32(3)),
	400:  int8(-int32(10)),
	401:  int8(27),
	402:  int8(-int32(17)),
	403:  int8(-int32(8)),
	404:  int8(-int32(3)),
	405:  int8(14),
	406:  int8(-int32(27)),
	407:  int8(33),
	408:  int8(13),
	409:  int8(39),
	410:  int8(28),
	411:  int8(-int32(7)),
	412:  int8(-int32(38)),
	413:  int8(29),
	414:  int8(16),
	415:  int8(44),
	416:  int8(19),
	417:  int8(55),
	418:  int8(-int32(3)),
	419:  int8(9),
	420:  int8(-int32(13)),
	421:  int8(-int32(57)),
	422:  int8(43),
	423:  int8(43),
	424:  int8(31),
	426:  int8(-int32(93)),
	427:  int8(-int32(17)),
	428:  int8(19),
	429:  int8(-int32(56)),
	430:  int8(4),
	431:  int8(-int32(12)),
	432:  int8(-int32(25)),
	433:  int8(37),
	434:  int8(-int32(85)),
	435:  int8(-int32(13)),
	436:  int8(-int32(118)),
	437:  int8(33),
	438:  int8(-int32(17)),
	439:  int8(56),
	440:  int8(71),
	441:  int8(-int32(80)),
	442:  int8(-int32(4)),
	443:  int8(6),
	444:  int8(-int32(11)),
	445:  int8(-int32(18)),
	446:  int8(47),
	447:  int8(-int32(52)),
	448:  int8(25),
	449:  int8(9),
	450:  int8(48),
	451:  int8(-int32(107)),
	452:  int8(1),
	453:  int8(21),
	454:  int8(20),
	455:  int8(-int32(3)),
	456:  int8(10),
	457:  int8(-int32(16)),
	458:  int8(-int32(4)),
	459:  int8(24),
	460:  int8(17),
	461:  int8(31),
	462:  int8(-int32(61)),
	463:  int8(-int32(18)),
	464:  int8(-int32(50)),
	465:  int8(24),
	466:  int8(-int32(10)),
	467:  int8(12),
	468:  int8(71),
	469:  int8(26),
	470:  int8(11),
	471:  int8(-int32(3)),
	472:  int8(4),
	473:  int8(1),
	475:  int8(-int32(7)),
	476:  int8(-int32(40)),
	477:  int8(18),
	478:  int8(38),
	479:  int8(-int32(34)),
	480:  int8(38),
	481:  int8(17),
	482:  int8(8),
	483:  int8(-int32(34)),
	484:  int8(2),
	485:  int8(21),
	486:  int8(123),
	487:  int8(-int32(32)),
	488:  int8(-int32(26)),
	489:  int8(43),
	490:  int8(14),
	491:  int8(-int32(34)),
	492:  int8(-int32(1)),
	493:  int8(-int32(9)),
	494:  int8(37),
	495:  int8(-int32(16)),
	496:  int8(6),
	497:  int8(-int32(17)),
	498:  int8(-int32(62)),
	499:  int8(68),
	500:  int8(22),
	501:  int8(17),
	502:  int8(11),
	503:  int8(-int32(75)),
	504:  int8(33),
	505:  int8(-int32(80)),
	506:  int8(62),
	507:  int8(-int32(9)),
	508:  int8(-int32(75)),
	509:  int8(76),
	510:  int8(36),
	511:  int8(-int32(41)),
	512:  int8(-int32(8)),
	513:  int8(-int32(40)),
	514:  int8(-int32(11)),
	515:  int8(-int32(71)),
	516:  int8(40),
	517:  int8(-int32(39)),
	518:  int8(62),
	519:  int8(-int32(49)),
	520:  int8(-int32(81)),
	521:  int8(16),
	522:  int8(-int32(9)),
	523:  int8(-int32(52)),
	524:  int8(52),
	525:  int8(61),
	526:  int8(17),
	527:  int8(-int32(103)),
	528:  int8(-int32(27)),
	529:  int8(-int32(10)),
	530:  int8(-int32(8)),
	531:  int8(-int32(54)),
	532:  int8(-int32(57)),
	533:  int8(21),
	534:  int8(23),
	535:  int8(-int32(16)),
	536:  int8(-int32(52)),
	537:  int8(36),
	538:  int8(18),
	539:  int8(10),
	540:  int8(-int32(5)),
	541:  int8(8),
	542:  int8(15),
	543:  int8(-int32(29)),
	544:  int8(5),
	545:  int8(-int32(19)),
	546:  int8(-int32(37)),
	547:  int8(8),
	548:  int8(-int32(53)),
	549:  int8(6),
	550:  int8(19),
	551:  int8(-int32(37)),
	552:  int8(38),
	553:  int8(-int32(17)),
	554:  int8(48),
	555:  int8(10),
	557:  int8(81),
	558:  int8(46),
	559:  int8(70),
	560:  int8(-int32(29)),
	561:  int8(101),
	562:  int8(11),
	563:  int8(44),
	564:  int8(-int32(44)),
	565:  int8(-int32(3)),
	566:  int8(24),
	567:  int8(11),
	568:  int8(3),
	569:  int8(14),
	570:  int8(-int32(9)),
	571:  int8(11),
	572:  int8(14),
	573:  int8(-int32(45)),
	574:  int8(13),
	575:  int8(46),
	576:  int8(-int32(3)),
	577:  int8(-int32(57)),
	578:  int8(68),
	579:  int8(44),
	580:  int8(63),
	581:  int8(98),
	582:  int8(25),
	583:  int8(-int32(28)),
	584:  int8(-int32(23)),
	585:  int8(15),
	586:  int8(32),
	587:  int8(-int32(10)),
	588:  int8(53),
	589:  int8(-int32(6)),
	590:  int8(-int32(2)),
	591:  int8(-int32(9)),
	592:  int8(-int32(6)),
	593:  int8(16),
	594:  int8(-int32(107)),
	595:  int8(-int32(11)),
	596:  int8(-int32(11)),
	597:  int8(-int32(28)),
	598:  int8(59),
	599:  int8(57),
	600:  int8(-int32(22)),
	601:  int8(38),
	602:  int8(42),
	603:  int8(83),
	604:  int8(27),
	605:  int8(5),
	606:  int8(29),
	607:  int8(-int32(30)),
	608:  int8(12),
	609:  int8(-int32(21)),
	610:  int8(-int32(13)),
	611:  int8(31),
	612:  int8(38),
	613:  int8(-int32(21)),
	614:  int8(58),
	615:  int8(-int32(10)),
	616:  int8(-int32(10)),
	617:  int8(-int32(15)),
	618:  int8(-int32(2)),
	619:  int8(-int32(5)),
	620:  int8(11),
	621:  int8(12),
	622:  int8(-int32(73)),
	623:  int8(-int32(28)),
	624:  int8(-int32(38)),
	625:  int8(22),
	626:  int8(2),
	627:  int8(-int32(25)),
	628:  int8(73),
	629:  int8(-int32(52)),
	630:  int8(-int32(12)),
	631:  int8(-int32(55)),
	632:  int8(32),
	633:  int8(-int32(63)),
	634:  int8(21),
	635:  int8(51),
	636:  int8(33),
	637:  int8(52),
	638:  int8(-int32(26)),
	639:  int8(55),
	640:  int8(-int32(26)),
	641:  int8(-int32(26)),
	642:  int8(57),
	643:  int8(-int32(32)),
	644:  int8(-int32(4)),
	645:  int8(-int32(52)),
	646:  int8(-int32(61)),
	647:  int8(21),
	648:  int8(-int32(33)),
	649:  int8(-int32(91)),
	650:  int8(-int32(51)),
	651:  int8(69),
	652:  int8(-int32(90)),
	653:  int8(-int32(53)),
	654:  int8(-int32(38)),
	655:  int8(-int32(44)),
	656:  int8(12),
	657:  int8(-int32(76)),
	658:  int8(-int32(20)),
	659:  int8(77),
	660:  int8(-int32(45)),
	661:  int8(-int32(7)),
	662:  int8(86),
	663:  int8(43),
	664:  int8(-int32(109)),
	665:  int8(-int32(33)),
	666:  int8(-int32(105)),
	667:  int8(-int32(40)),
	668:  int8(-int32(121)),
	669:  int8(-int32(10)),
	671:  int8(-int32(72)),
	672:  int8(45),
	673:  int8(-int32(51)),
	674:  int8(-int32(75)),
	675:  int8(-int32(49)),
	676:  int8(-int32(38)),
	677:  int8(-int32(1)),
	678:  int8(-int32(62)),
	679:  int8(18),
	680:  int8(-int32(1)),
	681:  int8(30),
	682:  int8(-int32(44)),
	683:  int8(-int32(14)),
	684:  int8(-int32(10)),
	685:  int8(-int32(67)),
	686:  int8(40),
	687:  int8(-int32(10)),
	688:  int8(-int32(34)),
	689:  int8(46),
	690:  int8(-int32(64)),
	691:  int8(-int32(32)),
	692:  int8(29),
	693:  int8(-int32(13)),
	694:  int8(33),
	695:  int8(3),
	696:  int8(-int32(32)),
	697:  int8(-int32(5)),
	698:  int8(28),
	699:  int8(-int32(27)),
	700:  int8(-int32(25)),
	701:  int8(93),
	702:  int8(24),
	703:  int8(68),
	704:  int8(-int32(40)),
	705:  int8(57),
	706:  int8(23),
	707:  int8(-int32(3)),
	708:  int8(-int32(21)),
	709:  int8(-int32(58)),
	710:  int8(17),
	711:  int8(-int32(39)),
	712:  int8(-int32(17)),
	713:  int8(-int32(22)),
	714:  int8(-int32(89)),
	715:  int8(11),
	716:  int8(18),
	717:  int8(-int32(46)),
	718:  int8(27),
	719:  int8(24),
	720:  int8(46),
	721:  int8(127),
	722:  int8(61),
	723:  int8(87),
	724:  int8(31),
	725:  int8(127),
	726:  int8(-int32(36)),
	727:  int8(47),
	728:  int8(-int32(23)),
	729:  int8(47),
	730:  int8(127),
	731:  int8(-int32(24)),
	732:  int8(110),
	733:  int8(122),
	734:  int8(30),
	735:  int8(100),
	737:  int8(96),
	738:  int8(-int32(12)),
	739:  int8(6),
	740:  int8(50),
	741:  int8(44),
	742:  int8(-int32(13)),
	743:  int8(73),
	744:  int8(4),
	745:  int8(55),
	746:  int8(-int32(11)),
	747:  int8(-int32(15)),
	748:  int8(49),
	749:  int8(42),
	750:  int8(-int32(6)),
	751:  int8(20),
	752:  int8(-int32(35)),
	753:  int8(58),
	754:  int8(18),
	755:  int8(38),
	756:  int8(42),
	757:  int8(72),
	758:  int8(19),
	759:  int8(-int32(21)),
	760:  int8(11),
	761:  int8(9),
	762:  int8(-int32(37)),
	763:  int8(7),
	764:  int8(29),
	765:  int8(31),
	766:  int8(16),
	767:  int8(-int32(17)),
	768:  int8(13),
	769:  int8(-int32(50)),
	770:  int8(19),
	771:  int8(5),
	772:  int8(-int32(23)),
	773:  int8(51),
	774:  int8(-int32(16)),
	775:  int8(-int32(5)),
	776:  int8(4),
	777:  int8(-int32(24)),
	778:  int8(76),
	779:  int8(10),
	780:  int8(-int32(53)),
	781:  int8(-int32(28)),
	782:  int8(-int32(7)),
	783:  int8(-int32(65)),
	784:  int8(74),
	785:  int8(40),
	786:  int8(-int32(16)),
	787:  int8(-int32(29)),
	788:  int8(32),
	789:  int8(-int32(16)),
	790:  int8(-int32(49)),
	791:  int8(-int32(35)),
	792:  int8(-int32(3)),
	793:  int8(59),
	794:  int8(-int32(96)),
	795:  int8(-int32(50)),
	796:  int8(-int32(43)),
	797:  int8(-int32(43)),
	798:  int8(-int32(61)),
	799:  int8(-int32(15)),
	800:  int8(-int32(8)),
	801:  int8(-int32(36)),
	802:  int8(-int32(34)),
	803:  int8(-int32(33)),
	804:  int8(-int32(14)),
	805:  int8(11),
	806:  int8(-int32(3)),
	807:  int8(-int32(39)),
	808:  int8(4),
	809:  int8(-int32(114)),
	810:  int8(-int32(123)),
	811:  int8(-int32(11)),
	812:  int8(-int32(49)),
	813:  int8(-int32(21)),
	814:  int8(14),
	815:  int8(-int32(56)),
	816:  int8(1),
	817:  int8(43),
	818:  int8(-int32(63)),
	819:  int8(26),
	820:  int8(40),
	821:  int8(18),
	822:  int8(-int32(10)),
	823:  int8(-int32(26)),
	824:  int8(-int32(14)),
	825:  int8(-int32(15)),
	826:  int8(-int32(35)),
	827:  int8(-int32(35)),
	828:  int8(-int32(11)),
	829:  int8(32),
	830:  int8(-int32(44)),
	831:  int8(-int32(67)),
	832:  int8(2),
	833:  int8(22),
	834:  int8(7),
	835:  int8(3),
	836:  int8(-int32(9)),
	837:  int8(-int32(30)),
	838:  int8(-int32(51)),
	839:  int8(-int32(28)),
	840:  int8(28),
	841:  int8(6),
	842:  int8(-int32(22)),
	843:  int8(16),
	844:  int8(34),
	845:  int8(-int32(25)),
	846:  int8(-int32(52)),
	847:  int8(-int32(54)),
	848:  int8(-int32(8)),
	849:  int8(-int32(6)),
	850:  int8(5),
	851:  int8(8),
	852:  int8(20),
	853:  int8(-int32(16)),
	854:  int8(-int32(17)),
	855:  int8(-int32(44)),
	856:  int8(27),
	857:  int8(3),
	858:  int8(31),
	859:  int8(-int32(5)),
	860:  int8(-int32(48)),
	861:  int8(-int32(1)),
	862:  int8(-int32(3)),
	863:  int8(116),
	864:  int8(11),
	865:  int8(71),
	866:  int8(-int32(31)),
	867:  int8(-int32(47)),
	868:  int8(109),
	869:  int8(50),
	870:  int8(-int32(22)),
	871:  int8(-int32(12)),
	872:  int8(-int32(57)),
	873:  int8(32),
	874:  int8(66),
	875:  int8(8),
	876:  int8(-int32(25)),
	877:  int8(-int32(93)),
	878:  int8(-int32(54)),
	879:  int8(-int32(10)),
	880:  int8(19),
	881:  int8(-int32(76)),
	882:  int8(-int32(34)),
	883:  int8(97),
	884:  int8(48),
	885:  int8(-int32(36)),
	886:  int8(-int32(18)),
	887:  int8(-int32(30)),
	888:  int8(-int32(39)),
	889:  int8(-int32(26)),
	890:  int8(-int32(12)),
	891:  int8(28),
	892:  int8(14),
	893:  int8(12),
	894:  int8(-int32(12)),
	895:  int8(-int32(31)),
	896:  int8(38),
	897:  int8(2),
	898:  int8(10),
	899:  int8(4),
	900:  int8(-int32(40)),
	901:  int8(20),
	902:  int8(16),
	903:  int8(-int32(61)),
	904:  int8(2),
	905:  int8(64),
	906:  int8(39),
	907:  int8(5),
	908:  int8(15),
	909:  int8(33),
	910:  int8(40),
	911:  int8(-int32(61)),
	912:  int8(-int32(49)),
	913:  int8(93),
	914:  int8(-int32(10)),
	915:  int8(33),
	916:  int8(28),
	917:  int8(-int32(11)),
	918:  int8(-int32(27)),
	919:  int8(-int32(18)),
	920:  int8(39),
	921:  int8(-int32(62)),
	922:  int8(-int32(6)),
	923:  int8(-int32(6)),
	924:  int8(62),
	925:  int8(11),
	926:  int8(-int32(8)),
	927:  int8(38),
	928:  int8(-int32(67)),
	929:  int8(12),
	930:  int8(27),
	931:  int8(39),
	932:  int8(-int32(27)),
	933:  int8(123),
	934:  int8(-int32(18)),
	935:  int8(-int32(6)),
	936:  int8(-int32(65)),
	937:  int8(83),
	938:  int8(-int32(64)),
	939:  int8(20),
	940:  int8(19),
	941:  int8(-int32(11)),
	942:  int8(33),
	943:  int8(24),
	944:  int8(17),
	945:  int8(56),
	946:  int8(78),
	947:  int8(7),
	948:  int8(-int32(15)),
	949:  int8(54),
	950:  int8(-int32(101)),
	951:  int8(-int32(9)),
	952:  int8(115),
	953:  int8(-int32(96)),
	954:  int8(50),
	955:  int8(51),
	956:  int8(35),
	957:  int8(34),
	958:  int8(27),
	959:  int8(37),
	960:  int8(-int32(40)),
	961:  int8(-int32(11)),
	962:  int8(8),
	963:  int8(-int32(36)),
	964:  int8(42),
	965:  int8(-int32(45)),
	966:  int8(2),
	967:  int8(-int32(23)),
	969:  int8(67),
	970:  int8(-int32(8)),
	971:  int8(-int32(9)),
	972:  int8(-int32(13)),
	973:  int8(50),
	974:  int8(-int32(14)),
	975:  int8(-int32(27)),
	976:  int8(4),
	978:  int8(-int32(8)),
	979:  int8(-int32(14)),
	980:  int8(30),
	981:  int8(-int32(9)),
	982:  int8(29),
	983:  int8(15),
	984:  int8(9),
	985:  int8(-int32(38)),
	986:  int8(37),
	987:  int8(-int32(8)),
	988:  int8(50),
	989:  int8(-int32(46)),
	990:  int8(54),
	991:  int8(41),
	992:  int8(-int32(11)),
	993:  int8(-int32(8)),
	994:  int8(-int32(11)),
	995:  int8(-int32(26)),
	996:  int8(39),
	997:  int8(45),
	998:  int8(14),
	999:  int8(-int32(26)),
	1000: int8(-int32(17)),
	1001: int8(-int32(27)),
	1002: int8(69),
	1003: int8(38),
	1004: int8(39),
	1005: int8(98),
	1006: int8(66),
	1008: int8(42),
	1009: int8(123),
	1010: int8(-int32(101)),
	1011: int8(-int32(19)),
	1012: int8(-int32(83)),
	1013: int8(117),
	1014: int8(-int32(32)),
	1015: int8(56),
	1016: int8(10),
	1017: int8(12),
	1018: int8(-int32(88)),
	1019: int8(79),
	1020: int8(-int32(53)),
	1021: int8(56),
	1022: int8(63),
	1023: int8(95),
	1024: int8(-int32(62)),
	1025: int8(9),
	1026: int8(36),
	1027: int8(-int32(13)),
	1028: int8(-int32(79)),
	1029: int8(-int32(16)),
	1030: int8(37),
	1031: int8(-int32(46)),
	1032: int8(35),
	1033: int8(-int32(34)),
	1034: int8(14),
	1035: int8(17),
	1036: int8(-int32(54)),
	1037: int8(5),
	1038: int8(21),
	1039: int8(-int32(7)),
	1040: int8(7),
	1041: int8(63),
	1042: int8(56),
	1043: int8(15),
	1044: int8(27),
	1045: int8(-int32(76)),
	1046: int8(-int32(25)),
	1047: int8(4),
	1048: int8(-int32(26)),
	1049: int8(-int32(63)),
	1050: int8(28),
	1051: int8(-int32(67)),
	1052: int8(-int32(52)),
	1053: int8(43),
	1054: int8(-int32(47)),
	1055: int8(-int32(70)),
	1056: int8(40),
	1057: int8(-int32(12)),
	1058: int8(40),
	1059: int8(-int32(66)),
	1060: int8(-int32(37)),
	1062: int8(35),
	1063: int8(37),
	1064: int8(-int32(53)),
	1065: int8(4),
	1066: int8(-int32(17)),
	1067: int8(-int32(51)),
	1068: int8(11),
	1069: int8(21),
	1070: int8(14),
	1071: int8(-int32(34)),
	1072: int8(-int32(4)),
	1073: int8(24),
	1074: int8(-int32(42)),
	1075: int8(29),
	1076: int8(22),
	1077: int8(7),
	1078: int8(28),
	1079: int8(12),
	1080: int8(37),
	1081: int8(39),
	1082: int8(-int32(39)),
	1083: int8(-int32(19)),
	1084: int8(65),
	1085: int8(-int32(60)),
	1086: int8(-int32(50)),
	1087: int8(-int32(2)),
	1088: int8(1),
	1089: int8(82),
	1090: int8(39),
	1091: int8(19),
	1092: int8(-int32(23)),
	1093: int8(-int32(43)),
	1094: int8(-int32(22)),
	1095: int8(-int32(67)),
	1096: int8(-int32(35)),
	1097: int8(-int32(34)),
	1098: int8(32),
	1099: int8(102),
	1100: int8(81),
	1101: int8(127),
	1102: int8(36),
	1103: int8(67),
	1104: int8(-int32(45)),
	1105: int8(1),
	1106: int8(-int32(67)),
	1107: int8(-int32(52)),
	1108: int8(-int32(4)),
	1109: int8(35),
	1110: int8(20),
	1111: int8(28),
	1112: int8(71),
	1113: int8(86),
	1114: int8(-int32(35)),
	1115: int8(-int32(9)),
	1116: int8(-int32(83)),
	1117: int8(-int32(34)),
	1118: int8(12),
	1119: int8(9),
	1120: int8(-int32(23)),
	1121: int8(2),
	1122: int8(14),
	1123: int8(28),
	1124: int8(-int32(23)),
	1125: int8(7),
	1126: int8(-int32(25)),
	1127: int8(45),
	1128: int8(7),
	1129: int8(17),
	1130: int8(-int32(37)),
	1132: int8(-int32(19)),
	1133: int8(31),
	1134: int8(26),
	1135: int8(40),
	1136: int8(-int32(27)),
	1137: int8(-int32(16)),
	1138: int8(17),
	1139: int8(5),
	1140: int8(-int32(21)),
	1141: int8(23),
	1142: int8(24),
	1143: int8(96),
	1144: int8(-int32(55)),
	1145: int8(52),
	1146: int8(-int32(19)),
	1147: int8(-int32(14)),
	1148: int8(-int32(6)),
	1149: int8(1),
	1150: int8(50),
	1151: int8(-int32(34)),
	1152: int8(86),
	1153: int8(-int32(53)),
	1154: int8(38),
	1155: int8(2),
	1156: int8(-int32(52)),
	1157: int8(-int32(36)),
	1158: int8(-int32(13)),
	1159: int8(60),
	1160: int8(-int32(85)),
	1161: int8(-int32(120)),
	1162: int8(32),
	1163: int8(7),
	1164: int8(-int32(12)),
	1165: int8(22),
	1166: int8(70),
	1167: int8(-int32(7)),
	1168: int8(-int32(94)),
	1169: int8(38),
	1170: int8(-int32(76)),
	1171: int8(-int32(31)),
	1172: int8(-int32(20)),
	1173: int8(15),
	1174: int8(-int32(28)),
	1175: int8(7),
	1176: int8(6),
	1177: int8(40),
	1178: int8(53),
	1179: int8(88),
	1180: int8(3),
	1181: int8(38),
	1182: int8(18),
	1183: int8(-int32(8)),
	1184: int8(-int32(22)),
	1185: int8(-int32(23)),
	1186: int8(51),
	1187: int8(37),
	1188: int8(-int32(9)),
	1189: int8(13),
	1190: int8(-int32(32)),
	1191: int8(25),
	1192: int8(-int32(21)),
	1193: int8(27),
	1194: int8(31),
	1195: int8(20),
	1196: int8(18),
	1197: int8(-int32(9)),
	1198: int8(-int32(13)),
	1199: int8(1),
	1200: int8(21),
	1201: int8(-int32(24)),
	1202: int8(-int32(13)),
	1203: int8(39),
	1204: int8(15),
	1205: int8(-int32(11)),
	1206: int8(-int32(29)),
	1207: int8(-int32(36)),
	1208: int8(18),
	1209: int8(15),
	1210: int8(8),
	1211: int8(27),
	1212: int8(21),
	1213: int8(-int32(94)),
	1214: int8(-int32(1)),
	1215: int8(-int32(22)),
	1216: int8(49),
	1217: int8(66),
	1218: int8(-int32(1)),
	1219: int8(6),
	1220: int8(-int32(3)),
	1221: int8(-int32(40)),
	1222: int8(-int32(18)),
	1223: int8(6),
	1224: int8(28),
	1225: int8(12),
	1226: int8(33),
	1227: int8(-int32(59)),
	1228: int8(62),
	1229: int8(60),
	1230: int8(-int32(48)),
	1231: int8(90),
	1232: int8(-int32(1)),
	1233: int8(108),
	1234: int8(9),
	1235: int8(18),
	1236: int8(-int32(2)),
	1237: int8(27),
	1238: int8(77),
	1239: int8(-int32(65)),
	1240: int8(82),
	1241: int8(-int32(48)),
	1242: int8(-int32(38)),
	1243: int8(-int32(19)),
	1244: int8(-int32(11)),
	1245: int8(127),
	1246: int8(50),
	1247: int8(66),
	1248: int8(18),
	1249: int8(-int32(13)),
	1250: int8(-int32(22)),
	1251: int8(60),
	1252: int8(-int32(38)),
	1253: int8(40),
	1254: int8(-int32(14)),
	1255: int8(-int32(26)),
	1256: int8(-int32(13)),
	1257: int8(38),
	1258: int8(67),
	1259: int8(57),
	1260: int8(30),
	1261: int8(33),
	1262: int8(26),
	1263: int8(36),
	1264: int8(38),
	1265: int8(-int32(17)),
	1266: int8(27),
	1267: int8(-int32(28)),
	1268: int8(20),
	1269: int8(12),
	1270: int8(-int32(64)),
	1271: int8(18),
	1272: int8(5),
	1273: int8(-int32(33)),
	1274: int8(-int32(27)),
	1275: int8(13),
	1276: int8(-int32(26)),
	1277: int8(32),
	1278: int8(35),
	1279: int8(-int32(5)),
	1280: int8(-int32(48)),
	1281: int8(-int32(14)),
	1282: int8(92),
	1283: int8(43),
	1284: int8(-int32(47)),
	1285: int8(-int32(14)),
	1286: int8(40),
	1287: int8(11),
	1288: int8(51),
	1289: int8(66),
	1290: int8(22),
	1291: int8(-int32(63)),
	1292: int8(-int32(16)),
	1293: int8(-int32(61)),
	1294: int8(4),
	1295: int8(-int32(28)),
	1296: int8(27),
	1297: int8(20),
	1298: int8(-int32(33)),
	1299: int8(-int32(30)),
	1300: int8(-int32(21)),
	1301: int8(-int32(29)),
	1302: int8(-int32(53)),
	1303: int8(31),
	1304: int8(-int32(40)),
	1305: int8(24),
	1306: int8(43),
	1307: int8(-int32(4)),
	1308: int8(-int32(19)),
	1309: int8(21),
	1310: int8(67),
	1311: int8(20),
	1312: int8(100),
	1313: int8(-int32(16)),
	1314: int8(-int32(93)),
	1315: int8(78),
	1316: int8(-int32(6)),
	1317: int8(-int32(18)),
	1318: int8(-int32(52)),
	1319: int8(-int32(37)),
	1320: int8(-int32(9)),
	1321: int8(66),
	1322: int8(-int32(31)),
	1323: int8(-int32(8)),
	1324: int8(26),
	1325: int8(18),
	1326: int8(4),
	1327: int8(24),
	1328: int8(-int32(22)),
	1329: int8(17),
	1330: int8(-int32(2)),
	1331: int8(-int32(13)),
	1332: int8(27),
	1334: int8(8),
	1335: int8(-int32(18)),
	1336: int8(-int32(25)),
	1337: int8(5),
	1338: int8(-int32(21)),
	1339: int8(-int32(24)),
	1340: int8(-int32(7)),
	1341: int8(18),
	1342: int8(-int32(93)),
	1343: int8(21),
	1344: int8(7),
	1345: int8(2),
	1346: int8(-int32(75)),
	1347: int8(69),
	1348: int8(50),
	1349: int8(-int32(5)),
	1350: int8(-int32(15)),
	1351: int8(-int32(17)),
	1352: int8(60),
	1353: int8(-int32(42)),
	1354: int8(55),
	1355: int8(1),
	1356: int8(-int32(4)),
	1357: int8(3),
	1358: int8(10),
	1359: int8(46),
	1360: int8(16),
	1361: int8(-int32(13)),
	1362: int8(45),
	1363: int8(-int32(7)),
	1364: int8(-int32(10)),
	1365: int8(-int32(44)),
	1366: int8(-int32(108)),
	1367: int8(49),
	1368: int8(2),
	1369: int8(-int32(15)),
	1370: int8(-int32(64)),
	1371: int8(-int32(12)),
	1372: int8(-int32(72)),
	1373: int8(32),
	1374: int8(-int32(38)),
	1375: int8(-int32(45)),
	1376: int8(10),
	1377: int8(-int32(54)),
	1378: int8(13),
	1379: int8(-int32(13)),
	1380: int8(-int32(27)),
	1381: int8(-int32(36)),
	1382: int8(-int32(64)),
	1383: int8(58),
	1384: int8(-int32(62)),
	1385: int8(-int32(101)),
	1386: int8(88),
	1387: int8(-int32(86)),
	1388: int8(-int32(71)),
	1389: int8(-int32(39)),
	1390: int8(-int32(9)),
	1391: int8(-int32(128)),
	1392: int8(32),
	1393: int8(15),
	1394: int8(-int32(4)),
	1395: int8(54),
	1396: int8(-int32(16)),
	1397: int8(-int32(39)),
	1398: int8(-int32(26)),
	1399: int8(-int32(36)),
	1400: int8(46),
	1401: int8(48),
	1402: int8(-int32(64)),
	1403: int8(-int32(10)),
	1404: int8(19),
	1405: int8(30),
	1406: int8(-int32(13)),
	1407: int8(34),
	1408: int8(-int32(8)),
	1409: int8(50),
	1410: int8(60),
	1411: int8(-int32(22)),
	1412: int8(-int32(6)),
	1413: int8(-int32(11)),
	1414: int8(-int32(30)),
	1415: int8(5),
	1416: int8(50),
	1417: int8(32),
	1418: int8(56),
	1420: int8(25),
	1421: int8(6),
	1422: int8(68),
	1423: int8(11),
	1424: int8(-int32(29)),
	1425: int8(45),
	1426: int8(-int32(9)),
	1427: int8(-int32(12)),
	1428: int8(4),
	1429: int8(1),
	1430: int8(18),
	1431: int8(-int32(49)),
	1433: int8(-int32(38)),
	1434: int8(-int32(19)),
	1435: int8(90),
	1436: int8(29),
	1437: int8(35),
	1438: int8(51),
	1439: int8(8),
	1440: int8(-int32(48)),
	1441: int8(96),
	1442: int8(-int32(1)),
	1443: int8(-int32(12)),
	1444: int8(-int32(9)),
	1445: int8(-int32(32)),
	1446: int8(-int32(63)),
	1447: int8(-int32(65)),
	1448: int8(-int32(7)),
	1449: int8(38),
	1450: int8(89),
	1451: int8(28),
	1452: int8(-int32(85)),
	1453: int8(-int32(28)),
	1454: int8(-int32(23)),
	1455: int8(-int32(25)),
	1456: int8(-int32(128)),
	1457: int8(56),
	1458: int8(79),
	1459: int8(-int32(36)),
	1460: int8(99),
	1461: int8(-int32(6)),
	1462: int8(-int32(37)),
	1463: int8(7),
	1464: int8(-int32(13)),
	1465: int8(-int32(69)),
	1466: int8(-int32(46)),
	1467: int8(-int32(29)),
	1468: int8(25),
	1469: int8(64),
	1470: int8(-int32(21)),
	1471: int8(17),
	1472: int8(1),
	1473: int8(42),
	1474: int8(-int32(66)),
	1475: int8(1),
	1476: int8(80),
	1477: int8(26),
	1478: int8(-int32(32)),
	1479: int8(21),
	1480: int8(15),
	1481: int8(15),
	1482: int8(6),
	1483: int8(6),
	1484: int8(-int32(10)),
	1485: int8(15),
	1486: int8(127),
	1487: int8(5),
	1488: int8(38),
	1489: int8(27),
	1490: int8(87),
	1491: int8(-int32(57)),
	1492: int8(-int32(25)),
	1493: int8(11),
	1494: int8(72),
	1495: int8(-int32(21)),
	1496: int8(-int32(5)),
	1497: int8(11),
	1498: int8(-int32(13)),
	1499: int8(-int32(66)),
	1500: int8(78),
	1501: int8(36),
	1502: int8(-int32(3)),
	1503: int8(41),
	1504: int8(-int32(21)),
	1505: int8(8),
	1506: int8(-int32(33)),
	1507: int8(23),
	1508: int8(73),
	1509: int8(28),
	1510: int8(57),
	1511: int8(-int32(25)),
	1512: int8(-int32(5)),
	1513: int8(4),
	1514: int8(-int32(22)),
	1515: int8(-int32(47)),
	1516: int8(15),
	1517: int8(4),
	1518: int8(-int32(57)),
	1519: int8(-int32(72)),
	1520: int8(33),
	1521: int8(1),
	1522: int8(18),
	1523: int8(2),
	1524: int8(53),
	1525: int8(-int32(71)),
	1526: int8(-int32(99)),
	1527: int8(-int32(21)),
	1528: int8(-int32(3)),
	1529: int8(-int32(111)),
	1530: int8(108),
	1531: int8(71),
	1532: int8(-int32(14)),
	1533: int8(82),
	1534: int8(25),
	1535: int8(61),
	1536: int8(-int32(48)),
	1537: int8(5),
	1538: int8(9),
	1539: int8(-int32(51)),
	1540: int8(-int32(20)),
	1541: int8(-int32(25)),
	1542: int8(-int32(3)),
	1543: int8(14),
	1544: int8(-int32(33)),
	1545: int8(14),
	1546: int8(-int32(3)),
	1547: int8(-int32(34)),
	1548: int8(22),
	1549: int8(12),
	1550: int8(-int32(19)),
	1551: int8(-int32(38)),
	1552: int8(-int32(16)),
	1553: int8(2),
	1554: int8(21),
	1555: int8(16),
	1556: int8(26),
	1557: int8(-int32(31)),
	1558: int8(75),
	1559: int8(44),
	1560: int8(-int32(31)),
	1561: int8(16),
	1562: int8(26),
	1563: int8(66),
	1564: int8(17),
	1565: int8(-int32(9)),
	1566: int8(-int32(22)),
	1567: int8(-int32(22)),
	1568: int8(22),
	1569: int8(-int32(44)),
	1570: int8(22),
	1571: int8(27),
	1572: int8(2),
	1573: int8(58),
	1574: int8(-int32(14)),
	1575: int8(10),
	1576: int8(-int32(73)),
	1577: int8(-int32(42)),
	1578: int8(55),
	1579: int8(-int32(25)),
	1580: int8(-int32(61)),
	1581: int8(72),
	1582: int8(-int32(1)),
	1583: int8(30),
	1584: int8(-int32(58)),
	1585: int8(-int32(25)),
	1586: int8(63),
	1587: int8(26),
	1588: int8(-int32(48)),
	1589: int8(-int32(40)),
	1590: int8(26),
	1591: int8(-int32(30)),
	1592: int8(60),
	1593: int8(8),
	1594: int8(-int32(17)),
	1595: int8(-int32(1)),
	1596: int8(-int32(18)),
	1597: int8(-int32(20)),
	1598: int8(43),
	1599: int8(-int32(20)),
	1600: int8(-int32(4)),
	1601: int8(-int32(28)),
	1602: int8(127),
	1603: int8(-int32(106)),
	1604: int8(29),
	1605: int8(70),
	1606: int8(64),
	1607: int8(-int32(27)),
	1608: int8(39),
	1609: int8(-int32(33)),
	1610: int8(-int32(5)),
	1611: int8(-int32(88)),
	1612: int8(-int32(40)),
	1613: int8(-int32(52)),
	1614: int8(26),
	1615: int8(44),
	1616: int8(-int32(17)),
	1617: int8(23),
	1618: int8(2),
	1619: int8(-int32(49)),
	1620: int8(22),
	1621: int8(-int32(9)),
	1622: int8(-int32(8)),
	1623: int8(86),
	1624: int8(49),
	1625: int8(-int32(43)),
	1626: int8(-int32(60)),
	1627: int8(1),
	1628: int8(10),
	1629: int8(45),
	1630: int8(36),
	1631: int8(-int32(53)),
	1632: int8(-int32(4)),
	1633: int8(33),
	1634: int8(38),
	1635: int8(48),
	1636: int8(-int32(72)),
	1637: int8(1),
	1638: int8(19),
	1639: int8(21),
	1640: int8(-int32(65)),
	1641: int8(4),
	1642: int8(-int32(5)),
	1643: int8(-int32(62)),
	1644: int8(27),
	1645: int8(-int32(25)),
	1646: int8(17),
	1647: int8(-int32(6)),
	1648: int8(6),
	1649: int8(-int32(45)),
	1650: int8(-int32(39)),
	1651: int8(-int32(46)),
	1652: int8(4),
	1653: int8(26),
	1654: int8(127),
	1655: int8(-int32(9)),
	1656: int8(18),
	1657: int8(-int32(33)),
	1658: int8(-int32(18)),
	1659: int8(-int32(3)),
	1660: int8(33),
	1661: int8(2),
	1662: int8(-int32(5)),
	1663: int8(15),
	1664: int8(-int32(26)),
	1665: int8(-int32(22)),
	1666: int8(-int32(117)),
	1667: int8(-int32(63)),
	1668: int8(-int32(17)),
	1669: int8(-int32(59)),
	1670: int8(61),
	1671: int8(-int32(74)),
	1672: int8(7),
	1673: int8(-int32(47)),
	1674: int8(-int32(58)),
	1675: int8(-int32(128)),
	1676: int8(-int32(67)),
	1677: int8(15),
	1678: int8(-int32(16)),
	1679: int8(-int32(128)),
	1680: int8(12),
	1681: int8(2),
	1682: int8(20),
	1683: int8(9),
	1684: int8(-int32(48)),
	1685: int8(-int32(40)),
	1686: int8(43),
	1687: int8(3),
	1688: int8(-int32(40)),
	1689: int8(-int32(16)),
	1690: int8(-int32(38)),
	1691: int8(-int32(6)),
	1692: int8(-int32(22)),
	1693: int8(-int32(28)),
	1694: int8(-int32(16)),
	1695: int8(-int32(59)),
	1696: int8(-int32(22)),
	1697: int8(6),
	1698: int8(-int32(5)),
	1699: int8(11),
	1700: int8(-int32(12)),
	1701: int8(-int32(66)),
	1702: int8(-int32(40)),
	1703: int8(27),
	1704: int8(-int32(62)),
	1705: int8(-int32(44)),
	1706: int8(-int32(19)),
	1707: int8(38),
	1708: int8(-int32(3)),
	1709: int8(39),
	1710: int8(-int32(8)),
	1711: int8(40),
	1712: int8(-int32(24)),
	1713: int8(13),
	1714: int8(21),
	1715: int8(50),
	1716: int8(-int32(60)),
	1717: int8(-int32(22)),
	1718: int8(53),
	1719: int8(-int32(29)),
	1720: int8(-int32(6)),
	1721: int8(1),
	1722: int8(22),
	1723: int8(-int32(59)),
	1725: int8(17),
	1726: int8(-int32(39)),
	1727: int8(115),
}

var layer1_bias = [72]OpusT_opus_int8{
	0:  int8(-int32(42)),
	1:  int8(20),
	2:  int8(16),
	4:  int8(105),
	5:  int8(60),
	6:  int8(1),
	7:  int8(-int32(97)),
	8:  int8(24),
	9:  int8(60),
	10: int8(18),
	11: int8(13),
	12: int8(62),
	13: int8(25),
	14: int8(127),
	15: int8(34),
	16: int8(79),
	17: int8(55),
	18: int8(118),
	19: int8(127),
	20: int8(95),
	21: int8(31),
	22: int8(-int32(4)),
	23: int8(87),
	24: int8(21),
	25: int8(12),
	26: int8(2),
	27: int8(-int32(14)),
	28: int8(18),
	29: int8(23),
	30: int8(8),
	31: int8(17),
	32: int8(-int32(1)),
	33: int8(-int32(8)),
	34: int8(5),
	35: int8(4),
	36: int8(24),
	37: int8(37),
	38: int8(21),
	39: int8(13),
	40: int8(36),
	41: int8(13),
	42: int8(17),
	43: int8(18),
	44: int8(37),
	45: int8(30),
	46: int8(33),
	47: int8(1),
	48: int8(8),
	49: int8(-int32(16)),
	50: int8(-int32(11)),
	51: int8(-int32(5)),
	52: int8(-int32(31)),
	53: int8(-int32(3)),
	54: int8(-int32(5)),
	56: int8(6),
	57: int8(3),
	58: int8(58),
	59: int8(-int32(7)),
	60: int8(-int32(1)),
	61: int8(-int32(16)),
	62: int8(5),
	63: int8(-int32(13)),
	64: int8(16),
	65: int8(10),
	66: int8(-int32(2)),
	67: int8(-int32(14)),
	68: int8(11),
	69: int8(-int32(4)),
	70: int8(3),
	71: int8(-int32(11)),
}

var layer2_weights = [48]OpusT_opus_int8{
	0:  int8(-int32(113)),
	1:  int8(-int32(88)),
	2:  int8(31),
	3:  int8(-int32(128)),
	4:  int8(-int32(126)),
	5:  int8(-int32(61)),
	6:  int8(85),
	7:  int8(-int32(35)),
	8:  int8(118),
	9:  int8(-int32(128)),
	10: int8(-int32(61)),
	11: int8(127),
	12: int8(-int32(128)),
	13: int8(-int32(17)),
	14: int8(-int32(128)),
	15: int8(127),
	16: int8(104),
	17: int8(-int32(9)),
	18: int8(-int32(128)),
	19: int8(33),
	20: int8(45),
	21: int8(127),
	22: int8(5),
	23: int8(83),
	24: int8(84),
	25: int8(-int32(128)),
	26: int8(-int32(85)),
	27: int8(-int32(128)),
	28: int8(-int32(45)),
	29: int8(48),
	30: int8(-int32(53)),
	31: int8(-int32(128)),
	32: int8(46),
	33: int8(127),
	34: int8(-int32(17)),
	35: int8(125),
	36: int8(117),
	37: int8(-int32(41)),
	38: int8(-int32(117)),
	39: int8(-int32(91)),
	40: int8(-int32(127)),
	41: int8(-int32(68)),
	42: int8(-int32(1)),
	43: int8(-int32(89)),
	44: int8(-int32(80)),
	45: int8(32),
	46: int8(106),
	47: int8(7),
}

var layer2_bias = [2]OpusT_opus_int8{
	0: int8(14),
	1: int8(117),
}

const EPSILON3 = 1e-15
const MIN_STEREO_ENERGY = 1e-10
const NORM_SCALING1 = 1
const Q31ONE1 = 1
const celt_inner_prod_norm = "celt_inner_prod"
const celt_inner_prod_norm_shift = "celt_inner_prod"

var trim_icdf12 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf12 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf12 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff7 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff7 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

func Opus_anti_collapse(tls *libc.TLS, m uintptr, X_ uintptr, collapse_masks uintptr, LM int32, C int32, size int32, start int32, end int32, logE uintptr, prev1logE uintptr, prev2logE uintptr, pulses uintptr, seed OpusT_opus_uint32, encode int32, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var Ediff, v13 OpusT_opus_val32
	var N0, c, depth, i, j, k, renormalize, v8 int32
	var X uintptr
	var frac, v5, v6 float32
	var integer OpusT_opus_int32
	var prev1, prev2, v10 OpusT_celt_glog
	var r, v20 OpusT_celt_norm
	var sqrt_1, thresh, v17 OpusT_opus_val16
	var v2, v3 OpusT_opus_uint32
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Ediff, N0, X, c, depth, frac, i, integer, j, k, prev1, prev2, r, renormalize, sqrt_1, thresh, v10, v13, v17, v2, v20, v3, v5, v6, v8
	i = start
	for {
		if !(i < end) {
			break
		}
		N0 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))
		/* depth in 1/8 bits */
		_ = *(*int32)(unsafe.Pointer(pulses + uintptr(i)*4)) >= libc.Int32FromInt32(0)
		v2 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2))))
		_ = v2 > libc.Uint32FromInt32(0)
		v3 = libc.Uint32FromInt32(int32(1)+*(*int32)(unsafe.Pointer(pulses + uintptr(i)*4))) / v2
		goto _4
	_4:
		depth = libc.Int32FromUint32(v3 >> LM)
		v5 = float32(-libc.Float32FromFloat32(0.125) * float32(depth))
		integer = int32(libc.Xfloor(tls, float64(v5)))
		if integer < -libc.Int32FromInt32(50) {
			v6 = libc.Float32FromInt32(0)
			goto _7
		}
		frac = v5 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v6 = *(*float32)(unsafe.Pointer(bp))
		goto _7
	_7:
		thresh = OpusT_opus_val16(libc.Float32FromFloat32(0.5) * v6)
		sqrt_1 = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(N0<<LM)))
		c = 0
		for {
			renormalize = 0
			prev1 = *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
			prev2 = *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
			if !(encode != 0) && C == int32(1) {
				if prev1 > *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) {
					v10 = prev1
				} else {
					v10 = *(*OpusT_celt_glog)(unsafe.Pointer(prev1logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
				}
				prev1 = v10
				if prev2 > *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) {
					v10 = prev2
				} else {
					v10 = *(*OpusT_celt_glog)(unsafe.Pointer(prev2logE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4))
				}
				prev2 = v10
			}
			if prev1 < prev2 {
				v10 = prev1
			} else {
				v10 = prev2
			}
			Ediff = *(*OpusT_celt_glog)(unsafe.Pointer(logE + uintptr(c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands+i)*4)) - v10
			if float32(libc.Int32FromInt32(0)) > Ediff {
				v13 = float32(libc.Int32FromInt32(0))
			} else {
				v13 = Ediff
			}
			Ediff = v13
			/* r needs to be multiplied by 2 or 2*sqrt(2) depending on LM because
			   short blocks don't have the same energy as long */
			v5 = -Ediff
			integer = int32(libc.Xfloor(tls, float64(v5)))
			if integer < -libc.Int32FromInt32(50) {
				v6 = libc.Float32FromInt32(0)
				goto _16
			}
			frac = v5 - float32(integer)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
			v6 = *(*float32)(unsafe.Pointer(bp))
			goto _16
		_16:
			r = OpusT_celt_norm(libc.Float32FromFloat32(2) * v6)
			if LM == int32(3) {
				r = r * libc.Float32FromFloat32(1.41421356)
			}
			if thresh < r {
				v17 = thresh
			} else {
				v17 = r
			}
			r = v17
			r = OpusT_celt_norm(r * sqrt_1)
			X = X_ + uintptr(c*size)*4 + uintptr(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))<<LM)*4
			k = 0
			for {
				if !(k < int32(1)<<LM) {
					break
				}
				/* Detect collapse */
				if !(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i*C+c))))&(libc.Int32FromInt32(1)<<k) != 0) {
					/* Fill with noise */
					j = 0
					for {
						if !(j < N0) {
							break
						}
						seed = Opus_celt_lcg_rand(tls, seed)
						if seed&uint32(0x8000) != 0 {
							v20 = r
						} else {
							v20 = -r
						}
						*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j<<LM+k)*4)) = v20
						goto _19
					_19:
						;
						j = j + 1
					}
					renormalize = int32(1)
				}
				goto _18
			_18:
				;
				k = k + 1
			}
			/* We just added some energy, so we need to renormalise */
			if renormalize != 0 {
				Opus_renormalise_vector(tls, X, N0<<LM, libc.Float32FromFloat32(1), arch)
			}
			goto _9
		_9:
			;
			c = c + 1
			v8 = c
			if !(v8 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

// C documentation
//
//	/* Compute the weights to use for optimizing normalized distortion across
//	   channels. We use the amplitude to weight square distortion, which means
//	   that we use the square root of the value we would have been using if we
//	   wanted to minimize the MSE in the non-normalized domain. This roughly
//	   corresponds to some quick-and-dirty perceptual experiments I ran to
//	   measure inter-aural masking (there doesn't seem to be any published data
//	   on the topic). */

func Opus_bitexact_cos(tls *libc.TLS, x OpusT_opus_int16) (r OpusT_opus_int16) {
	var tmp OpusT_opus_int32
	var x2 OpusT_opus_int16
	_, _ = tmp, x2
	tmp = (int32(4096) + int32(x)*int32(x)) >> int32(13)
	_ = tmp <= libc.Int32FromInt32(32767)
	x2 = int16(tmp)
	x2 = int16(int32(32767) - int32(x2) + (int32(16384)+int32(x2)*int32(int16(-libc.Int32FromInt32(7651)+(libc.Int32FromInt32(16384)+int32(x2)*int32(int16(libc.Int32FromInt32(8277)+(libc.Int32FromInt32(16384)+int32(int16(-libc.Int32FromInt32(626)))*int32(x2))>>libc.Int32FromInt32(15))))>>libc.Int32FromInt32(15))))>>int32(15))
	_ = int32(x2) <= libc.Int32FromInt32(32766)
	return int16(int32(1) + int32(x2))
}

func Opus_bitexact_log2tan(tls *libc.TLS, isin int32, icos int32) (r int32) {
	var lc, ls int32
	_, _ = lc, ls
	lc = libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(icos))
	ls = libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, libc.Uint32FromInt32(isin))
	icos = icos << (int32(15) - lc)
	isin = isin << (int32(15) - ls)
	return (ls-lc)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(11)) + (int32(16384)+int32(int16(isin))*int32(int16((libc.Int32FromInt32(16384)+int32(int16(isin))*int32(int16(-libc.Int32FromInt32(2597))))>>libc.Int32FromInt32(15)+libc.Int32FromInt32(7932))))>>int32(15) - (int32(16384)+int32(int16(icos))*int32(int16((libc.Int32FromInt32(16384)+int32(int16(icos))*int32(int16(-libc.Int32FromInt32(2597))))>>libc.Int32FromInt32(15)+libc.Int32FromInt32(7932))))>>int32(15)
}

// C documentation
//
//	/* Compute the amplitude (sqrt energy) in each of the bands */

func Opus_check_control_input(tls *libc.TLS, encControl uintptr) (r int32) {
	if !(encControl != libc.UintptrFromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+9222, __ccgo_ts+9259, int32(41))
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(8000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(12000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(16000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(24000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(32000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(44100) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FAPI_sampleRate != int32(48000) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate != int32(8000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate != int32(12000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate != int32(16000) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate != int32(8000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate != int32(12000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate != int32(16000) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate != int32(8000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate != int32(12000) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate != int32(16000) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate > (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate < (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FdesiredInternalSampleRate || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FminInternalSampleRate > (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FmaxInternalSampleRate {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(65))
		}
		return -int32(102)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms != int32(10) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms != int32(20) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms != int32(40) && (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpayloadSize_ms != int32(60) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(72))
		}
		return -int32(103)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpacketLossPercentage < 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FpacketLossPercentage > int32(100) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(76))
		}
		return -int32(105)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseDTX < 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseDTX > int32(1) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(80))
		}
		return -int32(108)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseCBR < 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseCBR > int32(1) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(84))
		}
		return -int32(109)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseInBandFEC < 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FuseInBandFEC > int32(1) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(88))
		}
		return -int32(107)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI < int32(1) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI > int32(ENCODER_NUM_CHANNELS) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(92))
		}
		return -int32(111)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal < int32(1) || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal > int32(ENCODER_NUM_CHANNELS) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(96))
		}
		return -int32(111)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsInternal > (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).FnChannelsAPI {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(100))
		}
		return -int32(111)
	}
	if (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity < 0 || (*OpusT_silk_EncControlStruct)(unsafe.Pointer(encControl)).Fcomplexity > int32(10) {
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+9259, int32(104))
		}
		return -int32(106)
	}
	return SILK_NO_ERROR
}

const VARIABLE_HP_MAX_DELTA_FREQ2 = "0.4f"
const VARIABLE_HP_SMTH_COEF12 = "0.1f"

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Decay time for bitreservoir */

/*******************/
/* Pitch estimator */
/*******************/

/* Level of noise floor for whitening filter LPC analysis in pitch analysis */

/* Bandwidth expansion for whitening filter in pitch analysis */

/*********************/
/* Linear prediction */
/*********************/

/* LPC analysis regularization */

/* Max cumulative LTP gain */

/* LTP analysis defines */

/***********************/
/* High pass filtering */
/***********************/

/* Smoothing parameters for low end of pitch frequency range estimation */

/* Min and max cut-off frequency values (-3 dB points) */

/***********/
/* Various */
/***********/

/* VAD threshold */

/* Speech Activity LBRR enable threshold */

/*************************/
/* Perceptual parameters */
/*************************/

/* reduction in coding SNR during low speech activity */

/* factor for reducing quantization noise during voiced speech */

/* factor for reducing quantization noise for unvoiced sparse signals */

/* threshold for sparseness measure above which to use lower quantization offset during unvoiced */

/* warping control */

/* fraction added to first autocorrelation value */

/* noise shaping filter chirp factor */

/* harmonic noise shaping */

/* extra harmonic noise shaping for high bitrates or noisy input */

/* parameter for shaping noise towards higher frequencies */

/* parameter for shaping noise even more towards higher frequencies during voiced speech */

/* parameter for applying a high-pass tilt to the input signal */

/* parameter for extra high-pass tilt to the input signal at high rates */

/* parameter for reducing noise at the very low frequencies */

/* less reduction of noise at the very low frequencies for signals with low SNR at low frequencies */

/* subframe smoothing coefficient for HarmBoost, HarmShapeGain, Tilt (lower -> more smoothing) */

/* parameters defining the R/D tradeoff in the residual quantizer */

/* Compensation in bitrate calculations for 10 ms modes */

/* Maximum time before allowing a bandwidth transition */

// C documentation
//
//	/* These tables hold SNR values divided by 21 (so they fit in 8 bits)
//	   for different target bitrates spaced at 400 bps interval. The first
//	   10 values are omitted (0-4 kb/s) because they're all zeros.
//	   These tables were obtained by running different SNRs through the
//	   encoder and measuring the active bitrate. */
var silk_TargetRate_NB_21 = [107]uint8{
	1:   uint8(15),
	2:   uint8(39),
	3:   uint8(52),
	4:   uint8(61),
	5:   uint8(68),
	6:   uint8(74),
	7:   uint8(79),
	8:   uint8(84),
	9:   uint8(88),
	10:  uint8(92),
	11:  uint8(95),
	12:  uint8(99),
	13:  uint8(102),
	14:  uint8(105),
	15:  uint8(108),
	16:  uint8(111),
	17:  uint8(114),
	18:  uint8(117),
	19:  uint8(119),
	20:  uint8(122),
	21:  uint8(124),
	22:  uint8(126),
	23:  uint8(129),
	24:  uint8(131),
	25:  uint8(133),
	26:  uint8(135),
	27:  uint8(137),
	28:  uint8(139),
	29:  uint8(142),
	30:  uint8(143),
	31:  uint8(145),
	32:  uint8(147),
	33:  uint8(149),
	34:  uint8(151),
	35:  uint8(153),
	36:  uint8(155),
	37:  uint8(157),
	38:  uint8(158),
	39:  uint8(160),
	40:  uint8(162),
	41:  uint8(163),
	42:  uint8(165),
	43:  uint8(167),
	44:  uint8(168),
	45:  uint8(170),
	46:  uint8(171),
	47:  uint8(173),
	48:  uint8(174),
	49:  uint8(176),
	50:  uint8(177),
	51:  uint8(179),
	52:  uint8(180),
	53:  uint8(182),
	54:  uint8(183),
	55:  uint8(185),
	56:  uint8(186),
	57:  uint8(187),
	58:  uint8(189),
	59:  uint8(190),
	60:  uint8(192),
	61:  uint8(193),
	62:  uint8(194),
	63:  uint8(196),
	64:  uint8(197),
	65:  uint8(199),
	66:  uint8(200),
	67:  uint8(201),
	68:  uint8(203),
	69:  uint8(204),
	70:  uint8(205),
	71:  uint8(207),
	72:  uint8(208),
	73:  uint8(209),
	74:  uint8(211),
	75:  uint8(212),
	76:  uint8(213),
	77:  uint8(215),
	78:  uint8(216),
	79:  uint8(217),
	80:  uint8(219),
	81:  uint8(220),
	82:  uint8(221),
	83:  uint8(223),
	84:  uint8(224),
	85:  uint8(225),
	86:  uint8(227),
	87:  uint8(228),
	88:  uint8(230),
	89:  uint8(231),
	90:  uint8(232),
	91:  uint8(234),
	92:  uint8(235),
	93:  uint8(236),
	94:  uint8(238),
	95:  uint8(239),
	96:  uint8(241),
	97:  uint8(242),
	98:  uint8(243),
	99:  uint8(245),
	100: uint8(246),
	101: uint8(248),
	102: uint8(249),
	103: uint8(250),
	104: uint8(252),
	105: uint8(253),
	106: uint8(255),
}

var silk_TargetRate_MB_21 = [155]uint8{
	2:   uint8(28),
	3:   uint8(43),
	4:   uint8(52),
	5:   uint8(59),
	6:   uint8(65),
	7:   uint8(70),
	8:   uint8(74),
	9:   uint8(78),
	10:  uint8(81),
	11:  uint8(85),
	12:  uint8(87),
	13:  uint8(90),
	14:  uint8(93),
	15:  uint8(95),
	16:  uint8(98),
	17:  uint8(100),
	18:  uint8(102),
	19:  uint8(105),
	20:  uint8(107),
	21:  uint8(109),
	22:  uint8(111),
	23:  uint8(113),
	24:  uint8(115),
	25:  uint8(116),
	26:  uint8(118),
	27:  uint8(120),
	28:  uint8(122),
	29:  uint8(123),
	30:  uint8(125),
	31:  uint8(127),
	32:  uint8(128),
	33:  uint8(130),
	34:  uint8(131),
	35:  uint8(133),
	36:  uint8(134),
	37:  uint8(136),
	38:  uint8(137),
	39:  uint8(138),
	40:  uint8(140),
	41:  uint8(141),
	42:  uint8(143),
	43:  uint8(144),
	44:  uint8(145),
	45:  uint8(147),
	46:  uint8(148),
	47:  uint8(149),
	48:  uint8(151),
	49:  uint8(152),
	50:  uint8(153),
	51:  uint8(154),
	52:  uint8(156),
	53:  uint8(157),
	54:  uint8(158),
	55:  uint8(159),
	56:  uint8(160),
	57:  uint8(162),
	58:  uint8(163),
	59:  uint8(164),
	60:  uint8(165),
	61:  uint8(166),
	62:  uint8(167),
	63:  uint8(168),
	64:  uint8(169),
	65:  uint8(171),
	66:  uint8(172),
	67:  uint8(173),
	68:  uint8(174),
	69:  uint8(175),
	70:  uint8(176),
	71:  uint8(177),
	72:  uint8(178),
	73:  uint8(179),
	74:  uint8(180),
	75:  uint8(181),
	76:  uint8(182),
	77:  uint8(183),
	78:  uint8(184),
	79:  uint8(185),
	80:  uint8(186),
	81:  uint8(187),
	82:  uint8(188),
	83:  uint8(188),
	84:  uint8(189),
	85:  uint8(190),
	86:  uint8(191),
	87:  uint8(192),
	88:  uint8(193),
	89:  uint8(194),
	90:  uint8(195),
	91:  uint8(196),
	92:  uint8(197),
	93:  uint8(198),
	94:  uint8(199),
	95:  uint8(200),
	96:  uint8(201),
	97:  uint8(202),
	98:  uint8(203),
	99:  uint8(203),
	100: uint8(204),
	101: uint8(205),
	102: uint8(206),
	103: uint8(207),
	104: uint8(208),
	105: uint8(209),
	106: uint8(210),
	107: uint8(211),
	108: uint8(212),
	109: uint8(213),
	110: uint8(214),
	111: uint8(214),
	112: uint8(215),
	113: uint8(216),
	114: uint8(217),
	115: uint8(218),
	116: uint8(219),
	117: uint8(220),
	118: uint8(221),
	119: uint8(222),
	120: uint8(223),
	121: uint8(224),
	122: uint8(224),
	123: uint8(225),
	124: uint8(226),
	125: uint8(227),
	126: uint8(228),
	127: uint8(229),
	128: uint8(230),
	129: uint8(231),
	130: uint8(232),
	131: uint8(233),
	132: uint8(234),
	133: uint8(235),
	134: uint8(236),
	135: uint8(236),
	136: uint8(237),
	137: uint8(238),
	138: uint8(239),
	139: uint8(240),
	140: uint8(241),
	141: uint8(242),
	142: uint8(243),
	143: uint8(244),
	144: uint8(245),
	145: uint8(246),
	146: uint8(247),
	147: uint8(248),
	148: uint8(249),
	149: uint8(250),
	150: uint8(251),
	151: uint8(252),
	152: uint8(253),
	153: uint8(254),
	154: uint8(255),
}

var silk_TargetRate_WB_21 = [191]uint8{
	3:   uint8(8),
	4:   uint8(29),
	5:   uint8(41),
	6:   uint8(49),
	7:   uint8(56),
	8:   uint8(62),
	9:   uint8(66),
	10:  uint8(70),
	11:  uint8(74),
	12:  uint8(77),
	13:  uint8(80),
	14:  uint8(83),
	15:  uint8(86),
	16:  uint8(88),
	17:  uint8(91),
	18:  uint8(93),
	19:  uint8(95),
	20:  uint8(97),
	21:  uint8(99),
	22:  uint8(101),
	23:  uint8(103),
	24:  uint8(105),
	25:  uint8(107),
	26:  uint8(108),
	27:  uint8(110),
	28:  uint8(112),
	29:  uint8(113),
	30:  uint8(115),
	31:  uint8(116),
	32:  uint8(118),
	33:  uint8(119),
	34:  uint8(121),
	35:  uint8(122),
	36:  uint8(123),
	37:  uint8(125),
	38:  uint8(126),
	39:  uint8(127),
	40:  uint8(129),
	41:  uint8(130),
	42:  uint8(131),
	43:  uint8(132),
	44:  uint8(134),
	45:  uint8(135),
	46:  uint8(136),
	47:  uint8(137),
	48:  uint8(138),
	49:  uint8(140),
	50:  uint8(141),
	51:  uint8(142),
	52:  uint8(143),
	53:  uint8(144),
	54:  uint8(145),
	55:  uint8(146),
	56:  uint8(147),
	57:  uint8(148),
	58:  uint8(149),
	59:  uint8(150),
	60:  uint8(151),
	61:  uint8(152),
	62:  uint8(153),
	63:  uint8(154),
	64:  uint8(156),
	65:  uint8(157),
	66:  uint8(158),
	67:  uint8(159),
	68:  uint8(159),
	69:  uint8(160),
	70:  uint8(161),
	71:  uint8(162),
	72:  uint8(163),
	73:  uint8(164),
	74:  uint8(165),
	75:  uint8(166),
	76:  uint8(167),
	77:  uint8(168),
	78:  uint8(169),
	79:  uint8(170),
	80:  uint8(171),
	81:  uint8(171),
	82:  uint8(172),
	83:  uint8(173),
	84:  uint8(174),
	85:  uint8(175),
	86:  uint8(176),
	87:  uint8(177),
	88:  uint8(177),
	89:  uint8(178),
	90:  uint8(179),
	91:  uint8(180),
	92:  uint8(181),
	93:  uint8(181),
	94:  uint8(182),
	95:  uint8(183),
	96:  uint8(184),
	97:  uint8(185),
	98:  uint8(185),
	99:  uint8(186),
	100: uint8(187),
	101: uint8(188),
	102: uint8(189),
	103: uint8(189),
	104: uint8(190),
	105: uint8(191),
	106: uint8(192),
	107: uint8(192),
	108: uint8(193),
	109: uint8(194),
	110: uint8(195),
	111: uint8(195),
	112: uint8(196),
	113: uint8(197),
	114: uint8(198),
	115: uint8(198),
	116: uint8(199),
	117: uint8(200),
	118: uint8(200),
	119: uint8(201),
	120: uint8(202),
	121: uint8(203),
	122: uint8(203),
	123: uint8(204),
	124: uint8(205),
	125: uint8(206),
	126: uint8(206),
	127: uint8(207),
	128: uint8(208),
	129: uint8(209),
	130: uint8(209),
	131: uint8(210),
	132: uint8(211),
	133: uint8(211),
	134: uint8(212),
	135: uint8(213),
	136: uint8(214),
	137: uint8(214),
	138: uint8(215),
	139: uint8(216),
	140: uint8(216),
	141: uint8(217),
	142: uint8(218),
	143: uint8(219),
	144: uint8(219),
	145: uint8(220),
	146: uint8(221),
	147: uint8(221),
	148: uint8(222),
	149: uint8(223),
	150: uint8(224),
	151: uint8(224),
	152: uint8(225),
	153: uint8(226),
	154: uint8(226),
	155: uint8(227),
	156: uint8(228),
	157: uint8(229),
	158: uint8(229),
	159: uint8(230),
	160: uint8(231),
	161: uint8(232),
	162: uint8(232),
	163: uint8(233),
	164: uint8(234),
	165: uint8(234),
	166: uint8(235),
	167: uint8(236),
	168: uint8(237),
	169: uint8(237),
	170: uint8(238),
	171: uint8(239),
	172: uint8(240),
	173: uint8(240),
	174: uint8(241),
	175: uint8(242),
	176: uint8(243),
	177: uint8(243),
	178: uint8(244),
	179: uint8(245),
	180: uint8(246),
	181: uint8(246),
	182: uint8(247),
	183: uint8(248),
	184: uint8(249),
	185: uint8(249),
	186: uint8(250),
	187: uint8(251),
	188: uint8(252),
	189: uint8(253),
	190: uint8(255),
}

// C documentation
//
//	/* Control SNR of residual quantizer */

func Opus_clt_compute_allocation(tls *libc.TLS, m uintptr, start int32, end int32, offsets uintptr, cap1 uintptr, alloc_trim int32, intensity uintptr, dual_stereo uintptr, total OpusT_opus_int32, balance uintptr, pulses uintptr, ebits uintptr, fine_priority uintptr, C int32, LM int32, ec uintptr, encode int32, prev int32, signalBandwidth int32) (r int32) {
	var N, N1, bits1j, bits2j, bitsj, codedBands, done, dual_stereo_rsv, hi, intensity_rsv, j, len1, lo, mid, psum, skip_rsv, skip_start, v5 int32
	var _saved_stack, bits1, bits2, st, thresh, trim_offset, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N1, _saved_stack, bits1, bits1j, bits2, bits2j, bitsj, codedBands, done, dual_stereo_rsv, hi, intensity_rsv, j, len1, lo, mid, psum, skip_rsv, skip_start, st, thresh, trim_offset, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v3, v5, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if total > 0 {
		v5 = total
	} else {
		v5 = 0
	}
	total = v5
	len1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands
	skip_start = start
	/* Reserve a bit to signal the end of manually skipped bands. */
	if total >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
		v5 = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
	} else {
		v5 = 0
	}
	skip_rsv = v5
	total = total - skip_rsv
	/* Reserve bits for the intensity and dual stereo parameters. */
	v5 = libc.Int32FromInt32(0)
	dual_stereo_rsv = v5
	intensity_rsv = v5
	if C == int32(2) {
		intensity_rsv = libc.Int32FromUint8(LOG2_FRAC_TABLE[end-start])
		if intensity_rsv > total {
			intensity_rsv = 0
		} else {
			total = total - intensity_rsv
			if total >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
				v5 = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
			} else {
				v5 = 0
			}
			dual_stereo_rsv = v5
			total = total - dual_stereo_rsv
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _12
_12:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6113, int32(570))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _32
_32:
	bits1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6113, int32(571))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _56
_56:
	bits2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _60
_60:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6113, int32(572))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _80
_80:
	thresh = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _84
_84:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _86
	_86:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _88
_88:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _90
	_90:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _92
_92:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _94
	_94:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _96
_96:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6113, int32(573))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _98
	_98:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _100
_100:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _102
	_102:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _104
_104:
	trim_offset = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	j = start
	for {
		if !(j < end) {
			break
		}
		/* Below this threshold, we're sure not to allocate any PVQ bits */
		if C<<int32(BITRES) > int32(3)*(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))<<LM<<int32(BITRES)>>int32(4) {
			v5 = C << int32(BITRES)
		} else {
			v5 = int32(3) * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))) << LM << int32(BITRES) >> int32(4)
		}
		*(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) = v5
		/* Tilt of the allocation curve */
		*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) = C * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))) * (alloc_trim - int32(5) - LM) * (end - j - int32(1)) * (int32(1) << (LM + int32(BITRES))) >> int32(6)
		/* Giving less resolution to single-coefficient bands because they get
		   more benefit from having one coarse value per coefficient*/
		if (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))<<LM == int32(1) {
			*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) -= C << int32(BITRES)
		}
		goto _105
	_105:
		;
		j = j + 1
	}
	lo = int32(1)
	hi = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbAllocVectors - int32(1)
	for cond := true; cond; cond = lo <= hi {
		done = 0
		psum = 0
		mid = (lo + hi) >> int32(1)
		j = end
		for {
			v5 = j
			j = j - 1
			if !(v5 > start) {
				break
			}
			N = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
			bitsj = C * N * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(mid*len1+j)))) << LM >> int32(2)
			if bitsj > 0 {
				if 0 > bitsj+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
					v5 = 0
				} else {
					v5 = bitsj + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
				}
				bitsj = v5
			}
			bitsj = bitsj + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
			if bitsj >= *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) || done != 0 {
				done = int32(1)
				/* Don't allocate more than we can actually use */
				if bitsj < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
					v5 = bitsj
				} else {
					v5 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
				}
				psum = psum + v5
			} else {
				if bitsj >= C<<int32(BITRES) {
					psum = psum + C<<int32(BITRES)
				}
			}
			goto _107
		_107:
		}
		if psum > total {
			hi = mid - int32(1)
		} else {
			lo = mid + int32(1)
		}
		/*printf ("lo = %d, hi = %d\n", lo, hi);*/
	}
	v5 = lo
	lo = lo - 1
	hi = v5
	/*printf ("interp between %d and %d\n", lo, hi);*/
	j = start
	for {
		if !(j < end) {
			break
		}
		N1 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		bits1j = C * N1 * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(lo*len1+j)))) << LM >> int32(2)
		if hi >= (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbAllocVectors {
			v5 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
		} else {
			v5 = C * N1 * libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FallocVectors + uintptr(hi*len1+j)))) << LM >> int32(2)
		}
		bits2j = v5
		if bits1j > 0 {
			if 0 > bits1j+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
				v5 = 0
			} else {
				v5 = bits1j + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
			}
			bits1j = v5
		}
		if bits2j > 0 {
			if 0 > bits2j+*(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4)) {
				v5 = 0
			} else {
				v5 = bits2j + *(*int32)(unsafe.Pointer(trim_offset + uintptr(j)*4))
			}
			bits2j = v5
		}
		if lo > 0 {
			bits1j = bits1j + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
		}
		bits2j = bits2j + *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4))
		if *(*int32)(unsafe.Pointer(offsets + uintptr(j)*4)) > 0 {
			skip_start = j
		}
		if 0 > bits2j-bits1j {
			v5 = 0
		} else {
			v5 = bits2j - bits1j
		}
		bits2j = v5
		*(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) = bits1j
		*(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4)) = bits2j
		goto _112
	_112:
		;
		j = j + 1
	}
	codedBands = interp_bits2pulses(tls, m, start, end, skip_start, bits1, bits2, thresh, cap1, total, balance, skip_rsv, intensity, intensity_rsv, dual_stereo, dual_stereo_rsv, pulses, ebits, fine_priority, C, LM, ec, encode, prev, signalBandwidth)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _118
	_118:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _120
_120:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return codedBands
}

const EPSILON7 = 1e-15
const Q15ONE7 = 1

var log2_x_norm_coeff21 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff21 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf21 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf21 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf21 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/***********************************************************************
Copyright (c) 2006-2011, Skype Limited. All rights reserved.
Copyright (C) 2012 Xiph.Org Foundation
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
- Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
- Neither the name of Internet Society, IETF or IETF Trust, nor the
names of specific contributors, may be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
***********************************************************************/

/* Redefine macro functions with extensive assertion in DEBUG mode.
   As functions can't be undefined, this file can't work with SigProcFIX_MacroCount.h */

func Opus_clt_mdct_backward_c(tls *libc.TLS, l uintptr, in uintptr, out uintptr, window uintptr, overlap int32, shift int32, stride int32, arch int32) {
	var N, N2, N4, i, rev int32
	var bitrev, t, t1, trig, wp1, wp2, xp1, xp11, xp2, yp, yp0, yp1, yp11, v3 uintptr
	var im, re, t0, t11, x11, x21, yi, yi1, yr, yr1 float32
	var x1, x2 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N2, N4, bitrev, i, im, re, rev, t, t0, t1, t11, trig, wp1, wp2, x1, x11, x2, x21, xp1, xp11, xp2, yi, yi1, yp, yp0, yp1, yp11, yr, yr1, v3
	_ = arch
	N = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Fn
	trig = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Ftrig
	i = 0
	for {
		if !(i < shift) {
			break
		}
		N = N >> int32(1)
		trig = trig + uintptr(N)*4
		goto _1
	_1:
		;
		i = i + 1
	}
	N2 = N >> int32(1)
	N4 = N >> int32(2)
	/* Pre-rotate */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	xp1 = in
	xp2 = in + uintptr(stride*(N2-int32(1)))*4
	yp = out + uintptr(overlap>>libc.Int32FromInt32(1))*4
	t = trig
	bitrev = (*OpusT_kiss_fft_state)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8)))).Fbitrev
	i = 0
	for {
		if !(i < N4) {
			break
		}
		v3 = bitrev
		bitrev += 2
		rev = int32(*(*OpusT_opus_int16)(unsafe.Pointer(v3)))
		x1 = *(*float32)(unsafe.Pointer(xp1))
		x2 = *(*float32)(unsafe.Pointer(xp2))
		yr = OpusT_opus_val32(x2**(*float32)(unsafe.Pointer(t + uintptr(i)*4))) + OpusT_opus_val32(x1**(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4)))
		yi = OpusT_opus_val32(x1**(*float32)(unsafe.Pointer(t + uintptr(i)*4))) - OpusT_opus_val32(x2**(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4)))
		/* We swap real and imag because we use an FFT instead of an IFFT. */
		*(*float32)(unsafe.Pointer(yp + uintptr(int32(2)*rev+int32(1))*4)) = yr
		*(*float32)(unsafe.Pointer(yp + uintptr(int32(2)*rev)*4)) = yi
		/* Storing the pre-rotation directly in the bitrev order. */
		xp1 = xp1 + uintptr(int32(2)*stride)*4
		xp2 = xp2 - uintptr(int32(2)*stride)*4
		goto _2
	_2:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, *(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8)), out+uintptr(overlap>>libc.Int32FromInt32(1))*4)
	/* Post-rotate and de-shuffle from both ends of the buffer at once to make
	   it in-place. */
	yp0 = out + uintptr(overlap>>libc.Int32FromInt32(1))*4
	yp1 = out + uintptr(overlap>>libc.Int32FromInt32(1))*4 + uintptr(N2)*4 - uintptr(2)*4
	t1 = trig
	/* Loop to (N4+1)>>1 to handle odd N4. When N4 is odd, the
	   middle pair will be computed twice. */
	i = 0
	for {
		if !(i < (N4+int32(1))>>int32(1)) {
			break
		}
		/* We swap real and imag because we're using an FFT instead of an IFFT. */
		re = *(*float32)(unsafe.Pointer(yp0 + 1*4))
		im = *(*float32)(unsafe.Pointer(yp0))
		t0 = *(*float32)(unsafe.Pointer(t1 + uintptr(i)*4))
		t11 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4+i)*4))
		/* We'd scale up by 2 here, but instead it's done when mixing the windows */
		yr1 = float32(re*t0) + float32(im*t11)
		yi1 = float32(re*t11) - float32(im*t0)
		/* We swap real and imag because we're using an FFT instead of an IFFT. */
		re = *(*float32)(unsafe.Pointer(yp1 + 1*4))
		im = *(*float32)(unsafe.Pointer(yp1))
		*(*float32)(unsafe.Pointer(yp0)) = yr1
		*(*float32)(unsafe.Pointer(yp1 + 1*4)) = yi1
		t0 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4-i-libc.Int32FromInt32(1))*4))
		t11 = *(*float32)(unsafe.Pointer(t1 + uintptr(N2-i-libc.Int32FromInt32(1))*4))
		/* We'd scale up by 2 here, but instead it's done when mixing the windows */
		yr1 = float32(re*t0) + float32(im*t11)
		yi1 = float32(re*t11) - float32(im*t0)
		*(*float32)(unsafe.Pointer(yp1)) = yr1
		*(*float32)(unsafe.Pointer(yp0 + 1*4)) = yi1
		yp0 = yp0 + uintptr(2)*4
		yp1 = yp1 - uintptr(2)*4
		goto _4
	_4:
		;
		i = i + 1
	}
	/* Mirror on both sides for TDAC */
	xp11 = out + uintptr(overlap)*4 - uintptr(1)*4
	yp11 = out
	wp1 = window
	wp2 = window + uintptr(overlap)*4 - uintptr(1)*4
	i = 0
	for {
		if !(i < overlap/int32(2)) {
			break
		}
		x11 = *(*float32)(unsafe.Pointer(xp11))
		x21 = *(*float32)(unsafe.Pointer(yp11))
		v3 = yp11
		yp11 += 4
		*(*float32)(unsafe.Pointer(v3)) = float32(x21**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) - float32(x11**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		v3 = xp11
		xp11 -= 4
		*(*float32)(unsafe.Pointer(v3)) = float32(x21**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) + float32(x11**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		wp1 += 4
		wp2 -= 4
		goto _5
	_5:
		;
		i = i + 1
	}
}

const BITALLOC_SIZE = 11
const M_PI1 = 3.1415926535897931
const TOTAL_MODES = 1

var trim_icdf16 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf16 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf16 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff16 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff16 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2010 Xiph.Org Foundation
 * Copyright (c) 2013 Parrot */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var eband5ms = [22]OpusT_opus_int16{
	1:  int16(1),
	2:  int16(2),
	3:  int16(3),
	4:  int16(4),
	5:  int16(5),
	6:  int16(6),
	7:  int16(7),
	8:  int16(8),
	9:  int16(10),
	10: int16(12),
	11: int16(14),
	12: int16(16),
	13: int16(20),
	14: int16(24),
	15: int16(28),
	16: int16(34),
	17: int16(40),
	18: int16(48),
	19: int16(60),
	20: int16(78),
	21: int16(100),
}

// C documentation
//
//	/* Alternate tuning (partially derived from Vorbis) */
//	/* Bit allocation table in units of 1/32 bit/sample (0.1875 dB SNR) */
var band_allocation = [231]uint8{
	21:  uint8(90),
	22:  uint8(80),
	23:  uint8(75),
	24:  uint8(69),
	25:  uint8(63),
	26:  uint8(56),
	27:  uint8(49),
	28:  uint8(40),
	29:  uint8(34),
	30:  uint8(29),
	31:  uint8(20),
	32:  uint8(18),
	33:  uint8(10),
	42:  uint8(110),
	43:  uint8(100),
	44:  uint8(90),
	45:  uint8(84),
	46:  uint8(78),
	47:  uint8(71),
	48:  uint8(65),
	49:  uint8(58),
	50:  uint8(51),
	51:  uint8(45),
	52:  uint8(39),
	53:  uint8(32),
	54:  uint8(26),
	55:  uint8(20),
	56:  uint8(12),
	63:  uint8(118),
	64:  uint8(110),
	65:  uint8(103),
	66:  uint8(93),
	67:  uint8(86),
	68:  uint8(80),
	69:  uint8(75),
	70:  uint8(70),
	71:  uint8(65),
	72:  uint8(59),
	73:  uint8(53),
	74:  uint8(47),
	75:  uint8(40),
	76:  uint8(31),
	77:  uint8(23),
	78:  uint8(15),
	79:  uint8(4),
	84:  uint8(126),
	85:  uint8(119),
	86:  uint8(112),
	87:  uint8(104),
	88:  uint8(95),
	89:  uint8(89),
	90:  uint8(83),
	91:  uint8(78),
	92:  uint8(72),
	93:  uint8(66),
	94:  uint8(60),
	95:  uint8(54),
	96:  uint8(47),
	97:  uint8(39),
	98:  uint8(32),
	99:  uint8(25),
	100: uint8(17),
	101: uint8(12),
	102: uint8(1),
	105: uint8(134),
	106: uint8(127),
	107: uint8(120),
	108: uint8(114),
	109: uint8(103),
	110: uint8(97),
	111: uint8(91),
	112: uint8(85),
	113: uint8(78),
	114: uint8(72),
	115: uint8(66),
	116: uint8(60),
	117: uint8(54),
	118: uint8(47),
	119: uint8(41),
	120: uint8(35),
	121: uint8(29),
	122: uint8(23),
	123: uint8(16),
	124: uint8(10),
	125: uint8(1),
	126: uint8(144),
	127: uint8(137),
	128: uint8(130),
	129: uint8(124),
	130: uint8(113),
	131: uint8(107),
	132: uint8(101),
	133: uint8(95),
	134: uint8(88),
	135: uint8(82),
	136: uint8(76),
	137: uint8(70),
	138: uint8(64),
	139: uint8(57),
	140: uint8(51),
	141: uint8(45),
	142: uint8(39),
	143: uint8(33),
	144: uint8(26),
	145: uint8(15),
	146: uint8(1),
	147: uint8(152),
	148: uint8(145),
	149: uint8(138),
	150: uint8(132),
	151: uint8(123),
	152: uint8(117),
	153: uint8(111),
	154: uint8(105),
	155: uint8(98),
	156: uint8(92),
	157: uint8(86),
	158: uint8(80),
	159: uint8(74),
	160: uint8(67),
	161: uint8(61),
	162: uint8(55),
	163: uint8(49),
	164: uint8(43),
	165: uint8(36),
	166: uint8(20),
	167: uint8(1),
	168: uint8(162),
	169: uint8(155),
	170: uint8(148),
	171: uint8(142),
	172: uint8(133),
	173: uint8(127),
	174: uint8(121),
	175: uint8(115),
	176: uint8(108),
	177: uint8(102),
	178: uint8(96),
	179: uint8(90),
	180: uint8(84),
	181: uint8(77),
	182: uint8(71),
	183: uint8(65),
	184: uint8(59),
	185: uint8(53),
	186: uint8(46),
	187: uint8(30),
	188: uint8(1),
	189: uint8(172),
	190: uint8(165),
	191: uint8(158),
	192: uint8(152),
	193: uint8(143),
	194: uint8(137),
	195: uint8(131),
	196: uint8(125),
	197: uint8(118),
	198: uint8(112),
	199: uint8(106),
	200: uint8(100),
	201: uint8(94),
	202: uint8(87),
	203: uint8(81),
	204: uint8(75),
	205: uint8(69),
	206: uint8(63),
	207: uint8(56),
	208: uint8(45),
	209: uint8(20),
	210: uint8(200),
	211: uint8(200),
	212: uint8(200),
	213: uint8(200),
	214: uint8(200),
	215: uint8(200),
	216: uint8(200),
	217: uint8(200),
	218: uint8(198),
	219: uint8(193),
	220: uint8(188),
	221: uint8(183),
	222: uint8(178),
	223: uint8(173),
	224: uint8(168),
	225: uint8(163),
	226: uint8(158),
	227: uint8(153),
	228: uint8(148),
	229: uint8(129),
	230: uint8(104),
}
var window120 = [120]OpusT_celt_coef{
	0:   libc.Float32FromFloat32(6.7286966e-05),
	1:   libc.Float32FromFloat32(0.00060551348),
	2:   libc.Float32FromFloat32(0.001681597),
	3:   libc.Float32FromFloat32(0.0032947962),
	4:   libc.Float32FromFloat32(0.0054439943),
	5:   libc.Float32FromFloat32(0.0081276923),
	6:   libc.Float32FromFloat32(0.011344001),
	7:   libc.Float32FromFloat32(0.015090633),
	8:   libc.Float32FromFloat32(0.019364886),
	9:   libc.Float32FromFloat32(0.024163635),
	10:  libc.Float32FromFloat32(0.029483315),
	11:  libc.Float32FromFloat32(0.035319905),
	12:  libc.Float32FromFloat32(0.041668911),
	13:  libc.Float32FromFloat32(0.048525347),
	14:  libc.Float32FromFloat32(0.055883718),
	15:  libc.Float32FromFloat32(0.063737999),
	16:  libc.Float32FromFloat32(0.072081616),
	17:  libc.Float32FromFloat32(0.080907428),
	18:  libc.Float32FromFloat32(0.090207705),
	19:  libc.Float32FromFloat32(0.099974111),
	20:  libc.Float32FromFloat32(0.11019769),
	21:  libc.Float32FromFloat32(0.12086883),
	22:  libc.Float32FromFloat32(0.13197729),
	23:  libc.Float32FromFloat32(0.14351214),
	24:  libc.Float32FromFloat32(0.15546177),
	25:  libc.Float32FromFloat32(0.16781389),
	26:  libc.Float32FromFloat32(0.1805555),
	27:  libc.Float32FromFloat32(0.1936729),
	28:  libc.Float32FromFloat32(0.20715171),
	29:  libc.Float32FromFloat32(0.22097682),
	30:  libc.Float32FromFloat32(0.23513243),
	31:  libc.Float32FromFloat32(0.24960208),
	32:  libc.Float32FromFloat32(0.2643686),
	33:  libc.Float32FromFloat32(0.27941419),
	34:  libc.Float32FromFloat32(0.2947204),
	35:  libc.Float32FromFloat32(0.31026818),
	36:  libc.Float32FromFloat32(0.32603788),
	37:  libc.Float32FromFloat32(0.34200931),
	38:  libc.Float32FromFloat32(0.35816177),
	39:  libc.Float32FromFloat32(0.37447407),
	40:  libc.Float32FromFloat32(0.39092462),
	41:  libc.Float32FromFloat32(0.40749142),
	42:  libc.Float32FromFloat32(0.42415215),
	43:  libc.Float32FromFloat32(0.44088423),
	44:  libc.Float32FromFloat32(0.45766484),
	45:  libc.Float32FromFloat32(0.47447104),
	46:  libc.Float32FromFloat32(0.49127978),
	47:  libc.Float32FromFloat32(0.50806798),
	48:  libc.Float32FromFloat32(0.52481261),
	49:  libc.Float32FromFloat32(0.54149077),
	50:  libc.Float32FromFloat32(0.55807973),
	51:  libc.Float32FromFloat32(0.57455701),
	52:  libc.Float32FromFloat32(0.59090049),
	53:  libc.Float32FromFloat32(0.60708841),
	54:  libc.Float32FromFloat32(0.62309951),
	55:  libc.Float32FromFloat32(0.63891306),
	56:  libc.Float32FromFloat32(0.65450896),
	57:  libc.Float32FromFloat32(0.66986776),
	58:  libc.Float32FromFloat32(0.68497077),
	59:  libc.Float32FromFloat32(0.6998001),
	60:  libc.Float32FromFloat32(0.71433873),
	61:  libc.Float32FromFloat32(0.72857055),
	62:  libc.Float32FromFloat32(0.74248043),
	63:  libc.Float32FromFloat32(0.75605425),
	64:  libc.Float32FromFloat32(0.76927895),
	65:  libc.Float32FromFloat32(0.78214257),
	66:  libc.Float32FromFloat32(0.7946343),
	67:  libc.Float32FromFloat32(0.80674445),
	68:  libc.Float32FromFloat32(0.81846456),
	69:  libc.Float32FromFloat32(0.82978733),
	70:  libc.Float32FromFloat32(0.84070669),
	71:  libc.Float32FromFloat32(0.85121779),
	72:  libc.Float32FromFloat32(0.86131698),
	73:  libc.Float32FromFloat32(0.87100183),
	74:  libc.Float32FromFloat32(0.88027111),
	75:  libc.Float32FromFloat32(0.88912479),
	76:  libc.Float32FromFloat32(0.89756398),
	77:  libc.Float32FromFloat32(0.90559094),
	78:  libc.Float32FromFloat32(0.91320904),
	79:  libc.Float32FromFloat32(0.9204227),
	80:  libc.Float32FromFloat32(0.92723738),
	81:  libc.Float32FromFloat32(0.93365955),
	82:  libc.Float32FromFloat32(0.93969656),
	83:  libc.Float32FromFloat32(0.94535671),
	84:  libc.Float32FromFloat32(0.95064907),
	85:  libc.Float32FromFloat32(0.95558353),
	86:  libc.Float32FromFloat32(0.96017067),
	87:  libc.Float32FromFloat32(0.96442171),
	88:  libc.Float32FromFloat32(0.96834849),
	89:  libc.Float32FromFloat32(0.97196334),
	90:  libc.Float32FromFloat32(0.97527906),
	91:  libc.Float32FromFloat32(0.97830883),
	92:  libc.Float32FromFloat32(0.98106616),
	93:  libc.Float32FromFloat32(0.9835648),
	94:  libc.Float32FromFloat32(0.98581869),
	95:  libc.Float32FromFloat32(0.98784191),
	96:  libc.Float32FromFloat32(0.98964856),
	97:  libc.Float32FromFloat32(0.99125274),
	98:  libc.Float32FromFloat32(0.99266849),
	99:  libc.Float32FromFloat32(0.99390969),
	100: libc.Float32FromFloat32(0.99499004),
	101: libc.Float32FromFloat32(0.99592297),
	102: libc.Float32FromFloat32(0.99672162),
	103: libc.Float32FromFloat32(0.99739874),
	104: libc.Float32FromFloat32(0.99796667),
	105: libc.Float32FromFloat32(0.99843728),
	106: libc.Float32FromFloat32(0.99882195),
	107: libc.Float32FromFloat32(0.99913147),
	108: libc.Float32FromFloat32(0.99937606),
	109: libc.Float32FromFloat32(0.99956527),
	110: libc.Float32FromFloat32(0.99970802),
	111: libc.Float32FromFloat32(0.99981248),
	112: libc.Float32FromFloat32(0.99988613),
	113: libc.Float32FromFloat32(0.99993565),
	114: libc.Float32FromFloat32(0.99996697),
	115: libc.Float32FromFloat32(0.99998518),
	116: libc.Float32FromFloat32(0.99999457),
	117: libc.Float32FromFloat32(0.99999859),
	118: libc.Float32FromFloat32(0.99999982),
	119: libc.Float32FromFloat32(1),
}
var logN400 = [21]OpusT_opus_int16{
	8:  int16(8),
	9:  int16(8),
	10: int16(8),
	11: int16(8),
	12: int16(16),
	13: int16(16),
	14: int16(16),
	15: int16(21),
	16: int16(21),
	17: int16(24),
	18: int16(29),
	19: int16(34),
	20: int16(36),
}
var cache_index50 = [105]OpusT_opus_int16{
	0:   int16(-int32(1)),
	1:   int16(-int32(1)),
	2:   int16(-int32(1)),
	3:   int16(-int32(1)),
	4:   int16(-int32(1)),
	5:   int16(-int32(1)),
	6:   int16(-int32(1)),
	7:   int16(-int32(1)),
	12:  int16(41),
	13:  int16(41),
	14:  int16(41),
	15:  int16(82),
	16:  int16(82),
	17:  int16(123),
	18:  int16(164),
	19:  int16(200),
	20:  int16(222),
	29:  int16(41),
	30:  int16(41),
	31:  int16(41),
	32:  int16(41),
	33:  int16(123),
	34:  int16(123),
	35:  int16(123),
	36:  int16(164),
	37:  int16(164),
	38:  int16(240),
	39:  int16(266),
	40:  int16(283),
	41:  int16(295),
	42:  int16(41),
	43:  int16(41),
	44:  int16(41),
	45:  int16(41),
	46:  int16(41),
	47:  int16(41),
	48:  int16(41),
	49:  int16(41),
	50:  int16(123),
	51:  int16(123),
	52:  int16(123),
	53:  int16(123),
	54:  int16(240),
	55:  int16(240),
	56:  int16(240),
	57:  int16(266),
	58:  int16(266),
	59:  int16(305),
	60:  int16(318),
	61:  int16(328),
	62:  int16(336),
	63:  int16(123),
	64:  int16(123),
	65:  int16(123),
	66:  int16(123),
	67:  int16(123),
	68:  int16(123),
	69:  int16(123),
	70:  int16(123),
	71:  int16(240),
	72:  int16(240),
	73:  int16(240),
	74:  int16(240),
	75:  int16(305),
	76:  int16(305),
	77:  int16(305),
	78:  int16(318),
	79:  int16(318),
	80:  int16(343),
	81:  int16(351),
	82:  int16(358),
	83:  int16(364),
	84:  int16(240),
	85:  int16(240),
	86:  int16(240),
	87:  int16(240),
	88:  int16(240),
	89:  int16(240),
	90:  int16(240),
	91:  int16(240),
	92:  int16(305),
	93:  int16(305),
	94:  int16(305),
	95:  int16(305),
	96:  int16(343),
	97:  int16(343),
	98:  int16(343),
	99:  int16(351),
	100: int16(351),
	101: int16(370),
	102: int16(376),
	103: int16(382),
	104: int16(387),
}
var cache_bits50 = [392]uint8{
	0:   uint8(40),
	1:   uint8(7),
	2:   uint8(7),
	3:   uint8(7),
	4:   uint8(7),
	5:   uint8(7),
	6:   uint8(7),
	7:   uint8(7),
	8:   uint8(7),
	9:   uint8(7),
	10:  uint8(7),
	11:  uint8(7),
	12:  uint8(7),
	13:  uint8(7),
	14:  uint8(7),
	15:  uint8(7),
	16:  uint8(7),
	17:  uint8(7),
	18:  uint8(7),
	19:  uint8(7),
	20:  uint8(7),
	21:  uint8(7),
	22:  uint8(7),
	23:  uint8(7),
	24:  uint8(7),
	25:  uint8(7),
	26:  uint8(7),
	27:  uint8(7),
	28:  uint8(7),
	29:  uint8(7),
	30:  uint8(7),
	31:  uint8(7),
	32:  uint8(7),
	33:  uint8(7),
	34:  uint8(7),
	35:  uint8(7),
	36:  uint8(7),
	37:  uint8(7),
	38:  uint8(7),
	39:  uint8(7),
	40:  uint8(7),
	41:  uint8(40),
	42:  uint8(15),
	43:  uint8(23),
	44:  uint8(28),
	45:  uint8(31),
	46:  uint8(34),
	47:  uint8(36),
	48:  uint8(38),
	49:  uint8(39),
	50:  uint8(41),
	51:  uint8(42),
	52:  uint8(43),
	53:  uint8(44),
	54:  uint8(45),
	55:  uint8(46),
	56:  uint8(47),
	57:  uint8(47),
	58:  uint8(49),
	59:  uint8(50),
	60:  uint8(51),
	61:  uint8(52),
	62:  uint8(53),
	63:  uint8(54),
	64:  uint8(55),
	65:  uint8(55),
	66:  uint8(57),
	67:  uint8(58),
	68:  uint8(59),
	69:  uint8(60),
	70:  uint8(61),
	71:  uint8(62),
	72:  uint8(63),
	73:  uint8(63),
	74:  uint8(65),
	75:  uint8(66),
	76:  uint8(67),
	77:  uint8(68),
	78:  uint8(69),
	79:  uint8(70),
	80:  uint8(71),
	81:  uint8(71),
	82:  uint8(40),
	83:  uint8(20),
	84:  uint8(33),
	85:  uint8(41),
	86:  uint8(48),
	87:  uint8(53),
	88:  uint8(57),
	89:  uint8(61),
	90:  uint8(64),
	91:  uint8(66),
	92:  uint8(69),
	93:  uint8(71),
	94:  uint8(73),
	95:  uint8(75),
	96:  uint8(76),
	97:  uint8(78),
	98:  uint8(80),
	99:  uint8(82),
	100: uint8(85),
	101: uint8(87),
	102: uint8(89),
	103: uint8(91),
	104: uint8(92),
	105: uint8(94),
	106: uint8(96),
	107: uint8(98),
	108: uint8(101),
	109: uint8(103),
	110: uint8(105),
	111: uint8(107),
	112: uint8(108),
	113: uint8(110),
	114: uint8(112),
	115: uint8(114),
	116: uint8(117),
	117: uint8(119),
	118: uint8(121),
	119: uint8(123),
	120: uint8(124),
	121: uint8(126),
	122: uint8(128),
	123: uint8(40),
	124: uint8(23),
	125: uint8(39),
	126: uint8(51),
	127: uint8(60),
	128: uint8(67),
	129: uint8(73),
	130: uint8(79),
	131: uint8(83),
	132: uint8(87),
	133: uint8(91),
	134: uint8(94),
	135: uint8(97),
	136: uint8(100),
	137: uint8(102),
	138: uint8(105),
	139: uint8(107),
	140: uint8(111),
	141: uint8(115),
	142: uint8(118),
	143: uint8(121),
	144: uint8(124),
	145: uint8(126),
	146: uint8(129),
	147: uint8(131),
	148: uint8(135),
	149: uint8(139),
	150: uint8(142),
	151: uint8(145),
	152: uint8(148),
	153: uint8(150),
	154: uint8(153),
	155: uint8(155),
	156: uint8(159),
	157: uint8(163),
	158: uint8(166),
	159: uint8(169),
	160: uint8(172),
	161: uint8(174),
	162: uint8(177),
	163: uint8(179),
	164: uint8(35),
	165: uint8(28),
	166: uint8(49),
	167: uint8(65),
	168: uint8(78),
	169: uint8(89),
	170: uint8(99),
	171: uint8(107),
	172: uint8(114),
	173: uint8(120),
	174: uint8(126),
	175: uint8(132),
	176: uint8(136),
	177: uint8(141),
	178: uint8(145),
	179: uint8(149),
	180: uint8(153),
	181: uint8(159),
	182: uint8(165),
	183: uint8(171),
	184: uint8(176),
	185: uint8(180),
	186: uint8(185),
	187: uint8(189),
	188: uint8(192),
	189: uint8(199),
	190: uint8(205),
	191: uint8(211),
	192: uint8(216),
	193: uint8(220),
	194: uint8(225),
	195: uint8(229),
	196: uint8(232),
	197: uint8(239),
	198: uint8(245),
	199: uint8(251),
	200: uint8(21),
	201: uint8(33),
	202: uint8(58),
	203: uint8(79),
	204: uint8(97),
	205: uint8(112),
	206: uint8(125),
	207: uint8(137),
	208: uint8(148),
	209: uint8(157),
	210: uint8(166),
	211: uint8(174),
	212: uint8(182),
	213: uint8(189),
	214: uint8(195),
	215: uint8(201),
	216: uint8(207),
	217: uint8(217),
	218: uint8(227),
	219: uint8(235),
	220: uint8(243),
	221: uint8(251),
	222: uint8(17),
	223: uint8(35),
	224: uint8(63),
	225: uint8(86),
	226: uint8(106),
	227: uint8(123),
	228: uint8(139),
	229: uint8(152),
	230: uint8(165),
	231: uint8(177),
	232: uint8(187),
	233: uint8(197),
	234: uint8(206),
	235: uint8(214),
	236: uint8(222),
	237: uint8(230),
	238: uint8(237),
	239: uint8(250),
	240: uint8(25),
	241: uint8(31),
	242: uint8(55),
	243: uint8(75),
	244: uint8(91),
	245: uint8(105),
	246: uint8(117),
	247: uint8(128),
	248: uint8(138),
	249: uint8(146),
	250: uint8(154),
	251: uint8(161),
	252: uint8(168),
	253: uint8(174),
	254: uint8(180),
	255: uint8(185),
	256: uint8(190),
	257: uint8(200),
	258: uint8(208),
	259: uint8(215),
	260: uint8(222),
	261: uint8(229),
	262: uint8(235),
	263: uint8(240),
	264: uint8(245),
	265: uint8(255),
	266: uint8(16),
	267: uint8(36),
	268: uint8(65),
	269: uint8(89),
	270: uint8(110),
	271: uint8(128),
	272: uint8(144),
	273: uint8(159),
	274: uint8(173),
	275: uint8(185),
	276: uint8(196),
	277: uint8(207),
	278: uint8(217),
	279: uint8(226),
	280: uint8(234),
	281: uint8(242),
	282: uint8(250),
	283: uint8(11),
	284: uint8(41),
	285: uint8(74),
	286: uint8(103),
	287: uint8(128),
	288: uint8(151),
	289: uint8(172),
	290: uint8(191),
	291: uint8(209),
	292: uint8(225),
	293: uint8(241),
	294: uint8(255),
	295: uint8(9),
	296: uint8(43),
	297: uint8(79),
	298: uint8(110),
	299: uint8(138),
	300: uint8(163),
	301: uint8(186),
	302: uint8(207),
	303: uint8(227),
	304: uint8(246),
	305: uint8(12),
	306: uint8(39),
	307: uint8(71),
	308: uint8(99),
	309: uint8(123),
	310: uint8(144),
	311: uint8(164),
	312: uint8(182),
	313: uint8(198),
	314: uint8(214),
	315: uint8(228),
	316: uint8(241),
	317: uint8(253),
	318: uint8(9),
	319: uint8(44),
	320: uint8(81),
	321: uint8(113),
	322: uint8(142),
	323: uint8(168),
	324: uint8(192),
	325: uint8(214),
	326: uint8(235),
	327: uint8(255),
	328: uint8(7),
	329: uint8(49),
	330: uint8(90),
	331: uint8(127),
	332: uint8(160),
	333: uint8(191),
	334: uint8(220),
	335: uint8(247),
	336: uint8(6),
	337: uint8(51),
	338: uint8(95),
	339: uint8(134),
	340: uint8(170),
	341: uint8(203),
	342: uint8(234),
	343: uint8(7),
	344: uint8(47),
	345: uint8(87),
	346: uint8(123),
	347: uint8(155),
	348: uint8(184),
	349: uint8(212),
	350: uint8(237),
	351: uint8(6),
	352: uint8(52),
	353: uint8(97),
	354: uint8(137),
	355: uint8(174),
	356: uint8(208),
	357: uint8(240),
	358: uint8(5),
	359: uint8(57),
	360: uint8(106),
	361: uint8(151),
	362: uint8(192),
	363: uint8(231),
	364: uint8(5),
	365: uint8(59),
	366: uint8(111),
	367: uint8(158),
	368: uint8(202),
	369: uint8(243),
	370: uint8(5),
	371: uint8(55),
	372: uint8(103),
	373: uint8(147),
	374: uint8(187),
	375: uint8(224),
	376: uint8(5),
	377: uint8(60),
	378: uint8(113),
	379: uint8(161),
	380: uint8(206),
	381: uint8(248),
	382: uint8(4),
	383: uint8(65),
	384: uint8(122),
	385: uint8(175),
	386: uint8(224),
	387: uint8(4),
	388: uint8(67),
	389: uint8(127),
	390: uint8(182),
	391: uint8(234),
}
var cache_caps50 = [168]uint8{
	0:   uint8(224),
	1:   uint8(224),
	2:   uint8(224),
	3:   uint8(224),
	4:   uint8(224),
	5:   uint8(224),
	6:   uint8(224),
	7:   uint8(224),
	8:   uint8(160),
	9:   uint8(160),
	10:  uint8(160),
	11:  uint8(160),
	12:  uint8(185),
	13:  uint8(185),
	14:  uint8(185),
	15:  uint8(178),
	16:  uint8(178),
	17:  uint8(168),
	18:  uint8(134),
	19:  uint8(61),
	20:  uint8(37),
	21:  uint8(224),
	22:  uint8(224),
	23:  uint8(224),
	24:  uint8(224),
	25:  uint8(224),
	26:  uint8(224),
	27:  uint8(224),
	28:  uint8(224),
	29:  uint8(240),
	30:  uint8(240),
	31:  uint8(240),
	32:  uint8(240),
	33:  uint8(207),
	34:  uint8(207),
	35:  uint8(207),
	36:  uint8(198),
	37:  uint8(198),
	38:  uint8(183),
	39:  uint8(144),
	40:  uint8(66),
	41:  uint8(40),
	42:  uint8(160),
	43:  uint8(160),
	44:  uint8(160),
	45:  uint8(160),
	46:  uint8(160),
	47:  uint8(160),
	48:  uint8(160),
	49:  uint8(160),
	50:  uint8(185),
	51:  uint8(185),
	52:  uint8(185),
	53:  uint8(185),
	54:  uint8(193),
	55:  uint8(193),
	56:  uint8(193),
	57:  uint8(183),
	58:  uint8(183),
	59:  uint8(172),
	60:  uint8(138),
	61:  uint8(64),
	62:  uint8(38),
	63:  uint8(240),
	64:  uint8(240),
	65:  uint8(240),
	66:  uint8(240),
	67:  uint8(240),
	68:  uint8(240),
	69:  uint8(240),
	70:  uint8(240),
	71:  uint8(207),
	72:  uint8(207),
	73:  uint8(207),
	74:  uint8(207),
	75:  uint8(204),
	76:  uint8(204),
	77:  uint8(204),
	78:  uint8(193),
	79:  uint8(193),
	80:  uint8(180),
	81:  uint8(143),
	82:  uint8(66),
	83:  uint8(40),
	84:  uint8(185),
	85:  uint8(185),
	86:  uint8(185),
	87:  uint8(185),
	88:  uint8(185),
	89:  uint8(185),
	90:  uint8(185),
	91:  uint8(185),
	92:  uint8(193),
	93:  uint8(193),
	94:  uint8(193),
	95:  uint8(193),
	96:  uint8(193),
	97:  uint8(193),
	98:  uint8(193),
	99:  uint8(183),
	100: uint8(183),
	101: uint8(172),
	102: uint8(138),
	103: uint8(65),
	104: uint8(39),
	105: uint8(207),
	106: uint8(207),
	107: uint8(207),
	108: uint8(207),
	109: uint8(207),
	110: uint8(207),
	111: uint8(207),
	112: uint8(207),
	113: uint8(204),
	114: uint8(204),
	115: uint8(204),
	116: uint8(204),
	117: uint8(201),
	118: uint8(201),
	119: uint8(201),
	120: uint8(188),
	121: uint8(188),
	122: uint8(176),
	123: uint8(141),
	124: uint8(66),
	125: uint8(40),
	126: uint8(193),
	127: uint8(193),
	128: uint8(193),
	129: uint8(193),
	130: uint8(193),
	131: uint8(193),
	132: uint8(193),
	133: uint8(193),
	134: uint8(193),
	135: uint8(193),
	136: uint8(193),
	137: uint8(193),
	138: uint8(194),
	139: uint8(194),
	140: uint8(194),
	141: uint8(184),
	142: uint8(184),
	143: uint8(173),
	144: uint8(139),
	145: uint8(65),
	146: uint8(39),
	147: uint8(204),
	148: uint8(204),
	149: uint8(204),
	150: uint8(204),
	151: uint8(204),
	152: uint8(204),
	153: uint8(204),
	154: uint8(204),
	155: uint8(201),
	156: uint8(201),
	157: uint8(201),
	158: uint8(201),
	159: uint8(198),
	160: uint8(198),
	161: uint8(198),
	162: uint8(187),
	163: uint8(187),
	164: uint8(175),
	165: uint8(140),
	166: uint8(66),
	167: uint8(40),
}
var fft_twiddles48000_960 = [480]OpusT_kiss_twiddle_cpx{
	0: {
		Fr: libc.Float32FromFloat32(1),
		Fi: -libc.Float32FromFloat32(0),
	},
	1: {
		Fr: libc.Float32FromFloat32(0.99991433),
		Fi: -libc.Float32FromFloat32(0.013089596),
	},
	2: {
		Fr: libc.Float32FromFloat32(0.99965732),
		Fi: -libc.Float32FromFloat32(0.026176948),
	},
	3: {
		Fr: libc.Float32FromFloat32(0.99922904),
		Fi: -libc.Float32FromFloat32(0.039259816),
	},
	4: {
		Fr: libc.Float32FromFloat32(0.99862953),
		Fi: -libc.Float32FromFloat32(0.052335956),
	},
	5: {
		Fr: libc.Float32FromFloat32(0.99785892),
		Fi: -libc.Float32FromFloat32(0.065403129),
	},
	6: {
		Fr: libc.Float32FromFloat32(0.99691733),
		Fi: -libc.Float32FromFloat32(0.078459096),
	},
	7: {
		Fr: libc.Float32FromFloat32(0.99580493),
		Fi: -libc.Float32FromFloat32(0.091501619),
	},
	8: {
		Fr: libc.Float32FromFloat32(0.9945219),
		Fi: -libc.Float32FromFloat32(0.10452846),
	},
	9: {
		Fr: libc.Float32FromFloat32(0.99306846),
		Fi: -libc.Float32FromFloat32(0.1175374),
	},
	10: {
		Fr: libc.Float32FromFloat32(0.99144486),
		Fi: -libc.Float32FromFloat32(0.13052619),
	},
	11: {
		Fr: libc.Float32FromFloat32(0.98965139),
		Fi: -libc.Float32FromFloat32(0.14349262),
	},
	12: {
		Fr: libc.Float32FromFloat32(0.98768834),
		Fi: -libc.Float32FromFloat32(0.15643447),
	},
	13: {
		Fr: libc.Float32FromFloat32(0.98555606),
		Fi: -libc.Float32FromFloat32(0.1693495),
	},
	14: {
		Fr: libc.Float32FromFloat32(0.98325491),
		Fi: -libc.Float32FromFloat32(0.18223553),
	},
	15: {
		Fr: libc.Float32FromFloat32(0.98078528),
		Fi: -libc.Float32FromFloat32(0.19509032),
	},
	16: {
		Fr: libc.Float32FromFloat32(0.9781476),
		Fi: -libc.Float32FromFloat32(0.20791169),
	},
	17: {
		Fr: libc.Float32FromFloat32(0.97534232),
		Fi: -libc.Float32FromFloat32(0.22069744),
	},
	18: {
		Fr: libc.Float32FromFloat32(0.97236992),
		Fi: -libc.Float32FromFloat32(0.23344536),
	},
	19: {
		Fr: libc.Float32FromFloat32(0.96923091),
		Fi: -libc.Float32FromFloat32(0.24615329),
	},
	20: {
		Fr: libc.Float32FromFloat32(0.96592583),
		Fi: -libc.Float32FromFloat32(0.25881905),
	},
	21: {
		Fr: libc.Float32FromFloat32(0.96245524),
		Fi: -libc.Float32FromFloat32(0.27144045),
	},
	22: {
		Fr: libc.Float32FromFloat32(0.95881973),
		Fi: -libc.Float32FromFloat32(0.28401534),
	},
	23: {
		Fr: libc.Float32FromFloat32(0.95501994),
		Fi: -libc.Float32FromFloat32(0.29654157),
	},
	24: {
		Fr: libc.Float32FromFloat32(0.95105652),
		Fi: -libc.Float32FromFloat32(0.30901699),
	},
	25: {
		Fr: libc.Float32FromFloat32(0.94693013),
		Fi: -libc.Float32FromFloat32(0.32143947),
	},
	26: {
		Fr: libc.Float32FromFloat32(0.94264149),
		Fi: -libc.Float32FromFloat32(0.33380686),
	},
	27: {
		Fr: libc.Float32FromFloat32(0.93819134),
		Fi: -libc.Float32FromFloat32(0.34611706),
	},
	28: {
		Fr: libc.Float32FromFloat32(0.93358043),
		Fi: -libc.Float32FromFloat32(0.35836795),
	},
	29: {
		Fr: libc.Float32FromFloat32(0.92880955),
		Fi: -libc.Float32FromFloat32(0.37055744),
	},
	30: {
		Fr: libc.Float32FromFloat32(0.92387953),
		Fi: -libc.Float32FromFloat32(0.38268343),
	},
	31: {
		Fr: libc.Float32FromFloat32(0.91879121),
		Fi: -libc.Float32FromFloat32(0.39474386),
	},
	32: {
		Fr: libc.Float32FromFloat32(0.91354546),
		Fi: -libc.Float32FromFloat32(0.40673664),
	},
	33: {
		Fr: libc.Float32FromFloat32(0.90814317),
		Fi: -libc.Float32FromFloat32(0.41865974),
	},
	34: {
		Fr: libc.Float32FromFloat32(0.90258528),
		Fi: -libc.Float32FromFloat32(0.4305111),
	},
	35: {
		Fr: libc.Float32FromFloat32(0.89687274),
		Fi: -libc.Float32FromFloat32(0.44228869),
	},
	36: {
		Fr: libc.Float32FromFloat32(0.89100652),
		Fi: -libc.Float32FromFloat32(0.4539905),
	},
	37: {
		Fr: libc.Float32FromFloat32(0.88498764),
		Fi: -libc.Float32FromFloat32(0.46561452),
	},
	38: {
		Fr: libc.Float32FromFloat32(0.87881711),
		Fi: -libc.Float32FromFloat32(0.47715876),
	},
	39: {
		Fr: libc.Float32FromFloat32(0.87249601),
		Fi: -libc.Float32FromFloat32(0.48862124),
	},
	40: {
		Fr: libc.Float32FromFloat32(0.8660254),
		Fi: -libc.Float32FromFloat32(0.5),
	},
	41: {
		Fr: libc.Float32FromFloat32(0.85940641),
		Fi: -libc.Float32FromFloat32(0.51129309),
	},
	42: {
		Fr: libc.Float32FromFloat32(0.85264016),
		Fi: -libc.Float32FromFloat32(0.52249856),
	},
	43: {
		Fr: libc.Float32FromFloat32(0.84572782),
		Fi: -libc.Float32FromFloat32(0.53361452),
	},
	44: {
		Fr: libc.Float32FromFloat32(0.83867057),
		Fi: -libc.Float32FromFloat32(0.54463904),
	},
	45: {
		Fr: libc.Float32FromFloat32(0.83146961),
		Fi: -libc.Float32FromFloat32(0.55557023),
	},
	46: {
		Fr: libc.Float32FromFloat32(0.82412619),
		Fi: -libc.Float32FromFloat32(0.56640624),
	},
	47: {
		Fr: libc.Float32FromFloat32(0.81664156),
		Fi: -libc.Float32FromFloat32(0.57714519),
	},
	48: {
		Fr: libc.Float32FromFloat32(0.80901699),
		Fi: -libc.Float32FromFloat32(0.58778525),
	},
	49: {
		Fr: libc.Float32FromFloat32(0.80125381),
		Fi: -libc.Float32FromFloat32(0.5983246),
	},
	50: {
		Fr: libc.Float32FromFloat32(0.79335334),
		Fi: -libc.Float32FromFloat32(0.60876143),
	},
	51: {
		Fr: libc.Float32FromFloat32(0.78531693),
		Fi: -libc.Float32FromFloat32(0.61909395),
	},
	52: {
		Fr: libc.Float32FromFloat32(0.77714596),
		Fi: -libc.Float32FromFloat32(0.62932039),
	},
	53: {
		Fr: libc.Float32FromFloat32(0.76884183),
		Fi: -libc.Float32FromFloat32(0.639439),
	},
	54: {
		Fr: libc.Float32FromFloat32(0.76040597),
		Fi: -libc.Float32FromFloat32(0.64944805),
	},
	55: {
		Fr: libc.Float32FromFloat32(0.75183981),
		Fi: -libc.Float32FromFloat32(0.65934582),
	},
	56: {
		Fr: libc.Float32FromFloat32(0.74314483),
		Fi: -libc.Float32FromFloat32(0.66913061),
	},
	57: {
		Fr: libc.Float32FromFloat32(0.73432251),
		Fi: -libc.Float32FromFloat32(0.67880075),
	},
	58: {
		Fr: libc.Float32FromFloat32(0.72537437),
		Fi: -libc.Float32FromFloat32(0.68835458),
	},
	59: {
		Fr: libc.Float32FromFloat32(0.71630194),
		Fi: -libc.Float32FromFloat32(0.69779046),
	},
	60: {
		Fr: libc.Float32FromFloat32(0.70710678),
		Fi: -libc.Float32FromFloat32(0.70710678),
	},
	61: {
		Fr: libc.Float32FromFloat32(0.69779046),
		Fi: -libc.Float32FromFloat32(0.71630194),
	},
	62: {
		Fr: libc.Float32FromFloat32(0.68835458),
		Fi: -libc.Float32FromFloat32(0.72537437),
	},
	63: {
		Fr: libc.Float32FromFloat32(0.67880075),
		Fi: -libc.Float32FromFloat32(0.73432251),
	},
	64: {
		Fr: libc.Float32FromFloat32(0.66913061),
		Fi: -libc.Float32FromFloat32(0.74314483),
	},
	65: {
		Fr: libc.Float32FromFloat32(0.65934582),
		Fi: -libc.Float32FromFloat32(0.75183981),
	},
	66: {
		Fr: libc.Float32FromFloat32(0.64944805),
		Fi: -libc.Float32FromFloat32(0.76040597),
	},
	67: {
		Fr: libc.Float32FromFloat32(0.639439),
		Fi: -libc.Float32FromFloat32(0.76884183),
	},
	68: {
		Fr: libc.Float32FromFloat32(0.62932039),
		Fi: -libc.Float32FromFloat32(0.77714596),
	},
	69: {
		Fr: libc.Float32FromFloat32(0.61909395),
		Fi: -libc.Float32FromFloat32(0.78531693),
	},
	70: {
		Fr: libc.Float32FromFloat32(0.60876143),
		Fi: -libc.Float32FromFloat32(0.79335334),
	},
	71: {
		Fr: libc.Float32FromFloat32(0.5983246),
		Fi: -libc.Float32FromFloat32(0.80125381),
	},
	72: {
		Fr: libc.Float32FromFloat32(0.58778525),
		Fi: -libc.Float32FromFloat32(0.80901699),
	},
	73: {
		Fr: libc.Float32FromFloat32(0.57714519),
		Fi: -libc.Float32FromFloat32(0.81664156),
	},
	74: {
		Fr: libc.Float32FromFloat32(0.56640624),
		Fi: -libc.Float32FromFloat32(0.82412619),
	},
	75: {
		Fr: libc.Float32FromFloat32(0.55557023),
		Fi: -libc.Float32FromFloat32(0.83146961),
	},
	76: {
		Fr: libc.Float32FromFloat32(0.54463904),
		Fi: -libc.Float32FromFloat32(0.83867057),
	},
	77: {
		Fr: libc.Float32FromFloat32(0.53361452),
		Fi: -libc.Float32FromFloat32(0.84572782),
	},
	78: {
		Fr: libc.Float32FromFloat32(0.52249856),
		Fi: -libc.Float32FromFloat32(0.85264016),
	},
	79: {
		Fr: libc.Float32FromFloat32(0.51129309),
		Fi: -libc.Float32FromFloat32(0.85940641),
	},
	80: {
		Fr: libc.Float32FromFloat32(0.5),
		Fi: -libc.Float32FromFloat32(0.8660254),
	},
	81: {
		Fr: libc.Float32FromFloat32(0.48862124),
		Fi: -libc.Float32FromFloat32(0.87249601),
	},
	82: {
		Fr: libc.Float32FromFloat32(0.47715876),
		Fi: -libc.Float32FromFloat32(0.87881711),
	},
	83: {
		Fr: libc.Float32FromFloat32(0.46561452),
		Fi: -libc.Float32FromFloat32(0.88498764),
	},
	84: {
		Fr: libc.Float32FromFloat32(0.4539905),
		Fi: -libc.Float32FromFloat32(0.89100652),
	},
	85: {
		Fr: libc.Float32FromFloat32(0.44228869),
		Fi: -libc.Float32FromFloat32(0.89687274),
	},
	86: {
		Fr: libc.Float32FromFloat32(0.4305111),
		Fi: -libc.Float32FromFloat32(0.90258528),
	},
	87: {
		Fr: libc.Float32FromFloat32(0.41865974),
		Fi: -libc.Float32FromFloat32(0.90814317),
	},
	88: {
		Fr: libc.Float32FromFloat32(0.40673664),
		Fi: -libc.Float32FromFloat32(0.91354546),
	},
	89: {
		Fr: libc.Float32FromFloat32(0.39474386),
		Fi: -libc.Float32FromFloat32(0.91879121),
	},
	90: {
		Fr: libc.Float32FromFloat32(0.38268343),
		Fi: -libc.Float32FromFloat32(0.92387953),
	},
	91: {
		Fr: libc.Float32FromFloat32(0.37055744),
		Fi: -libc.Float32FromFloat32(0.92880955),
	},
	92: {
		Fr: libc.Float32FromFloat32(0.35836795),
		Fi: -libc.Float32FromFloat32(0.93358043),
	},
	93: {
		Fr: libc.Float32FromFloat32(0.34611706),
		Fi: -libc.Float32FromFloat32(0.93819134),
	},
	94: {
		Fr: libc.Float32FromFloat32(0.33380686),
		Fi: -libc.Float32FromFloat32(0.94264149),
	},
	95: {
		Fr: libc.Float32FromFloat32(0.32143947),
		Fi: -libc.Float32FromFloat32(0.94693013),
	},
	96: {
		Fr: libc.Float32FromFloat32(0.30901699),
		Fi: -libc.Float32FromFloat32(0.95105652),
	},
	97: {
		Fr: libc.Float32FromFloat32(0.29654157),
		Fi: -libc.Float32FromFloat32(0.95501994),
	},
	98: {
		Fr: libc.Float32FromFloat32(0.28401534),
		Fi: -libc.Float32FromFloat32(0.95881973),
	},
	99: {
		Fr: libc.Float32FromFloat32(0.27144045),
		Fi: -libc.Float32FromFloat32(0.96245524),
	},
	100: {
		Fr: libc.Float32FromFloat32(0.25881905),
		Fi: -libc.Float32FromFloat32(0.96592583),
	},
	101: {
		Fr: libc.Float32FromFloat32(0.24615329),
		Fi: -libc.Float32FromFloat32(0.96923091),
	},
	102: {
		Fr: libc.Float32FromFloat32(0.23344536),
		Fi: -libc.Float32FromFloat32(0.97236992),
	},
	103: {
		Fr: libc.Float32FromFloat32(0.22069744),
		Fi: -libc.Float32FromFloat32(0.97534232),
	},
	104: {
		Fr: libc.Float32FromFloat32(0.20791169),
		Fi: -libc.Float32FromFloat32(0.9781476),
	},
	105: {
		Fr: libc.Float32FromFloat32(0.19509032),
		Fi: -libc.Float32FromFloat32(0.98078528),
	},
	106: {
		Fr: libc.Float32FromFloat32(0.18223553),
		Fi: -libc.Float32FromFloat32(0.98325491),
	},
	107: {
		Fr: libc.Float32FromFloat32(0.1693495),
		Fi: -libc.Float32FromFloat32(0.98555606),
	},
	108: {
		Fr: libc.Float32FromFloat32(0.15643447),
		Fi: -libc.Float32FromFloat32(0.98768834),
	},
	109: {
		Fr: libc.Float32FromFloat32(0.14349262),
		Fi: -libc.Float32FromFloat32(0.98965139),
	},
	110: {
		Fr: libc.Float32FromFloat32(0.13052619),
		Fi: -libc.Float32FromFloat32(0.99144486),
	},
	111: {
		Fr: libc.Float32FromFloat32(0.1175374),
		Fi: -libc.Float32FromFloat32(0.99306846),
	},
	112: {
		Fr: libc.Float32FromFloat32(0.10452846),
		Fi: -libc.Float32FromFloat32(0.9945219),
	},
	113: {
		Fr: libc.Float32FromFloat32(0.091501619),
		Fi: -libc.Float32FromFloat32(0.99580493),
	},
	114: {
		Fr: libc.Float32FromFloat32(0.078459096),
		Fi: -libc.Float32FromFloat32(0.99691733),
	},
	115: {
		Fr: libc.Float32FromFloat32(0.065403129),
		Fi: -libc.Float32FromFloat32(0.99785892),
	},
	116: {
		Fr: libc.Float32FromFloat32(0.052335956),
		Fi: -libc.Float32FromFloat32(0.99862953),
	},
	117: {
		Fr: libc.Float32FromFloat32(0.039259816),
		Fi: -libc.Float32FromFloat32(0.99922904),
	},
	118: {
		Fr: libc.Float32FromFloat32(0.026176948),
		Fi: -libc.Float32FromFloat32(0.99965732),
	},
	119: {
		Fr: libc.Float32FromFloat32(0.013089596),
		Fi: -libc.Float32FromFloat32(0.99991433),
	},
	120: {
		Fr: libc.Float32FromFloat32(6.123234e-17),
		Fi: -libc.Float32FromFloat32(1),
	},
	121: {
		Fr: -libc.Float32FromFloat32(0.013089596),
		Fi: -libc.Float32FromFloat32(0.99991433),
	},
	122: {
		Fr: -libc.Float32FromFloat32(0.026176948),
		Fi: -libc.Float32FromFloat32(0.99965732),
	},
	123: {
		Fr: -libc.Float32FromFloat32(0.039259816),
		Fi: -libc.Float32FromFloat32(0.99922904),
	},
	124: {
		Fr: -libc.Float32FromFloat32(0.052335956),
		Fi: -libc.Float32FromFloat32(0.99862953),
	},
	125: {
		Fr: -libc.Float32FromFloat32(0.065403129),
		Fi: -libc.Float32FromFloat32(0.99785892),
	},
	126: {
		Fr: -libc.Float32FromFloat32(0.078459096),
		Fi: -libc.Float32FromFloat32(0.99691733),
	},
	127: {
		Fr: -libc.Float32FromFloat32(0.091501619),
		Fi: -libc.Float32FromFloat32(0.99580493),
	},
	128: {
		Fr: -libc.Float32FromFloat32(0.10452846),
		Fi: -libc.Float32FromFloat32(0.9945219),
	},
	129: {
		Fr: -libc.Float32FromFloat32(0.1175374),
		Fi: -libc.Float32FromFloat32(0.99306846),
	},
	130: {
		Fr: -libc.Float32FromFloat32(0.13052619),
		Fi: -libc.Float32FromFloat32(0.99144486),
	},
	131: {
		Fr: -libc.Float32FromFloat32(0.14349262),
		Fi: -libc.Float32FromFloat32(0.98965139),
	},
	132: {
		Fr: -libc.Float32FromFloat32(0.15643447),
		Fi: -libc.Float32FromFloat32(0.98768834),
	},
	133: {
		Fr: -libc.Float32FromFloat32(0.1693495),
		Fi: -libc.Float32FromFloat32(0.98555606),
	},
	134: {
		Fr: -libc.Float32FromFloat32(0.18223553),
		Fi: -libc.Float32FromFloat32(0.98325491),
	},
	135: {
		Fr: -libc.Float32FromFloat32(0.19509032),
		Fi: -libc.Float32FromFloat32(0.98078528),
	},
	136: {
		Fr: -libc.Float32FromFloat32(0.20791169),
		Fi: -libc.Float32FromFloat32(0.9781476),
	},
	137: {
		Fr: -libc.Float32FromFloat32(0.22069744),
		Fi: -libc.Float32FromFloat32(0.97534232),
	},
	138: {
		Fr: -libc.Float32FromFloat32(0.23344536),
		Fi: -libc.Float32FromFloat32(0.97236992),
	},
	139: {
		Fr: -libc.Float32FromFloat32(0.24615329),
		Fi: -libc.Float32FromFloat32(0.96923091),
	},
	140: {
		Fr: -libc.Float32FromFloat32(0.25881905),
		Fi: -libc.Float32FromFloat32(0.96592583),
	},
	141: {
		Fr: -libc.Float32FromFloat32(0.27144045),
		Fi: -libc.Float32FromFloat32(0.96245524),
	},
	142: {
		Fr: -libc.Float32FromFloat32(0.28401534),
		Fi: -libc.Float32FromFloat32(0.95881973),
	},
	143: {
		Fr: -libc.Float32FromFloat32(0.29654157),
		Fi: -libc.Float32FromFloat32(0.95501994),
	},
	144: {
		Fr: -libc.Float32FromFloat32(0.30901699),
		Fi: -libc.Float32FromFloat32(0.95105652),
	},
	145: {
		Fr: -libc.Float32FromFloat32(0.32143947),
		Fi: -libc.Float32FromFloat32(0.94693013),
	},
	146: {
		Fr: -libc.Float32FromFloat32(0.33380686),
		Fi: -libc.Float32FromFloat32(0.94264149),
	},
	147: {
		Fr: -libc.Float32FromFloat32(0.34611706),
		Fi: -libc.Float32FromFloat32(0.93819134),
	},
	148: {
		Fr: -libc.Float32FromFloat32(0.35836795),
		Fi: -libc.Float32FromFloat32(0.93358043),
	},
	149: {
		Fr: -libc.Float32FromFloat32(0.37055744),
		Fi: -libc.Float32FromFloat32(0.92880955),
	},
	150: {
		Fr: -libc.Float32FromFloat32(0.38268343),
		Fi: -libc.Float32FromFloat32(0.92387953),
	},
	151: {
		Fr: -libc.Float32FromFloat32(0.39474386),
		Fi: -libc.Float32FromFloat32(0.91879121),
	},
	152: {
		Fr: -libc.Float32FromFloat32(0.40673664),
		Fi: -libc.Float32FromFloat32(0.91354546),
	},
	153: {
		Fr: -libc.Float32FromFloat32(0.41865974),
		Fi: -libc.Float32FromFloat32(0.90814317),
	},
	154: {
		Fr: -libc.Float32FromFloat32(0.4305111),
		Fi: -libc.Float32FromFloat32(0.90258528),
	},
	155: {
		Fr: -libc.Float32FromFloat32(0.44228869),
		Fi: -libc.Float32FromFloat32(0.89687274),
	},
	156: {
		Fr: -libc.Float32FromFloat32(0.4539905),
		Fi: -libc.Float32FromFloat32(0.89100652),
	},
	157: {
		Fr: -libc.Float32FromFloat32(0.46561452),
		Fi: -libc.Float32FromFloat32(0.88498764),
	},
	158: {
		Fr: -libc.Float32FromFloat32(0.47715876),
		Fi: -libc.Float32FromFloat32(0.87881711),
	},
	159: {
		Fr: -libc.Float32FromFloat32(0.48862124),
		Fi: -libc.Float32FromFloat32(0.87249601),
	},
	160: {
		Fr: -libc.Float32FromFloat32(0.5),
		Fi: -libc.Float32FromFloat32(0.8660254),
	},
	161: {
		Fr: -libc.Float32FromFloat32(0.51129309),
		Fi: -libc.Float32FromFloat32(0.85940641),
	},
	162: {
		Fr: -libc.Float32FromFloat32(0.52249856),
		Fi: -libc.Float32FromFloat32(0.85264016),
	},
	163: {
		Fr: -libc.Float32FromFloat32(0.53361452),
		Fi: -libc.Float32FromFloat32(0.84572782),
	},
	164: {
		Fr: -libc.Float32FromFloat32(0.54463904),
		Fi: -libc.Float32FromFloat32(0.83867057),
	},
	165: {
		Fr: -libc.Float32FromFloat32(0.55557023),
		Fi: -libc.Float32FromFloat32(0.83146961),
	},
	166: {
		Fr: -libc.Float32FromFloat32(0.56640624),
		Fi: -libc.Float32FromFloat32(0.82412619),
	},
	167: {
		Fr: -libc.Float32FromFloat32(0.57714519),
		Fi: -libc.Float32FromFloat32(0.81664156),
	},
	168: {
		Fr: -libc.Float32FromFloat32(0.58778525),
		Fi: -libc.Float32FromFloat32(0.80901699),
	},
	169: {
		Fr: -libc.Float32FromFloat32(0.5983246),
		Fi: -libc.Float32FromFloat32(0.80125381),
	},
	170: {
		Fr: -libc.Float32FromFloat32(0.60876143),
		Fi: -libc.Float32FromFloat32(0.79335334),
	},
	171: {
		Fr: -libc.Float32FromFloat32(0.61909395),
		Fi: -libc.Float32FromFloat32(0.78531693),
	},
	172: {
		Fr: -libc.Float32FromFloat32(0.62932039),
		Fi: -libc.Float32FromFloat32(0.77714596),
	},
	173: {
		Fr: -libc.Float32FromFloat32(0.639439),
		Fi: -libc.Float32FromFloat32(0.76884183),
	},
	174: {
		Fr: -libc.Float32FromFloat32(0.64944805),
		Fi: -libc.Float32FromFloat32(0.76040597),
	},
	175: {
		Fr: -libc.Float32FromFloat32(0.65934582),
		Fi: -libc.Float32FromFloat32(0.75183981),
	},
	176: {
		Fr: -libc.Float32FromFloat32(0.66913061),
		Fi: -libc.Float32FromFloat32(0.74314483),
	},
	177: {
		Fr: -libc.Float32FromFloat32(0.67880075),
		Fi: -libc.Float32FromFloat32(0.73432251),
	},
	178: {
		Fr: -libc.Float32FromFloat32(0.68835458),
		Fi: -libc.Float32FromFloat32(0.72537437),
	},
	179: {
		Fr: -libc.Float32FromFloat32(0.69779046),
		Fi: -libc.Float32FromFloat32(0.71630194),
	},
	180: {
		Fr: -libc.Float32FromFloat32(0.70710678),
		Fi: -libc.Float32FromFloat32(0.70710678),
	},
	181: {
		Fr: -libc.Float32FromFloat32(0.71630194),
		Fi: -libc.Float32FromFloat32(0.69779046),
	},
	182: {
		Fr: -libc.Float32FromFloat32(0.72537437),
		Fi: -libc.Float32FromFloat32(0.68835458),
	},
	183: {
		Fr: -libc.Float32FromFloat32(0.73432251),
		Fi: -libc.Float32FromFloat32(0.67880075),
	},
	184: {
		Fr: -libc.Float32FromFloat32(0.74314483),
		Fi: -libc.Float32FromFloat32(0.66913061),
	},
	185: {
		Fr: -libc.Float32FromFloat32(0.75183981),
		Fi: -libc.Float32FromFloat32(0.65934582),
	},
	186: {
		Fr: -libc.Float32FromFloat32(0.76040597),
		Fi: -libc.Float32FromFloat32(0.64944805),
	},
	187: {
		Fr: -libc.Float32FromFloat32(0.76884183),
		Fi: -libc.Float32FromFloat32(0.639439),
	},
	188: {
		Fr: -libc.Float32FromFloat32(0.77714596),
		Fi: -libc.Float32FromFloat32(0.62932039),
	},
	189: {
		Fr: -libc.Float32FromFloat32(0.78531693),
		Fi: -libc.Float32FromFloat32(0.61909395),
	},
	190: {
		Fr: -libc.Float32FromFloat32(0.79335334),
		Fi: -libc.Float32FromFloat32(0.60876143),
	},
	191: {
		Fr: -libc.Float32FromFloat32(0.80125381),
		Fi: -libc.Float32FromFloat32(0.5983246),
	},
	192: {
		Fr: -libc.Float32FromFloat32(0.80901699),
		Fi: -libc.Float32FromFloat32(0.58778525),
	},
	193: {
		Fr: -libc.Float32FromFloat32(0.81664156),
		Fi: -libc.Float32FromFloat32(0.57714519),
	},
	194: {
		Fr: -libc.Float32FromFloat32(0.82412619),
		Fi: -libc.Float32FromFloat32(0.56640624),
	},
	195: {
		Fr: -libc.Float32FromFloat32(0.83146961),
		Fi: -libc.Float32FromFloat32(0.55557023),
	},
	196: {
		Fr: -libc.Float32FromFloat32(0.83867057),
		Fi: -libc.Float32FromFloat32(0.54463904),
	},
	197: {
		Fr: -libc.Float32FromFloat32(0.84572782),
		Fi: -libc.Float32FromFloat32(0.53361452),
	},
	198: {
		Fr: -libc.Float32FromFloat32(0.85264016),
		Fi: -libc.Float32FromFloat32(0.52249856),
	},
	199: {
		Fr: -libc.Float32FromFloat32(0.85940641),
		Fi: -libc.Float32FromFloat32(0.51129309),
	},
	200: {
		Fr: -libc.Float32FromFloat32(0.8660254),
		Fi: -libc.Float32FromFloat32(0.5),
	},
	201: {
		Fr: -libc.Float32FromFloat32(0.87249601),
		Fi: -libc.Float32FromFloat32(0.48862124),
	},
	202: {
		Fr: -libc.Float32FromFloat32(0.87881711),
		Fi: -libc.Float32FromFloat32(0.47715876),
	},
	203: {
		Fr: -libc.Float32FromFloat32(0.88498764),
		Fi: -libc.Float32FromFloat32(0.46561452),
	},
	204: {
		Fr: -libc.Float32FromFloat32(0.89100652),
		Fi: -libc.Float32FromFloat32(0.4539905),
	},
	205: {
		Fr: -libc.Float32FromFloat32(0.89687274),
		Fi: -libc.Float32FromFloat32(0.44228869),
	},
	206: {
		Fr: -libc.Float32FromFloat32(0.90258528),
		Fi: -libc.Float32FromFloat32(0.4305111),
	},
	207: {
		Fr: -libc.Float32FromFloat32(0.90814317),
		Fi: -libc.Float32FromFloat32(0.41865974),
	},
	208: {
		Fr: -libc.Float32FromFloat32(0.91354546),
		Fi: -libc.Float32FromFloat32(0.40673664),
	},
	209: {
		Fr: -libc.Float32FromFloat32(0.91879121),
		Fi: -libc.Float32FromFloat32(0.39474386),
	},
	210: {
		Fr: -libc.Float32FromFloat32(0.92387953),
		Fi: -libc.Float32FromFloat32(0.38268343),
	},
	211: {
		Fr: -libc.Float32FromFloat32(0.92880955),
		Fi: -libc.Float32FromFloat32(0.37055744),
	},
	212: {
		Fr: -libc.Float32FromFloat32(0.93358043),
		Fi: -libc.Float32FromFloat32(0.35836795),
	},
	213: {
		Fr: -libc.Float32FromFloat32(0.93819134),
		Fi: -libc.Float32FromFloat32(0.34611706),
	},
	214: {
		Fr: -libc.Float32FromFloat32(0.94264149),
		Fi: -libc.Float32FromFloat32(0.33380686),
	},
	215: {
		Fr: -libc.Float32FromFloat32(0.94693013),
		Fi: -libc.Float32FromFloat32(0.32143947),
	},
	216: {
		Fr: -libc.Float32FromFloat32(0.95105652),
		Fi: -libc.Float32FromFloat32(0.30901699),
	},
	217: {
		Fr: -libc.Float32FromFloat32(0.95501994),
		Fi: -libc.Float32FromFloat32(0.29654157),
	},
	218: {
		Fr: -libc.Float32FromFloat32(0.95881973),
		Fi: -libc.Float32FromFloat32(0.28401534),
	},
	219: {
		Fr: -libc.Float32FromFloat32(0.96245524),
		Fi: -libc.Float32FromFloat32(0.27144045),
	},
	220: {
		Fr: -libc.Float32FromFloat32(0.96592583),
		Fi: -libc.Float32FromFloat32(0.25881905),
	},
	221: {
		Fr: -libc.Float32FromFloat32(0.96923091),
		Fi: -libc.Float32FromFloat32(0.24615329),
	},
	222: {
		Fr: -libc.Float32FromFloat32(0.97236992),
		Fi: -libc.Float32FromFloat32(0.23344536),
	},
	223: {
		Fr: -libc.Float32FromFloat32(0.97534232),
		Fi: -libc.Float32FromFloat32(0.22069744),
	},
	224: {
		Fr: -libc.Float32FromFloat32(0.9781476),
		Fi: -libc.Float32FromFloat32(0.20791169),
	},
	225: {
		Fr: -libc.Float32FromFloat32(0.98078528),
		Fi: -libc.Float32FromFloat32(0.19509032),
	},
	226: {
		Fr: -libc.Float32FromFloat32(0.98325491),
		Fi: -libc.Float32FromFloat32(0.18223553),
	},
	227: {
		Fr: -libc.Float32FromFloat32(0.98555606),
		Fi: -libc.Float32FromFloat32(0.1693495),
	},
	228: {
		Fr: -libc.Float32FromFloat32(0.98768834),
		Fi: -libc.Float32FromFloat32(0.15643447),
	},
	229: {
		Fr: -libc.Float32FromFloat32(0.98965139),
		Fi: -libc.Float32FromFloat32(0.14349262),
	},
	230: {
		Fr: -libc.Float32FromFloat32(0.99144486),
		Fi: -libc.Float32FromFloat32(0.13052619),
	},
	231: {
		Fr: -libc.Float32FromFloat32(0.99306846),
		Fi: -libc.Float32FromFloat32(0.1175374),
	},
	232: {
		Fr: -libc.Float32FromFloat32(0.9945219),
		Fi: -libc.Float32FromFloat32(0.10452846),
	},
	233: {
		Fr: -libc.Float32FromFloat32(0.99580493),
		Fi: -libc.Float32FromFloat32(0.091501619),
	},
	234: {
		Fr: -libc.Float32FromFloat32(0.99691733),
		Fi: -libc.Float32FromFloat32(0.078459096),
	},
	235: {
		Fr: -libc.Float32FromFloat32(0.99785892),
		Fi: -libc.Float32FromFloat32(0.065403129),
	},
	236: {
		Fr: -libc.Float32FromFloat32(0.99862953),
		Fi: -libc.Float32FromFloat32(0.052335956),
	},
	237: {
		Fr: -libc.Float32FromFloat32(0.99922904),
		Fi: -libc.Float32FromFloat32(0.039259816),
	},
	238: {
		Fr: -libc.Float32FromFloat32(0.99965732),
		Fi: -libc.Float32FromFloat32(0.026176948),
	},
	239: {
		Fr: -libc.Float32FromFloat32(0.99991433),
		Fi: -libc.Float32FromFloat32(0.013089596),
	},
	240: {
		Fr: -libc.Float32FromFloat32(1),
		Fi: -libc.Float32FromFloat32(1.2246468e-16),
	},
	241: {
		Fr: -libc.Float32FromFloat32(0.99991433),
		Fi: libc.Float32FromFloat32(0.013089596),
	},
	242: {
		Fr: -libc.Float32FromFloat32(0.99965732),
		Fi: libc.Float32FromFloat32(0.026176948),
	},
	243: {
		Fr: -libc.Float32FromFloat32(0.99922904),
		Fi: libc.Float32FromFloat32(0.039259816),
	},
	244: {
		Fr: -libc.Float32FromFloat32(0.99862953),
		Fi: libc.Float32FromFloat32(0.052335956),
	},
	245: {
		Fr: -libc.Float32FromFloat32(0.99785892),
		Fi: libc.Float32FromFloat32(0.065403129),
	},
	246: {
		Fr: -libc.Float32FromFloat32(0.99691733),
		Fi: libc.Float32FromFloat32(0.078459096),
	},
	247: {
		Fr: -libc.Float32FromFloat32(0.99580493),
		Fi: libc.Float32FromFloat32(0.091501619),
	},
	248: {
		Fr: -libc.Float32FromFloat32(0.9945219),
		Fi: libc.Float32FromFloat32(0.10452846),
	},
	249: {
		Fr: -libc.Float32FromFloat32(0.99306846),
		Fi: libc.Float32FromFloat32(0.1175374),
	},
	250: {
		Fr: -libc.Float32FromFloat32(0.99144486),
		Fi: libc.Float32FromFloat32(0.13052619),
	},
	251: {
		Fr: -libc.Float32FromFloat32(0.98965139),
		Fi: libc.Float32FromFloat32(0.14349262),
	},
	252: {
		Fr: -libc.Float32FromFloat32(0.98768834),
		Fi: libc.Float32FromFloat32(0.15643447),
	},
	253: {
		Fr: -libc.Float32FromFloat32(0.98555606),
		Fi: libc.Float32FromFloat32(0.1693495),
	},
	254: {
		Fr: -libc.Float32FromFloat32(0.98325491),
		Fi: libc.Float32FromFloat32(0.18223553),
	},
	255: {
		Fr: -libc.Float32FromFloat32(0.98078528),
		Fi: libc.Float32FromFloat32(0.19509032),
	},
	256: {
		Fr: -libc.Float32FromFloat32(0.9781476),
		Fi: libc.Float32FromFloat32(0.20791169),
	},
	257: {
		Fr: -libc.Float32FromFloat32(0.97534232),
		Fi: libc.Float32FromFloat32(0.22069744),
	},
	258: {
		Fr: -libc.Float32FromFloat32(0.97236992),
		Fi: libc.Float32FromFloat32(0.23344536),
	},
	259: {
		Fr: -libc.Float32FromFloat32(0.96923091),
		Fi: libc.Float32FromFloat32(0.24615329),
	},
	260: {
		Fr: -libc.Float32FromFloat32(0.96592583),
		Fi: libc.Float32FromFloat32(0.25881905),
	},
	261: {
		Fr: -libc.Float32FromFloat32(0.96245524),
		Fi: libc.Float32FromFloat32(0.27144045),
	},
	262: {
		Fr: -libc.Float32FromFloat32(0.95881973),
		Fi: libc.Float32FromFloat32(0.28401534),
	},
	263: {
		Fr: -libc.Float32FromFloat32(0.95501994),
		Fi: libc.Float32FromFloat32(0.29654157),
	},
	264: {
		Fr: -libc.Float32FromFloat32(0.95105652),
		Fi: libc.Float32FromFloat32(0.30901699),
	},
	265: {
		Fr: -libc.Float32FromFloat32(0.94693013),
		Fi: libc.Float32FromFloat32(0.32143947),
	},
	266: {
		Fr: -libc.Float32FromFloat32(0.94264149),
		Fi: libc.Float32FromFloat32(0.33380686),
	},
	267: {
		Fr: -libc.Float32FromFloat32(0.93819134),
		Fi: libc.Float32FromFloat32(0.34611706),
	},
	268: {
		Fr: -libc.Float32FromFloat32(0.93358043),
		Fi: libc.Float32FromFloat32(0.35836795),
	},
	269: {
		Fr: -libc.Float32FromFloat32(0.92880955),
		Fi: libc.Float32FromFloat32(0.37055744),
	},
	270: {
		Fr: -libc.Float32FromFloat32(0.92387953),
		Fi: libc.Float32FromFloat32(0.38268343),
	},
	271: {
		Fr: -libc.Float32FromFloat32(0.91879121),
		Fi: libc.Float32FromFloat32(0.39474386),
	},
	272: {
		Fr: -libc.Float32FromFloat32(0.91354546),
		Fi: libc.Float32FromFloat32(0.40673664),
	},
	273: {
		Fr: -libc.Float32FromFloat32(0.90814317),
		Fi: libc.Float32FromFloat32(0.41865974),
	},
	274: {
		Fr: -libc.Float32FromFloat32(0.90258528),
		Fi: libc.Float32FromFloat32(0.4305111),
	},
	275: {
		Fr: -libc.Float32FromFloat32(0.89687274),
		Fi: libc.Float32FromFloat32(0.44228869),
	},
	276: {
		Fr: -libc.Float32FromFloat32(0.89100652),
		Fi: libc.Float32FromFloat32(0.4539905),
	},
	277: {
		Fr: -libc.Float32FromFloat32(0.88498764),
		Fi: libc.Float32FromFloat32(0.46561452),
	},
	278: {
		Fr: -libc.Float32FromFloat32(0.87881711),
		Fi: libc.Float32FromFloat32(0.47715876),
	},
	279: {
		Fr: -libc.Float32FromFloat32(0.87249601),
		Fi: libc.Float32FromFloat32(0.48862124),
	},
	280: {
		Fr: -libc.Float32FromFloat32(0.8660254),
		Fi: libc.Float32FromFloat32(0.5),
	},
	281: {
		Fr: -libc.Float32FromFloat32(0.85940641),
		Fi: libc.Float32FromFloat32(0.51129309),
	},
	282: {
		Fr: -libc.Float32FromFloat32(0.85264016),
		Fi: libc.Float32FromFloat32(0.52249856),
	},
	283: {
		Fr: -libc.Float32FromFloat32(0.84572782),
		Fi: libc.Float32FromFloat32(0.53361452),
	},
	284: {
		Fr: -libc.Float32FromFloat32(0.83867057),
		Fi: libc.Float32FromFloat32(0.54463904),
	},
	285: {
		Fr: -libc.Float32FromFloat32(0.83146961),
		Fi: libc.Float32FromFloat32(0.55557023),
	},
	286: {
		Fr: -libc.Float32FromFloat32(0.82412619),
		Fi: libc.Float32FromFloat32(0.56640624),
	},
	287: {
		Fr: -libc.Float32FromFloat32(0.81664156),
		Fi: libc.Float32FromFloat32(0.57714519),
	},
	288: {
		Fr: -libc.Float32FromFloat32(0.80901699),
		Fi: libc.Float32FromFloat32(0.58778525),
	},
	289: {
		Fr: -libc.Float32FromFloat32(0.80125381),
		Fi: libc.Float32FromFloat32(0.5983246),
	},
	290: {
		Fr: -libc.Float32FromFloat32(0.79335334),
		Fi: libc.Float32FromFloat32(0.60876143),
	},
	291: {
		Fr: -libc.Float32FromFloat32(0.78531693),
		Fi: libc.Float32FromFloat32(0.61909395),
	},
	292: {
		Fr: -libc.Float32FromFloat32(0.77714596),
		Fi: libc.Float32FromFloat32(0.62932039),
	},
	293: {
		Fr: -libc.Float32FromFloat32(0.76884183),
		Fi: libc.Float32FromFloat32(0.639439),
	},
	294: {
		Fr: -libc.Float32FromFloat32(0.76040597),
		Fi: libc.Float32FromFloat32(0.64944805),
	},
	295: {
		Fr: -libc.Float32FromFloat32(0.75183981),
		Fi: libc.Float32FromFloat32(0.65934582),
	},
	296: {
		Fr: -libc.Float32FromFloat32(0.74314483),
		Fi: libc.Float32FromFloat32(0.66913061),
	},
	297: {
		Fr: -libc.Float32FromFloat32(0.73432251),
		Fi: libc.Float32FromFloat32(0.67880075),
	},
	298: {
		Fr: -libc.Float32FromFloat32(0.72537437),
		Fi: libc.Float32FromFloat32(0.68835458),
	},
	299: {
		Fr: -libc.Float32FromFloat32(0.71630194),
		Fi: libc.Float32FromFloat32(0.69779046),
	},
	300: {
		Fr: -libc.Float32FromFloat32(0.70710678),
		Fi: libc.Float32FromFloat32(0.70710678),
	},
	301: {
		Fr: -libc.Float32FromFloat32(0.69779046),
		Fi: libc.Float32FromFloat32(0.71630194),
	},
	302: {
		Fr: -libc.Float32FromFloat32(0.68835458),
		Fi: libc.Float32FromFloat32(0.72537437),
	},
	303: {
		Fr: -libc.Float32FromFloat32(0.67880075),
		Fi: libc.Float32FromFloat32(0.73432251),
	},
	304: {
		Fr: -libc.Float32FromFloat32(0.66913061),
		Fi: libc.Float32FromFloat32(0.74314483),
	},
	305: {
		Fr: -libc.Float32FromFloat32(0.65934582),
		Fi: libc.Float32FromFloat32(0.75183981),
	},
	306: {
		Fr: -libc.Float32FromFloat32(0.64944805),
		Fi: libc.Float32FromFloat32(0.76040597),
	},
	307: {
		Fr: -libc.Float32FromFloat32(0.639439),
		Fi: libc.Float32FromFloat32(0.76884183),
	},
	308: {
		Fr: -libc.Float32FromFloat32(0.62932039),
		Fi: libc.Float32FromFloat32(0.77714596),
	},
	309: {
		Fr: -libc.Float32FromFloat32(0.61909395),
		Fi: libc.Float32FromFloat32(0.78531693),
	},
	310: {
		Fr: -libc.Float32FromFloat32(0.60876143),
		Fi: libc.Float32FromFloat32(0.79335334),
	},
	311: {
		Fr: -libc.Float32FromFloat32(0.5983246),
		Fi: libc.Float32FromFloat32(0.80125381),
	},
	312: {
		Fr: -libc.Float32FromFloat32(0.58778525),
		Fi: libc.Float32FromFloat32(0.80901699),
	},
	313: {
		Fr: -libc.Float32FromFloat32(0.57714519),
		Fi: libc.Float32FromFloat32(0.81664156),
	},
	314: {
		Fr: -libc.Float32FromFloat32(0.56640624),
		Fi: libc.Float32FromFloat32(0.82412619),
	},
	315: {
		Fr: -libc.Float32FromFloat32(0.55557023),
		Fi: libc.Float32FromFloat32(0.83146961),
	},
	316: {
		Fr: -libc.Float32FromFloat32(0.54463904),
		Fi: libc.Float32FromFloat32(0.83867057),
	},
	317: {
		Fr: -libc.Float32FromFloat32(0.53361452),
		Fi: libc.Float32FromFloat32(0.84572782),
	},
	318: {
		Fr: -libc.Float32FromFloat32(0.52249856),
		Fi: libc.Float32FromFloat32(0.85264016),
	},
	319: {
		Fr: -libc.Float32FromFloat32(0.51129309),
		Fi: libc.Float32FromFloat32(0.85940641),
	},
	320: {
		Fr: -libc.Float32FromFloat32(0.5),
		Fi: libc.Float32FromFloat32(0.8660254),
	},
	321: {
		Fr: -libc.Float32FromFloat32(0.48862124),
		Fi: libc.Float32FromFloat32(0.87249601),
	},
	322: {
		Fr: -libc.Float32FromFloat32(0.47715876),
		Fi: libc.Float32FromFloat32(0.87881711),
	},
	323: {
		Fr: -libc.Float32FromFloat32(0.46561452),
		Fi: libc.Float32FromFloat32(0.88498764),
	},
	324: {
		Fr: -libc.Float32FromFloat32(0.4539905),
		Fi: libc.Float32FromFloat32(0.89100652),
	},
	325: {
		Fr: -libc.Float32FromFloat32(0.44228869),
		Fi: libc.Float32FromFloat32(0.89687274),
	},
	326: {
		Fr: -libc.Float32FromFloat32(0.4305111),
		Fi: libc.Float32FromFloat32(0.90258528),
	},
	327: {
		Fr: -libc.Float32FromFloat32(0.41865974),
		Fi: libc.Float32FromFloat32(0.90814317),
	},
	328: {
		Fr: -libc.Float32FromFloat32(0.40673664),
		Fi: libc.Float32FromFloat32(0.91354546),
	},
	329: {
		Fr: -libc.Float32FromFloat32(0.39474386),
		Fi: libc.Float32FromFloat32(0.91879121),
	},
	330: {
		Fr: -libc.Float32FromFloat32(0.38268343),
		Fi: libc.Float32FromFloat32(0.92387953),
	},
	331: {
		Fr: -libc.Float32FromFloat32(0.37055744),
		Fi: libc.Float32FromFloat32(0.92880955),
	},
	332: {
		Fr: -libc.Float32FromFloat32(0.35836795),
		Fi: libc.Float32FromFloat32(0.93358043),
	},
	333: {
		Fr: -libc.Float32FromFloat32(0.34611706),
		Fi: libc.Float32FromFloat32(0.93819134),
	},
	334: {
		Fr: -libc.Float32FromFloat32(0.33380686),
		Fi: libc.Float32FromFloat32(0.94264149),
	},
	335: {
		Fr: -libc.Float32FromFloat32(0.32143947),
		Fi: libc.Float32FromFloat32(0.94693013),
	},
	336: {
		Fr: -libc.Float32FromFloat32(0.30901699),
		Fi: libc.Float32FromFloat32(0.95105652),
	},
	337: {
		Fr: -libc.Float32FromFloat32(0.29654157),
		Fi: libc.Float32FromFloat32(0.95501994),
	},
	338: {
		Fr: -libc.Float32FromFloat32(0.28401534),
		Fi: libc.Float32FromFloat32(0.95881973),
	},
	339: {
		Fr: -libc.Float32FromFloat32(0.27144045),
		Fi: libc.Float32FromFloat32(0.96245524),
	},
	340: {
		Fr: -libc.Float32FromFloat32(0.25881905),
		Fi: libc.Float32FromFloat32(0.96592583),
	},
	341: {
		Fr: -libc.Float32FromFloat32(0.24615329),
		Fi: libc.Float32FromFloat32(0.96923091),
	},
	342: {
		Fr: -libc.Float32FromFloat32(0.23344536),
		Fi: libc.Float32FromFloat32(0.97236992),
	},
	343: {
		Fr: -libc.Float32FromFloat32(0.22069744),
		Fi: libc.Float32FromFloat32(0.97534232),
	},
	344: {
		Fr: -libc.Float32FromFloat32(0.20791169),
		Fi: libc.Float32FromFloat32(0.9781476),
	},
	345: {
		Fr: -libc.Float32FromFloat32(0.19509032),
		Fi: libc.Float32FromFloat32(0.98078528),
	},
	346: {
		Fr: -libc.Float32FromFloat32(0.18223553),
		Fi: libc.Float32FromFloat32(0.98325491),
	},
	347: {
		Fr: -libc.Float32FromFloat32(0.1693495),
		Fi: libc.Float32FromFloat32(0.98555606),
	},
	348: {
		Fr: -libc.Float32FromFloat32(0.15643447),
		Fi: libc.Float32FromFloat32(0.98768834),
	},
	349: {
		Fr: -libc.Float32FromFloat32(0.14349262),
		Fi: libc.Float32FromFloat32(0.98965139),
	},
	350: {
		Fr: -libc.Float32FromFloat32(0.13052619),
		Fi: libc.Float32FromFloat32(0.99144486),
	},
	351: {
		Fr: -libc.Float32FromFloat32(0.1175374),
		Fi: libc.Float32FromFloat32(0.99306846),
	},
	352: {
		Fr: -libc.Float32FromFloat32(0.10452846),
		Fi: libc.Float32FromFloat32(0.9945219),
	},
	353: {
		Fr: -libc.Float32FromFloat32(0.091501619),
		Fi: libc.Float32FromFloat32(0.99580493),
	},
	354: {
		Fr: -libc.Float32FromFloat32(0.078459096),
		Fi: libc.Float32FromFloat32(0.99691733),
	},
	355: {
		Fr: -libc.Float32FromFloat32(0.065403129),
		Fi: libc.Float32FromFloat32(0.99785892),
	},
	356: {
		Fr: -libc.Float32FromFloat32(0.052335956),
		Fi: libc.Float32FromFloat32(0.99862953),
	},
	357: {
		Fr: -libc.Float32FromFloat32(0.039259816),
		Fi: libc.Float32FromFloat32(0.99922904),
	},
	358: {
		Fr: -libc.Float32FromFloat32(0.026176948),
		Fi: libc.Float32FromFloat32(0.99965732),
	},
	359: {
		Fr: -libc.Float32FromFloat32(0.013089596),
		Fi: libc.Float32FromFloat32(0.99991433),
	},
	360: {
		Fr: -libc.Float32FromFloat32(1.8369702e-16),
		Fi: libc.Float32FromFloat32(1),
	},
	361: {
		Fr: libc.Float32FromFloat32(0.013089596),
		Fi: libc.Float32FromFloat32(0.99991433),
	},
	362: {
		Fr: libc.Float32FromFloat32(0.026176948),
		Fi: libc.Float32FromFloat32(0.99965732),
	},
	363: {
		Fr: libc.Float32FromFloat32(0.039259816),
		Fi: libc.Float32FromFloat32(0.99922904),
	},
	364: {
		Fr: libc.Float32FromFloat32(0.052335956),
		Fi: libc.Float32FromFloat32(0.99862953),
	},
	365: {
		Fr: libc.Float32FromFloat32(0.065403129),
		Fi: libc.Float32FromFloat32(0.99785892),
	},
	366: {
		Fr: libc.Float32FromFloat32(0.078459096),
		Fi: libc.Float32FromFloat32(0.99691733),
	},
	367: {
		Fr: libc.Float32FromFloat32(0.091501619),
		Fi: libc.Float32FromFloat32(0.99580493),
	},
	368: {
		Fr: libc.Float32FromFloat32(0.10452846),
		Fi: libc.Float32FromFloat32(0.9945219),
	},
	369: {
		Fr: libc.Float32FromFloat32(0.1175374),
		Fi: libc.Float32FromFloat32(0.99306846),
	},
	370: {
		Fr: libc.Float32FromFloat32(0.13052619),
		Fi: libc.Float32FromFloat32(0.99144486),
	},
	371: {
		Fr: libc.Float32FromFloat32(0.14349262),
		Fi: libc.Float32FromFloat32(0.98965139),
	},
	372: {
		Fr: libc.Float32FromFloat32(0.15643447),
		Fi: libc.Float32FromFloat32(0.98768834),
	},
	373: {
		Fr: libc.Float32FromFloat32(0.1693495),
		Fi: libc.Float32FromFloat32(0.98555606),
	},
	374: {
		Fr: libc.Float32FromFloat32(0.18223553),
		Fi: libc.Float32FromFloat32(0.98325491),
	},
	375: {
		Fr: libc.Float32FromFloat32(0.19509032),
		Fi: libc.Float32FromFloat32(0.98078528),
	},
	376: {
		Fr: libc.Float32FromFloat32(0.20791169),
		Fi: libc.Float32FromFloat32(0.9781476),
	},
	377: {
		Fr: libc.Float32FromFloat32(0.22069744),
		Fi: libc.Float32FromFloat32(0.97534232),
	},
	378: {
		Fr: libc.Float32FromFloat32(0.23344536),
		Fi: libc.Float32FromFloat32(0.97236992),
	},
	379: {
		Fr: libc.Float32FromFloat32(0.24615329),
		Fi: libc.Float32FromFloat32(0.96923091),
	},
	380: {
		Fr: libc.Float32FromFloat32(0.25881905),
		Fi: libc.Float32FromFloat32(0.96592583),
	},
	381: {
		Fr: libc.Float32FromFloat32(0.27144045),
		Fi: libc.Float32FromFloat32(0.96245524),
	},
	382: {
		Fr: libc.Float32FromFloat32(0.28401534),
		Fi: libc.Float32FromFloat32(0.95881973),
	},
	383: {
		Fr: libc.Float32FromFloat32(0.29654157),
		Fi: libc.Float32FromFloat32(0.95501994),
	},
	384: {
		Fr: libc.Float32FromFloat32(0.30901699),
		Fi: libc.Float32FromFloat32(0.95105652),
	},
	385: {
		Fr: libc.Float32FromFloat32(0.32143947),
		Fi: libc.Float32FromFloat32(0.94693013),
	},
	386: {
		Fr: libc.Float32FromFloat32(0.33380686),
		Fi: libc.Float32FromFloat32(0.94264149),
	},
	387: {
		Fr: libc.Float32FromFloat32(0.34611706),
		Fi: libc.Float32FromFloat32(0.93819134),
	},
	388: {
		Fr: libc.Float32FromFloat32(0.35836795),
		Fi: libc.Float32FromFloat32(0.93358043),
	},
	389: {
		Fr: libc.Float32FromFloat32(0.37055744),
		Fi: libc.Float32FromFloat32(0.92880955),
	},
	390: {
		Fr: libc.Float32FromFloat32(0.38268343),
		Fi: libc.Float32FromFloat32(0.92387953),
	},
	391: {
		Fr: libc.Float32FromFloat32(0.39474386),
		Fi: libc.Float32FromFloat32(0.91879121),
	},
	392: {
		Fr: libc.Float32FromFloat32(0.40673664),
		Fi: libc.Float32FromFloat32(0.91354546),
	},
	393: {
		Fr: libc.Float32FromFloat32(0.41865974),
		Fi: libc.Float32FromFloat32(0.90814317),
	},
	394: {
		Fr: libc.Float32FromFloat32(0.4305111),
		Fi: libc.Float32FromFloat32(0.90258528),
	},
	395: {
		Fr: libc.Float32FromFloat32(0.44228869),
		Fi: libc.Float32FromFloat32(0.89687274),
	},
	396: {
		Fr: libc.Float32FromFloat32(0.4539905),
		Fi: libc.Float32FromFloat32(0.89100652),
	},
	397: {
		Fr: libc.Float32FromFloat32(0.46561452),
		Fi: libc.Float32FromFloat32(0.88498764),
	},
	398: {
		Fr: libc.Float32FromFloat32(0.47715876),
		Fi: libc.Float32FromFloat32(0.87881711),
	},
	399: {
		Fr: libc.Float32FromFloat32(0.48862124),
		Fi: libc.Float32FromFloat32(0.87249601),
	},
	400: {
		Fr: libc.Float32FromFloat32(0.5),
		Fi: libc.Float32FromFloat32(0.8660254),
	},
	401: {
		Fr: libc.Float32FromFloat32(0.51129309),
		Fi: libc.Float32FromFloat32(0.85940641),
	},
	402: {
		Fr: libc.Float32FromFloat32(0.52249856),
		Fi: libc.Float32FromFloat32(0.85264016),
	},
	403: {
		Fr: libc.Float32FromFloat32(0.53361452),
		Fi: libc.Float32FromFloat32(0.84572782),
	},
	404: {
		Fr: libc.Float32FromFloat32(0.54463904),
		Fi: libc.Float32FromFloat32(0.83867057),
	},
	405: {
		Fr: libc.Float32FromFloat32(0.55557023),
		Fi: libc.Float32FromFloat32(0.83146961),
	},
	406: {
		Fr: libc.Float32FromFloat32(0.56640624),
		Fi: libc.Float32FromFloat32(0.82412619),
	},
	407: {
		Fr: libc.Float32FromFloat32(0.57714519),
		Fi: libc.Float32FromFloat32(0.81664156),
	},
	408: {
		Fr: libc.Float32FromFloat32(0.58778525),
		Fi: libc.Float32FromFloat32(0.80901699),
	},
	409: {
		Fr: libc.Float32FromFloat32(0.5983246),
		Fi: libc.Float32FromFloat32(0.80125381),
	},
	410: {
		Fr: libc.Float32FromFloat32(0.60876143),
		Fi: libc.Float32FromFloat32(0.79335334),
	},
	411: {
		Fr: libc.Float32FromFloat32(0.61909395),
		Fi: libc.Float32FromFloat32(0.78531693),
	},
	412: {
		Fr: libc.Float32FromFloat32(0.62932039),
		Fi: libc.Float32FromFloat32(0.77714596),
	},
	413: {
		Fr: libc.Float32FromFloat32(0.639439),
		Fi: libc.Float32FromFloat32(0.76884183),
	},
	414: {
		Fr: libc.Float32FromFloat32(0.64944805),
		Fi: libc.Float32FromFloat32(0.76040597),
	},
	415: {
		Fr: libc.Float32FromFloat32(0.65934582),
		Fi: libc.Float32FromFloat32(0.75183981),
	},
	416: {
		Fr: libc.Float32FromFloat32(0.66913061),
		Fi: libc.Float32FromFloat32(0.74314483),
	},
	417: {
		Fr: libc.Float32FromFloat32(0.67880075),
		Fi: libc.Float32FromFloat32(0.73432251),
	},
	418: {
		Fr: libc.Float32FromFloat32(0.68835458),
		Fi: libc.Float32FromFloat32(0.72537437),
	},
	419: {
		Fr: libc.Float32FromFloat32(0.69779046),
		Fi: libc.Float32FromFloat32(0.71630194),
	},
	420: {
		Fr: libc.Float32FromFloat32(0.70710678),
		Fi: libc.Float32FromFloat32(0.70710678),
	},
	421: {
		Fr: libc.Float32FromFloat32(0.71630194),
		Fi: libc.Float32FromFloat32(0.69779046),
	},
	422: {
		Fr: libc.Float32FromFloat32(0.72537437),
		Fi: libc.Float32FromFloat32(0.68835458),
	},
	423: {
		Fr: libc.Float32FromFloat32(0.73432251),
		Fi: libc.Float32FromFloat32(0.67880075),
	},
	424: {
		Fr: libc.Float32FromFloat32(0.74314483),
		Fi: libc.Float32FromFloat32(0.66913061),
	},
	425: {
		Fr: libc.Float32FromFloat32(0.75183981),
		Fi: libc.Float32FromFloat32(0.65934582),
	},
	426: {
		Fr: libc.Float32FromFloat32(0.76040597),
		Fi: libc.Float32FromFloat32(0.64944805),
	},
	427: {
		Fr: libc.Float32FromFloat32(0.76884183),
		Fi: libc.Float32FromFloat32(0.639439),
	},
	428: {
		Fr: libc.Float32FromFloat32(0.77714596),
		Fi: libc.Float32FromFloat32(0.62932039),
	},
	429: {
		Fr: libc.Float32FromFloat32(0.78531693),
		Fi: libc.Float32FromFloat32(0.61909395),
	},
	430: {
		Fr: libc.Float32FromFloat32(0.79335334),
		Fi: libc.Float32FromFloat32(0.60876143),
	},
	431: {
		Fr: libc.Float32FromFloat32(0.80125381),
		Fi: libc.Float32FromFloat32(0.5983246),
	},
	432: {
		Fr: libc.Float32FromFloat32(0.80901699),
		Fi: libc.Float32FromFloat32(0.58778525),
	},
	433: {
		Fr: libc.Float32FromFloat32(0.81664156),
		Fi: libc.Float32FromFloat32(0.57714519),
	},
	434: {
		Fr: libc.Float32FromFloat32(0.82412619),
		Fi: libc.Float32FromFloat32(0.56640624),
	},
	435: {
		Fr: libc.Float32FromFloat32(0.83146961),
		Fi: libc.Float32FromFloat32(0.55557023),
	},
	436: {
		Fr: libc.Float32FromFloat32(0.83867057),
		Fi: libc.Float32FromFloat32(0.54463904),
	},
	437: {
		Fr: libc.Float32FromFloat32(0.84572782),
		Fi: libc.Float32FromFloat32(0.53361452),
	},
	438: {
		Fr: libc.Float32FromFloat32(0.85264016),
		Fi: libc.Float32FromFloat32(0.52249856),
	},
	439: {
		Fr: libc.Float32FromFloat32(0.85940641),
		Fi: libc.Float32FromFloat32(0.51129309),
	},
	440: {
		Fr: libc.Float32FromFloat32(0.8660254),
		Fi: libc.Float32FromFloat32(0.5),
	},
	441: {
		Fr: libc.Float32FromFloat32(0.87249601),
		Fi: libc.Float32FromFloat32(0.48862124),
	},
	442: {
		Fr: libc.Float32FromFloat32(0.87881711),
		Fi: libc.Float32FromFloat32(0.47715876),
	},
	443: {
		Fr: libc.Float32FromFloat32(0.88498764),
		Fi: libc.Float32FromFloat32(0.46561452),
	},
	444: {
		Fr: libc.Float32FromFloat32(0.89100652),
		Fi: libc.Float32FromFloat32(0.4539905),
	},
	445: {
		Fr: libc.Float32FromFloat32(0.89687274),
		Fi: libc.Float32FromFloat32(0.44228869),
	},
	446: {
		Fr: libc.Float32FromFloat32(0.90258528),
		Fi: libc.Float32FromFloat32(0.4305111),
	},
	447: {
		Fr: libc.Float32FromFloat32(0.90814317),
		Fi: libc.Float32FromFloat32(0.41865974),
	},
	448: {
		Fr: libc.Float32FromFloat32(0.91354546),
		Fi: libc.Float32FromFloat32(0.40673664),
	},
	449: {
		Fr: libc.Float32FromFloat32(0.91879121),
		Fi: libc.Float32FromFloat32(0.39474386),
	},
	450: {
		Fr: libc.Float32FromFloat32(0.92387953),
		Fi: libc.Float32FromFloat32(0.38268343),
	},
	451: {
		Fr: libc.Float32FromFloat32(0.92880955),
		Fi: libc.Float32FromFloat32(0.37055744),
	},
	452: {
		Fr: libc.Float32FromFloat32(0.93358043),
		Fi: libc.Float32FromFloat32(0.35836795),
	},
	453: {
		Fr: libc.Float32FromFloat32(0.93819134),
		Fi: libc.Float32FromFloat32(0.34611706),
	},
	454: {
		Fr: libc.Float32FromFloat32(0.94264149),
		Fi: libc.Float32FromFloat32(0.33380686),
	},
	455: {
		Fr: libc.Float32FromFloat32(0.94693013),
		Fi: libc.Float32FromFloat32(0.32143947),
	},
	456: {
		Fr: libc.Float32FromFloat32(0.95105652),
		Fi: libc.Float32FromFloat32(0.30901699),
	},
	457: {
		Fr: libc.Float32FromFloat32(0.95501994),
		Fi: libc.Float32FromFloat32(0.29654157),
	},
	458: {
		Fr: libc.Float32FromFloat32(0.95881973),
		Fi: libc.Float32FromFloat32(0.28401534),
	},
	459: {
		Fr: libc.Float32FromFloat32(0.96245524),
		Fi: libc.Float32FromFloat32(0.27144045),
	},
	460: {
		Fr: libc.Float32FromFloat32(0.96592583),
		Fi: libc.Float32FromFloat32(0.25881905),
	},
	461: {
		Fr: libc.Float32FromFloat32(0.96923091),
		Fi: libc.Float32FromFloat32(0.24615329),
	},
	462: {
		Fr: libc.Float32FromFloat32(0.97236992),
		Fi: libc.Float32FromFloat32(0.23344536),
	},
	463: {
		Fr: libc.Float32FromFloat32(0.97534232),
		Fi: libc.Float32FromFloat32(0.22069744),
	},
	464: {
		Fr: libc.Float32FromFloat32(0.9781476),
		Fi: libc.Float32FromFloat32(0.20791169),
	},
	465: {
		Fr: libc.Float32FromFloat32(0.98078528),
		Fi: libc.Float32FromFloat32(0.19509032),
	},
	466: {
		Fr: libc.Float32FromFloat32(0.98325491),
		Fi: libc.Float32FromFloat32(0.18223553),
	},
	467: {
		Fr: libc.Float32FromFloat32(0.98555606),
		Fi: libc.Float32FromFloat32(0.1693495),
	},
	468: {
		Fr: libc.Float32FromFloat32(0.98768834),
		Fi: libc.Float32FromFloat32(0.15643447),
	},
	469: {
		Fr: libc.Float32FromFloat32(0.98965139),
		Fi: libc.Float32FromFloat32(0.14349262),
	},
	470: {
		Fr: libc.Float32FromFloat32(0.99144486),
		Fi: libc.Float32FromFloat32(0.13052619),
	},
	471: {
		Fr: libc.Float32FromFloat32(0.99306846),
		Fi: libc.Float32FromFloat32(0.1175374),
	},
	472: {
		Fr: libc.Float32FromFloat32(0.9945219),
		Fi: libc.Float32FromFloat32(0.10452846),
	},
	473: {
		Fr: libc.Float32FromFloat32(0.99580493),
		Fi: libc.Float32FromFloat32(0.091501619),
	},
	474: {
		Fr: libc.Float32FromFloat32(0.99691733),
		Fi: libc.Float32FromFloat32(0.078459096),
	},
	475: {
		Fr: libc.Float32FromFloat32(0.99785892),
		Fi: libc.Float32FromFloat32(0.065403129),
	},
	476: {
		Fr: libc.Float32FromFloat32(0.99862953),
		Fi: libc.Float32FromFloat32(0.052335956),
	},
	477: {
		Fr: libc.Float32FromFloat32(0.99922904),
		Fi: libc.Float32FromFloat32(0.039259816),
	},
	478: {
		Fr: libc.Float32FromFloat32(0.99965732),
		Fi: libc.Float32FromFloat32(0.026176948),
	},
	479: {
		Fr: libc.Float32FromFloat32(0.99991433),
		Fi: libc.Float32FromFloat32(0.013089596),
	},
}
var fft_bitrev480 = [480]OpusT_opus_int16{
	1:   int16(96),
	2:   int16(192),
	3:   int16(288),
	4:   int16(384),
	5:   int16(32),
	6:   int16(128),
	7:   int16(224),
	8:   int16(320),
	9:   int16(416),
	10:  int16(64),
	11:  int16(160),
	12:  int16(256),
	13:  int16(352),
	14:  int16(448),
	15:  int16(8),
	16:  int16(104),
	17:  int16(200),
	18:  int16(296),
	19:  int16(392),
	20:  int16(40),
	21:  int16(136),
	22:  int16(232),
	23:  int16(328),
	24:  int16(424),
	25:  int16(72),
	26:  int16(168),
	27:  int16(264),
	28:  int16(360),
	29:  int16(456),
	30:  int16(16),
	31:  int16(112),
	32:  int16(208),
	33:  int16(304),
	34:  int16(400),
	35:  int16(48),
	36:  int16(144),
	37:  int16(240),
	38:  int16(336),
	39:  int16(432),
	40:  int16(80),
	41:  int16(176),
	42:  int16(272),
	43:  int16(368),
	44:  int16(464),
	45:  int16(24),
	46:  int16(120),
	47:  int16(216),
	48:  int16(312),
	49:  int16(408),
	50:  int16(56),
	51:  int16(152),
	52:  int16(248),
	53:  int16(344),
	54:  int16(440),
	55:  int16(88),
	56:  int16(184),
	57:  int16(280),
	58:  int16(376),
	59:  int16(472),
	60:  int16(4),
	61:  int16(100),
	62:  int16(196),
	63:  int16(292),
	64:  int16(388),
	65:  int16(36),
	66:  int16(132),
	67:  int16(228),
	68:  int16(324),
	69:  int16(420),
	70:  int16(68),
	71:  int16(164),
	72:  int16(260),
	73:  int16(356),
	74:  int16(452),
	75:  int16(12),
	76:  int16(108),
	77:  int16(204),
	78:  int16(300),
	79:  int16(396),
	80:  int16(44),
	81:  int16(140),
	82:  int16(236),
	83:  int16(332),
	84:  int16(428),
	85:  int16(76),
	86:  int16(172),
	87:  int16(268),
	88:  int16(364),
	89:  int16(460),
	90:  int16(20),
	91:  int16(116),
	92:  int16(212),
	93:  int16(308),
	94:  int16(404),
	95:  int16(52),
	96:  int16(148),
	97:  int16(244),
	98:  int16(340),
	99:  int16(436),
	100: int16(84),
	101: int16(180),
	102: int16(276),
	103: int16(372),
	104: int16(468),
	105: int16(28),
	106: int16(124),
	107: int16(220),
	108: int16(316),
	109: int16(412),
	110: int16(60),
	111: int16(156),
	112: int16(252),
	113: int16(348),
	114: int16(444),
	115: int16(92),
	116: int16(188),
	117: int16(284),
	118: int16(380),
	119: int16(476),
	120: int16(1),
	121: int16(97),
	122: int16(193),
	123: int16(289),
	124: int16(385),
	125: int16(33),
	126: int16(129),
	127: int16(225),
	128: int16(321),
	129: int16(417),
	130: int16(65),
	131: int16(161),
	132: int16(257),
	133: int16(353),
	134: int16(449),
	135: int16(9),
	136: int16(105),
	137: int16(201),
	138: int16(297),
	139: int16(393),
	140: int16(41),
	141: int16(137),
	142: int16(233),
	143: int16(329),
	144: int16(425),
	145: int16(73),
	146: int16(169),
	147: int16(265),
	148: int16(361),
	149: int16(457),
	150: int16(17),
	151: int16(113),
	152: int16(209),
	153: int16(305),
	154: int16(401),
	155: int16(49),
	156: int16(145),
	157: int16(241),
	158: int16(337),
	159: int16(433),
	160: int16(81),
	161: int16(177),
	162: int16(273),
	163: int16(369),
	164: int16(465),
	165: int16(25),
	166: int16(121),
	167: int16(217),
	168: int16(313),
	169: int16(409),
	170: int16(57),
	171: int16(153),
	172: int16(249),
	173: int16(345),
	174: int16(441),
	175: int16(89),
	176: int16(185),
	177: int16(281),
	178: int16(377),
	179: int16(473),
	180: int16(5),
	181: int16(101),
	182: int16(197),
	183: int16(293),
	184: int16(389),
	185: int16(37),
	186: int16(133),
	187: int16(229),
	188: int16(325),
	189: int16(421),
	190: int16(69),
	191: int16(165),
	192: int16(261),
	193: int16(357),
	194: int16(453),
	195: int16(13),
	196: int16(109),
	197: int16(205),
	198: int16(301),
	199: int16(397),
	200: int16(45),
	201: int16(141),
	202: int16(237),
	203: int16(333),
	204: int16(429),
	205: int16(77),
	206: int16(173),
	207: int16(269),
	208: int16(365),
	209: int16(461),
	210: int16(21),
	211: int16(117),
	212: int16(213),
	213: int16(309),
	214: int16(405),
	215: int16(53),
	216: int16(149),
	217: int16(245),
	218: int16(341),
	219: int16(437),
	220: int16(85),
	221: int16(181),
	222: int16(277),
	223: int16(373),
	224: int16(469),
	225: int16(29),
	226: int16(125),
	227: int16(221),
	228: int16(317),
	229: int16(413),
	230: int16(61),
	231: int16(157),
	232: int16(253),
	233: int16(349),
	234: int16(445),
	235: int16(93),
	236: int16(189),
	237: int16(285),
	238: int16(381),
	239: int16(477),
	240: int16(2),
	241: int16(98),
	242: int16(194),
	243: int16(290),
	244: int16(386),
	245: int16(34),
	246: int16(130),
	247: int16(226),
	248: int16(322),
	249: int16(418),
	250: int16(66),
	251: int16(162),
	252: int16(258),
	253: int16(354),
	254: int16(450),
	255: int16(10),
	256: int16(106),
	257: int16(202),
	258: int16(298),
	259: int16(394),
	260: int16(42),
	261: int16(138),
	262: int16(234),
	263: int16(330),
	264: int16(426),
	265: int16(74),
	266: int16(170),
	267: int16(266),
	268: int16(362),
	269: int16(458),
	270: int16(18),
	271: int16(114),
	272: int16(210),
	273: int16(306),
	274: int16(402),
	275: int16(50),
	276: int16(146),
	277: int16(242),
	278: int16(338),
	279: int16(434),
	280: int16(82),
	281: int16(178),
	282: int16(274),
	283: int16(370),
	284: int16(466),
	285: int16(26),
	286: int16(122),
	287: int16(218),
	288: int16(314),
	289: int16(410),
	290: int16(58),
	291: int16(154),
	292: int16(250),
	293: int16(346),
	294: int16(442),
	295: int16(90),
	296: int16(186),
	297: int16(282),
	298: int16(378),
	299: int16(474),
	300: int16(6),
	301: int16(102),
	302: int16(198),
	303: int16(294),
	304: int16(390),
	305: int16(38),
	306: int16(134),
	307: int16(230),
	308: int16(326),
	309: int16(422),
	310: int16(70),
	311: int16(166),
	312: int16(262),
	313: int16(358),
	314: int16(454),
	315: int16(14),
	316: int16(110),
	317: int16(206),
	318: int16(302),
	319: int16(398),
	320: int16(46),
	321: int16(142),
	322: int16(238),
	323: int16(334),
	324: int16(430),
	325: int16(78),
	326: int16(174),
	327: int16(270),
	328: int16(366),
	329: int16(462),
	330: int16(22),
	331: int16(118),
	332: int16(214),
	333: int16(310),
	334: int16(406),
	335: int16(54),
	336: int16(150),
	337: int16(246),
	338: int16(342),
	339: int16(438),
	340: int16(86),
	341: int16(182),
	342: int16(278),
	343: int16(374),
	344: int16(470),
	345: int16(30),
	346: int16(126),
	347: int16(222),
	348: int16(318),
	349: int16(414),
	350: int16(62),
	351: int16(158),
	352: int16(254),
	353: int16(350),
	354: int16(446),
	355: int16(94),
	356: int16(190),
	357: int16(286),
	358: int16(382),
	359: int16(478),
	360: int16(3),
	361: int16(99),
	362: int16(195),
	363: int16(291),
	364: int16(387),
	365: int16(35),
	366: int16(131),
	367: int16(227),
	368: int16(323),
	369: int16(419),
	370: int16(67),
	371: int16(163),
	372: int16(259),
	373: int16(355),
	374: int16(451),
	375: int16(11),
	376: int16(107),
	377: int16(203),
	378: int16(299),
	379: int16(395),
	380: int16(43),
	381: int16(139),
	382: int16(235),
	383: int16(331),
	384: int16(427),
	385: int16(75),
	386: int16(171),
	387: int16(267),
	388: int16(363),
	389: int16(459),
	390: int16(19),
	391: int16(115),
	392: int16(211),
	393: int16(307),
	394: int16(403),
	395: int16(51),
	396: int16(147),
	397: int16(243),
	398: int16(339),
	399: int16(435),
	400: int16(83),
	401: int16(179),
	402: int16(275),
	403: int16(371),
	404: int16(467),
	405: int16(27),
	406: int16(123),
	407: int16(219),
	408: int16(315),
	409: int16(411),
	410: int16(59),
	411: int16(155),
	412: int16(251),
	413: int16(347),
	414: int16(443),
	415: int16(91),
	416: int16(187),
	417: int16(283),
	418: int16(379),
	419: int16(475),
	420: int16(7),
	421: int16(103),
	422: int16(199),
	423: int16(295),
	424: int16(391),
	425: int16(39),
	426: int16(135),
	427: int16(231),
	428: int16(327),
	429: int16(423),
	430: int16(71),
	431: int16(167),
	432: int16(263),
	433: int16(359),
	434: int16(455),
	435: int16(15),
	436: int16(111),
	437: int16(207),
	438: int16(303),
	439: int16(399),
	440: int16(47),
	441: int16(143),
	442: int16(239),
	443: int16(335),
	444: int16(431),
	445: int16(79),
	446: int16(175),
	447: int16(271),
	448: int16(367),
	449: int16(463),
	450: int16(23),
	451: int16(119),
	452: int16(215),
	453: int16(311),
	454: int16(407),
	455: int16(55),
	456: int16(151),
	457: int16(247),
	458: int16(343),
	459: int16(439),
	460: int16(87),
	461: int16(183),
	462: int16(279),
	463: int16(375),
	464: int16(471),
	465: int16(31),
	466: int16(127),
	467: int16(223),
	468: int16(319),
	469: int16(415),
	470: int16(63),
	471: int16(159),
	472: int16(255),
	473: int16(351),
	474: int16(447),
	475: int16(95),
	476: int16(191),
	477: int16(287),
	478: int16(383),
	479: int16(479),
}
var fft_bitrev240 = [240]OpusT_opus_int16{
	1:   int16(48),
	2:   int16(96),
	3:   int16(144),
	4:   int16(192),
	5:   int16(16),
	6:   int16(64),
	7:   int16(112),
	8:   int16(160),
	9:   int16(208),
	10:  int16(32),
	11:  int16(80),
	12:  int16(128),
	13:  int16(176),
	14:  int16(224),
	15:  int16(4),
	16:  int16(52),
	17:  int16(100),
	18:  int16(148),
	19:  int16(196),
	20:  int16(20),
	21:  int16(68),
	22:  int16(116),
	23:  int16(164),
	24:  int16(212),
	25:  int16(36),
	26:  int16(84),
	27:  int16(132),
	28:  int16(180),
	29:  int16(228),
	30:  int16(8),
	31:  int16(56),
	32:  int16(104),
	33:  int16(152),
	34:  int16(200),
	35:  int16(24),
	36:  int16(72),
	37:  int16(120),
	38:  int16(168),
	39:  int16(216),
	40:  int16(40),
	41:  int16(88),
	42:  int16(136),
	43:  int16(184),
	44:  int16(232),
	45:  int16(12),
	46:  int16(60),
	47:  int16(108),
	48:  int16(156),
	49:  int16(204),
	50:  int16(28),
	51:  int16(76),
	52:  int16(124),
	53:  int16(172),
	54:  int16(220),
	55:  int16(44),
	56:  int16(92),
	57:  int16(140),
	58:  int16(188),
	59:  int16(236),
	60:  int16(1),
	61:  int16(49),
	62:  int16(97),
	63:  int16(145),
	64:  int16(193),
	65:  int16(17),
	66:  int16(65),
	67:  int16(113),
	68:  int16(161),
	69:  int16(209),
	70:  int16(33),
	71:  int16(81),
	72:  int16(129),
	73:  int16(177),
	74:  int16(225),
	75:  int16(5),
	76:  int16(53),
	77:  int16(101),
	78:  int16(149),
	79:  int16(197),
	80:  int16(21),
	81:  int16(69),
	82:  int16(117),
	83:  int16(165),
	84:  int16(213),
	85:  int16(37),
	86:  int16(85),
	87:  int16(133),
	88:  int16(181),
	89:  int16(229),
	90:  int16(9),
	91:  int16(57),
	92:  int16(105),
	93:  int16(153),
	94:  int16(201),
	95:  int16(25),
	96:  int16(73),
	97:  int16(121),
	98:  int16(169),
	99:  int16(217),
	100: int16(41),
	101: int16(89),
	102: int16(137),
	103: int16(185),
	104: int16(233),
	105: int16(13),
	106: int16(61),
	107: int16(109),
	108: int16(157),
	109: int16(205),
	110: int16(29),
	111: int16(77),
	112: int16(125),
	113: int16(173),
	114: int16(221),
	115: int16(45),
	116: int16(93),
	117: int16(141),
	118: int16(189),
	119: int16(237),
	120: int16(2),
	121: int16(50),
	122: int16(98),
	123: int16(146),
	124: int16(194),
	125: int16(18),
	126: int16(66),
	127: int16(114),
	128: int16(162),
	129: int16(210),
	130: int16(34),
	131: int16(82),
	132: int16(130),
	133: int16(178),
	134: int16(226),
	135: int16(6),
	136: int16(54),
	137: int16(102),
	138: int16(150),
	139: int16(198),
	140: int16(22),
	141: int16(70),
	142: int16(118),
	143: int16(166),
	144: int16(214),
	145: int16(38),
	146: int16(86),
	147: int16(134),
	148: int16(182),
	149: int16(230),
	150: int16(10),
	151: int16(58),
	152: int16(106),
	153: int16(154),
	154: int16(202),
	155: int16(26),
	156: int16(74),
	157: int16(122),
	158: int16(170),
	159: int16(218),
	160: int16(42),
	161: int16(90),
	162: int16(138),
	163: int16(186),
	164: int16(234),
	165: int16(14),
	166: int16(62),
	167: int16(110),
	168: int16(158),
	169: int16(206),
	170: int16(30),
	171: int16(78),
	172: int16(126),
	173: int16(174),
	174: int16(222),
	175: int16(46),
	176: int16(94),
	177: int16(142),
	178: int16(190),
	179: int16(238),
	180: int16(3),
	181: int16(51),
	182: int16(99),
	183: int16(147),
	184: int16(195),
	185: int16(19),
	186: int16(67),
	187: int16(115),
	188: int16(163),
	189: int16(211),
	190: int16(35),
	191: int16(83),
	192: int16(131),
	193: int16(179),
	194: int16(227),
	195: int16(7),
	196: int16(55),
	197: int16(103),
	198: int16(151),
	199: int16(199),
	200: int16(23),
	201: int16(71),
	202: int16(119),
	203: int16(167),
	204: int16(215),
	205: int16(39),
	206: int16(87),
	207: int16(135),
	208: int16(183),
	209: int16(231),
	210: int16(11),
	211: int16(59),
	212: int16(107),
	213: int16(155),
	214: int16(203),
	215: int16(27),
	216: int16(75),
	217: int16(123),
	218: int16(171),
	219: int16(219),
	220: int16(43),
	221: int16(91),
	222: int16(139),
	223: int16(187),
	224: int16(235),
	225: int16(15),
	226: int16(63),
	227: int16(111),
	228: int16(159),
	229: int16(207),
	230: int16(31),
	231: int16(79),
	232: int16(127),
	233: int16(175),
	234: int16(223),
	235: int16(47),
	236: int16(95),
	237: int16(143),
	238: int16(191),
	239: int16(239),
}
var fft_bitrev120 = [120]OpusT_opus_int16{
	1:   int16(24),
	2:   int16(48),
	3:   int16(72),
	4:   int16(96),
	5:   int16(8),
	6:   int16(32),
	7:   int16(56),
	8:   int16(80),
	9:   int16(104),
	10:  int16(16),
	11:  int16(40),
	12:  int16(64),
	13:  int16(88),
	14:  int16(112),
	15:  int16(4),
	16:  int16(28),
	17:  int16(52),
	18:  int16(76),
	19:  int16(100),
	20:  int16(12),
	21:  int16(36),
	22:  int16(60),
	23:  int16(84),
	24:  int16(108),
	25:  int16(20),
	26:  int16(44),
	27:  int16(68),
	28:  int16(92),
	29:  int16(116),
	30:  int16(1),
	31:  int16(25),
	32:  int16(49),
	33:  int16(73),
	34:  int16(97),
	35:  int16(9),
	36:  int16(33),
	37:  int16(57),
	38:  int16(81),
	39:  int16(105),
	40:  int16(17),
	41:  int16(41),
	42:  int16(65),
	43:  int16(89),
	44:  int16(113),
	45:  int16(5),
	46:  int16(29),
	47:  int16(53),
	48:  int16(77),
	49:  int16(101),
	50:  int16(13),
	51:  int16(37),
	52:  int16(61),
	53:  int16(85),
	54:  int16(109),
	55:  int16(21),
	56:  int16(45),
	57:  int16(69),
	58:  int16(93),
	59:  int16(117),
	60:  int16(2),
	61:  int16(26),
	62:  int16(50),
	63:  int16(74),
	64:  int16(98),
	65:  int16(10),
	66:  int16(34),
	67:  int16(58),
	68:  int16(82),
	69:  int16(106),
	70:  int16(18),
	71:  int16(42),
	72:  int16(66),
	73:  int16(90),
	74:  int16(114),
	75:  int16(6),
	76:  int16(30),
	77:  int16(54),
	78:  int16(78),
	79:  int16(102),
	80:  int16(14),
	81:  int16(38),
	82:  int16(62),
	83:  int16(86),
	84:  int16(110),
	85:  int16(22),
	86:  int16(46),
	87:  int16(70),
	88:  int16(94),
	89:  int16(118),
	90:  int16(3),
	91:  int16(27),
	92:  int16(51),
	93:  int16(75),
	94:  int16(99),
	95:  int16(11),
	96:  int16(35),
	97:  int16(59),
	98:  int16(83),
	99:  int16(107),
	100: int16(19),
	101: int16(43),
	102: int16(67),
	103: int16(91),
	104: int16(115),
	105: int16(7),
	106: int16(31),
	107: int16(55),
	108: int16(79),
	109: int16(103),
	110: int16(15),
	111: int16(39),
	112: int16(63),
	113: int16(87),
	114: int16(111),
	115: int16(23),
	116: int16(47),
	117: int16(71),
	118: int16(95),
	119: int16(119),
}
var fft_bitrev60 = [60]OpusT_opus_int16{
	1:  int16(12),
	2:  int16(24),
	3:  int16(36),
	4:  int16(48),
	5:  int16(4),
	6:  int16(16),
	7:  int16(28),
	8:  int16(40),
	9:  int16(52),
	10: int16(8),
	11: int16(20),
	12: int16(32),
	13: int16(44),
	14: int16(56),
	15: int16(1),
	16: int16(13),
	17: int16(25),
	18: int16(37),
	19: int16(49),
	20: int16(5),
	21: int16(17),
	22: int16(29),
	23: int16(41),
	24: int16(53),
	25: int16(9),
	26: int16(21),
	27: int16(33),
	28: int16(45),
	29: int16(57),
	30: int16(2),
	31: int16(14),
	32: int16(26),
	33: int16(38),
	34: int16(50),
	35: int16(6),
	36: int16(18),
	37: int16(30),
	38: int16(42),
	39: int16(54),
	40: int16(10),
	41: int16(22),
	42: int16(34),
	43: int16(46),
	44: int16(58),
	45: int16(3),
	46: int16(15),
	47: int16(27),
	48: int16(39),
	49: int16(51),
	50: int16(7),
	51: int16(19),
	52: int16(31),
	53: int16(43),
	54: int16(55),
	55: int16(11),
	56: int16(23),
	57: int16(35),
	58: int16(47),
	59: int16(59),
}
var fft_state48000_960_0 = OpusT_kiss_fft_state{
	Fnfft:  int32(480),
	Fscale: libc.Float32FromFloat32(0.0020833334),
	Fshift: -int32(1),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(96),
		2: int16(3),
		3: int16(32),
		4: int16(4),
		5: int16(8),
		6: int16(2),
		7: int16(4),
		8: int16(4),
		9: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev480)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_1 = OpusT_kiss_fft_state{
	Fnfft:  int32(240),
	Fscale: libc.Float32FromFloat32(0.0041666669),
	Fshift: int32(1),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(48),
		2: int16(3),
		3: int16(16),
		4: int16(4),
		5: int16(4),
		6: int16(4),
		7: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev240)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_2 = OpusT_kiss_fft_state{
	Fnfft:  int32(120),
	Fscale: libc.Float32FromFloat32(0.0083333338),
	Fshift: int32(2),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(24),
		2: int16(3),
		3: int16(8),
		4: int16(2),
		5: int16(4),
		6: int16(4),
		7: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev120)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var fft_state48000_960_3 = OpusT_kiss_fft_state{
	Fnfft:  int32(60),
	Fscale: libc.Float32FromFloat32(0.016666668),
	Fshift: int32(3),
	Ffactors: [16]OpusT_opus_int16{
		0: int16(5),
		1: int16(12),
		2: int16(3),
		3: int16(4),
		4: int16(4),
		5: int16(1),
	},
	Fbitrev:   uintptr(unsafe.Pointer(&fft_bitrev60)),
	Ftwiddles: uintptr(unsafe.Pointer(&fft_twiddles48000_960)),
}
var mdct_twiddles960 = [1800]OpusT_celt_coef{
	0:    libc.Float32FromFloat32(0.99999992),
	1:    libc.Float32FromFloat32(0.99999322),
	2:    libc.Float32FromFloat32(0.99997582),
	3:    libc.Float32FromFloat32(0.99994771),
	4:    libc.Float32FromFloat32(0.99990889),
	5:    libc.Float32FromFloat32(0.99985936),
	6:    libc.Float32FromFloat32(0.99979913),
	7:    libc.Float32FromFloat32(0.99972818),
	8:    libc.Float32FromFloat32(0.99964653),
	9:    libc.Float32FromFloat32(0.99955418),
	10:   libc.Float32FromFloat32(0.99945112),
	11:   libc.Float32FromFloat32(0.99933736),
	12:   libc.Float32FromFloat32(0.99921289),
	13:   libc.Float32FromFloat32(0.99907773),
	14:   libc.Float32FromFloat32(0.99893186),
	15:   libc.Float32FromFloat32(0.9987753),
	16:   libc.Float32FromFloat32(0.99860804),
	17:   libc.Float32FromFloat32(0.99843009),
	18:   libc.Float32FromFloat32(0.99824144),
	19:   libc.Float32FromFloat32(0.99804211),
	20:   libc.Float32FromFloat32(0.99783209),
	21:   libc.Float32FromFloat32(0.99761138),
	22:   libc.Float32FromFloat32(0.99737998),
	23:   libc.Float32FromFloat32(0.99713791),
	24:   libc.Float32FromFloat32(0.99688516),
	25:   libc.Float32FromFloat32(0.99662173),
	26:   libc.Float32FromFloat32(0.99634763),
	27:   libc.Float32FromFloat32(0.99606285),
	28:   libc.Float32FromFloat32(0.99576741),
	29:   libc.Float32FromFloat32(0.99546131),
	30:   libc.Float32FromFloat32(0.99514455),
	31:   libc.Float32FromFloat32(0.99481713),
	32:   libc.Float32FromFloat32(0.99447905),
	33:   libc.Float32FromFloat32(0.99413033),
	34:   libc.Float32FromFloat32(0.99377096),
	35:   libc.Float32FromFloat32(0.99340095),
	36:   libc.Float32FromFloat32(0.99302029),
	37:   libc.Float32FromFloat32(0.99262901),
	38:   libc.Float32FromFloat32(0.99222709),
	39:   libc.Float32FromFloat32(0.99181455),
	40:   libc.Float32FromFloat32(0.99139139),
	41:   libc.Float32FromFloat32(0.9909576),
	42:   libc.Float32FromFloat32(0.99051321),
	43:   libc.Float32FromFloat32(0.99005821),
	44:   libc.Float32FromFloat32(0.98959261),
	45:   libc.Float32FromFloat32(0.98911641),
	46:   libc.Float32FromFloat32(0.98862961),
	47:   libc.Float32FromFloat32(0.98813223),
	48:   libc.Float32FromFloat32(0.98762427),
	49:   libc.Float32FromFloat32(0.98710573),
	50:   libc.Float32FromFloat32(0.98657662),
	51:   libc.Float32FromFloat32(0.98603694),
	52:   libc.Float32FromFloat32(0.9854867),
	53:   libc.Float32FromFloat32(0.98492591),
	54:   libc.Float32FromFloat32(0.98435457),
	55:   libc.Float32FromFloat32(0.98377269),
	56:   libc.Float32FromFloat32(0.98318028),
	57:   libc.Float32FromFloat32(0.98257734),
	58:   libc.Float32FromFloat32(0.98196387),
	59:   libc.Float32FromFloat32(0.98133989),
	60:   libc.Float32FromFloat32(0.98070539),
	61:   libc.Float32FromFloat32(0.9800604),
	62:   libc.Float32FromFloat32(0.97940491),
	63:   libc.Float32FromFloat32(0.97873893),
	64:   libc.Float32FromFloat32(0.97806247),
	65:   libc.Float32FromFloat32(0.97737554),
	66:   libc.Float32FromFloat32(0.97667813),
	67:   libc.Float32FromFloat32(0.97597027),
	68:   libc.Float32FromFloat32(0.97525196),
	69:   libc.Float32FromFloat32(0.9745232),
	70:   libc.Float32FromFloat32(0.97378401),
	71:   libc.Float32FromFloat32(0.97303439),
	72:   libc.Float32FromFloat32(0.97227435),
	73:   libc.Float32FromFloat32(0.97150389),
	74:   libc.Float32FromFloat32(0.97072303),
	75:   libc.Float32FromFloat32(0.96993178),
	76:   libc.Float32FromFloat32(0.96913014),
	77:   libc.Float32FromFloat32(0.96831812),
	78:   libc.Float32FromFloat32(0.96749573),
	79:   libc.Float32FromFloat32(0.96666298),
	80:   libc.Float32FromFloat32(0.96581987),
	81:   libc.Float32FromFloat32(0.96496643),
	82:   libc.Float32FromFloat32(0.96410265),
	83:   libc.Float32FromFloat32(0.96322854),
	84:   libc.Float32FromFloat32(0.96234412),
	85:   libc.Float32FromFloat32(0.96144939),
	86:   libc.Float32FromFloat32(0.96054437),
	87:   libc.Float32FromFloat32(0.95962906),
	88:   libc.Float32FromFloat32(0.95870347),
	89:   libc.Float32FromFloat32(0.95776762),
	90:   libc.Float32FromFloat32(0.95682151),
	91:   libc.Float32FromFloat32(0.95586515),
	92:   libc.Float32FromFloat32(0.95489856),
	93:   libc.Float32FromFloat32(0.95392174),
	94:   libc.Float32FromFloat32(0.95293471),
	95:   libc.Float32FromFloat32(0.95193746),
	96:   libc.Float32FromFloat32(0.95093003),
	97:   libc.Float32FromFloat32(0.94991241),
	98:   libc.Float32FromFloat32(0.94888462),
	99:   libc.Float32FromFloat32(0.94784667),
	100:  libc.Float32FromFloat32(0.94679856),
	101:  libc.Float32FromFloat32(0.94574032),
	102:  libc.Float32FromFloat32(0.94467195),
	103:  libc.Float32FromFloat32(0.94359346),
	104:  libc.Float32FromFloat32(0.94250486),
	105:  libc.Float32FromFloat32(0.94140618),
	106:  libc.Float32FromFloat32(0.94029741),
	107:  libc.Float32FromFloat32(0.93917857),
	108:  libc.Float32FromFloat32(0.93804967),
	109:  libc.Float32FromFloat32(0.93691073),
	110:  libc.Float32FromFloat32(0.93576176),
	111:  libc.Float32FromFloat32(0.93460276),
	112:  libc.Float32FromFloat32(0.93343375),
	113:  libc.Float32FromFloat32(0.93225475),
	114:  libc.Float32FromFloat32(0.93106577),
	115:  libc.Float32FromFloat32(0.92986681),
	116:  libc.Float32FromFloat32(0.92865789),
	117:  libc.Float32FromFloat32(0.92743903),
	118:  libc.Float32FromFloat32(0.92621024),
	119:  libc.Float32FromFloat32(0.92497153),
	120:  libc.Float32FromFloat32(0.92372291),
	121:  libc.Float32FromFloat32(0.9224644),
	122:  libc.Float32FromFloat32(0.92119602),
	123:  libc.Float32FromFloat32(0.91991776),
	124:  libc.Float32FromFloat32(0.91862966),
	125:  libc.Float32FromFloat32(0.91733172),
	126:  libc.Float32FromFloat32(0.91602395),
	127:  libc.Float32FromFloat32(0.91470637),
	128:  libc.Float32FromFloat32(0.913379),
	129:  libc.Float32FromFloat32(0.91204185),
	130:  libc.Float32FromFloat32(0.91069493),
	131:  libc.Float32FromFloat32(0.90933825),
	132:  libc.Float32FromFloat32(0.90797184),
	133:  libc.Float32FromFloat32(0.9065957),
	134:  libc.Float32FromFloat32(0.90520986),
	135:  libc.Float32FromFloat32(0.90381432),
	136:  libc.Float32FromFloat32(0.9024091),
	137:  libc.Float32FromFloat32(0.90099422),
	138:  libc.Float32FromFloat32(0.89956969),
	139:  libc.Float32FromFloat32(0.89813553),
	140:  libc.Float32FromFloat32(0.89669174),
	141:  libc.Float32FromFloat32(0.89523836),
	142:  libc.Float32FromFloat32(0.89377538),
	143:  libc.Float32FromFloat32(0.89230284),
	144:  libc.Float32FromFloat32(0.89082074),
	145:  libc.Float32FromFloat32(0.8893291),
	146:  libc.Float32FromFloat32(0.88782793),
	147:  libc.Float32FromFloat32(0.88631726),
	148:  libc.Float32FromFloat32(0.8847971),
	149:  libc.Float32FromFloat32(0.88326746),
	150:  libc.Float32FromFloat32(0.88172836),
	151:  libc.Float32FromFloat32(0.88017982),
	152:  libc.Float32FromFloat32(0.87862185),
	153:  libc.Float32FromFloat32(0.87705448),
	154:  libc.Float32FromFloat32(0.87547771),
	155:  libc.Float32FromFloat32(0.87389156),
	156:  libc.Float32FromFloat32(0.87229606),
	157:  libc.Float32FromFloat32(0.87069121),
	158:  libc.Float32FromFloat32(0.86907704),
	159:  libc.Float32FromFloat32(0.86745357),
	160:  libc.Float32FromFloat32(0.8658208),
	161:  libc.Float32FromFloat32(0.86417876),
	162:  libc.Float32FromFloat32(0.86252747),
	163:  libc.Float32FromFloat32(0.86086694),
	164:  libc.Float32FromFloat32(0.85919719),
	165:  libc.Float32FromFloat32(0.85751824),
	166:  libc.Float32FromFloat32(0.8558301),
	167:  libc.Float32FromFloat32(0.85413281),
	168:  libc.Float32FromFloat32(0.85242636),
	169:  libc.Float32FromFloat32(0.85071078),
	170:  libc.Float32FromFloat32(0.8489861),
	171:  libc.Float32FromFloat32(0.84725232),
	172:  libc.Float32FromFloat32(0.84550947),
	173:  libc.Float32FromFloat32(0.84375756),
	174:  libc.Float32FromFloat32(0.84199662),
	175:  libc.Float32FromFloat32(0.84022666),
	176:  libc.Float32FromFloat32(0.83844771),
	177:  libc.Float32FromFloat32(0.83665977),
	178:  libc.Float32FromFloat32(0.83486287),
	179:  libc.Float32FromFloat32(0.83305704),
	180:  libc.Float32FromFloat32(0.83124228),
	181:  libc.Float32FromFloat32(0.82941862),
	182:  libc.Float32FromFloat32(0.82758608),
	183:  libc.Float32FromFloat32(0.82574467),
	184:  libc.Float32FromFloat32(0.82389442),
	185:  libc.Float32FromFloat32(0.82203535),
	186:  libc.Float32FromFloat32(0.82016748),
	187:  libc.Float32FromFloat32(0.81829082),
	188:  libc.Float32FromFloat32(0.8164054),
	189:  libc.Float32FromFloat32(0.81451123),
	190:  libc.Float32FromFloat32(0.81260835),
	191:  libc.Float32FromFloat32(0.81069676),
	192:  libc.Float32FromFloat32(0.80877649),
	193:  libc.Float32FromFloat32(0.80684755),
	194:  libc.Float32FromFloat32(0.80490998),
	195:  libc.Float32FromFloat32(0.80296379),
	196:  libc.Float32FromFloat32(0.80100899),
	197:  libc.Float32FromFloat32(0.79904562),
	198:  libc.Float32FromFloat32(0.7970737),
	199:  libc.Float32FromFloat32(0.79509323),
	200:  libc.Float32FromFloat32(0.79310425),
	201:  libc.Float32FromFloat32(0.79110678),
	202:  libc.Float32FromFloat32(0.78910084),
	203:  libc.Float32FromFloat32(0.78708644),
	204:  libc.Float32FromFloat32(0.78506362),
	205:  libc.Float32FromFloat32(0.78303239),
	206:  libc.Float32FromFloat32(0.78099277),
	207:  libc.Float32FromFloat32(0.77894479),
	208:  libc.Float32FromFloat32(0.77688847),
	209:  libc.Float32FromFloat32(0.77482382),
	210:  libc.Float32FromFloat32(0.77275088),
	211:  libc.Float32FromFloat32(0.77066967),
	212:  libc.Float32FromFloat32(0.7685802),
	213:  libc.Float32FromFloat32(0.7664825),
	214:  libc.Float32FromFloat32(0.76437659),
	215:  libc.Float32FromFloat32(0.7622625),
	216:  libc.Float32FromFloat32(0.76014024),
	217:  libc.Float32FromFloat32(0.75800984),
	218:  libc.Float32FromFloat32(0.75587132),
	219:  libc.Float32FromFloat32(0.75372471),
	220:  libc.Float32FromFloat32(0.75157003),
	221:  libc.Float32FromFloat32(0.7494073),
	222:  libc.Float32FromFloat32(0.74723654),
	223:  libc.Float32FromFloat32(0.74505779),
	224:  libc.Float32FromFloat32(0.74287105),
	225:  libc.Float32FromFloat32(0.74067635),
	226:  libc.Float32FromFloat32(0.73847373),
	227:  libc.Float32FromFloat32(0.7362632),
	228:  libc.Float32FromFloat32(0.73404478),
	229:  libc.Float32FromFloat32(0.7318185),
	230:  libc.Float32FromFloat32(0.72958438),
	231:  libc.Float32FromFloat32(0.72734245),
	232:  libc.Float32FromFloat32(0.72509273),
	233:  libc.Float32FromFloat32(0.72283525),
	234:  libc.Float32FromFloat32(0.72057002),
	235:  libc.Float32FromFloat32(0.71829708),
	236:  libc.Float32FromFloat32(0.71601644),
	237:  libc.Float32FromFloat32(0.71372814),
	238:  libc.Float32FromFloat32(0.7114322),
	239:  libc.Float32FromFloat32(0.70912863),
	240:  libc.Float32FromFloat32(0.70681747),
	241:  libc.Float32FromFloat32(0.70449874),
	242:  libc.Float32FromFloat32(0.70217247),
	243:  libc.Float32FromFloat32(0.69983868),
	244:  libc.Float32FromFloat32(0.69749739),
	245:  libc.Float32FromFloat32(0.69514863),
	246:  libc.Float32FromFloat32(0.69279243),
	247:  libc.Float32FromFloat32(0.69042881),
	248:  libc.Float32FromFloat32(0.6880578),
	249:  libc.Float32FromFloat32(0.68567941),
	250:  libc.Float32FromFloat32(0.68329369),
	251:  libc.Float32FromFloat32(0.68090064),
	252:  libc.Float32FromFloat32(0.67850031),
	253:  libc.Float32FromFloat32(0.6760927),
	254:  libc.Float32FromFloat32(0.67367786),
	255:  libc.Float32FromFloat32(0.6712558),
	256:  libc.Float32FromFloat32(0.66882656),
	257:  libc.Float32FromFloat32(0.66639015),
	258:  libc.Float32FromFloat32(0.66394661),
	259:  libc.Float32FromFloat32(0.66149595),
	260:  libc.Float32FromFloat32(0.65903821),
	261:  libc.Float32FromFloat32(0.65657341),
	262:  libc.Float32FromFloat32(0.65410159),
	263:  libc.Float32FromFloat32(0.65162275),
	264:  libc.Float32FromFloat32(0.64913694),
	265:  libc.Float32FromFloat32(0.64664418),
	266:  libc.Float32FromFloat32(0.64414449),
	267:  libc.Float32FromFloat32(0.6416379),
	268:  libc.Float32FromFloat32(0.63912444),
	269:  libc.Float32FromFloat32(0.63660414),
	270:  libc.Float32FromFloat32(0.63407702),
	271:  libc.Float32FromFloat32(0.63154311),
	272:  libc.Float32FromFloat32(0.62900244),
	273:  libc.Float32FromFloat32(0.62645503),
	274:  libc.Float32FromFloat32(0.62390091),
	275:  libc.Float32FromFloat32(0.62134011),
	276:  libc.Float32FromFloat32(0.61877265),
	277:  libc.Float32FromFloat32(0.61619857),
	278:  libc.Float32FromFloat32(0.61361789),
	279:  libc.Float32FromFloat32(0.61103064),
	280:  libc.Float32FromFloat32(0.60843685),
	281:  libc.Float32FromFloat32(0.60583654),
	282:  libc.Float32FromFloat32(0.60322974),
	283:  libc.Float32FromFloat32(0.60061648),
	284:  libc.Float32FromFloat32(0.59799679),
	285:  libc.Float32FromFloat32(0.59537069),
	286:  libc.Float32FromFloat32(0.59273822),
	287:  libc.Float32FromFloat32(0.5900994),
	288:  libc.Float32FromFloat32(0.58745427),
	289:  libc.Float32FromFloat32(0.58480284),
	290:  libc.Float32FromFloat32(0.58214514),
	291:  libc.Float32FromFloat32(0.57948122),
	292:  libc.Float32FromFloat32(0.57681109),
	293:  libc.Float32FromFloat32(0.57413478),
	294:  libc.Float32FromFloat32(0.57145232),
	295:  libc.Float32FromFloat32(0.56876374),
	296:  libc.Float32FromFloat32(0.56606907),
	297:  libc.Float32FromFloat32(0.56336834),
	298:  libc.Float32FromFloat32(0.56066158),
	299:  libc.Float32FromFloat32(0.55794881),
	300:  libc.Float32FromFloat32(0.55523006),
	301:  libc.Float32FromFloat32(0.55250537),
	302:  libc.Float32FromFloat32(0.54977477),
	303:  libc.Float32FromFloat32(0.54703827),
	304:  libc.Float32FromFloat32(0.54429592),
	305:  libc.Float32FromFloat32(0.54154774),
	306:  libc.Float32FromFloat32(0.53879376),
	307:  libc.Float32FromFloat32(0.53603401),
	308:  libc.Float32FromFloat32(0.53326852),
	309:  libc.Float32FromFloat32(0.53049731),
	310:  libc.Float32FromFloat32(0.52772043),
	311:  libc.Float32FromFloat32(0.5249379),
	312:  libc.Float32FromFloat32(0.52214974),
	313:  libc.Float32FromFloat32(0.51935599),
	314:  libc.Float32FromFloat32(0.51655668),
	315:  libc.Float32FromFloat32(0.51375184),
	316:  libc.Float32FromFloat32(0.51094149),
	317:  libc.Float32FromFloat32(0.50812568),
	318:  libc.Float32FromFloat32(0.50530442),
	319:  libc.Float32FromFloat32(0.50247775),
	320:  libc.Float32FromFloat32(0.4996457),
	321:  libc.Float32FromFloat32(0.4968083),
	322:  libc.Float32FromFloat32(0.49396558),
	323:  libc.Float32FromFloat32(0.49111757),
	324:  libc.Float32FromFloat32(0.4882643),
	325:  libc.Float32FromFloat32(0.4854058),
	326:  libc.Float32FromFloat32(0.4825421),
	327:  libc.Float32FromFloat32(0.47967323),
	328:  libc.Float32FromFloat32(0.47679923),
	329:  libc.Float32FromFloat32(0.47392012),
	330:  libc.Float32FromFloat32(0.47103594),
	331:  libc.Float32FromFloat32(0.46814671),
	332:  libc.Float32FromFloat32(0.46525247),
	333:  libc.Float32FromFloat32(0.46235324),
	334:  libc.Float32FromFloat32(0.45944907),
	335:  libc.Float32FromFloat32(0.45653997),
	336:  libc.Float32FromFloat32(0.45362599),
	337:  libc.Float32FromFloat32(0.45070714),
	338:  libc.Float32FromFloat32(0.44778347),
	339:  libc.Float32FromFloat32(0.44485501),
	340:  libc.Float32FromFloat32(0.44192178),
	341:  libc.Float32FromFloat32(0.43898381),
	342:  libc.Float32FromFloat32(0.43604115),
	343:  libc.Float32FromFloat32(0.43309382),
	344:  libc.Float32FromFloat32(0.43014185),
	345:  libc.Float32FromFloat32(0.42718527),
	346:  libc.Float32FromFloat32(0.42422412),
	347:  libc.Float32FromFloat32(0.42125842),
	348:  libc.Float32FromFloat32(0.41828822),
	349:  libc.Float32FromFloat32(0.41531353),
	350:  libc.Float32FromFloat32(0.4123344),
	351:  libc.Float32FromFloat32(0.40935085),
	352:  libc.Float32FromFloat32(0.40636291),
	353:  libc.Float32FromFloat32(0.40337063),
	354:  libc.Float32FromFloat32(0.40037402),
	355:  libc.Float32FromFloat32(0.39737313),
	356:  libc.Float32FromFloat32(0.39436798),
	357:  libc.Float32FromFloat32(0.39135861),
	358:  libc.Float32FromFloat32(0.38834505),
	359:  libc.Float32FromFloat32(0.38532733),
	360:  libc.Float32FromFloat32(0.38230548),
	361:  libc.Float32FromFloat32(0.37927953),
	362:  libc.Float32FromFloat32(0.37624953),
	363:  libc.Float32FromFloat32(0.3732155),
	364:  libc.Float32FromFloat32(0.37017747),
	365:  libc.Float32FromFloat32(0.36713547),
	366:  libc.Float32FromFloat32(0.36408955),
	367:  libc.Float32FromFloat32(0.36103972),
	368:  libc.Float32FromFloat32(0.35798603),
	369:  libc.Float32FromFloat32(0.3549285),
	370:  libc.Float32FromFloat32(0.35186718),
	371:  libc.Float32FromFloat32(0.34880208),
	372:  libc.Float32FromFloat32(0.34573325),
	373:  libc.Float32FromFloat32(0.34266072),
	374:  libc.Float32FromFloat32(0.33958451),
	375:  libc.Float32FromFloat32(0.33650468),
	376:  libc.Float32FromFloat32(0.33342123),
	377:  libc.Float32FromFloat32(0.33033422),
	378:  libc.Float32FromFloat32(0.32724367),
	379:  libc.Float32FromFloat32(0.32414961),
	380:  libc.Float32FromFloat32(0.32105209),
	381:  libc.Float32FromFloat32(0.31795112),
	382:  libc.Float32FromFloat32(0.31484675),
	383:  libc.Float32FromFloat32(0.31173901),
	384:  libc.Float32FromFloat32(0.30862793),
	385:  libc.Float32FromFloat32(0.30551354),
	386:  libc.Float32FromFloat32(0.30239588),
	387:  libc.Float32FromFloat32(0.29927499),
	388:  libc.Float32FromFloat32(0.29615089),
	389:  libc.Float32FromFloat32(0.29302362),
	390:  libc.Float32FromFloat32(0.28989321),
	391:  libc.Float32FromFloat32(0.28675969),
	392:  libc.Float32FromFloat32(0.2836231),
	393:  libc.Float32FromFloat32(0.28048348),
	394:  libc.Float32FromFloat32(0.27734085),
	395:  libc.Float32FromFloat32(0.27419526),
	396:  libc.Float32FromFloat32(0.27104672),
	397:  libc.Float32FromFloat32(0.26789529),
	398:  libc.Float32FromFloat32(0.26474098),
	399:  libc.Float32FromFloat32(0.26158384),
	400:  libc.Float32FromFloat32(0.2584239),
	401:  libc.Float32FromFloat32(0.25526119),
	402:  libc.Float32FromFloat32(0.25209575),
	403:  libc.Float32FromFloat32(0.24892761),
	404:  libc.Float32FromFloat32(0.2457568),
	405:  libc.Float32FromFloat32(0.24258336),
	406:  libc.Float32FromFloat32(0.23940732),
	407:  libc.Float32FromFloat32(0.23622872),
	408:  libc.Float32FromFloat32(0.23304759),
	409:  libc.Float32FromFloat32(0.22986396),
	410:  libc.Float32FromFloat32(0.22667787),
	411:  libc.Float32FromFloat32(0.22348935),
	412:  libc.Float32FromFloat32(0.22029844),
	413:  libc.Float32FromFloat32(0.21710517),
	414:  libc.Float32FromFloat32(0.21390958),
	415:  libc.Float32FromFloat32(0.21071169),
	416:  libc.Float32FromFloat32(0.20751155),
	417:  libc.Float32FromFloat32(0.20430919),
	418:  libc.Float32FromFloat32(0.20110463),
	419:  libc.Float32FromFloat32(0.19789793),
	420:  libc.Float32FromFloat32(0.1946891),
	421:  libc.Float32FromFloat32(0.19147819),
	422:  libc.Float32FromFloat32(0.18826523),
	423:  libc.Float32FromFloat32(0.18505026),
	424:  libc.Float32FromFloat32(0.1818333),
	425:  libc.Float32FromFloat32(0.17861439),
	426:  libc.Float32FromFloat32(0.17539357),
	427:  libc.Float32FromFloat32(0.17217088),
	428:  libc.Float32FromFloat32(0.16894634),
	429:  libc.Float32FromFloat32(0.16571999),
	430:  libc.Float32FromFloat32(0.16249186),
	431:  libc.Float32FromFloat32(0.159262),
	432:  libc.Float32FromFloat32(0.15603043),
	433:  libc.Float32FromFloat32(0.15279719),
	434:  libc.Float32FromFloat32(0.14956231),
	435:  libc.Float32FromFloat32(0.14632583),
	436:  libc.Float32FromFloat32(0.14308778),
	437:  libc.Float32FromFloat32(0.1398482),
	438:  libc.Float32FromFloat32(0.13660713),
	439:  libc.Float32FromFloat32(0.13336459),
	440:  libc.Float32FromFloat32(0.13012062),
	441:  libc.Float32FromFloat32(0.12687526),
	442:  libc.Float32FromFloat32(0.12362854),
	443:  libc.Float32FromFloat32(0.12038049),
	444:  libc.Float32FromFloat32(0.11713116),
	445:  libc.Float32FromFloat32(0.11388057),
	446:  libc.Float32FromFloat32(0.11062877),
	447:  libc.Float32FromFloat32(0.10737578),
	448:  libc.Float32FromFloat32(0.10412163),
	449:  libc.Float32FromFloat32(0.10086638),
	450:  libc.Float32FromFloat32(0.09761004),
	451:  libc.Float32FromFloat32(0.094352658),
	452:  libc.Float32FromFloat32(0.091094266),
	453:  libc.Float32FromFloat32(0.087834897),
	454:  libc.Float32FromFloat32(0.084574589),
	455:  libc.Float32FromFloat32(0.081313374),
	456:  libc.Float32FromFloat32(0.078051289),
	457:  libc.Float32FromFloat32(0.074788367),
	458:  libc.Float32FromFloat32(0.071524645),
	459:  libc.Float32FromFloat32(0.068260157),
	460:  libc.Float32FromFloat32(0.064994938),
	461:  libc.Float32FromFloat32(0.061729023),
	462:  libc.Float32FromFloat32(0.058462447),
	463:  libc.Float32FromFloat32(0.055195244),
	464:  libc.Float32FromFloat32(0.051927451),
	465:  libc.Float32FromFloat32(0.048659101),
	466:  libc.Float32FromFloat32(0.045390231),
	467:  libc.Float32FromFloat32(0.042120874),
	468:  libc.Float32FromFloat32(0.038851066),
	469:  libc.Float32FromFloat32(0.035580842),
	470:  libc.Float32FromFloat32(0.032310238),
	471:  libc.Float32FromFloat32(0.029039287),
	472:  libc.Float32FromFloat32(0.025768025),
	473:  libc.Float32FromFloat32(0.022496487),
	474:  libc.Float32FromFloat32(0.019224708),
	475:  libc.Float32FromFloat32(0.015952723),
	476:  libc.Float32FromFloat32(0.012680568),
	477:  libc.Float32FromFloat32(0.0094082767),
	478:  libc.Float32FromFloat32(0.0061358846),
	479:  libc.Float32FromFloat32(0.0028634269),
	480:  -libc.Float32FromFloat32(0.00040906153),
	481:  -libc.Float32FromFloat32(0.0036815456),
	482:  -libc.Float32FromFloat32(0.0069539902),
	483:  -libc.Float32FromFloat32(0.01022636),
	484:  -libc.Float32FromFloat32(0.013498621),
	485:  -libc.Float32FromFloat32(0.016770737),
	486:  -libc.Float32FromFloat32(0.020042673),
	487:  -libc.Float32FromFloat32(0.023314395),
	488:  -libc.Float32FromFloat32(0.026585867),
	489:  -libc.Float32FromFloat32(0.029857055),
	490:  -libc.Float32FromFloat32(0.033127923),
	491:  -libc.Float32FromFloat32(0.036398436),
	492:  -libc.Float32FromFloat32(0.039668559),
	493:  -libc.Float32FromFloat32(0.042938257),
	494:  -libc.Float32FromFloat32(0.046207495),
	495:  -libc.Float32FromFloat32(0.049476239),
	496:  -libc.Float32FromFloat32(0.052744453),
	497:  -libc.Float32FromFloat32(0.056012102),
	498:  -libc.Float32FromFloat32(0.059279151),
	499:  -libc.Float32FromFloat32(0.062545565),
	500:  -libc.Float32FromFloat32(0.065811309),
	501:  -libc.Float32FromFloat32(0.069076349),
	502:  -libc.Float32FromFloat32(0.072340649),
	503:  -libc.Float32FromFloat32(0.075604174),
	504:  -libc.Float32FromFloat32(0.07886689),
	505:  -libc.Float32FromFloat32(0.082128761),
	506:  -libc.Float32FromFloat32(0.085389752),
	507:  -libc.Float32FromFloat32(0.088649829),
	508:  -libc.Float32FromFloat32(0.091908956),
	509:  -libc.Float32FromFloat32(0.0951671),
	510:  -libc.Float32FromFloat32(0.098424224),
	511:  -libc.Float32FromFloat32(0.10168029),
	512:  -libc.Float32FromFloat32(0.10493528),
	513:  -libc.Float32FromFloat32(0.10818913),
	514:  -libc.Float32FromFloat32(0.11144183),
	515:  -libc.Float32FromFloat32(0.11469334),
	516:  -libc.Float32FromFloat32(0.11794361),
	517:  -libc.Float32FromFloat32(0.12119263),
	518:  -libc.Float32FromFloat32(0.12444034),
	519:  -libc.Float32FromFloat32(0.12768673),
	520:  -libc.Float32FromFloat32(0.13093174),
	521:  -libc.Float32FromFloat32(0.13417536),
	522:  -libc.Float32FromFloat32(0.13741753),
	523:  -libc.Float32FromFloat32(0.14065824),
	524:  -libc.Float32FromFloat32(0.14389744),
	525:  -libc.Float32FromFloat32(0.1471351),
	526:  -libc.Float32FromFloat32(0.15037118),
	527:  -libc.Float32FromFloat32(0.15360565),
	528:  -libc.Float32FromFloat32(0.15683848),
	529:  -libc.Float32FromFloat32(0.16006962),
	530:  -libc.Float32FromFloat32(0.16329906),
	531:  -libc.Float32FromFloat32(0.16652674),
	532:  -libc.Float32FromFloat32(0.16975264),
	533:  -libc.Float32FromFloat32(0.17297673),
	534:  -libc.Float32FromFloat32(0.17619896),
	535:  -libc.Float32FromFloat32(0.1794193),
	536:  -libc.Float32FromFloat32(0.18263772),
	537:  -libc.Float32FromFloat32(0.18585419),
	538:  -libc.Float32FromFloat32(0.18906866),
	539:  -libc.Float32FromFloat32(0.19228112),
	540:  -libc.Float32FromFloat32(0.19549151),
	541:  -libc.Float32FromFloat32(0.19869981),
	542:  -libc.Float32FromFloat32(0.20190598),
	543:  -libc.Float32FromFloat32(0.20510998),
	544:  -libc.Float32FromFloat32(0.2083118),
	545:  -libc.Float32FromFloat32(0.21151138),
	546:  -libc.Float32FromFloat32(0.21470869),
	547:  -libc.Float32FromFloat32(0.21790371),
	548:  -libc.Float32FromFloat32(0.22109639),
	549:  -libc.Float32FromFloat32(0.22428671),
	550:  -libc.Float32FromFloat32(0.22747462),
	551:  -libc.Float32FromFloat32(0.2306601),
	552:  -libc.Float32FromFloat32(0.2338431),
	553:  -libc.Float32FromFloat32(0.23702361),
	554:  -libc.Float32FromFloat32(0.24020157),
	555:  -libc.Float32FromFloat32(0.24337696),
	556:  -libc.Float32FromFloat32(0.24654975),
	557:  -libc.Float32FromFloat32(0.24971989),
	558:  -libc.Float32FromFloat32(0.25288736),
	559:  -libc.Float32FromFloat32(0.25605213),
	560:  -libc.Float32FromFloat32(0.25921415),
	561:  -libc.Float32FromFloat32(0.26237339),
	562:  -libc.Float32FromFloat32(0.26552983),
	563:  -libc.Float32FromFloat32(0.26868342),
	564:  -libc.Float32FromFloat32(0.27183413),
	565:  -libc.Float32FromFloat32(0.27498193),
	566:  -libc.Float32FromFloat32(0.27812679),
	567:  -libc.Float32FromFloat32(0.28126867),
	568:  -libc.Float32FromFloat32(0.28440754),
	569:  -libc.Float32FromFloat32(0.28754336),
	570:  -libc.Float32FromFloat32(0.2906761),
	571:  -libc.Float32FromFloat32(0.29380573),
	572:  -libc.Float32FromFloat32(0.29693221),
	573:  -libc.Float32FromFloat32(0.30005551),
	574:  -libc.Float32FromFloat32(0.3031756),
	575:  -libc.Float32FromFloat32(0.30629245),
	576:  -libc.Float32FromFloat32(0.30940601),
	577:  -libc.Float32FromFloat32(0.31251626),
	578:  -libc.Float32FromFloat32(0.31562316),
	579:  -libc.Float32FromFloat32(0.31872668),
	580:  -libc.Float32FromFloat32(0.32182679),
	581:  -libc.Float32FromFloat32(0.32492345),
	582:  -libc.Float32FromFloat32(0.32801664),
	583:  -libc.Float32FromFloat32(0.33110631),
	584:  -libc.Float32FromFloat32(0.33419243),
	585:  -libc.Float32FromFloat32(0.33727497),
	586:  -libc.Float32FromFloat32(0.34035391),
	587:  -libc.Float32FromFloat32(0.3434292),
	588:  -libc.Float32FromFloat32(0.34650081),
	589:  -libc.Float32FromFloat32(0.34956871),
	590:  -libc.Float32FromFloat32(0.35263286),
	591:  -libc.Float32FromFloat32(0.35569324),
	592:  -libc.Float32FromFloat32(0.35874981),
	593:  -libc.Float32FromFloat32(0.36180254),
	594:  -libc.Float32FromFloat32(0.36485139),
	595:  -libc.Float32FromFloat32(0.36789634),
	596:  -libc.Float32FromFloat32(0.37093735),
	597:  -libc.Float32FromFloat32(0.37397438),
	598:  -libc.Float32FromFloat32(0.37700741),
	599:  -libc.Float32FromFloat32(0.3800364),
	600:  -libc.Float32FromFloat32(0.38306132),
	601:  -libc.Float32FromFloat32(0.38608214),
	602:  -libc.Float32FromFloat32(0.38909883),
	603:  -libc.Float32FromFloat32(0.39211135),
	604:  -libc.Float32FromFloat32(0.39511967),
	605:  -libc.Float32FromFloat32(0.39812375),
	606:  -libc.Float32FromFloat32(0.40112358),
	607:  -libc.Float32FromFloat32(0.4041191),
	608:  -libc.Float32FromFloat32(0.40711031),
	609:  -libc.Float32FromFloat32(0.41009715),
	610:  -libc.Float32FromFloat32(0.41307959),
	611:  -libc.Float32FromFloat32(0.41605762),
	612:  -libc.Float32FromFloat32(0.41903119),
	613:  -libc.Float32FromFloat32(0.42200027),
	614:  -libc.Float32FromFloat32(0.42496483),
	615:  -libc.Float32FromFloat32(0.42792484),
	616:  -libc.Float32FromFloat32(0.43088027),
	617:  -libc.Float32FromFloat32(0.43383109),
	618:  -libc.Float32FromFloat32(0.43677726),
	619:  -libc.Float32FromFloat32(0.43971875),
	620:  -libc.Float32FromFloat32(0.44265553),
	621:  -libc.Float32FromFloat32(0.44558757),
	622:  -libc.Float32FromFloat32(0.44851484),
	623:  -libc.Float32FromFloat32(0.45143731),
	624:  -libc.Float32FromFloat32(0.45435494),
	625:  -libc.Float32FromFloat32(0.4572677),
	626:  -libc.Float32FromFloat32(0.46017557),
	627:  -libc.Float32FromFloat32(0.46307851),
	628:  -libc.Float32FromFloat32(0.4659765),
	629:  -libc.Float32FromFloat32(0.46886949),
	630:  -libc.Float32FromFloat32(0.47175746),
	631:  -libc.Float32FromFloat32(0.47464038),
	632:  -libc.Float32FromFloat32(0.47751821),
	633:  -libc.Float32FromFloat32(0.48039093),
	634:  -libc.Float32FromFloat32(0.48325851),
	635:  -libc.Float32FromFloat32(0.48612091),
	636:  -libc.Float32FromFloat32(0.48897811),
	637:  -libc.Float32FromFloat32(0.49183006),
	638:  -libc.Float32FromFloat32(0.49467676),
	639:  -libc.Float32FromFloat32(0.49751815),
	640:  -libc.Float32FromFloat32(0.50035422),
	641:  -libc.Float32FromFloat32(0.50318492),
	642:  -libc.Float32FromFloat32(0.50601024),
	643:  -libc.Float32FromFloat32(0.50883014),
	644:  -libc.Float32FromFloat32(0.51164459),
	645:  -libc.Float32FromFloat32(0.51445356),
	646:  -libc.Float32FromFloat32(0.51725703),
	647:  -libc.Float32FromFloat32(0.52005495),
	648:  -libc.Float32FromFloat32(0.5228473),
	649:  -libc.Float32FromFloat32(0.52563406),
	650:  -libc.Float32FromFloat32(0.52841518),
	651:  -libc.Float32FromFloat32(0.53119065),
	652:  -libc.Float32FromFloat32(0.53396043),
	653:  -libc.Float32FromFloat32(0.53672449),
	654:  -libc.Float32FromFloat32(0.5394828),
	655:  -libc.Float32FromFloat32(0.54223533),
	656:  -libc.Float32FromFloat32(0.54498206),
	657:  -libc.Float32FromFloat32(0.54772295),
	658:  -libc.Float32FromFloat32(0.55045797),
	659:  -libc.Float32FromFloat32(0.5531871),
	660:  -libc.Float32FromFloat32(0.55591031),
	661:  -libc.Float32FromFloat32(0.55862756),
	662:  -libc.Float32FromFloat32(0.56133883),
	663:  -libc.Float32FromFloat32(0.56404409),
	664:  -libc.Float32FromFloat32(0.56674331),
	665:  -libc.Float32FromFloat32(0.56943646),
	666:  -libc.Float32FromFloat32(0.57212351),
	667:  -libc.Float32FromFloat32(0.57480443),
	668:  -libc.Float32FromFloat32(0.5774792),
	669:  -libc.Float32FromFloat32(0.58014778),
	670:  -libc.Float32FromFloat32(0.58281015),
	671:  -libc.Float32FromFloat32(0.58546628),
	672:  -libc.Float32FromFloat32(0.58811614),
	673:  -libc.Float32FromFloat32(0.5907597),
	674:  -libc.Float32FromFloat32(0.59339694),
	675:  -libc.Float32FromFloat32(0.59602782),
	676:  -libc.Float32FromFloat32(0.59865231),
	677:  -libc.Float32FromFloat32(0.6012704),
	678:  -libc.Float32FromFloat32(0.60388204),
	679:  -libc.Float32FromFloat32(0.60648722),
	680:  -libc.Float32FromFloat32(0.60908591),
	681:  -libc.Float32FromFloat32(0.61167807),
	682:  -libc.Float32FromFloat32(0.61426368),
	683:  -libc.Float32FromFloat32(0.61684271),
	684:  -libc.Float32FromFloat32(0.61941514),
	685:  -libc.Float32FromFloat32(0.62198093),
	686:  -libc.Float32FromFloat32(0.62454007),
	687:  -libc.Float32FromFloat32(0.62709251),
	688:  -libc.Float32FromFloat32(0.62963824),
	689:  -libc.Float32FromFloat32(0.63217722),
	690:  -libc.Float32FromFloat32(0.63470944),
	691:  -libc.Float32FromFloat32(0.63723486),
	692:  -libc.Float32FromFloat32(0.63975345),
	693:  -libc.Float32FromFloat32(0.64226519),
	694:  -libc.Float32FromFloat32(0.64477006),
	695:  -libc.Float32FromFloat32(0.64726802),
	696:  -libc.Float32FromFloat32(0.64975905),
	697:  -libc.Float32FromFloat32(0.65224312),
	698:  -libc.Float32FromFloat32(0.6547202),
	699:  -libc.Float32FromFloat32(0.65719027),
	700:  -libc.Float32FromFloat32(0.65965331),
	701:  -libc.Float32FromFloat32(0.66210928),
	702:  -libc.Float32FromFloat32(0.66455816),
	703:  -libc.Float32FromFloat32(0.66699992),
	704:  -libc.Float32FromFloat32(0.66943454),
	705:  -libc.Float32FromFloat32(0.67186199),
	706:  -libc.Float32FromFloat32(0.67428225),
	707:  -libc.Float32FromFloat32(0.67669528),
	708:  -libc.Float32FromFloat32(0.67910107),
	709:  -libc.Float32FromFloat32(0.68149959),
	710:  -libc.Float32FromFloat32(0.6838908),
	711:  -libc.Float32FromFloat32(0.6862747),
	712:  -libc.Float32FromFloat32(0.68865124),
	713:  -libc.Float32FromFloat32(0.69102041),
	714:  -libc.Float32FromFloat32(0.69338218),
	715:  -libc.Float32FromFloat32(0.69573652),
	716:  -libc.Float32FromFloat32(0.69808341),
	717:  -libc.Float32FromFloat32(0.70042283),
	718:  -libc.Float32FromFloat32(0.70275474),
	719:  -libc.Float32FromFloat32(0.70507913),
	720:  -libc.Float32FromFloat32(0.70739597),
	721:  -libc.Float32FromFloat32(0.70970524),
	722:  -libc.Float32FromFloat32(0.7120069),
	723:  -libc.Float32FromFloat32(0.71430093),
	724:  -libc.Float32FromFloat32(0.71658732),
	725:  -libc.Float32FromFloat32(0.71886604),
	726:  -libc.Float32FromFloat32(0.72113705),
	727:  -libc.Float32FromFloat32(0.72340034),
	728:  -libc.Float32FromFloat32(0.72565589),
	729:  -libc.Float32FromFloat32(0.72790366),
	730:  -libc.Float32FromFloat32(0.73014364),
	731:  -libc.Float32FromFloat32(0.7323758),
	732:  -libc.Float32FromFloat32(0.73460012),
	733:  -libc.Float32FromFloat32(0.73681657),
	734:  -libc.Float32FromFloat32(0.73902513),
	735:  -libc.Float32FromFloat32(0.74122577),
	736:  -libc.Float32FromFloat32(0.74341848),
	737:  -libc.Float32FromFloat32(0.74560322),
	738:  -libc.Float32FromFloat32(0.74777998),
	739:  -libc.Float32FromFloat32(0.74994874),
	740:  -libc.Float32FromFloat32(0.75210946),
	741:  -libc.Float32FromFloat32(0.75426212),
	742:  -libc.Float32FromFloat32(0.75640671),
	743:  -libc.Float32FromFloat32(0.7585432),
	744:  -libc.Float32FromFloat32(0.76067157),
	745:  -libc.Float32FromFloat32(0.76279178),
	746:  -libc.Float32FromFloat32(0.76490383),
	747:  -libc.Float32FromFloat32(0.76700769),
	748:  -libc.Float32FromFloat32(0.76910334),
	749:  -libc.Float32FromFloat32(0.77119075),
	750:  -libc.Float32FromFloat32(0.77326989),
	751:  -libc.Float32FromFloat32(0.77534076),
	752:  -libc.Float32FromFloat32(0.77740333),
	753:  -libc.Float32FromFloat32(0.77945757),
	754:  -libc.Float32FromFloat32(0.78150346),
	755:  -libc.Float32FromFloat32(0.78354098),
	756:  -libc.Float32FromFloat32(0.78557011),
	757:  -libc.Float32FromFloat32(0.78759083),
	758:  -libc.Float32FromFloat32(0.78960312),
	759:  -libc.Float32FromFloat32(0.79160694),
	760:  -libc.Float32FromFloat32(0.79360229),
	761:  -libc.Float32FromFloat32(0.79558915),
	762:  -libc.Float32FromFloat32(0.79756748),
	763:  -libc.Float32FromFloat32(0.79953727),
	764:  -libc.Float32FromFloat32(0.8014985),
	765:  -libc.Float32FromFloat32(0.80345114),
	766:  -libc.Float32FromFloat32(0.80539518),
	767:  -libc.Float32FromFloat32(0.8073306),
	768:  -libc.Float32FromFloat32(0.80925737),
	769:  -libc.Float32FromFloat32(0.81117547),
	770:  -libc.Float32FromFloat32(0.81308489),
	771:  -libc.Float32FromFloat32(0.81498559),
	772:  -libc.Float32FromFloat32(0.81687757),
	773:  -libc.Float32FromFloat32(0.81876081),
	774:  -libc.Float32FromFloat32(0.82063527),
	775:  -libc.Float32FromFloat32(0.82250095),
	776:  -libc.Float32FromFloat32(0.82435781),
	777:  -libc.Float32FromFloat32(0.82620585),
	778:  -libc.Float32FromFloat32(0.82804505),
	779:  -libc.Float32FromFloat32(0.82987537),
	780:  -libc.Float32FromFloat32(0.83169681),
	781:  -libc.Float32FromFloat32(0.83350933),
	782:  -libc.Float32FromFloat32(0.83531294),
	783:  -libc.Float32FromFloat32(0.8371076),
	784:  -libc.Float32FromFloat32(0.83889329),
	785:  -libc.Float32FromFloat32(0.84067),
	786:  -libc.Float32FromFloat32(0.8424377),
	787:  -libc.Float32FromFloat32(0.84419639),
	788:  -libc.Float32FromFloat32(0.84594603),
	789:  -libc.Float32FromFloat32(0.84768662),
	790:  -libc.Float32FromFloat32(0.84941812),
	791:  -libc.Float32FromFloat32(0.85114053),
	792:  -libc.Float32FromFloat32(0.85285383),
	793:  -libc.Float32FromFloat32(0.85455799),
	794:  -libc.Float32FromFloat32(0.856253),
	795:  -libc.Float32FromFloat32(0.85793884),
	796:  -libc.Float32FromFloat32(0.85961549),
	797:  -libc.Float32FromFloat32(0.86128294),
	798:  -libc.Float32FromFloat32(0.86294116),
	799:  -libc.Float32FromFloat32(0.86459014),
	800:  -libc.Float32FromFloat32(0.86622986),
	801:  -libc.Float32FromFloat32(0.86786031),
	802:  -libc.Float32FromFloat32(0.86948146),
	803:  -libc.Float32FromFloat32(0.8710933),
	804:  -libc.Float32FromFloat32(0.87269581),
	805:  -libc.Float32FromFloat32(0.87428898),
	806:  -libc.Float32FromFloat32(0.87587278),
	807:  -libc.Float32FromFloat32(0.8774472),
	808:  -libc.Float32FromFloat32(0.87901223),
	809:  -libc.Float32FromFloat32(0.88056784),
	810:  -libc.Float32FromFloat32(0.88211402),
	811:  -libc.Float32FromFloat32(0.88365076),
	812:  -libc.Float32FromFloat32(0.88517803),
	813:  -libc.Float32FromFloat32(0.88669582),
	814:  -libc.Float32FromFloat32(0.88820412),
	815:  -libc.Float32FromFloat32(0.8897029),
	816:  -libc.Float32FromFloat32(0.89119216),
	817:  -libc.Float32FromFloat32(0.89267187),
	818:  -libc.Float32FromFloat32(0.89414203),
	819:  -libc.Float32FromFloat32(0.8956026),
	820:  -libc.Float32FromFloat32(0.89705359),
	821:  -libc.Float32FromFloat32(0.89849497),
	822:  -libc.Float32FromFloat32(0.89992673),
	823:  -libc.Float32FromFloat32(0.90134885),
	824:  -libc.Float32FromFloat32(0.90276131),
	825:  -libc.Float32FromFloat32(0.90416411),
	826:  -libc.Float32FromFloat32(0.90555723),
	827:  -libc.Float32FromFloat32(0.90694065),
	828:  -libc.Float32FromFloat32(0.90831436),
	829:  -libc.Float32FromFloat32(0.90967833),
	830:  -libc.Float32FromFloat32(0.91103257),
	831:  -libc.Float32FromFloat32(0.91237705),
	832:  -libc.Float32FromFloat32(0.91371176),
	833:  -libc.Float32FromFloat32(0.91503669),
	834:  -libc.Float32FromFloat32(0.91635181),
	835:  -libc.Float32FromFloat32(0.91765712),
	836:  -libc.Float32FromFloat32(0.91895261),
	837:  -libc.Float32FromFloat32(0.92023825),
	838:  -libc.Float32FromFloat32(0.92151404),
	839:  -libc.Float32FromFloat32(0.92277996),
	840:  -libc.Float32FromFloat32(0.924036),
	841:  -libc.Float32FromFloat32(0.92528214),
	842:  -libc.Float32FromFloat32(0.92651837),
	843:  -libc.Float32FromFloat32(0.92774468),
	844:  -libc.Float32FromFloat32(0.92896106),
	845:  -libc.Float32FromFloat32(0.93016748),
	846:  -libc.Float32FromFloat32(0.93136395),
	847:  -libc.Float32FromFloat32(0.93255044),
	848:  -libc.Float32FromFloat32(0.93372694),
	849:  -libc.Float32FromFloat32(0.93489345),
	850:  -libc.Float32FromFloat32(0.93604994),
	851:  -libc.Float32FromFloat32(0.93719641),
	852:  -libc.Float32FromFloat32(0.93833284),
	853:  -libc.Float32FromFloat32(0.93945922),
	854:  -libc.Float32FromFloat32(0.94057555),
	855:  -libc.Float32FromFloat32(0.9416818),
	856:  -libc.Float32FromFloat32(0.94277796),
	857:  -libc.Float32FromFloat32(0.94386403),
	858:  -libc.Float32FromFloat32(0.94493999),
	859:  -libc.Float32FromFloat32(0.94600583),
	860:  -libc.Float32FromFloat32(0.94706154),
	861:  -libc.Float32FromFloat32(0.94810711),
	862:  -libc.Float32FromFloat32(0.94914252),
	863:  -libc.Float32FromFloat32(0.95016777),
	864:  -libc.Float32FromFloat32(0.95118284),
	865:  -libc.Float32FromFloat32(0.95218773),
	866:  -libc.Float32FromFloat32(0.95318242),
	867:  -libc.Float32FromFloat32(0.9541669),
	868:  -libc.Float32FromFloat32(0.95514117),
	869:  -libc.Float32FromFloat32(0.9561052),
	870:  -libc.Float32FromFloat32(0.957059),
	871:  -libc.Float32FromFloat32(0.95800255),
	872:  -libc.Float32FromFloat32(0.95893583),
	873:  -libc.Float32FromFloat32(0.95985885),
	874:  -libc.Float32FromFloat32(0.96077159),
	875:  -libc.Float32FromFloat32(0.96167404),
	876:  -libc.Float32FromFloat32(0.96256619),
	877:  -libc.Float32FromFloat32(0.96344803),
	878:  -libc.Float32FromFloat32(0.96431956),
	879:  -libc.Float32FromFloat32(0.96518076),
	880:  -libc.Float32FromFloat32(0.96603162),
	881:  -libc.Float32FromFloat32(0.96687213),
	882:  -libc.Float32FromFloat32(0.9677023),
	883:  -libc.Float32FromFloat32(0.96852209),
	884:  -libc.Float32FromFloat32(0.96933152),
	885:  -libc.Float32FromFloat32(0.97013057),
	886:  -libc.Float32FromFloat32(0.97091922),
	887:  -libc.Float32FromFloat32(0.97169748),
	888:  -libc.Float32FromFloat32(0.97246533),
	889:  -libc.Float32FromFloat32(0.97322277),
	890:  -libc.Float32FromFloat32(0.97396979),
	891:  -libc.Float32FromFloat32(0.97470637),
	892:  -libc.Float32FromFloat32(0.97543252),
	893:  -libc.Float32FromFloat32(0.97614822),
	894:  -libc.Float32FromFloat32(0.97685347),
	895:  -libc.Float32FromFloat32(0.97754825),
	896:  -libc.Float32FromFloat32(0.97823257),
	897:  -libc.Float32FromFloat32(0.97890641),
	898:  -libc.Float32FromFloat32(0.97956977),
	899:  -libc.Float32FromFloat32(0.98022263),
	900:  -libc.Float32FromFloat32(0.980865),
	901:  -libc.Float32FromFloat32(0.98149687),
	902:  -libc.Float32FromFloat32(0.98211822),
	903:  -libc.Float32FromFloat32(0.98272906),
	904:  -libc.Float32FromFloat32(0.98332937),
	905:  -libc.Float32FromFloat32(0.98391915),
	906:  -libc.Float32FromFloat32(0.9844984),
	907:  -libc.Float32FromFloat32(0.9850671),
	908:  -libc.Float32FromFloat32(0.98562525),
	909:  -libc.Float32FromFloat32(0.98617285),
	910:  -libc.Float32FromFloat32(0.98670988),
	911:  -libc.Float32FromFloat32(0.98723635),
	912:  -libc.Float32FromFloat32(0.98775225),
	913:  -libc.Float32FromFloat32(0.98825757),
	914:  -libc.Float32FromFloat32(0.9887523),
	915:  -libc.Float32FromFloat32(0.98923645),
	916:  -libc.Float32FromFloat32(0.98971),
	917:  -libc.Float32FromFloat32(0.99017295),
	918:  -libc.Float32FromFloat32(0.9906253),
	919:  -libc.Float32FromFloat32(0.99106704),
	920:  -libc.Float32FromFloat32(0.99149817),
	921:  -libc.Float32FromFloat32(0.99191868),
	922:  -libc.Float32FromFloat32(0.99232857),
	923:  -libc.Float32FromFloat32(0.99272783),
	924:  -libc.Float32FromFloat32(0.99311645),
	925:  -libc.Float32FromFloat32(0.99349445),
	926:  -libc.Float32FromFloat32(0.9938618),
	927:  -libc.Float32FromFloat32(0.99421851),
	928:  -libc.Float32FromFloat32(0.99456457),
	929:  -libc.Float32FromFloat32(0.99489998),
	930:  -libc.Float32FromFloat32(0.99522474),
	931:  -libc.Float32FromFloat32(0.99553884),
	932:  -libc.Float32FromFloat32(0.99584227),
	933:  -libc.Float32FromFloat32(0.99613505),
	934:  -libc.Float32FromFloat32(0.99641715),
	935:  -libc.Float32FromFloat32(0.99668858),
	936:  -libc.Float32FromFloat32(0.99694934),
	937:  -libc.Float32FromFloat32(0.99719943),
	938:  -libc.Float32FromFloat32(0.99743883),
	939:  -libc.Float32FromFloat32(0.99766756),
	940:  -libc.Float32FromFloat32(0.99788559),
	941:  -libc.Float32FromFloat32(0.99809295),
	942:  -libc.Float32FromFloat32(0.99828961),
	943:  -libc.Float32FromFloat32(0.99847558),
	944:  -libc.Float32FromFloat32(0.99865086),
	945:  -libc.Float32FromFloat32(0.99881544),
	946:  -libc.Float32FromFloat32(0.99896933),
	947:  -libc.Float32FromFloat32(0.99911252),
	948:  -libc.Float32FromFloat32(0.99924501),
	949:  -libc.Float32FromFloat32(0.9993668),
	950:  -libc.Float32FromFloat32(0.99947789),
	951:  -libc.Float32FromFloat32(0.99957827),
	952:  -libc.Float32FromFloat32(0.99966795),
	953:  -libc.Float32FromFloat32(0.99974692),
	954:  -libc.Float32FromFloat32(0.99981519),
	955:  -libc.Float32FromFloat32(0.99987275),
	956:  -libc.Float32FromFloat32(0.9999196),
	957:  -libc.Float32FromFloat32(0.99995574),
	958:  -libc.Float32FromFloat32(0.99998118),
	959:  -libc.Float32FromFloat32(0.9999959),
	960:  libc.Float32FromFloat32(0.99999967),
	961:  libc.Float32FromFloat32(0.99997289),
	962:  libc.Float32FromFloat32(0.99990328),
	963:  libc.Float32FromFloat32(0.99979084),
	964:  libc.Float32FromFloat32(0.99963557),
	965:  libc.Float32FromFloat32(0.99943748),
	966:  libc.Float32FromFloat32(0.99919658),
	967:  libc.Float32FromFloat32(0.99891288),
	968:  libc.Float32FromFloat32(0.99858638),
	969:  libc.Float32FromFloat32(0.99821711),
	970:  libc.Float32FromFloat32(0.99780508),
	971:  libc.Float32FromFloat32(0.99735031),
	972:  libc.Float32FromFloat32(0.99685281),
	973:  libc.Float32FromFloat32(0.99631261),
	974:  libc.Float32FromFloat32(0.99572973),
	975:  libc.Float32FromFloat32(0.9951042),
	976:  libc.Float32FromFloat32(0.99443605),
	977:  libc.Float32FromFloat32(0.99372529),
	978:  libc.Float32FromFloat32(0.99297196),
	979:  libc.Float32FromFloat32(0.9921761),
	980:  libc.Float32FromFloat32(0.99133774),
	981:  libc.Float32FromFloat32(0.99045692),
	982:  libc.Float32FromFloat32(0.98953366),
	983:  libc.Float32FromFloat32(0.98856802),
	984:  libc.Float32FromFloat32(0.98756003),
	985:  libc.Float32FromFloat32(0.98650973),
	986:  libc.Float32FromFloat32(0.98541718),
	987:  libc.Float32FromFloat32(0.98428242),
	988:  libc.Float32FromFloat32(0.98310549),
	989:  libc.Float32FromFloat32(0.98188645),
	990:  libc.Float32FromFloat32(0.98062534),
	991:  libc.Float32FromFloat32(0.97932224),
	992:  libc.Float32FromFloat32(0.97797718),
	993:  libc.Float32FromFloat32(0.97659022),
	994:  libc.Float32FromFloat32(0.97516144),
	995:  libc.Float32FromFloat32(0.97369088),
	996:  libc.Float32FromFloat32(0.97217861),
	997:  libc.Float32FromFloat32(0.97062469),
	998:  libc.Float32FromFloat32(0.9690292),
	999:  libc.Float32FromFloat32(0.9673922),
	1000: libc.Float32FromFloat32(0.96571376),
	1001: libc.Float32FromFloat32(0.96399395),
	1002: libc.Float32FromFloat32(0.96223284),
	1003: libc.Float32FromFloat32(0.96043052),
	1004: libc.Float32FromFloat32(0.95858705),
	1005: libc.Float32FromFloat32(0.95670253),
	1006: libc.Float32FromFloat32(0.95477702),
	1007: libc.Float32FromFloat32(0.95281061),
	1008: libc.Float32FromFloat32(0.95080338),
	1009: libc.Float32FromFloat32(0.94875543),
	1010: libc.Float32FromFloat32(0.94666684),
	1011: libc.Float32FromFloat32(0.94453769),
	1012: libc.Float32FromFloat32(0.94236808),
	1013: libc.Float32FromFloat32(0.9401581),
	1014: libc.Float32FromFloat32(0.93790786),
	1015: libc.Float32FromFloat32(0.93561743),
	1016: libc.Float32FromFloat32(0.93328693),
	1017: libc.Float32FromFloat32(0.93091644),
	1018: libc.Float32FromFloat32(0.92850608),
	1019: libc.Float32FromFloat32(0.92605595),
	1020: libc.Float32FromFloat32(0.92356614),
	1021: libc.Float32FromFloat32(0.92103677),
	1022: libc.Float32FromFloat32(0.91846795),
	1023: libc.Float32FromFloat32(0.91585979),
	1024: libc.Float32FromFloat32(0.91321239),
	1025: libc.Float32FromFloat32(0.91052587),
	1026: libc.Float32FromFloat32(0.90780035),
	1027: libc.Float32FromFloat32(0.90503595),
	1028: libc.Float32FromFloat32(0.90223277),
	1029: libc.Float32FromFloat32(0.89939095),
	1030: libc.Float32FromFloat32(0.89651059),
	1031: libc.Float32FromFloat32(0.89359184),
	1032: libc.Float32FromFloat32(0.89063481),
	1033: libc.Float32FromFloat32(0.88763962),
	1034: libc.Float32FromFloat32(0.88460641),
	1035: libc.Float32FromFloat32(0.88153531),
	1036: libc.Float32FromFloat32(0.87842644),
	1037: libc.Float32FromFloat32(0.87527995),
	1038: libc.Float32FromFloat32(0.87209596),
	1039: libc.Float32FromFloat32(0.86887462),
	1040: libc.Float32FromFloat32(0.86561605),
	1041: libc.Float32FromFloat32(0.86232041),
	1042: libc.Float32FromFloat32(0.85898782),
	1043: libc.Float32FromFloat32(0.85561844),
	1044: libc.Float32FromFloat32(0.85221241),
	1045: libc.Float32FromFloat32(0.84876987),
	1046: libc.Float32FromFloat32(0.84529098),
	1047: libc.Float32FromFloat32(0.84177587),
	1048: libc.Float32FromFloat32(0.83822471),
	1049: libc.Float32FromFloat32(0.83463763),
	1050: libc.Float32FromFloat32(0.83101481),
	1051: libc.Float32FromFloat32(0.82735639),
	1052: libc.Float32FromFloat32(0.82366252),
	1053: libc.Float32FromFloat32(0.81993338),
	1054: libc.Float32FromFloat32(0.81616911),
	1055: libc.Float32FromFloat32(0.81236987),
	1056: libc.Float32FromFloat32(0.80853584),
	1057: libc.Float32FromFloat32(0.80466718),
	1058: libc.Float32FromFloat32(0.80076404),
	1059: libc.Float32FromFloat32(0.7968266),
	1060: libc.Float32FromFloat32(0.79285503),
	1061: libc.Float32FromFloat32(0.7888495),
	1062: libc.Float32FromFloat32(0.78481017),
	1063: libc.Float32FromFloat32(0.78073723),
	1064: libc.Float32FromFloat32(0.77663084),
	1065: libc.Float32FromFloat32(0.77249118),
	1066: libc.Float32FromFloat32(0.76831844),
	1067: libc.Float32FromFloat32(0.76411277),
	1068: libc.Float32FromFloat32(0.75987438),
	1069: libc.Float32FromFloat32(0.75560344),
	1070: libc.Float32FromFloat32(0.75130013),
	1071: libc.Float32FromFloat32(0.74696464),
	1072: libc.Float32FromFloat32(0.74259715),
	1073: libc.Float32FromFloat32(0.73819784),
	1074: libc.Float32FromFloat32(0.73376692),
	1075: libc.Float32FromFloat32(0.72930457),
	1076: libc.Float32FromFloat32(0.72481097),
	1077: libc.Float32FromFloat32(0.72028632),
	1078: libc.Float32FromFloat32(0.71573083),
	1079: libc.Float32FromFloat32(0.71114467),
	1080: libc.Float32FromFloat32(0.70652804),
	1081: libc.Float32FromFloat32(0.70188116),
	1082: libc.Float32FromFloat32(0.6972042),
	1083: libc.Float32FromFloat32(0.69249738),
	1084: libc.Float32FromFloat32(0.6877609),
	1085: libc.Float32FromFloat32(0.68299495),
	1086: libc.Float32FromFloat32(0.67819975),
	1087: libc.Float32FromFloat32(0.6733755),
	1088: libc.Float32FromFloat32(0.6685224),
	1089: libc.Float32FromFloat32(0.66364066),
	1090: libc.Float32FromFloat32(0.6587305),
	1091: libc.Float32FromFloat32(0.65379211),
	1092: libc.Float32FromFloat32(0.64882573),
	1093: libc.Float32FromFloat32(0.64383154),
	1094: libc.Float32FromFloat32(0.63880978),
	1095: libc.Float32FromFloat32(0.63376065),
	1096: libc.Float32FromFloat32(0.62868438),
	1097: libc.Float32FromFloat32(0.62358117),
	1098: libc.Float32FromFloat32(0.61845126),
	1099: libc.Float32FromFloat32(0.61329485),
	1100: libc.Float32FromFloat32(0.60811216),
	1101: libc.Float32FromFloat32(0.60290343),
	1102: libc.Float32FromFloat32(0.59766888),
	1103: libc.Float32FromFloat32(0.59240872),
	1104: libc.Float32FromFloat32(0.58712318),
	1105: libc.Float32FromFloat32(0.58181249),
	1106: libc.Float32FromFloat32(0.57647688),
	1107: libc.Float32FromFloat32(0.57111658),
	1108: libc.Float32FromFloat32(0.56573181),
	1109: libc.Float32FromFloat32(0.56032281),
	1110: libc.Float32FromFloat32(0.5548898),
	1111: libc.Float32FromFloat32(0.54943303),
	1112: libc.Float32FromFloat32(0.54395272),
	1113: libc.Float32FromFloat32(0.53844911),
	1114: libc.Float32FromFloat32(0.53292243),
	1115: libc.Float32FromFloat32(0.52737292),
	1116: libc.Float32FromFloat32(0.52180083),
	1117: libc.Float32FromFloat32(0.51620638),
	1118: libc.Float32FromFloat32(0.51058981),
	1119: libc.Float32FromFloat32(0.50495138),
	1120: libc.Float32FromFloat32(0.49929132),
	1121: libc.Float32FromFloat32(0.49360987),
	1122: libc.Float32FromFloat32(0.48790727),
	1123: libc.Float32FromFloat32(0.48218377),
	1124: libc.Float32FromFloat32(0.47643962),
	1125: libc.Float32FromFloat32(0.47067506),
	1126: libc.Float32FromFloat32(0.46489034),
	1127: libc.Float32FromFloat32(0.4590857),
	1128: libc.Float32FromFloat32(0.45326139),
	1129: libc.Float32FromFloat32(0.44741768),
	1130: libc.Float32FromFloat32(0.44155479),
	1131: libc.Float32FromFloat32(0.43567299),
	1132: libc.Float32FromFloat32(0.42977253),
	1133: libc.Float32FromFloat32(0.42385365),
	1134: libc.Float32FromFloat32(0.41791662),
	1135: libc.Float32FromFloat32(0.41196169),
	1136: libc.Float32FromFloat32(0.40598911),
	1137: libc.Float32FromFloat32(0.39999914),
	1138: libc.Float32FromFloat32(0.39399204),
	1139: libc.Float32FromFloat32(0.38796806),
	1140: libc.Float32FromFloat32(0.38192746),
	1141: libc.Float32FromFloat32(0.3758705),
	1142: libc.Float32FromFloat32(0.36979743),
	1143: libc.Float32FromFloat32(0.36370853),
	1144: libc.Float32FromFloat32(0.35760405),
	1145: libc.Float32FromFloat32(0.35148424),
	1146: libc.Float32FromFloat32(0.34534939),
	1147: libc.Float32FromFloat32(0.33919973),
	1148: libc.Float32FromFloat32(0.33303555),
	1149: libc.Float32FromFloat32(0.3268571),
	1150: libc.Float32FromFloat32(0.32066465),
	1151: libc.Float32FromFloat32(0.31445847),
	1152: libc.Float32FromFloat32(0.30823881),
	1153: libc.Float32FromFloat32(0.30200595),
	1154: libc.Float32FromFloat32(0.29576015),
	1155: libc.Float32FromFloat32(0.28950169),
	1156: libc.Float32FromFloat32(0.28323082),
	1157: libc.Float32FromFloat32(0.27694782),
	1158: libc.Float32FromFloat32(0.27065295),
	1159: libc.Float32FromFloat32(0.26434649),
	1160: libc.Float32FromFloat32(0.25802871),
	1161: libc.Float32FromFloat32(0.25169988),
	1162: libc.Float32FromFloat32(0.24536026),
	1163: libc.Float32FromFloat32(0.23901013),
	1164: libc.Float32FromFloat32(0.23264977),
	1165: libc.Float32FromFloat32(0.22627944),
	1166: libc.Float32FromFloat32(0.21989941),
	1167: libc.Float32FromFloat32(0.21350997),
	1168: libc.Float32FromFloat32(0.20711138),
	1169: libc.Float32FromFloat32(0.20070391),
	1170: libc.Float32FromFloat32(0.19428785),
	1171: libc.Float32FromFloat32(0.18786347),
	1172: libc.Float32FromFloat32(0.18143104),
	1173: libc.Float32FromFloat32(0.17499084),
	1174: libc.Float32FromFloat32(0.16854314),
	1175: libc.Float32FromFloat32(0.16208822),
	1176: libc.Float32FromFloat32(0.15562636),
	1177: libc.Float32FromFloat32(0.14915783),
	1178: libc.Float32FromFloat32(0.14268292),
	1179: libc.Float32FromFloat32(0.13620189),
	1180: libc.Float32FromFloat32(0.12971502),
	1181: libc.Float32FromFloat32(0.1232226),
	1182: libc.Float32FromFloat32(0.11672491),
	1183: libc.Float32FromFloat32(0.11022221),
	1184: libc.Float32FromFloat32(0.10371479),
	1185: libc.Float32FromFloat32(0.097202924),
	1186: libc.Float32FromFloat32(0.090686897),
	1187: libc.Float32FromFloat32(0.084166986),
	1188: libc.Float32FromFloat32(0.077643468),
	1189: libc.Float32FromFloat32(0.071116625),
	1190: libc.Float32FromFloat32(0.064586736),
	1191: libc.Float32FromFloat32(0.05805408),
	1192: libc.Float32FromFloat32(0.051518937),
	1193: libc.Float32FromFloat32(0.044981587),
	1194: libc.Float32FromFloat32(0.03844231),
	1195: libc.Float32FromFloat32(0.031901387),
	1196: libc.Float32FromFloat32(0.025359097),
	1197: libc.Float32FromFloat32(0.018815721),
	1198: libc.Float32FromFloat32(0.012271538),
	1199: libc.Float32FromFloat32(0.0057268303),
	1200: -libc.Float32FromFloat32(0.000818123),
	1201: -libc.Float32FromFloat32(0.0073630412),
	1202: -libc.Float32FromFloat32(0.013907644),
	1203: -libc.Float32FromFloat32(0.020451651),
	1204: -libc.Float32FromFloat32(0.026994782),
	1205: -libc.Float32FromFloat32(0.033536757),
	1206: -libc.Float32FromFloat32(0.040077295),
	1207: -libc.Float32FromFloat32(0.046616116),
	1208: -libc.Float32FromFloat32(0.053152941),
	1209: -libc.Float32FromFloat32(0.059687488),
	1210: -libc.Float32FromFloat32(0.066219479),
	1211: -libc.Float32FromFloat32(0.072748633),
	1212: -libc.Float32FromFloat32(0.07927467),
	1213: -libc.Float32FromFloat32(0.085797312),
	1214: -libc.Float32FromFloat32(0.092316279),
	1215: -libc.Float32FromFloat32(0.098831291),
	1216: -libc.Float32FromFloat32(0.10534207),
	1217: -libc.Float32FromFloat32(0.11184834),
	1218: -libc.Float32FromFloat32(0.11834981),
	1219: -libc.Float32FromFloat32(0.12484622),
	1220: -libc.Float32FromFloat32(0.13133727),
	1221: -libc.Float32FromFloat32(0.1378227),
	1222: -libc.Float32FromFloat32(0.14430223),
	1223: -libc.Float32FromFloat32(0.15077558),
	1224: -libc.Float32FromFloat32(0.15724246),
	1225: -libc.Float32FromFloat32(0.16370261),
	1226: -libc.Float32FromFloat32(0.17015575),
	1227: -libc.Float32FromFloat32(0.1766016),
	1228: -libc.Float32FromFloat32(0.18303989),
	1229: -libc.Float32FromFloat32(0.18947033),
	1230: -libc.Float32FromFloat32(0.19589266),
	1231: -libc.Float32FromFloat32(0.2023066),
	1232: -libc.Float32FromFloat32(0.20871187),
	1233: -libc.Float32FromFloat32(0.2151082),
	1234: -libc.Float32FromFloat32(0.22149531),
	1235: -libc.Float32FromFloat32(0.22787294),
	1236: -libc.Float32FromFloat32(0.2342408),
	1237: -libc.Float32FromFloat32(0.24059864),
	1238: -libc.Float32FromFloat32(0.24694616),
	1239: -libc.Float32FromFloat32(0.25328311),
	1240: -libc.Float32FromFloat32(0.2596092),
	1241: -libc.Float32FromFloat32(0.26592418),
	1242: -libc.Float32FromFloat32(0.27222777),
	1243: -libc.Float32FromFloat32(0.27851969),
	1244: -libc.Float32FromFloat32(0.28479968),
	1245: -libc.Float32FromFloat32(0.29106748),
	1246: -libc.Float32FromFloat32(0.2973228),
	1247: -libc.Float32FromFloat32(0.30356539),
	1248: -libc.Float32FromFloat32(0.30979497),
	1249: -libc.Float32FromFloat32(0.31601129),
	1250: -libc.Float32FromFloat32(0.32221406),
	1251: -libc.Float32FromFloat32(0.32840304),
	1252: -libc.Float32FromFloat32(0.33457794),
	1253: -libc.Float32FromFloat32(0.34073852),
	1254: -libc.Float32FromFloat32(0.3468845),
	1255: -libc.Float32FromFloat32(0.35301562),
	1256: -libc.Float32FromFloat32(0.35913161),
	1257: -libc.Float32FromFloat32(0.36523223),
	1258: -libc.Float32FromFloat32(0.37131719),
	1259: -libc.Float32FromFloat32(0.37738626),
	1260: -libc.Float32FromFloat32(0.38343915),
	1261: -libc.Float32FromFloat32(0.38947562),
	1262: -libc.Float32FromFloat32(0.39549541),
	1263: -libc.Float32FromFloat32(0.40149825),
	1264: -libc.Float32FromFloat32(0.4074839),
	1265: -libc.Float32FromFloat32(0.41345209),
	1266: -libc.Float32FromFloat32(0.41940257),
	1267: -libc.Float32FromFloat32(0.42533508),
	1268: -libc.Float32FromFloat32(0.43124938),
	1269: -libc.Float32FromFloat32(0.4371452),
	1270: -libc.Float32FromFloat32(0.44302229),
	1271: -libc.Float32FromFloat32(0.44888041),
	1272: -libc.Float32FromFloat32(0.4547193),
	1273: -libc.Float32FromFloat32(0.46053871),
	1274: -libc.Float32FromFloat32(0.46633839),
	1275: -libc.Float32FromFloat32(0.4721181),
	1276: -libc.Float32FromFloat32(0.47787758),
	1277: -libc.Float32FromFloat32(0.48361659),
	1278: -libc.Float32FromFloat32(0.48933489),
	1279: -libc.Float32FromFloat32(0.49503222),
	1280: -libc.Float32FromFloat32(0.50070835),
	1281: -libc.Float32FromFloat32(0.50636303),
	1282: -libc.Float32FromFloat32(0.51199602),
	1283: -libc.Float32FromFloat32(0.51760707),
	1284: -libc.Float32FromFloat32(0.52319595),
	1285: -libc.Float32FromFloat32(0.52876243),
	1286: -libc.Float32FromFloat32(0.53430625),
	1287: -libc.Float32FromFloat32(0.53982718),
	1288: -libc.Float32FromFloat32(0.54532499),
	1289: -libc.Float32FromFloat32(0.55079944),
	1290: -libc.Float32FromFloat32(0.55625029),
	1291: -libc.Float32FromFloat32(0.56167732),
	1292: -libc.Float32FromFloat32(0.56708028),
	1293: -libc.Float32FromFloat32(0.57245896),
	1294: -libc.Float32FromFloat32(0.57781311),
	1295: -libc.Float32FromFloat32(0.58314251),
	1296: -libc.Float32FromFloat32(0.58844693),
	1297: -libc.Float32FromFloat32(0.59372614),
	1298: -libc.Float32FromFloat32(0.59897992),
	1299: -libc.Float32FromFloat32(0.60420805),
	1300: -libc.Float32FromFloat32(0.60941029),
	1301: -libc.Float32FromFloat32(0.61458642),
	1302: -libc.Float32FromFloat32(0.61973623),
	1303: -libc.Float32FromFloat32(0.62485949),
	1304: -libc.Float32FromFloat32(0.62995598),
	1305: -libc.Float32FromFloat32(0.63502549),
	1306: -libc.Float32FromFloat32(0.6400678),
	1307: -libc.Float32FromFloat32(0.64508268),
	1308: -libc.Float32FromFloat32(0.65006994),
	1309: -libc.Float32FromFloat32(0.65502934),
	1310: -libc.Float32FromFloat32(0.65996069),
	1311: -libc.Float32FromFloat32(0.66486377),
	1312: -libc.Float32FromFloat32(0.66973837),
	1313: -libc.Float32FromFloat32(0.67458427),
	1314: -libc.Float32FromFloat32(0.67940128),
	1315: -libc.Float32FromFloat32(0.68418919),
	1316: -libc.Float32FromFloat32(0.68894779),
	1317: -libc.Float32FromFloat32(0.69367688),
	1318: -libc.Float32FromFloat32(0.69837625),
	1319: -libc.Float32FromFloat32(0.70304571),
	1320: -libc.Float32FromFloat32(0.70768504),
	1321: -libc.Float32FromFloat32(0.71229407),
	1322: -libc.Float32FromFloat32(0.71687258),
	1323: -libc.Float32FromFloat32(0.72142039),
	1324: -libc.Float32FromFloat32(0.72593729),
	1325: -libc.Float32FromFloat32(0.73042309),
	1326: -libc.Float32FromFloat32(0.73487761),
	1327: -libc.Float32FromFloat32(0.73930064),
	1328: -libc.Float32FromFloat32(0.74369201),
	1329: -libc.Float32FromFloat32(0.74805152),
	1330: -libc.Float32FromFloat32(0.75237898),
	1331: -libc.Float32FromFloat32(0.75667422),
	1332: -libc.Float32FromFloat32(0.76093704),
	1333: -libc.Float32FromFloat32(0.76516727),
	1334: -libc.Float32FromFloat32(0.76936471),
	1335: -libc.Float32FromFloat32(0.77352921),
	1336: -libc.Float32FromFloat32(0.77766056),
	1337: -libc.Float32FromFloat32(0.78175861),
	1338: -libc.Float32FromFloat32(0.78582316),
	1339: -libc.Float32FromFloat32(0.78985406),
	1340: -libc.Float32FromFloat32(0.79385112),
	1341: -libc.Float32FromFloat32(0.79781417),
	1342: -libc.Float32FromFloat32(0.80174305),
	1343: -libc.Float32FromFloat32(0.80563758),
	1344: -libc.Float32FromFloat32(0.8094976),
	1345: -libc.Float32FromFloat32(0.81332295),
	1346: -libc.Float32FromFloat32(0.81711346),
	1347: -libc.Float32FromFloat32(0.82086896),
	1348: -libc.Float32FromFloat32(0.8245893),
	1349: -libc.Float32FromFloat32(0.82827432),
	1350: -libc.Float32FromFloat32(0.83192386),
	1351: -libc.Float32FromFloat32(0.83553776),
	1352: -libc.Float32FromFloat32(0.83911587),
	1353: -libc.Float32FromFloat32(0.84265803),
	1354: -libc.Float32FromFloat32(0.8461641),
	1355: -libc.Float32FromFloat32(0.84963392),
	1356: -libc.Float32FromFloat32(0.85306735),
	1357: -libc.Float32FromFloat32(0.85646423),
	1358: -libc.Float32FromFloat32(0.85982442),
	1359: -libc.Float32FromFloat32(0.86314779),
	1360: -libc.Float32FromFloat32(0.86643418),
	1361: -libc.Float32FromFloat32(0.86968345),
	1362: -libc.Float32FromFloat32(0.87289547),
	1363: -libc.Float32FromFloat32(0.87607009),
	1364: -libc.Float32FromFloat32(0.87920719),
	1365: -libc.Float32FromFloat32(0.88230663),
	1366: -libc.Float32FromFloat32(0.88536827),
	1367: -libc.Float32FromFloat32(0.88839199),
	1368: -libc.Float32FromFloat32(0.89137765),
	1369: -libc.Float32FromFloat32(0.89432512),
	1370: -libc.Float32FromFloat32(0.89723429),
	1371: -libc.Float32FromFloat32(0.90010502),
	1372: -libc.Float32FromFloat32(0.90293719),
	1373: -libc.Float32FromFloat32(0.90573069),
	1374: -libc.Float32FromFloat32(0.90848539),
	1375: -libc.Float32FromFloat32(0.91120117),
	1376: -libc.Float32FromFloat32(0.91387791),
	1377: -libc.Float32FromFloat32(0.91651551),
	1378: -libc.Float32FromFloat32(0.91911385),
	1379: -libc.Float32FromFloat32(0.92167282),
	1380: -libc.Float32FromFloat32(0.92419231),
	1381: -libc.Float32FromFloat32(0.9266722),
	1382: -libc.Float32FromFloat32(0.9291124),
	1383: -libc.Float32FromFloat32(0.9315128),
	1384: -libc.Float32FromFloat32(0.9338733),
	1385: -libc.Float32FromFloat32(0.9361938),
	1386: -libc.Float32FromFloat32(0.93847419),
	1387: -libc.Float32FromFloat32(0.94071438),
	1388: -libc.Float32FromFloat32(0.94291427),
	1389: -libc.Float32FromFloat32(0.94507377),
	1390: -libc.Float32FromFloat32(0.94719279),
	1391: -libc.Float32FromFloat32(0.94927123),
	1392: -libc.Float32FromFloat32(0.95130901),
	1393: -libc.Float32FromFloat32(0.95330604),
	1394: -libc.Float32FromFloat32(0.95526223),
	1395: -libc.Float32FromFloat32(0.9571775),
	1396: -libc.Float32FromFloat32(0.95905177),
	1397: -libc.Float32FromFloat32(0.96088496),
	1398: -libc.Float32FromFloat32(0.96267699),
	1399: -libc.Float32FromFloat32(0.96442777),
	1400: -libc.Float32FromFloat32(0.96613725),
	1401: -libc.Float32FromFloat32(0.96780534),
	1402: -libc.Float32FromFloat32(0.96943197),
	1403: -libc.Float32FromFloat32(0.97101707),
	1404: -libc.Float32FromFloat32(0.97256058),
	1405: -libc.Float32FromFloat32(0.97406243),
	1406: -libc.Float32FromFloat32(0.97552255),
	1407: -libc.Float32FromFloat32(0.97694089),
	1408: -libc.Float32FromFloat32(0.97831737),
	1409: -libc.Float32FromFloat32(0.97965195),
	1410: -libc.Float32FromFloat32(0.98094456),
	1411: -libc.Float32FromFloat32(0.98219515),
	1412: -libc.Float32FromFloat32(0.98340367),
	1413: -libc.Float32FromFloat32(0.98457006),
	1414: -libc.Float32FromFloat32(0.98569428),
	1415: -libc.Float32FromFloat32(0.98677627),
	1416: -libc.Float32FromFloat32(0.98781599),
	1417: -libc.Float32FromFloat32(0.9888134),
	1418: -libc.Float32FromFloat32(0.98976845),
	1419: -libc.Float32FromFloat32(0.9906811),
	1420: -libc.Float32FromFloat32(0.99155132),
	1421: -libc.Float32FromFloat32(0.99237906),
	1422: -libc.Float32FromFloat32(0.99316428),
	1423: -libc.Float32FromFloat32(0.99390697),
	1424: -libc.Float32FromFloat32(0.99460708),
	1425: -libc.Float32FromFloat32(0.99526458),
	1426: -libc.Float32FromFloat32(0.99587945),
	1427: -libc.Float32FromFloat32(0.99645166),
	1428: -libc.Float32FromFloat32(0.99698119),
	1429: -libc.Float32FromFloat32(0.99746801),
	1430: -libc.Float32FromFloat32(0.9979121),
	1431: -libc.Float32FromFloat32(0.99831344),
	1432: -libc.Float32FromFloat32(0.99867202),
	1433: -libc.Float32FromFloat32(0.99898782),
	1434: -libc.Float32FromFloat32(0.99926082),
	1435: -libc.Float32FromFloat32(0.99949102),
	1436: -libc.Float32FromFloat32(0.99967841),
	1437: -libc.Float32FromFloat32(0.99982297),
	1438: -libc.Float32FromFloat32(0.9999247),
	1439: -libc.Float32FromFloat32(0.9999836),
	1440: libc.Float32FromFloat32(0.99999866),
	1441: libc.Float32FromFloat32(0.99989157),
	1442: libc.Float32FromFloat32(0.99961315),
	1443: libc.Float32FromFloat32(0.99916346),
	1444: libc.Float32FromFloat32(0.99854256),
	1445: libc.Float32FromFloat32(0.99775057),
	1446: libc.Float32FromFloat32(0.99678762),
	1447: libc.Float32FromFloat32(0.99565388),
	1448: libc.Float32FromFloat32(0.99434953),
	1449: libc.Float32FromFloat32(0.99287481),
	1450: libc.Float32FromFloat32(0.99122996),
	1451: libc.Float32FromFloat32(0.98941527),
	1452: libc.Float32FromFloat32(0.98743105),
	1453: libc.Float32FromFloat32(0.98527764),
	1454: libc.Float32FromFloat32(0.98295541),
	1455: libc.Float32FromFloat32(0.98046475),
	1456: libc.Float32FromFloat32(0.9778061),
	1457: libc.Float32FromFloat32(0.9749799),
	1458: libc.Float32FromFloat32(0.97198664),
	1459: libc.Float32FromFloat32(0.96882685),
	1460: libc.Float32FromFloat32(0.96550104),
	1461: libc.Float32FromFloat32(0.9620098),
	1462: libc.Float32FromFloat32(0.95835373),
	1463: libc.Float32FromFloat32(0.95453345),
	1464: libc.Float32FromFloat32(0.95054962),
	1465: libc.Float32FromFloat32(0.94640291),
	1466: libc.Float32FromFloat32(0.94209404),
	1467: libc.Float32FromFloat32(0.93762375),
	1468: libc.Float32FromFloat32(0.9329928),
	1469: libc.Float32FromFloat32(0.92820199),
	1470: libc.Float32FromFloat32(0.92325213),
	1471: libc.Float32FromFloat32(0.91814408),
	1472: libc.Float32FromFloat32(0.91287871),
	1473: libc.Float32FromFloat32(0.90745693),
	1474: libc.Float32FromFloat32(0.90187965),
	1475: libc.Float32FromFloat32(0.89614785),
	1476: libc.Float32FromFloat32(0.89026249),
	1477: libc.Float32FromFloat32(0.88422459),
	1478: libc.Float32FromFloat32(0.87803519),
	1479: libc.Float32FromFloat32(0.87169533),
	1480: libc.Float32FromFloat32(0.86520612),
	1481: libc.Float32FromFloat32(0.85856866),
	1482: libc.Float32FromFloat32(0.85178409),
	1483: libc.Float32FromFloat32(0.84485357),
	1484: libc.Float32FromFloat32(0.83777828),
	1485: libc.Float32FromFloat32(0.83055945),
	1486: libc.Float32FromFloat32(0.82319831),
	1487: libc.Float32FromFloat32(0.81569611),
	1488: libc.Float32FromFloat32(0.80805415),
	1489: libc.Float32FromFloat32(0.80027373),
	1490: libc.Float32FromFloat32(0.7923562),
	1491: libc.Float32FromFloat32(0.78430289),
	1492: libc.Float32FromFloat32(0.7761152),
	1493: libc.Float32FromFloat32(0.76779452),
	1494: libc.Float32FromFloat32(0.75934229),
	1495: libc.Float32FromFloat32(0.75075995),
	1496: libc.Float32FromFloat32(0.74204897),
	1497: libc.Float32FromFloat32(0.73321084),
	1498: libc.Float32FromFloat32(0.72424708),
	1499: libc.Float32FromFloat32(0.71515923),
	1500: libc.Float32FromFloat32(0.70594883),
	1501: libc.Float32FromFloat32(0.69661748),
	1502: libc.Float32FromFloat32(0.68716676),
	1503: libc.Float32FromFloat32(0.6775983),
	1504: libc.Float32FromFloat32(0.66791374),
	1505: libc.Float32FromFloat32(0.65811474),
	1506: libc.Float32FromFloat32(0.64820297),
	1507: libc.Float32FromFloat32(0.63818013),
	1508: libc.Float32FromFloat32(0.62804795),
	1509: libc.Float32FromFloat32(0.61780815),
	1510: libc.Float32FromFloat32(0.60746249),
	1511: libc.Float32FromFloat32(0.59701275),
	1512: libc.Float32FromFloat32(0.58646072),
	1513: libc.Float32FromFloat32(0.57580819),
	1514: libc.Float32FromFloat32(0.56505701),
	1515: libc.Float32FromFloat32(0.554209),
	1516: libc.Float32FromFloat32(0.54326604),
	1517: libc.Float32FromFloat32(0.53222998),
	1518: libc.Float32FromFloat32(0.52110274),
	1519: libc.Float32FromFloat32(0.5098862),
	1520: libc.Float32FromFloat32(0.4985823),
	1521: libc.Float32FromFloat32(0.48719297),
	1522: libc.Float32FromFloat32(0.47572016),
	1523: libc.Float32FromFloat32(0.46416584),
	1524: libc.Float32FromFloat32(0.45253199),
	1525: libc.Float32FromFloat32(0.44082059),
	1526: libc.Float32FromFloat32(0.42903367),
	1527: libc.Float32FromFloat32(0.41717323),
	1528: libc.Float32FromFloat32(0.40524131),
	1529: libc.Float32FromFloat32(0.39323996),
	1530: libc.Float32FromFloat32(0.38117123),
	1531: libc.Float32FromFloat32(0.36903718),
	1532: libc.Float32FromFloat32(0.3568399),
	1533: libc.Float32FromFloat32(0.34458148),
	1534: libc.Float32FromFloat32(0.33226402),
	1535: libc.Float32FromFloat32(0.31988962),
	1536: libc.Float32FromFloat32(0.30746042),
	1537: libc.Float32FromFloat32(0.29497853),
	1538: libc.Float32FromFloat32(0.2824461),
	1539: libc.Float32FromFloat32(0.26986527),
	1540: libc.Float32FromFloat32(0.25723821),
	1541: libc.Float32FromFloat32(0.24456706),
	1542: libc.Float32FromFloat32(0.23185402),
	1543: libc.Float32FromFloat32(0.21910124),
	1544: libc.Float32FromFloat32(0.20631092),
	1545: libc.Float32FromFloat32(0.19348526),
	1546: libc.Float32FromFloat32(0.18062644),
	1547: libc.Float32FromFloat32(0.16773667),
	1548: libc.Float32FromFloat32(0.15481816),
	1549: libc.Float32FromFloat32(0.14187312),
	1550: libc.Float32FromFloat32(0.12890377),
	1551: libc.Float32FromFloat32(0.11591234),
	1552: libc.Float32FromFloat32(0.10290104),
	1553: libc.Float32FromFloat32(0.089872115),
	1554: libc.Float32FromFloat32(0.076827789),
	1555: libc.Float32FromFloat32(0.0637703),
	1556: libc.Float32FromFloat32(0.050701883),
	1557: libc.Float32FromFloat32(0.037624779),
	1558: libc.Float32FromFloat32(0.024541229),
	1559: libc.Float32FromFloat32(0.011453473),
	1560: -libc.Float32FromFloat32(0.0016362454),
	1561: -libc.Float32FromFloat32(0.014725683),
	1562: -libc.Float32FromFloat32(0.027812598),
	1563: -libc.Float32FromFloat32(0.040894747),
	1564: -libc.Float32FromFloat32(0.053969889),
	1565: -libc.Float32FromFloat32(0.067035784),
	1566: -libc.Float32FromFloat32(0.080090192),
	1567: -libc.Float32FromFloat32(0.093130877),
	1568: -libc.Float32FromFloat32(0.10615561),
	1569: -libc.Float32FromFloat32(0.11916214),
	1570: -libc.Float32FromFloat32(0.13214826),
	1571: -libc.Float32FromFloat32(0.14511174),
	1572: -libc.Float32FromFloat32(0.15805036),
	1573: -libc.Float32FromFloat32(0.17096189),
	1574: -libc.Float32FromFloat32(0.18384413),
	1575: -libc.Float32FromFloat32(0.19669487),
	1576: -libc.Float32FromFloat32(0.2095119),
	1577: -libc.Float32FromFloat32(0.22229304),
	1578: -libc.Float32FromFloat32(0.23503609),
	1579: -libc.Float32FromFloat32(0.24773886),
	1580: -libc.Float32FromFloat32(0.26039919),
	1581: -libc.Float32FromFloat32(0.2730149),
	1582: -libc.Float32FromFloat32(0.28558383),
	1583: -libc.Float32FromFloat32(0.29810383),
	1584: -libc.Float32FromFloat32(0.31057274),
	1585: -libc.Float32FromFloat32(0.32298845),
	1586: -libc.Float32FromFloat32(0.33534881),
	1587: -libc.Float32FromFloat32(0.34765171),
	1588: -libc.Float32FromFloat32(0.35989504),
	1589: -libc.Float32FromFloat32(0.3720767),
	1590: -libc.Float32FromFloat32(0.38419461),
	1591: -libc.Float32FromFloat32(0.3962467),
	1592: -libc.Float32FromFloat32(0.40823088),
	1593: -libc.Float32FromFloat32(0.42014512),
	1594: -libc.Float32FromFloat32(0.43198737),
	1595: -libc.Float32FromFloat32(0.4437556),
	1596: -libc.Float32FromFloat32(0.4554478),
	1597: -libc.Float32FromFloat32(0.46706195),
	1598: -libc.Float32FromFloat32(0.47859608),
	1599: -libc.Float32FromFloat32(0.49004821),
	1600: -libc.Float32FromFloat32(0.50141636),
	1601: -libc.Float32FromFloat32(0.5126986),
	1602: -libc.Float32FromFloat32(0.52389299),
	1603: -libc.Float32FromFloat32(0.53499762),
	1604: -libc.Float32FromFloat32(0.54601058),
	1605: -libc.Float32FromFloat32(0.55692998),
	1606: -libc.Float32FromFloat32(0.56775395),
	1607: -libc.Float32FromFloat32(0.57848064),
	1608: -libc.Float32FromFloat32(0.58910822),
	1609: -libc.Float32FromFloat32(0.59963485),
	1610: -libc.Float32FromFloat32(0.61005873),
	1611: -libc.Float32FromFloat32(0.62037809),
	1612: -libc.Float32FromFloat32(0.63059115),
	1613: -libc.Float32FromFloat32(0.64069616),
	1614: -libc.Float32FromFloat32(0.65069139),
	1615: -libc.Float32FromFloat32(0.66057513),
	1616: -libc.Float32FromFloat32(0.67034568),
	1617: -libc.Float32FromFloat32(0.68000137),
	1618: -libc.Float32FromFloat32(0.68954054),
	1619: -libc.Float32FromFloat32(0.69896157),
	1620: -libc.Float32FromFloat32(0.70826283),
	1621: -libc.Float32FromFloat32(0.71744274),
	1622: -libc.Float32FromFloat32(0.72649972),
	1623: -libc.Float32FromFloat32(0.73543221),
	1624: -libc.Float32FromFloat32(0.74423869),
	1625: -libc.Float32FromFloat32(0.75291765),
	1626: -libc.Float32FromFloat32(0.7614676),
	1627: -libc.Float32FromFloat32(0.76988708),
	1628: -libc.Float32FromFloat32(0.77817464),
	1629: -libc.Float32FromFloat32(0.78632887),
	1630: -libc.Float32FromFloat32(0.79434836),
	1631: -libc.Float32FromFloat32(0.80223175),
	1632: -libc.Float32FromFloat32(0.80997767),
	1633: -libc.Float32FromFloat32(0.81758481),
	1634: -libc.Float32FromFloat32(0.82505187),
	1635: -libc.Float32FromFloat32(0.83237755),
	1636: -libc.Float32FromFloat32(0.83956061),
	1637: -libc.Float32FromFloat32(0.84659981),
	1638: -libc.Float32FromFloat32(0.85349396),
	1639: -libc.Float32FromFloat32(0.86024186),
	1640: -libc.Float32FromFloat32(0.86684237),
	1641: -libc.Float32FromFloat32(0.87329434),
	1642: -libc.Float32FromFloat32(0.87959669),
	1643: -libc.Float32FromFloat32(0.88574831),
	1644: -libc.Float32FromFloat32(0.89174817),
	1645: -libc.Float32FromFloat32(0.89759523),
	1646: -libc.Float32FromFloat32(0.9032885),
	1647: -libc.Float32FromFloat32(0.90882699),
	1648: -libc.Float32FromFloat32(0.91420976),
	1649: -libc.Float32FromFloat32(0.91943588),
	1650: -libc.Float32FromFloat32(0.92450446),
	1651: -libc.Float32FromFloat32(0.92941463),
	1652: -libc.Float32FromFloat32(0.93416555),
	1653: -libc.Float32FromFloat32(0.93875641),
	1654: -libc.Float32FromFloat32(0.94318642),
	1655: -libc.Float32FromFloat32(0.94745482),
	1656: -libc.Float32FromFloat32(0.95156087),
	1657: -libc.Float32FromFloat32(0.95550388),
	1658: -libc.Float32FromFloat32(0.95928317),
	1659: -libc.Float32FromFloat32(0.96289809),
	1660: -libc.Float32FromFloat32(0.96634802),
	1661: -libc.Float32FromFloat32(0.96963238),
	1662: -libc.Float32FromFloat32(0.97275059),
	1663: -libc.Float32FromFloat32(0.97570213),
	1664: -libc.Float32FromFloat32(0.97848649),
	1665: -libc.Float32FromFloat32(0.98110318),
	1666: -libc.Float32FromFloat32(0.98355177),
	1667: -libc.Float32FromFloat32(0.98583184),
	1668: -libc.Float32FromFloat32(0.98794298),
	1669: -libc.Float32FromFloat32(0.98988485),
	1670: -libc.Float32FromFloat32(0.99165711),
	1671: -libc.Float32FromFloat32(0.99325945),
	1672: -libc.Float32FromFloat32(0.9946916),
	1673: -libc.Float32FromFloat32(0.99595331),
	1674: -libc.Float32FromFloat32(0.99704438),
	1675: -libc.Float32FromFloat32(0.9979646),
	1676: -libc.Float32FromFloat32(0.99871383),
	1677: -libc.Float32FromFloat32(0.99929194),
	1678: -libc.Float32FromFloat32(0.99969882),
	1679: -libc.Float32FromFloat32(0.99993441),
	1680: libc.Float32FromFloat32(0.99999465),
	1681: libc.Float32FromFloat32(0.99956631),
	1682: libc.Float32FromFloat32(0.99845292),
	1683: libc.Float32FromFloat32(0.99665524),
	1684: libc.Float32FromFloat32(0.9941745),
	1685: libc.Float32FromFloat32(0.99101241),
	1686: libc.Float32FromFloat32(0.98717112),
	1687: libc.Float32FromFloat32(0.98265328),
	1688: libc.Float32FromFloat32(0.97746197),
	1689: libc.Float32FromFloat32(0.97160077),
	1690: libc.Float32FromFloat32(0.96507367),
	1691: libc.Float32FromFloat32(0.95788516),
	1692: libc.Float32FromFloat32(0.95004017),
	1693: libc.Float32FromFloat32(0.94154407),
	1694: libc.Float32FromFloat32(0.93240267),
	1695: libc.Float32FromFloat32(0.92262226),
	1696: libc.Float32FromFloat32(0.91220953),
	1697: libc.Float32FromFloat32(0.90117161),
	1698: libc.Float32FromFloat32(0.88951608),
	1699: libc.Float32FromFloat32(0.87725091),
	1700: libc.Float32FromFloat32(0.86438452),
	1701: libc.Float32FromFloat32(0.85092573),
	1702: libc.Float32FromFloat32(0.83688375),
	1703: libc.Float32FromFloat32(0.82226822),
	1704: libc.Float32FromFloat32(0.80708914),
	1705: libc.Float32FromFloat32(0.79135693),
	1706: libc.Float32FromFloat32(0.77508236),
	1707: libc.Float32FromFloat32(0.75827658),
	1708: libc.Float32FromFloat32(0.74095113),
	1709: libc.Float32FromFloat32(0.72311786),
	1710: libc.Float32FromFloat32(0.704789),
	1711: libc.Float32FromFloat32(0.68597711),
	1712: libc.Float32FromFloat32(0.66669509),
	1713: libc.Float32FromFloat32(0.64695615),
	1714: libc.Float32FromFloat32(0.62677382),
	1715: libc.Float32FromFloat32(0.60616193),
	1716: libc.Float32FromFloat32(0.58513461),
	1717: libc.Float32FromFloat32(0.56370626),
	1718: libc.Float32FromFloat32(0.54189158),
	1719: libc.Float32FromFloat32(0.51970551),
	1720: libc.Float32FromFloat32(0.49716327),
	1721: libc.Float32FromFloat32(0.47428029),
	1722: libc.Float32FromFloat32(0.45107226),
	1723: libc.Float32FromFloat32(0.42755509),
	1724: libc.Float32FromFloat32(0.4037449),
	1725: libc.Float32FromFloat32(0.379658),
	1726: libc.Float32FromFloat32(0.3553109),
	1727: libc.Float32FromFloat32(0.33072029),
	1728: libc.Float32FromFloat32(0.30590302),
	1729: libc.Float32FromFloat32(0.2808761),
	1730: libc.Float32FromFloat32(0.25565668),
	1731: libc.Float32FromFloat32(0.23026205),
	1732: libc.Float32FromFloat32(0.2047096),
	1733: libc.Float32FromFloat32(0.17901686),
	1734: libc.Float32FromFloat32(0.15320143),
	1735: libc.Float32FromFloat32(0.127281),
	1736: libc.Float32FromFloat32(0.10127334),
	1737: libc.Float32FromFloat32(0.075196277),
	1738: libc.Float32FromFloat32(0.049067674),
	1739: libc.Float32FromFloat32(0.022905443),
	1740: -libc.Float32FromFloat32(0.0032724865),
	1741: -libc.Float32FromFloat32(0.029448173),
	1742: -libc.Float32FromFloat32(0.055603678),
	1743: -libc.Float32FromFloat32(0.081721074),
	1744: -libc.Float32FromFloat32(0.10778246),
	1745: -libc.Float32FromFloat32(0.13376998),
	1746: -libc.Float32FromFloat32(0.15966582),
	1747: -libc.Float32FromFloat32(0.18545224),
	1748: -libc.Float32FromFloat32(0.21111155),
	1749: -libc.Float32FromFloat32(0.23662618),
	1750: -libc.Float32FromFloat32(0.26197864),
	1751: -libc.Float32FromFloat32(0.28715155),
	1752: -libc.Float32FromFloat32(0.31212766),
	1753: -libc.Float32FromFloat32(0.33688985),
	1754: -libc.Float32FromFloat32(0.36142116),
	1755: -libc.Float32FromFloat32(0.38570477),
	1756: -libc.Float32FromFloat32(0.40972403),
	1757: -libc.Float32FromFloat32(0.43346249),
	1758: -libc.Float32FromFloat32(0.45690388),
	1759: -libc.Float32FromFloat32(0.48003212),
	1760: -libc.Float32FromFloat32(0.50283138),
	1761: -libc.Float32FromFloat32(0.52528602),
	1762: -libc.Float32FromFloat32(0.54738066),
	1763: -libc.Float32FromFloat32(0.56910015),
	1764: -libc.Float32FromFloat32(0.5904296),
	1765: -libc.Float32FromFloat32(0.61135441),
	1766: -libc.Float32FromFloat32(0.63186022),
	1767: -libc.Float32FromFloat32(0.65193299),
	1768: -libc.Float32FromFloat32(0.67155895),
	1769: -libc.Float32FromFloat32(0.69072467),
	1770: -libc.Float32FromFloat32(0.70941699),
	1771: -libc.Float32FromFloat32(0.72762312),
	1772: -libc.Float32FromFloat32(0.74533057),
	1773: -libc.Float32FromFloat32(0.7625272),
	1774: -libc.Float32FromFloat32(0.77920124),
	1775: -libc.Float32FromFloat32(0.79534126),
	1776: -libc.Float32FromFloat32(0.81093618),
	1777: -libc.Float32FromFloat32(0.82597533),
	1778: -libc.Float32FromFloat32(0.8404484),
	1779: -libc.Float32FromFloat32(0.85434547),
	1780: -libc.Float32FromFloat32(0.86765701),
	1781: -libc.Float32FromFloat32(0.8803739),
	1782: -libc.Float32FromFloat32(0.89248743),
	1783: -libc.Float32FromFloat32(0.90398929),
	1784: -libc.Float32FromFloat32(0.91487161),
	1785: -libc.Float32FromFloat32(0.92512691),
	1786: -libc.Float32FromFloat32(0.93474818),
	1787: -libc.Float32FromFloat32(0.94372882),
	1788: -libc.Float32FromFloat32(0.95206268),
	1789: -libc.Float32FromFloat32(0.95974404),
	1790: -libc.Float32FromFloat32(0.96676764),
	1791: -libc.Float32FromFloat32(0.97312866),
	1792: -libc.Float32FromFloat32(0.97882275),
	1793: -libc.Float32FromFloat32(0.98384601),
	1794: -libc.Float32FromFloat32(0.98819498),
	1795: -libc.Float32FromFloat32(0.9918667),
	1796: -libc.Float32FromFloat32(0.99485864),
	1797: -libc.Float32FromFloat32(0.99716875),
	1798: -libc.Float32FromFloat32(0.99879546),
	1799: -libc.Float32FromFloat32(0.99973764),
}
var mode48000_960_120 = OpusT_OpusCustomMode{
	FFs:        int32(48000),
	Foverlap:   int32(120),
	FnbEBands:  int32(21),
	FeffEBands: int32(21),
	Fpreemph: [4]OpusT_opus_val16{
		0: libc.Float32FromFloat32(0.8500061),
		2: libc.Float32FromFloat32(1),
		3: libc.Float32FromFloat32(1),
	},
	FeBands:         uintptr(unsafe.Pointer(&eband5ms)),
	FmaxLM:          int32(3),
	FnbShortMdcts:   int32(8),
	FshortMdctSize:  int32(120),
	FnbAllocVectors: int32(11),
	FallocVectors:   uintptr(unsafe.Pointer(&band_allocation)),
	FlogN:           uintptr(unsafe.Pointer(&logN400)),
	Fwindow:         uintptr(unsafe.Pointer(&window120)),
	Fmdct: OpusT_mdct_lookup{
		Fn:        int32(1920),
		Fmaxshift: int32(3),
		Fkfft: [4]uintptr{
			0: uintptr(unsafe.Pointer(&fft_state48000_960_0)),
			1: uintptr(unsafe.Pointer(&fft_state48000_960_1)),
			2: uintptr(unsafe.Pointer(&fft_state48000_960_2)),
			3: uintptr(unsafe.Pointer(&fft_state48000_960_3)),
		},
		Ftrig: uintptr(unsafe.Pointer(&mdct_twiddles960)),
	},
	Fcache: OpusT_PulseCache{
		Fsize:  int32(392),
		Findex: uintptr(unsafe.Pointer(&cache_index50)),
		Fbits:  uintptr(unsafe.Pointer(&cache_bits50)),
		Fcaps:  uintptr(unsafe.Pointer(&cache_caps50)),
	},
}
var static_mode_list = [1]uintptr{
	0: uintptr(unsafe.Pointer(&mode48000_960_120)),
}

func Opus_clt_mdct_forward_c(tls *libc.TLS, l uintptr, in uintptr, out uintptr, window uintptr, overlap int32, shift int32, stride int32, arch int32) {
	var N, N2, N4, i int32
	var _saved_stack, f, f2, fp, st, st1, t, t1, trig, wp1, wp2, xp1, xp2, yp, yp1, yp11, yp2, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var im, re, t0, t01, t11, t12, yi, yi1, yr, yr1 float32
	var scale OpusT_celt_coef
	var yc OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N2, N4, _saved_stack, f, f2, fp, i, im, re, scale, st, st1, t, t0, t01, t1, t11, t12, trig, wp1, wp2, xp1, xp2, yc, yi, yi1, yp, yp1, yp11, yp2, yr, yr1, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8
	st1 = *(*uintptr)(unsafe.Pointer(l + 8 + uintptr(shift)*8))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = arch
	scale = (*OpusT_kiss_fft_state)(unsafe.Pointer(st1)).Fscale
	N = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Fn
	trig = (*OpusT_mdct_lookup)(unsafe.Pointer(l)).Ftrig
	i = 0
	for {
		if !(i < shift) {
			break
		}
		N = N >> int32(1)
		trig = trig + uintptr(N)*4
		goto _5
	_5:
		;
		i = i + 1
	}
	N2 = N >> int32(1)
	N4 = N >> int32(2)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5804, int32(152))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(N2) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	f = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _37
_37:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _41
_41:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _45
_45:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N4)*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5804, int32(153))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _49
_49:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(N4) * (libc.Uint64FromInt64(8) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _53
_53:
	f2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N4)*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))
	/* Consider the input to be composed of four blocks: [a, b, c, d] */
	/* Window, shuffle, fold */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	xp1 = in + uintptr(overlap>>libc.Int32FromInt32(1))*4
	xp2 = in + uintptr(N2)*4 - uintptr(1)*4 + uintptr(overlap>>libc.Int32FromInt32(1))*4
	yp = f
	wp1 = window + uintptr(overlap>>libc.Int32FromInt32(1))*4
	wp2 = window + uintptr(overlap>>libc.Int32FromInt32(1))*4 - uintptr(1)*4
	i = 0
	for {
		if !(i < (overlap+int32(3))>>int32(2)) {
			break
		}
		/* Real part arranged as -d-cR, Imag part arranged as -b+aR*/
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1 + uintptr(N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) + float32(*(*float32)(unsafe.Pointer(xp2))**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1))**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) - float32(*(*float32)(unsafe.Pointer(xp2 + uintptr(-N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		wp1 = wp1 + uintptr(2)*4
		wp2 = wp2 - uintptr(2)*4
		goto _54
	_54:
		;
		i = i + 1
	}
	wp1 = window
	wp2 = window + uintptr(overlap)*4 - uintptr(1)*4
	for {
		if !(i < N4-(overlap+int32(3))>>int32(2)) {
			break
		}
		/* Real part arranged as a-bR, Imag part arranged as -c-dR */
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = *(*float32)(unsafe.Pointer(xp2))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = *(*float32)(unsafe.Pointer(xp1))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		goto _57
	_57:
		;
		i = i + 1
	}
	for {
		if !(i < N4) {
			break
		}
		/* Real part arranged as a-bR, Imag part arranged as -c-dR */
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = -float32(*(*float32)(unsafe.Pointer(xp1 + uintptr(-N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp1))) + float32(*(*float32)(unsafe.Pointer(xp2))**(*OpusT_celt_coef)(unsafe.Pointer(wp2)))
		v1 = yp
		yp += 4
		*(*float32)(unsafe.Pointer(v1)) = float32(*(*float32)(unsafe.Pointer(xp1))**(*OpusT_celt_coef)(unsafe.Pointer(wp2))) + float32(*(*float32)(unsafe.Pointer(xp2 + uintptr(N2)*4))**(*OpusT_celt_coef)(unsafe.Pointer(wp1)))
		xp1 = xp1 + uintptr(2)*4
		xp2 = xp2 - uintptr(2)*4
		wp1 = wp1 + uintptr(2)*4
		wp2 = wp2 - uintptr(2)*4
		goto _60
	_60:
		;
		i = i + 1
	}
	/* Pre-rotation */
	yp1 = f
	t = trig
	i = 0
	for {
		if !(i < N4) {
			break
		}
		t0 = *(*float32)(unsafe.Pointer(t + uintptr(i)*4))
		t11 = *(*float32)(unsafe.Pointer(t + uintptr(N4+i)*4))
		v1 = yp1
		yp1 += 4
		re = *(*float32)(unsafe.Pointer(v1))
		v1 = yp1
		yp1 += 4
		im = *(*float32)(unsafe.Pointer(v1))
		yr = float32(re*t0) - float32(im*t11)
		yi = float32(im*t0) + float32(re*t11)
		/* For QEXT, it's best to scale before the FFT, but otherwise it's best to scale after.
		   For floating-point it doesn't matter. */
		yc.Fr = float32(yr * scale)
		yc.Fi = float32(yi * scale)
		*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(f2 + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st1)).Fbitrev + uintptr(i)*2)))*8)) = yc
		goto _63
	_63:
		;
		i = i + 1
	}
	/* N/4 complex FFT, does not downscale anymore */
	Opus_opus_fft_impl(tls, st1, f2)
	/* Post-rotate */
	/* Temp pointers to make it really clear to the compiler what we're doing */
	fp = f2
	yp11 = out
	yp2 = out + uintptr(stride*(N2-int32(1)))*4
	t1 = trig
	/* Temp pointers to make it really clear to the compiler what we're doing */
	i = 0
	for {
		if !(i < N4) {
			break
		}
		t01 = *(*float32)(unsafe.Pointer(t1 + uintptr(i)*4))
		t12 = *(*float32)(unsafe.Pointer(t1 + uintptr(N4+i)*4))
		yr1 = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fi*t12) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fr*t01)
		yi1 = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fr*t12) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(fp)).Fi*t01)
		*(*float32)(unsafe.Pointer(yp11)) = yr1
		*(*float32)(unsafe.Pointer(yp2)) = yi1
		fp += 8
		yp11 = yp11 + uintptr(int32(2)*stride)*4
		yp2 = yp2 - uintptr(int32(2)*stride)*4
		goto _66
	_66:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _70
_70:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_comb_filter(tls *libc.TLS, y uintptr, x uintptr, T0 int32, T1 int32, N int32, g0 OpusT_opus_val16, g1 OpusT_opus_val16, tapset0 int32, tapset1 int32, window uintptr, overlap int32, arch int32) {
	var f, g00, g01, g02, g10, g11, g12 OpusT_celt_coef
	var i, v1 int32
	var x0, x1, x2, x3, x4 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, g00, g01, g02, g10, g11, g12, i, x0, x1, x2, x3, x4, v1
	if g0 == libc.Float32FromInt32(0) && g1 == libc.Float32FromInt32(0) {
		/* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
		if x != y {
			libc.Xmemmove(tls, y, x, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(y)-int64(x))/4)))
		}
		return
	}
	/* When the gain is zero, T0 and/or T1 is set to zero. We need
	   to have then be at least 2 to avoid processing garbage data. */
	if T0 > int32(COMBFILTER_MINPERIOD) {
		v1 = T0
	} else {
		v1 = int32(COMBFILTER_MINPERIOD)
	}
	T0 = v1
	if T1 > int32(COMBFILTER_MINPERIOD) {
		v1 = T1
	} else {
		v1 = int32(COMBFILTER_MINPERIOD)
	}
	T1 = v1
	g00 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12)))
	g01 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12 + 1*4)))
	g02 = OpusT_opus_val16(g0 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset0)*12 + 2*4)))
	g10 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12)))
	g11 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12 + 1*4)))
	g12 = OpusT_opus_val16(g1 * *(*OpusT_opus_val16)(unsafe.Pointer(uintptr(unsafe.Pointer(&gains)) + uintptr(tapset1)*12 + 2*4)))
	x1 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1+int32(1))*4))
	x2 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1)*4))
	x3 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1-int32(1))*4))
	x4 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T1-int32(2))*4))
	/* If the filter didn't change, we don't need the overlap */
	if g0 == g1 && T0 == T1 && tapset0 == tapset1 {
		overlap = 0
	}
	i = 0
	for {
		if !(i < overlap) {
			break
		}
		x0 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T1+int32(2))*4))
		f = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4)) * *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i)*4)))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i)*4)) + float32(float32((libc.Float32FromFloat32(1)-f)*g00)**(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0)*4))) + float32(float32((libc.Float32FromFloat32(1)-f)*g01)*(*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0+int32(1))*4))+*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0-int32(1))*4)))) + float32(float32((libc.Float32FromFloat32(1)-f)*g02)*(*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0+int32(2))*4))+*(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T0-int32(2))*4)))) + OpusT_celt_coef(OpusT_celt_coef(f*g10)*x2) + OpusT_celt_coef(OpusT_celt_coef(f*g11)*(x1+x3)) + OpusT_celt_coef(OpusT_celt_coef(f*g12)*(x0+x4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4))
		x4 = x3
		x3 = x2
		x2 = x1
		x1 = x0
		goto _3
	_3:
		;
		i = i + 1
	}
	if g1 == libc.Float32FromInt32(0) {
		/* OPT: Happens to work without the OPUS_MOVE(), but only because the current encoder already copies x to y */
		if x != y {
			libc.Xmemmove(tls, y+uintptr(overlap)*4, x+uintptr(overlap)*4, libc.Uint64FromInt32(N-overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(y+uintptr(overlap)*4)-int64(x+uintptr(overlap)*4))/4)))
		}
		return
	}
	/* Compute the part with the constant filter. */
	_ = arch
	comb_filter_const_c(tls, y+uintptr(i)*4, x+uintptr(i)*4, T1, N-i, g10, g11, g12)
}

var gains = [3][3]OpusT_opus_val16{
	0: {
		0: libc.Float32FromFloat32(0.306640625),
		1: libc.Float32FromFloat32(0.2170410156),
		2: libc.Float32FromFloat32(0.1296386719),
	},
	1: {
		0: libc.Float32FromFloat32(0.4638671875),
		1: libc.Float32FromFloat32(0.2680664062),
	},
	2: {
		0: libc.Float32FromFloat32(0.7998046875),
		1: libc.Float32FromFloat32(0.1000976562),
	},
}

func Opus_compute_band_energies(tls *libc.TLS, m uintptr, X uintptr, bandE uintptr, end int32, C int32, LM int32, arch int32) {
	var N1, c, i, i1, v1 int32
	var eBands uintptr
	var sum, xy, v5 OpusT_opus_val32
	_, _, _, _, _, _, _, _, _ = N1, c, eBands, i, i1, sum, xy, v1, v5
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize << LM
	c = 0
	for {
		i1 = 0
		for {
			if !(i1 < end) {
				break
			}
			_ = arch
			xy = libc.Float32FromInt32(0)
			i = libc.Int32FromInt32(0)
			for {
				if !(i < (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))<<LM) {
					break
				}
				xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(c*N1+int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(c*N1+int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4)))
				goto _4
			_4:
				;
				i = i + 1
			}
			v5 = xy
			goto _6
		_6:
			sum = libc.Float32FromFloat32(1e-27) + v5
			*(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = float32(libc.Xsqrt(tls, float64(sum)))
			/*printf ("%f ", bandE[i+c*m->nbEBands]);*/
			goto _3
		_3:
			;
			i1 = i1 + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	/*printf ("\n");*/
}

// C documentation
//
//	/* Normalise each band such that the energy is one. */

func Opus_compute_stereo_width(tls *libc.TLS, pcm uintptr, frame_size int32, Fs OpusT_opus_int32, mem uintptr) (r OpusT_opus_val16) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var corr, ldiff, qrrt_xx, qrrt_yy, short_alpha, sqrt_xx, sqrt_yy, width, x1, y, v19 OpusT_opus_val16
	var frame_rate, i, v1, v5 int32
	var pxx, pxy, pyy, xx, xy, yy, v2, v3 OpusT_opus_val32
	var v10, v7 bool
	var v18 float32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = corr, frame_rate, i, ldiff, pxx, pxy, pyy, qrrt_xx, qrrt_yy, short_alpha, sqrt_xx, sqrt_yy, width, x1, xx, xy, y, yy, v1, v10, v18, v19, v2, v3, v5, v7
	frame_rate = Fs / frame_size
	if int32(50) > frame_rate {
		v1 = int32(50)
	} else {
		v1 = frame_rate
	}
	short_alpha = OpusT_opus_val32(float32(libc.Int32FromInt32(25))*libc.Float32FromFloat32(1)) / float32(v1)
	v3 = libc.Float32FromInt32(0)
	yy = v3
	v2 = v3
	xy = v2
	xx = v2
	/* Unroll by 4. The frame size is always a multiple of 4 *except* for
	   2.5 ms frames at 12 kHz. Since this setting is very rare (and very
	   stupid), we just discard the last two samples. */
	i = 0
	for {
		if !(i < frame_size-int32(3)) {
			break
		}
		pxx = libc.Float32FromInt32(0)
		pxy = libc.Float32FromInt32(0)
		pyy = libc.Float32FromInt32(0)
		x1 = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i)*4))
		y = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(1))*4))
		pxx = OpusT_opus_val32(x1 * x1)
		pxy = OpusT_opus_val32(x1 * y)
		pyy = OpusT_opus_val32(y * y)
		x1 = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(2))*4))
		y = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(3))*4))
		pxx = pxx + OpusT_opus_val32(x1*x1)
		pxy = pxy + OpusT_opus_val32(x1*y)
		pyy = pyy + OpusT_opus_val32(y*y)
		x1 = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(4))*4))
		y = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(5))*4))
		pxx = pxx + OpusT_opus_val32(x1*x1)
		pxy = pxy + OpusT_opus_val32(x1*y)
		pyy = pyy + OpusT_opus_val32(y*y)
		x1 = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(6))*4))
		y = *(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*i+int32(7))*4))
		pxx = pxx + OpusT_opus_val32(x1*x1)
		pxy = pxy + OpusT_opus_val32(x1*y)
		pyy = pyy + OpusT_opus_val32(y*y)
		xx = xx + pxx
		xy = xy + pxy
		yy = yy + pyy
		goto _4
	_4:
		;
		i = i + int32(4)
	}
	if v7 = !(xx < libc.Float32FromFloat32(1e+09)); !v7 {
		*(*float32)(unsafe.Pointer(bp)) = xx
		v1 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
		goto _6
	_6:
	}
	if v10 = v7 || v1 != 0 || !(yy < libc.Float32FromFloat32(1e+09)); !v10 {
		*(*float32)(unsafe.Pointer(bp)) = yy
		v5 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
		goto _9
	_9:
	}
	if v10 || v5 != 0 {
		v3 = libc.Float32FromInt32(0)
		yy = v3
		v2 = v3
		xx = v2
		xy = v2
	}
	*(*OpusT_opus_val32)(unsafe.Pointer(mem)) += OpusT_opus_val16(short_alpha * (xx - (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX))
	/*mem->XY += MULT16_32_Q15(short_alpha, xy-mem->XY);*/
	/* Rewritten to avoid overflows on abrupt sign change. */
	(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY = float32((libc.Float32FromFloat32(1)-short_alpha)*(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY) + OpusT_opus_val16(short_alpha*xy)
	*(*OpusT_opus_val32)(unsafe.Pointer(mem + 8)) += OpusT_opus_val16(short_alpha * (yy - (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY))
	if float32(libc.Int32FromInt32(0)) > (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX {
		v2 = float32(libc.Int32FromInt32(0))
	} else {
		v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX
	}
	(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX = v2
	if float32(libc.Int32FromInt32(0)) > (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY {
		v2 = float32(libc.Int32FromInt32(0))
	} else {
		v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY
	}
	(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY = v2
	if float32(libc.Int32FromInt32(0)) > (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY {
		v2 = float32(libc.Int32FromInt32(0))
	} else {
		v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY
	}
	(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY = v2
	if (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX > (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY {
		v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX
	} else {
		v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY
	}
	if v2 > libc.Float32FromFloat32(0.0008) {
		sqrt_xx = float32(libc.Xsqrt(tls, float64((*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXX)))
		sqrt_yy = float32(libc.Xsqrt(tls, float64((*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FYY)))
		qrrt_xx = float32(libc.Xsqrt(tls, float64(sqrt_xx)))
		qrrt_yy = float32(libc.Xsqrt(tls, float64(sqrt_yy)))
		/* Inter-channel correlation */
		if (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY < OpusT_opus_val16(sqrt_xx*sqrt_yy) {
			v2 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY
		} else {
			v2 = OpusT_opus_val16(sqrt_xx * sqrt_yy)
		}
		(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY = v2
		corr = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).FXY / (libc.Float32FromFloat32(1e-15) + OpusT_opus_val32(sqrt_xx*sqrt_yy))
		/* Approximate loudness difference */
		ldiff = OpusT_opus_val32(libc.Float32FromFloat32(1)*float32(libc.Xfabs(tls, float64(qrrt_xx-qrrt_yy)))) / (libc.Float32FromFloat32(1e-15) + qrrt_xx + qrrt_yy)
		if libc.Float32FromFloat32(1) < float32(libc.Xsqrt(tls, float64(libc.Float32FromFloat32(1)-OpusT_opus_val32(corr*corr)))) {
			v18 = libc.Float32FromFloat32(1)
		} else {
			v18 = float32(libc.Xsqrt(tls, float64(libc.Float32FromFloat32(1)-OpusT_opus_val32(corr*corr))))
		}
		width = float32(v18 * ldiff)
		/* Smoothing over one second */
		*(*OpusT_opus_val16)(unsafe.Pointer(mem + 12)) += (width - (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fsmoothed_width) / float32(frame_rate)
		/* Peak follower */
		if (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fmax_follower-libc.Float32FromFloat32(0.02)/float32(frame_rate) > (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fsmoothed_width {
			v19 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fmax_follower - libc.Float32FromFloat32(0.02)/float32(frame_rate)
		} else {
			v19 = (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fsmoothed_width
		}
		(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fmax_follower = v19
	}
	/*printf("%f %f %f %f %f ", corr/(float)Q15ONE, ldiff/(float)Q15ONE, width/(float)Q15ONE, mem->smoothed_width/(float)Q15ONE, mem->max_follower/(float)Q15ONE);*/
	if libc.Float32FromFloat32(1) < OpusT_opus_val32(float32(libc.Int32FromInt32(20))*(*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fmax_follower) {
		v18 = libc.Float32FromFloat32(1)
	} else {
		v18 = OpusT_opus_val32(float32(libc.Int32FromInt32(20)) * (*OpusT_StereoWidthState)(unsafe.Pointer(mem)).Fmax_follower)
	}
	return v18
}

func Opus_decode_pulses(tls *libc.TLS, _y uintptr, _n int32, _k int32, _dec uintptr) (r OpusT_opus_val32) {
	var v1, v2, v3, v4 int32
	_, _, _, _ = v1, v2, v3, v4
	if _n < _k {
		v1 = _n
	} else {
		v1 = _k
	}
	if _n > _k {
		v2 = _n
	} else {
		v2 = _k
	}
	if _n < _k+int32(1) {
		v3 = _n
	} else {
		v3 = _k + int32(1)
	}
	if _n > _k+int32(1) {
		v4 = _n
	} else {
		v4 = _k + int32(1)
	}
	return cwrsi(tls, _n, _k, Opus_ec_dec_uint(tls, _dec, *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))+*(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v3] + uintptr(v4)*4))), _y)
}

/* Copyright (c) 2003-2008 Jean-Marc Valin
   Copyright (c) 2007-2008 CSIRO
   Copyright (c) 2007-2009 Xiph.Org Foundation
   Written by Jean-Marc Valin */
/**
  @file arch.h
  @brief Various architecture definitions for CELT
*/
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// C documentation
//
//	/* This is a faster version of ec_tell_frac() that takes advantage
//	   of the low (1/8 bit) resolution to use just a linear function
//	   followed by a lookup to determine the exact transition thresholds. */

func Opus_denormalise_bands(tls *libc.TLS, m uintptr, X uintptr, freq uintptr, bandLogE uintptr, start int32, end int32, M int32, downsample int32, silence int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var N, band_end, bound, i, j, v1 int32
	var eBands, f, x1, v4 uintptr
	var frac, v6, v7, v8 float32
	var g OpusT_opus_val32
	var integer OpusT_opus_int32
	var lg OpusT_celt_glog
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, band_end, bound, eBands, f, frac, g, i, integer, j, lg, x1, v1, v4, v6, v7, v8
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	bound = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end)*2)))
	if downsample != int32(1) {
		if bound < N/downsample {
			v1 = bound
		} else {
			v1 = N / downsample
		}
		bound = v1
	}
	if silence != 0 {
		bound = 0
		v1 = libc.Int32FromInt32(0)
		end = v1
		start = v1
	}
	f = freq
	x1 = X + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))*4
	if start != 0 {
		i = 0
		for {
			if !(i < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2)))) {
				break
			}
			v4 = f
			f += 4
			*(*OpusT_celt_sig)(unsafe.Pointer(v4)) = libc.Float32FromInt32(0)
			goto _3
		_3:
			;
			i = i + 1
		}
	} else {
		f = f + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))*4
	}
	i = start
	for {
		if !(i < end) {
			break
		}
		j = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))
		band_end = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))
		lg = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4)) + Opus_eMeans[i]
		if libc.Float32FromFloat32(32) < lg {
			v6 = libc.Float32FromFloat32(32)
		} else {
			v6 = lg
		}
		v7 = v6
		integer = int32(libc.Xfloor(tls, float64(v7)))
		if integer < -libc.Int32FromInt32(50) {
			v8 = libc.Float32FromInt32(0)
			goto _9
		}
		frac = v7 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v8 = *(*float32)(unsafe.Pointer(bp))
		goto _9
	_9:
		g = v8
		for {
			v4 = f
			f += 4
			*(*OpusT_celt_sig)(unsafe.Pointer(v4)) = OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x1)) * g)
			x1 += 4
			goto _11
		_11:
			;
			j = j + 1
			v1 = j
			if !(v1 < band_end) {
				break
			}
		}
		goto _5
	_5:
		;
		i = i + 1
	}
	if !(start <= end) {
		Opus_celt_fatal(tls, __ccgo_ts+3630, __ccgo_ts+3661, int32(254))
	}
	libc.Xmemset(tls, freq+uintptr(bound)*4, 0, libc.Uint64FromInt32(N-bound)*uint64(4))
}

// C documentation
//
//	/* This prevents energy collapse for transients with multiple short MDCTs */

func Opus_downmix_float(tls *libc.TLS, _x uintptr, y uintptr, subframe int32, offset int32, c1 int32, c2 int32, C int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, j, v6 int32
	var x1 uintptr
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _ = c, j, x1, v6
	x1 = _x
	j = 0
	for {
		if !(j < subframe) {
			break
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = float32(*(*float32)(unsafe.Pointer(x1 + uintptr((j+offset)*C+c1)*4)) * libc.Float32FromFloat32(32768))
		goto _1
	_1:
		;
		j = j + 1
	}
	if c2 > -int32(1) {
		j = 0
		for {
			if !(j < subframe) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(*(*float32)(unsafe.Pointer(x1 + uintptr((j+offset)*C+c2)*4)) * libc.Float32FromFloat32(32768))
			goto _2
		_2:
			;
			j = j + 1
		}
	} else {
		if c2 == -int32(2) {
			c = int32(1)
			for {
				if !(c < C) {
					break
				}
				j = 0
				for {
					if !(j < subframe) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(*(*float32)(unsafe.Pointer(x1 + uintptr((j+offset)*C+c)*4)) * libc.Float32FromFloat32(32768))
					goto _4
				_4:
					;
					j = j + 1
				}
				goto _3
			_3:
				;
				c = c + 1
			}
		}
	}
	/* Cap signal to +6 dBFS to avoid problems in the analysis. */
	j = 0
	for {
		if !(j < subframe) {
			break
		}
		if *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) < -libc.Float32FromFloat32(65536) {
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = -libc.Float32FromFloat32(65536)
		}
		if *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) > libc.Float32FromFloat32(65536) {
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = libc.Float32FromFloat32(65536)
		}
		*(*float32)(unsafe.Pointer(bp)) = *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4))
		v6 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
		goto _7
	_7:
		if v6 != 0 {
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = libc.Float32FromInt32(0)
		}
		goto _5
	_5:
		;
		j = j + 1
	}
}

func Opus_downmix_int(tls *libc.TLS, _x uintptr, y uintptr, subframe int32, offset int32, c1 int32, c2 int32, C int32) {
	var c, j int32
	var x uintptr
	_, _, _ = c, j, x
	x = _x
	j = 0
	for {
		if !(j < subframe) {
			break
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = float32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr((j+offset)*C+c1)*2)))
		goto _1
	_1:
		;
		j = j + 1
	}
	if c2 > -int32(1) {
		j = 0
		for {
			if !(j < subframe) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr((j+offset)*C+c2)*2)))
			goto _2
		_2:
			;
			j = j + 1
		}
	} else {
		if c2 == -int32(2) {
			c = int32(1)
			for {
				if !(c < C) {
					break
				}
				j = 0
				for {
					if !(j < subframe) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(*(*OpusT_opus_int16)(unsafe.Pointer(x + uintptr((j+offset)*C+c)*2)))
					goto _4
				_4:
					;
					j = j + 1
				}
				goto _3
			_3:
				;
				c = c + 1
			}
		}
	}
}

func Opus_downmix_int24(tls *libc.TLS, _x uintptr, y uintptr, subframe int32, offset int32, c1 int32, c2 int32, C int32) {
	var c, j int32
	var x uintptr
	_, _, _ = c, j, x
	x = _x
	j = 0
	for {
		if !(j < subframe) {
			break
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) = float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(x + uintptr((j+offset)*C+c1)*4))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(256)))
		goto _1
	_1:
		;
		j = j + 1
	}
	if c2 > -int32(1) {
		j = 0
		for {
			if !(j < subframe) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(x + uintptr((j+offset)*C+c2)*4))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(256)))
			goto _2
		_2:
			;
			j = j + 1
		}
	} else {
		if c2 == -int32(2) {
			c = int32(1)
			for {
				if !(c < C) {
					break
				}
				j = 0
				for {
					if !(j < subframe) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(j)*4)) += float32(float32(*(*OpusT_opus_int32)(unsafe.Pointer(x + uintptr((j+offset)*C+c)*4))) * (libc.Float32FromFloat32(1) / libc.Float32FromFloat32(256)))
					goto _4
				_4:
					;
					j = j + 1
				}
				goto _3
			_3:
				;
				c = c + 1
			}
		}
	}
}

func Opus_ec_dec_bit_logp(tls *libc.TLS, _this uintptr, _logp uint32) (r1 int32) {
	var d, r, s OpusT_opus_uint32
	var ret int32
	var v1 uint32
	_, _, _, _, _ = d, r, ret, s, v1
	r = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	s = r >> _logp
	ret = libc.BoolInt32(d < s)
	if !(ret != 0) {
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	}
	if ret != 0 {
		v1 = s
	} else {
		v1 = r - s
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = v1
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_bits(tls *libc.TLS, _this uintptr, _bits uint32) (r OpusT_opus_uint32) {
	var available int32
	var ret OpusT_opus_uint32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _, _ = available, ret, window, v1
	window = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window
	available = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits
	if libc.Uint32FromInt32(available) < _bits {
		for cond := true; cond; cond = available <= libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__)-libc.Int32FromInt32(EC_SYM_BITS) {
			window = window | libc.Uint32FromInt32(ec_read_byte_from_end(tls, _this))<<available
			available = available + int32(EC_SYM_BITS)
		}
	}
	ret = window & (libc.Uint32FromInt32(1)<<_bits - uint32(1))
	window = window >> _bits
	available = libc.Int32FromUint32(uint32(available) - _bits)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window = window
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits = available
	v1 = _this + 24
	*(*int32)(unsafe.Pointer(v1)) = int32(uint32(*(*int32)(unsafe.Pointer(v1))) + _bits)
	return ret
}

/* Copyright (c) 2001-2008 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2001-2011 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* (C) COPYRIGHT 1994-2002 Xiph.Org Foundation */
/* Modified by Jean-Marc Valin */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* opus_types.h based on ogg_types.h from libogg */

/**
  @file opus_types.h
  @brief Opus reference implementation types
*/
/* Copyright (c) 2010-2011 Xiph.Org Foundation, Skype Limited
   Written by Jean-Marc Valin and Koen Vos */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @file opus_defines.h
 * @brief Opus reference implementation constants
 */

/*Constants used by the entropy encoder/decoder.*/

/*The number of bits to output at a time.*/
/*The total number of bits in each of the state registers.*/
/*The maximum symbol value.*/
/*Bits to shift by to move a symbol into the high-order position.*/
/*Carry bit of the high-order range symbol.*/
/*Low-order bit of the high-order range symbol.*/
/*The number of bits available for the last, partial symbol in the code field.*/

/*A range encoder.
  See entdec.c and the references for implementation details \cite{Mar79,MNW98}.

  @INPROCEEDINGS{Mar79,
   author="Martin, G.N.N.",
   title="Range encoding: an algorithm for removing redundancy from a digitised
    message",
   booktitle="Video \& Data Recording Conference",
   year=1979,
   address="Southampton",
   month=Jul
  }
  @ARTICLE{MNW98,
   author="Alistair Moffat and Radford Neal and Ian H. Witten",
   title="Arithmetic Coding Revisited",
   journal="{ACM} Transactions on Information Systems",
   year=1998,
   volume=16,
   number=3,
   pages="256--294",
   month=Jul,
   URL="http://www.stanford.edu/class/ee398/handouts/papers/Moffat98ArithmCoding.pdf"
  }*/

func Opus_ec_dec_icdf(tls *libc.TLS, _this uintptr, _icdf uintptr, _ftb uint32) (r1 int32) {
	var d, r, s, t OpusT_opus_uint32
	var ret, v1 int32
	_, _, _, _, _, _ = d, r, ret, s, t, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	r = s >> _ftb
	ret = -int32(1)
	for cond := true; cond; cond = d < s {
		t = s
		ret = ret + 1
		v1 = ret
		s = r * uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(v1))))
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = t - s
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_icdf16(tls *libc.TLS, _this uintptr, _icdf uintptr, _ftb uint32) (r1 int32) {
	var d, r, s, t OpusT_opus_uint32
	var ret, v1 int32
	_, _, _, _, _, _ = d, r, ret, s, t, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng
	d = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval
	r = s >> _ftb
	ret = -int32(1)
	for cond := true; cond; cond = d < s {
		t = s
		ret = ret + 1
		v1 = ret
		s = r * uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(v1)*2)))
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = d - s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = t - s
	ec_dec_normalize(tls, _this)
	return ret
}

func Opus_ec_dec_init(tls *libc.TLS, _this uintptr, _buf uintptr, _storage OpusT_opus_uint32) {
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf = _buf
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage = _storage
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_offs = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_window = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnend_bits = 0
	/*This is the offset from which ec_tell() will subtract partial bits.
	  The final value after the ec_dec_normalize() call will be the same as in
	   the encoder, but we have to compensate for the bits that are added there.*/
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fnbits_total = libc.Int32FromInt32(EC_CODE_BITS) + libc.Int32FromInt32(1) - (libc.Int32FromInt32(EC_CODE_BITS)-((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS)+libc.Int32FromInt32(1)))/libc.Int32FromInt32(EC_SYM_BITS)*libc.Int32FromInt32(EC_SYM_BITS)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Foffs = uint32(0)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = libc.Uint32FromUint32(1) << ((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS) + libc.Int32FromInt32(1))
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem = ec_read_byte(tls, _this)
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng - uint32(1) - libc.Uint32FromInt32((*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem>>(libc.Int32FromInt32(EC_SYM_BITS)-((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS)+libc.Int32FromInt32(1))))
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Ferror1 = 0
	/*Normalize the interval.*/
	ec_dec_normalize(tls, _this)
}

func Opus_ec_dec_uint(tls *libc.TLS, _this uintptr, _ft OpusT_opus_uint32) (r OpusT_opus_uint32) {
	var ft, s uint32
	var ftb int32
	var t OpusT_opus_uint32
	_, _, _, _ = ft, ftb, s, t
	/*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
	if !(_ft > libc.Uint32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+5367, __ccgo_ts+5391, int32(224))
	}
	_ft = _ft - 1
	ftb = libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, _ft)
	if ftb > int32(EC_UINT_BITS) {
		ftb = ftb - int32(EC_UINT_BITS)
		ft = _ft>>ftb + uint32(1)
		s = Opus_ec_decode(tls, _this, ft)
		Opus_ec_dec_update(tls, _this, s, s+uint32(1), ft)
		t = s<<ftb | Opus_ec_dec_bits(tls, _this, libc.Uint32FromInt32(ftb))
		if t <= _ft {
			return t
		}
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Ferror1 = int32(1)
		return _ft
	} else {
		_ft = _ft + 1
		s = Opus_ec_decode(tls, _this, _ft)
		Opus_ec_dec_update(tls, _this, s, s+uint32(1), _ft)
		return s
	}
	return r
}

func Opus_ec_dec_update(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _ft uint32) {
	var s OpusT_opus_uint32
	var v1 uint32
	_, _ = s, v1
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext * (_ft - _fh)
	*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) -= s
	if _fl > uint32(0) {
		v1 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext * (_fh - _fl)
	} else {
		v1 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng - s
	}
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng = v1
	ec_dec_normalize(tls, _this)
}

// C documentation
//
//	/*The probability of having a "one" is 1/(1<<_logp).*/

func Opus_ec_decode(tls *libc.TLS, _this uintptr, _ft uint32) (r uint32) {
	var s uint32
	var v1, v2 OpusT_opus_uint32
	_, _, _ = s, v1, v2
	v1 = _ft
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng / v1
	goto _3
_3:
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext = v2
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval / (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext
	return _ft - (s + uint32(1) + (_ft-(s+uint32(1)))&libc.Uint32FromInt32(-libc.BoolInt32(_ft < s+libc.Uint32FromInt32(1))))
}

func Opus_ec_decode_bin(tls *libc.TLS, _this uintptr, _bits uint32) (r uint32) {
	var s uint32
	_ = s
	(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng >> _bits
	s = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval / (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fext
	return uint32(1)<<_bits - (s + uint32(1) + (uint32(1)<<_bits-(s+uint32(1)))&libc.Uint32FromInt32(-libc.BoolInt32(libc.Uint32FromUint32(1)<<_bits < s+libc.Uint32FromUint32(1))))
}

func Opus_ec_enc_bit_logp(tls *libc.TLS, _this uintptr, _val int32, _logp uint32) {
	var l, r, s OpusT_opus_uint32
	var v1 uint32
	_, _, _, _ = l, r, s, v1
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng
	l = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval
	s = r >> _logp
	r = r - s
	if _val != 0 {
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = l + r
	}
	if _val != 0 {
		v1 = s
	} else {
		v1 = r
	}
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = v1
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_bits(tls *libc.TLS, _this uintptr, _fl OpusT_opus_uint32, _bits uint32) {
	var used int32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _ = used, window, v1
	window = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window
	used = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits
	if !(_bits > libc.Uint32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5425, __ccgo_ts+5408, int32(209))
	}
	if libc.Uint32FromInt32(used)+_bits > libc.Uint32FromInt32(libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__)) {
		for cond := true; cond; cond = used >= int32(EC_SYM_BITS) {
			*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte_at_end(tls, _this, window&(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1)))
			window = window >> libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
			used = used - int32(EC_SYM_BITS)
		}
	}
	window = window | _fl<<used
	used = libc.Int32FromUint32(uint32(used) + _bits)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window = window
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits = used
	v1 = _this + 24
	*(*int32)(unsafe.Pointer(v1)) = int32(uint32(*(*int32)(unsafe.Pointer(v1))) + _bits)
}

func Opus_ec_enc_done(tls *libc.TLS, _this uintptr) {
	var end, msk OpusT_opus_uint32
	var l, used int32
	var window OpusT_ec_window
	var v1 uintptr
	_, _, _, _, _, _ = end, l, msk, used, window, v1
	/*We output the minimum number of bits that ensures that the symbols encoded
	  thus far will be decoded correctly regardless of the bits that follow.*/
	l = int32(EC_CODE_BITS) - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng))
	msk = (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1)) >> l
	end = ((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval + msk) & ^msk
	if end|msk >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng {
		l = l + 1
		msk = msk >> uint32(1)
		end = ((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval + msk) & ^msk
	}
	for l > 0 {
		ec_enc_carry_out(tls, _this, libc.Int32FromUint32(end>>(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))))
		end = end << libc.Int32FromInt32(EC_SYM_BITS) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
		l = l - int32(EC_SYM_BITS)
	}
	/*If we have a buffered byte flush it into the output buffer.*/
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 || (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext > uint32(0) {
		ec_enc_carry_out(tls, _this, 0)
	}
	/*If we have buffered extra bits, flush them as well.*/
	window = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window
	used = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits
	for used >= int32(EC_SYM_BITS) {
		*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte_at_end(tls, _this, window&(libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1)))
		window = window >> libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		used = used - int32(EC_SYM_BITS)
	}
	/*Clear any excess space and add any remaining extra bits to the last byte.*/
	if !((*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 != 0) {
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf != 0 {
			libc.Xmemset(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs), 0, uint64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)*uint64(1))
		}
		if used > 0 {
			/*If there's no range coder data at all, give up.*/
			if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
			} else {
				l = -l
				/*If we've busted, don't add too many extra bits to the last byte; it
				  would corrupt the range coder data, and that's more important.*/
				if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage && l < used {
					window = window & libc.Uint32FromInt32(int32(1)<<l-int32(1))
					(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
				}
				v1 = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs-uint32(1))
				*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(v1))) | libc.Int32FromUint8(uint8(window)))
			}
		}
	}
}

var log2_x_norm_coeff12 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff12 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The guts header contains all the multiplication and addition macros that are defined for
   complex numbers.  It also declares the kf_ internal functions.
*/

func Opus_ec_enc_icdf(tls *libc.TLS, _this uintptr, _s int32, _icdf uintptr, _ftb uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _ftb
	if _s > 0 {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s-int32(1)))))
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s-int32(1)))))-libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s)))))
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * uint32(*(*uint8)(unsafe.Pointer(_icdf + uintptr(_s))))
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_icdf16(tls *libc.TLS, _this uintptr, _s int32, _icdf uintptr, _ftb uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _ftb
	if _s > 0 {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s-int32(1))*2)))
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * libc.Uint32FromInt32(libc.Int32FromUint16(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s-int32(1))*2)))-libc.Int32FromUint16(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s)*2))))
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * uint32(*(*OpusT_opus_uint16)(unsafe.Pointer(_icdf + uintptr(_s)*2)))
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_enc_init(tls *libc.TLS, _this uintptr, _buf uintptr, _size OpusT_opus_uint32) {
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf = _buf
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_window = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnend_bits = 0
	/*This is the offset from which ec_tell() will subtract partial bits.*/
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fnbits_total = libc.Int32FromInt32(EC_CODE_BITS) + libc.Int32FromInt32(1)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = libc.Uint32FromUint32(1) << (libc.Int32FromInt32(EC_CODE_BITS) - libc.Int32FromInt32(1))
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = -int32(1)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext = uint32(0)
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage = _size
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = 0
}

func Opus_ec_enc_patch_initial_bits(tls *libc.TLS, _this uintptr, _val uint32, _nbits uint32) {
	var mask uint32
	var shift int32
	_, _ = mask, shift
	if !(_nbits <= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))) {
		Opus_celt_fatal(tls, __ccgo_ts+5451, __ccgo_ts+5408, int32(228))
	}
	shift = libc.Int32FromUint32(libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS)) - _nbits)
	mask = libc.Uint32FromInt32((int32(1)<<_nbits - int32(1)) << shift)
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs > uint32(0) {
		/*The first byte has been finalized.*/
		*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf)) = uint8(uint32(*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf))) & ^mask | _val<<shift)
	} else {
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 {
			/*The first byte is still awaiting carry propagation.*/
			(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = libc.Int32FromUint32(libc.Uint32FromInt32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem) & ^mask | _val<<shift)
		} else {
			if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>_nbits {
				/*The renormalization loop has never been run.*/
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval & ^(mask<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))) | _val<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1)+shift)
			} else {
				(*OpusT_ec_enc)(unsafe.Pointer(_this)).Ferror1 = -int32(1)
			}
		}
	}
}

func Opus_ec_enc_shrink(tls *libc.TLS, _this uintptr, _size OpusT_opus_uint32) {
	if !((*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs <= _size) {
		Opus_celt_fatal(tls, __ccgo_ts+5489, __ccgo_ts+5408, int32(249))
	}
	libc.Xmemmove(tls, (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr(_size)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs), (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs), uint64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)*uint64(1)+libc.Uint64FromInt64(0*(int64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr(_size)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs))-int64((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf+uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage)-uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs)))))
	(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage = _size
}

func Opus_ec_enc_uint(tls *libc.TLS, _this uintptr, _fl OpusT_opus_uint32, _ft OpusT_opus_uint32) {
	var fl, ft uint32
	var ftb int32
	_, _, _ = fl, ft, ftb
	/*In order to optimize EC_ILOG(), it is undefined for the value 0.*/
	if !(_ft > libc.Uint32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+5367, __ccgo_ts+5408, int32(191))
	}
	_ft = _ft - 1
	ftb = libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, _ft)
	if ftb > int32(EC_UINT_BITS) {
		ftb = ftb - int32(EC_UINT_BITS)
		ft = _ft>>ftb + uint32(1)
		fl = _fl >> ftb
		Opus_ec_encode(tls, _this, fl, fl+uint32(1), ft)
		Opus_ec_enc_bits(tls, _this, _fl&(libc.Uint32FromInt32(1)<<ftb-uint32(1)), libc.Uint32FromInt32(ftb))
	} else {
		Opus_ec_encode(tls, _this, _fl, _fl+uint32(1), _ft+uint32(1))
	}
}

func Opus_ec_encode(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _ft uint32) {
	var r, v1, v2 OpusT_opus_uint32
	_, _, _ = r, v1, v2
	v1 = _ft
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng / v1
	goto _3
_3:
	r = v2
	if _fl > uint32(0) {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*(_ft-_fl)
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * (_fh - _fl)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * (_ft - _fh)
	}
	ec_enc_normalize(tls, _this)
}

func Opus_ec_encode_bin(tls *libc.TLS, _this uintptr, _fl uint32, _fh uint32, _bits uint32) {
	var r OpusT_opus_uint32
	_ = r
	r = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng >> _bits
	if _fl > uint32(0) {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 36)) += (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng - r*(uint32(1)<<_bits-_fl)
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng = r * (_fh - _fl)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) -= r * (uint32(1)<<_bits - _fh)
	}
	ec_enc_normalize(tls, _this)
}

// C documentation
//
//	/*The probability of having a "one" is 1/(1<<_logp).*/

func Opus_ec_laplace_decode(tls *libc.TLS, dec uintptr, fs uint32, decay int32) (r int32) {
	var di, val int32
	var fl, fm, v1 uint32
	_, _, _, _, _ = di, fl, fm, val, v1
	val = 0
	fm = Opus_ec_decode_bin(tls, dec, uint32(15))
	fl = uint32(0)
	if fm >= fs {
		val = val + 1
		fl = fs
		fs = ec_laplace_get_freq1(tls, fs, decay) + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
		/* Search the decaying part of the PDF.*/
		for fs > libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) && fm >= fl+uint32(2)*fs {
			fs = fs * uint32(2)
			fl = fl + fs
			fs = (fs - libc.Uint32FromInt32(libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))) * libc.Uint32FromInt32(decay) >> int32(15)
			fs = fs + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
			val = val + 1
		}
		/* Everything beyond that has probability LAPLACE_MINP. */
		if fs <= libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) {
			di = libc.Int32FromUint32((fm - fl) >> (libc.Int32FromInt32(LAPLACE_LOG_MINP) + libc.Int32FromInt32(1)))
			val = val + di
			fl = fl + libc.Uint32FromInt32(int32(2)*di*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))
		}
		if fm < fl+fs {
			val = -val
		} else {
			fl = fl + fs
		}
	}
	if !(fl < libc.Uint32FromInt32(32768)) {
		Opus_celt_fatal(tls, __ccgo_ts+5713, __ccgo_ts+5672, int32(128))
	}
	if !(fs > libc.Uint32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5690, __ccgo_ts+5672, int32(129))
	}
	if !(fl <= fm) {
		Opus_celt_fatal(tls, __ccgo_ts+5740, __ccgo_ts+5672, int32(130))
	}
	if fl+fs < libc.Uint32FromInt32(libc.Int32FromInt32(32768)) {
		v1 = fl + fs
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(32768))
	}
	if !(fm < v1) {
		Opus_celt_fatal(tls, __ccgo_ts+5765, __ccgo_ts+5672, int32(131))
	}
	if fl+fs < libc.Uint32FromInt32(libc.Int32FromInt32(32768)) {
		v1 = fl + fs
	} else {
		v1 = libc.Uint32FromInt32(libc.Int32FromInt32(32768))
	}
	Opus_ec_dec_update(tls, dec, fl, v1, uint32(32768))
	return val
}

func Opus_ec_laplace_decode_p0(tls *libc.TLS, dec uintptr, p0 OpusT_opus_uint16, decay OpusT_opus_uint16) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i, s, v, value, v1 int32
	var _ /* icdf at bp+6 */ [8]OpusT_opus_uint16
	var _ /* sign_icdf at bp+0 */ [3]OpusT_opus_uint16
	_, _, _, _, _ = i, s, v, value, v1
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0] = libc.Uint16FromInt32(int32(32768) - libc.Int32FromUint16(p0))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(1)] = libc.Uint16FromInt32(libc.Int32FromUint16((*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0]) / int32(2))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(2)] = uint16(0)
	s = Opus_ec_dec_icdf16(tls, dec, bp, uint32(15))
	if s == int32(2) {
		s = -int32(1)
	}
	if s != 0 {
		if int32(7) > libc.Int32FromUint16(decay) {
			v1 = int32(7)
		} else {
			v1 = libc.Int32FromUint16(decay)
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[0] = libc.Uint16FromInt32(v1)
		i = int32(1)
		for {
			if !(i < int32(7)) {
				break
			}
			if int32(7)-i > libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)])*libc.Int32FromUint16(decay)>>int32(15) {
				v1 = int32(7) - i
			} else {
				v1 = libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)]) * libc.Int32FromUint16(decay) >> int32(15)
			}
			(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i] = libc.Uint16FromInt32(v1)
			goto _2
		_2:
			;
			i = i + 1
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[int32(7)] = uint16(0)
		value = int32(1)
		for cond := true; cond; cond = v == int32(7) {
			v = Opus_ec_dec_icdf16(tls, dec, bp+6, uint32(15))
			value = value + v
		}
		return s * value
	} else {
		return 0
	}
	return r
}

const CELT_SIG_SCALE9 = 32768

var log2_x_norm_coeff14 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff14 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

// C documentation
//
//	/*Compute floor(sqrt(_val)) with exact arithmetic.
//	  _val must be greater than 0.
//	  This has been tested on all possible 32-bit inputs greater than 0.*/

func Opus_ec_laplace_encode(tls *libc.TLS, enc uintptr, value uintptr, fs uint32, decay int32) {
	var di, i, ndi_max, s, val, v2 int32
	var fl, v3 uint32
	_, _, _, _, _, _, _, _ = di, fl, i, ndi_max, s, val, v2, v3
	val = *(*int32)(unsafe.Pointer(value))
	fl = uint32(0)
	if val != 0 {
		s = -libc.BoolInt32(val < 0)
		val = val + s ^ s
		fl = fs
		fs = ec_laplace_get_freq1(tls, fs, decay)
		/* Search the decaying part of the PDF.*/
		i = int32(1)
		for {
			if !(fs > uint32(0) && i < val) {
				break
			}
			fs = fs * uint32(2)
			fl = fl + (fs + libc.Uint32FromInt32(libc.Int32FromInt32(2)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))))
			fs = fs * libc.Uint32FromInt32(decay) >> int32(15)
			goto _1
		_1:
			;
			i = i + 1
		}
		/* Everything beyond that has probability LAPLACE_MINP. */
		if !(fs != 0) {
			ndi_max = libc.Int32FromUint32((uint32(32768) - fl + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) - uint32(1)) >> LAPLACE_LOG_MINP)
			ndi_max = (ndi_max - s) >> int32(1)
			if val-i < ndi_max-int32(1) {
				v2 = val - i
			} else {
				v2 = ndi_max - int32(1)
			}
			di = v2
			fl = fl + libc.Uint32FromInt32((int32(2)*di+int32(1)+s)*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)))
			if libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)) < uint32(32768)-fl {
				v3 = libc.Uint32FromInt32(libc.Int32FromInt32(1) << libc.Int32FromInt32(LAPLACE_LOG_MINP))
			} else {
				v3 = uint32(32768) - fl
			}
			fs = v3
			*(*int32)(unsafe.Pointer(value)) = i + di + s ^ s
		} else {
			fs = fs + libc.Uint32FromInt32(libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP))
			fl = fl + fs&libc.Uint32FromInt32(^s)
		}
		if !(fl+fs <= libc.Uint32FromInt32(32768)) {
			Opus_celt_fatal(tls, __ccgo_ts+5641, __ccgo_ts+5672, int32(88))
		}
		if !(fs > libc.Uint32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+5690, __ccgo_ts+5672, int32(89))
		}
	}
	Opus_ec_encode_bin(tls, enc, fl, fl+fs, uint32(15))
}

func Opus_ec_laplace_encode_p0(tls *libc.TLS, enc uintptr, value int32, p0 OpusT_opus_uint16, decay OpusT_opus_uint16) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i, s, v1, v2 int32
	var _ /* icdf at bp+6 */ [8]OpusT_opus_uint16
	var _ /* sign_icdf at bp+0 */ [3]OpusT_opus_uint16
	_, _, _, _ = i, s, v1, v2
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0] = libc.Uint16FromInt32(int32(32768) - libc.Int32FromUint16(p0))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(1)] = libc.Uint16FromInt32(libc.Int32FromUint16((*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[0]) / int32(2))
	(*(*[3]OpusT_opus_uint16)(unsafe.Pointer(bp)))[int32(2)] = uint16(0)
	if value == 0 {
		v1 = 0
	} else {
		if value > 0 {
			v2 = int32(1)
		} else {
			v2 = int32(2)
		}
		v1 = v2
	}
	s = v1
	Opus_ec_enc_icdf16(tls, enc, s, bp, uint32(15))
	value = libc.Xabs(tls, value)
	if value != 0 {
		if int32(7) > libc.Int32FromUint16(decay) {
			v1 = int32(7)
		} else {
			v1 = libc.Int32FromUint16(decay)
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[0] = libc.Uint16FromInt32(v1)
		i = int32(1)
		for {
			if !(i < int32(7)) {
				break
			}
			if int32(7)-i > libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)])*libc.Int32FromUint16(decay)>>int32(15) {
				v1 = int32(7) - i
			} else {
				v1 = libc.Int32FromUint16((*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i-int32(1)]) * libc.Int32FromUint16(decay) >> int32(15)
			}
			(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[i] = libc.Uint16FromInt32(v1)
			goto _4
		_4:
			;
			i = i + 1
		}
		(*(*[8]OpusT_opus_uint16)(unsafe.Pointer(bp + 6)))[int32(7)] = uint16(0)
		value = value - 1
		for cond := true; cond; cond = value >= 0 {
			if value < int32(7) {
				v1 = value
			} else {
				v1 = int32(7)
			}
			Opus_ec_enc_icdf16(tls, enc, v1, bp+6, uint32(15))
			value = value - int32(7)
		}
	}
}

func Opus_ec_tell_frac(tls *libc.TLS, _this uintptr) (r1 OpusT_opus_uint32) {
	var b uint32
	var l int32
	var nbits, r OpusT_opus_uint32
	_, _, _, _ = b, l, nbits, r
	nbits = libc.Uint32FromInt32((*OpusT_ec_ctx)(unsafe.Pointer(_this)).Fnbits_total << int32(BITRES))
	l = libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(_this)).Frng)
	r = (*OpusT_ec_ctx)(unsafe.Pointer(_this)).Frng >> (l - int32(16))
	b = r>>libc.Int32FromInt32(12) - uint32(8)
	b = b + libc.BoolUint32(r > correction[b])
	l = libc.Int32FromUint32(libc.Uint32FromInt32(l<<libc.Int32FromInt32(3)) + b)
	return nbits - libc.Uint32FromInt32(l)
}

var correction = [8]uint32{
	0: uint32(35733),
	1: uint32(38967),
	2: uint32(42495),
	3: uint32(46340),
	4: uint32(50535),
	5: uint32(55109),
	6: uint32(60097),
	7: uint32(65535),
}

const EC_CODE_BITS = 32
const EC_SYM_BITS = 8
const _mfrngcode_H = 1

/* Copyright (c) 2001-2008 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Copyright (c) 2001-2011 Timothy B. Terriberry
   Copyright (c) 2008-2009 Xiph.Org Foundation */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* (C) COPYRIGHT 1994-2002 Xiph.Org Foundation */
/* Modified by Jean-Marc Valin */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* opus_types.h based on ogg_types.h from libogg */

/**
  @file opus_types.h
  @brief Opus reference implementation types
*/
/* Copyright (c) 2010-2011 Xiph.Org Foundation, Skype Limited
   Written by Jean-Marc Valin and Koen Vos */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * @file opus_defines.h
 * @brief Opus reference implementation constants
 */

/*Constants used by the entropy encoder/decoder.*/

/*The number of bits to output at a time.*/
/*The total number of bits in each of the state registers.*/
/*The maximum symbol value.*/
/*Bits to shift by to move a symbol into the high-order position.*/
/*Carry bit of the high-order range symbol.*/
/*Low-order bit of the high-order range symbol.*/
/*The number of bits available for the last, partial symbol in the code field.*/

/*A range decoder.
  This is an entropy decoder based upon \cite{Mar79}, which is itself a
   rediscovery of the FIFO arithmetic code introduced by \cite{Pas76}.
  It is very similar to arithmetic encoding, except that encoding is done with
   digits in any base, instead of with bits, and so it is faster when using
   larger bases (i.e.: a byte).
  The author claims an average waste of $\frac{1}{2}\log_b(2b)$ bits, where $b$
   is the base, longer than the theoretical optimum, but to my knowledge there
   is no published justification for this claim.
  This only seems true when using near-infinite precision arithmetic so that
   the process is carried out with no rounding errors.

  An excellent description of implementation details is available at
   http://www.arturocampos.com/ac_range.html
  A recent work \cite{MNW98} which proposes several changes to arithmetic
   encoding for efficiency actually re-discovers many of the principles
   behind range encoding, and presents a good theoretical analysis of them.

  End of stream is handled by writing out the smallest number of bits that
   ensures that the stream will be correctly decoded regardless of the value of
   any subsequent bits.
  ec_tell() can be used to determine how many bits were needed to decode
   all the symbols thus far; other data can be packed in the remaining bits of
   the input buffer.
  @PHDTHESIS{Pas76,
    author="Richard Clark Pasco",
    title="Source coding algorithms for fast data compression",
    school="Dept. of Electrical Engineering, Stanford University",
    address="Stanford, CA",
    month=May,
    year=1976
  }
  @INPROCEEDINGS{Mar79,
   author="Martin, G.N.N.",
   title="Range encoding: an algorithm for removing redundancy from a digitised
    message",
   booktitle="Video & Data Recording Conference",
   year=1979,
   address="Southampton",
   month=Jul
  }
  @ARTICLE{MNW98,
   author="Alistair Moffat and Radford Neal and Ian H. Witten",
   title="Arithmetic Coding Revisited",
   journal="{ACM} Transactions on Information Systems",
   year=1998,
   volume=16,
   number=3,
   pages="256--294",
   month=Jul,
   URL="http://www.stanford.edu/class/ee398a/handouts/papers/Moffat98ArithmCoding.pdf"
  }*/

func Opus_encode_pulses(tls *libc.TLS, _y uintptr, _n int32, _k int32, _enc uintptr) {
	var v1, v2, v3, v4 int32
	_, _, _, _ = v1, v2, v3, v4
	if !(_k > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5321, __ccgo_ts+5306, int32(463))
	}
	if _n < _k {
		v1 = _n
	} else {
		v1 = _k
	}
	if _n > _k {
		v2 = _n
	} else {
		v2 = _k
	}
	if _n < _k+int32(1) {
		v3 = _n
	} else {
		v3 = _k + int32(1)
	}
	if _n > _k+int32(1) {
		v4 = _n
	} else {
		v4 = _k + int32(1)
	}
	Opus_ec_enc_uint(tls, _enc, icwrs(tls, _n, _y), *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))+*(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v3] + uintptr(v4)*4)))
}

func Opus_encode_size(tls *libc.TLS, size int32, data uintptr) (r int32) {
	if size < int32(252) {
		*(*uint8)(unsafe.Pointer(data)) = libc.Uint8FromInt32(size)
		return int32(1)
	} else {
		*(*uint8)(unsafe.Pointer(data)) = libc.Uint8FromInt32(int32(252) + size&int32(0x3))
		*(*uint8)(unsafe.Pointer(data + 1)) = libc.Uint8FromInt32((size - libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))) >> int32(2))
		return int32(2)
	}
	return r
}

func Opus_exp_rotation(tls *libc.TLS, X uintptr, len1 int32, dir int32, stride int32, K int32, spread int32) {
	var c, gain, s, theta OpusT_opus_val16
	var factor, i, stride2 int32
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _ = c, factor, gain, i, s, stride2, theta, v1, v2
	stride2 = 0
	if int32(2)*K >= len1 || spread == SPREAD_NONE {
		return
	}
	factor = SPREAD_FACTOR[spread-int32(1)]
	gain = OpusT_opus_val32(libc.Float32FromFloat32(1)*float32(len1)) / float32(len1+factor*K)
	theta = float32(libc.Float32FromFloat32(0.5) * OpusT_opus_val16(gain*gain))
	c = float32(libc.Xcos(tls, float64(float64(libc.Float64FromFloat32(0.5)*libc.Float64FromFloat64(3.141592653589793))*float64(theta))))
	s = float32(libc.Xcos(tls, float64(float64(libc.Float64FromFloat32(0.5)*libc.Float64FromFloat64(3.141592653589793))*float64(libc.Float32FromFloat32(1)-theta)))) /*  sin(theta) */
	if len1 >= int32(8)*stride {
		stride2 = int32(1)
		/* This is just a simple (equivalent) way of computing sqrt(len/stride) with rounding.
		   It's basically incrementing long as (stride2+0.5)^2 < len/stride. */
		for (stride2*stride2+stride2)*stride+stride>>int32(2) < len1 {
			stride2 = stride2 + 1
		}
	}
	/*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
	  extract_collapse_mask().*/
	v1 = libc.Uint32FromInt32(stride)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(len1) / v1
	goto _3
_3:
	len1 = libc.Int32FromUint32(v2)
	i = 0
	for {
		if !(i < stride) {
			break
		}
		if dir < 0 {
			if stride2 != 0 {
				exp_rotation1(tls, X+uintptr(i*len1)*4, len1, stride2, s, c)
			}
			exp_rotation1(tls, X+uintptr(i*len1)*4, len1, int32(1), c, s)
		} else {
			exp_rotation1(tls, X+uintptr(i*len1)*4, len1, int32(1), c, -s)
			if stride2 != 0 {
				exp_rotation1(tls, X+uintptr(i*len1)*4, len1, stride2, s, -c)
			}
		}
		goto _4
	_4:
		;
		i = i + 1
	}
}

var SPREAD_FACTOR = [3]int32{
	0: int32(15),
	1: int32(10),
	2: int32(5),
}

// C documentation
//
//	/** Normalizes the decoded integer pvq codeword to unit norm. */

func Opus_frame_size_select(tls *libc.TLS, application int32, frame_size OpusT_opus_int32, variable_duration int32, Fs OpusT_opus_int32) (r OpusT_opus_int32) {
	var new_size int32
	_ = new_size
	if frame_size < Fs/int32(400) {
		return -int32(1)
	}
	if variable_duration == int32(OPUS_FRAMESIZE_ARG) {
		new_size = frame_size
	} else {
		if variable_duration >= int32(OPUS_FRAMESIZE_2_5_MS) && variable_duration <= int32(OPUS_FRAMESIZE_120_MS) {
			if variable_duration <= int32(OPUS_FRAMESIZE_40_MS) {
				new_size = Fs / int32(400) << (variable_duration - int32(OPUS_FRAMESIZE_2_5_MS))
			} else {
				new_size = (variable_duration - int32(OPUS_FRAMESIZE_2_5_MS) - int32(2)) * Fs / int32(50)
			}
		} else {
			return -int32(1)
		}
	}
	if new_size > frame_size {
		return -int32(1)
	}
	if int32(400)*new_size != Fs && int32(200)*new_size != Fs && int32(100)*new_size != Fs && int32(50)*new_size != Fs && int32(25)*new_size != Fs && int32(50)*new_size != int32(3)*Fs && int32(50)*new_size != int32(4)*Fs && int32(50)*new_size != int32(5)*Fs && int32(50)*new_size != int32(6)*Fs {
		return -int32(1)
	}
	if application == int32(OPUS_APPLICATION_RESTRICTED_SILK) && new_size < Fs/int32(100) {
		return -int32(1)
	}
	return new_size
}

func Opus_get_left_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id*int32(2) {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

func Opus_get_mono_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id+(*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_coupled_streams {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

const CELT_MAX_PULSES = 128
const FINE_OFFSET = 21
const LOG_MAX_PSEUDO = 6
const MAX_FINE_BITS = 8
const MAX_OVERLAP = 120
const MAX_PSEUDO = 40
const QTHETA_OFFSET = 4
const QTHETA_OFFSET_TWOPHASE = 16
const SPREAD_AGGRESSIVE = 3
const SPREAD_LIGHT = 1
const SPREAD_NONE = 0
const SPREAD_NORMAL = 2

var trim_icdf5 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf5 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf5 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff3 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff3 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

type OpusT_VorbisLayout = struct {
	Fnb_streams         int32
	Fnb_coupled_streams int32
	Fmapping            [8]uint8
}

// C documentation
//
//	/* Index is nb_channel-1*/
var vorbis_mappings = [8]OpusT_VorbisLayout{
	0: {
		Fnb_streams: int32(1),
	},
	1: {
		Fnb_streams:         int32(1),
		Fnb_coupled_streams: int32(1),
		Fmapping: [8]uint8{
			1: uint8(1),
		},
	},
	2: {
		Fnb_streams:         int32(2),
		Fnb_coupled_streams: int32(1),
		Fmapping: [8]uint8{
			1: uint8(2),
			2: uint8(1),
		},
	},
	3: {
		Fnb_streams:         int32(2),
		Fnb_coupled_streams: int32(2),
		Fmapping: [8]uint8{
			1: uint8(1),
			2: uint8(2),
			3: uint8(3),
		},
	},
	4: {
		Fnb_streams:         int32(3),
		Fnb_coupled_streams: int32(2),
		Fmapping: [8]uint8{
			1: uint8(4),
			2: uint8(1),
			3: uint8(2),
			4: uint8(3),
		},
	},
	5: {
		Fnb_streams:         int32(4),
		Fnb_coupled_streams: int32(2),
		Fmapping: [8]uint8{
			1: uint8(4),
			2: uint8(1),
			3: uint8(2),
			4: uint8(3),
			5: uint8(5),
		},
	},
	6: {
		Fnb_streams:         int32(4),
		Fnb_coupled_streams: int32(3),
		Fmapping: [8]uint8{
			1: uint8(4),
			2: uint8(1),
			3: uint8(2),
			4: uint8(3),
			5: uint8(5),
			6: uint8(6),
		},
	},
	7: {
		Fnb_streams:         int32(5),
		Fnb_coupled_streams: int32(3),
		Fmapping: [8]uint8{
			1: uint8(6),
			2: uint8(1),
			3: uint8(2),
			4: uint8(3),
			5: uint8(4),
			6: uint8(5),
			7: uint8(7),
		},
	},
}

func Opus_get_right_channel(tls *libc.TLS, layout uintptr, stream_id int32, prev int32) (r int32) {
	var i, v1 int32
	_, _ = i, v1
	if prev < 0 {
		v1 = 0
	} else {
		v1 = prev + int32(1)
	}
	i = v1
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) == stream_id*int32(2)+int32(1) {
			return i
		}
		goto _2
	_2:
		;
		i = i + 1
	}
	return -int32(1)
}

func Opus_haar1(tls *libc.TLS, X uintptr, N0 int32, stride int32) {
	var i, j int32
	var tmp1, tmp2 OpusT_opus_val32
	_, _, _, _ = i, j, tmp1, tmp2
	N0 = N0 >> int32(1)
	i = 0
	for {
		if !(i < stride) {
			break
		}
		j = 0
		for {
			if !(j < N0) {
				break
			}
			tmp1 = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*int32(2)*j+i)*4)))
			tmp2 = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*(int32(2)*j+int32(1))+i)*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*int32(2)*j+i)*4)) = tmp1 + tmp2
			*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(stride*(int32(2)*j+int32(1))+i)*4)) = tmp1 - tmp2
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_hysteresis_decision(tls *libc.TLS, val OpusT_opus_val16, thresholds uintptr, hysteresis uintptr, N int32, prev int32) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < N) {
			break
		}
		if val < *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(i)*4)) {
			break
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if i > prev && val < *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(prev)*4))+*(*OpusT_opus_val16)(unsafe.Pointer(hysteresis + uintptr(prev)*4)) {
		i = prev
	}
	if i < prev && val > *(*OpusT_opus_val16)(unsafe.Pointer(thresholds + uintptr(prev-int32(1))*4))-*(*OpusT_opus_val16)(unsafe.Pointer(hysteresis + uintptr(prev-int32(1))*4)) {
		i = prev
	}
	return i
}

func Opus_init_caps(tls *libc.TLS, m uintptr, cap1 uintptr, LM int32, C int32) {
	var N, i int32
	_, _ = N, i
	i = 0
	for {
		if !(i < (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) {
			break
		}
		N = (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))) << LM
		*(*int32)(unsafe.Pointer(cap1 + uintptr(i)*4)) = (libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).Fcache.Fcaps + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands*(int32(2)*LM+C-int32(1))+i)))) + int32(64)) * C * N >> int32(2)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_is_digital_silence(tls *libc.TLS, pcm uintptr, frame_size int32, channels int32, lsb_depth int32) (r int32) {
	var i, silence int32
	var maxval, minval, v3, v4, v7 OpusT_opus_val16
	var sample_max, v5 OpusT_opus_val32
	var v1 uintptr
	_, _, _, _, _, _, _, _, _, _ = i, maxval, minval, sample_max, silence, v1, v3, v4, v5, v7
	silence = 0
	sample_max = libc.Float32FromInt32(0)
	v1 = pcm
	maxval = libc.Float32FromInt32(0)
	minval = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < frame_size*channels) {
			break
		}
		if maxval > *(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4)) {
			v3 = maxval
		} else {
			v3 = *(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))
		}
		maxval = v3
		if minval < *(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4)) {
			v4 = minval
		} else {
			v4 = *(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))
		}
		minval = v4
		goto _2
	_2:
		;
		i = i + 1
	}
	if maxval > -minval {
		v7 = maxval
	} else {
		v7 = -minval
	}
	v5 = v7
	goto _6
_6:
	sample_max = v5
	silence = libc.BoolInt32(sample_max <= libc.Float32FromInt32(1)/float32(libc.Int32FromInt32(1)<<lsb_depth))
	return silence
}

func Opus_isqrt32(tls *libc.TLS, _val OpusT_opus_uint32) (r uint32) {
	var b, g uint32
	var bshift int32
	var t OpusT_opus_uint32
	_, _, _, _ = b, bshift, g, t
	/*Uses the second method from
	   http://www.azillionmonkeys.com/qed/sqroot.html
	  The main idea is to search for the largest binary digit b such that
	   (g+b)*(g+b) <= _val, and add it to the solution g.*/
	g = uint32(0)
	bshift = (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, _val) - int32(1)) >> int32(1)
	b = uint32(1) << bshift
	for cond := true; cond; cond = bshift >= 0 {
		t = (g<<libc.Int32FromInt32(1) + b) << bshift
		if t <= _val {
			g = g + b
			_val = _val - t
		}
		b = b >> uint32(1)
		bshift = bshift - 1
	}
	return g
}

func Opus_lrint(tls *libc.TLS, x float64) (r int64) {
	return lrint_ties_to_even_double(tls, x)
}

const ATAN2_2_OVER_PI = 0.636619772367581
const ATAN2_COEFF_A05 = 0.19962704181671143
const ATAN2_COEFF_A09 = 0.09794234484434128
const ATAN2_COEFF_A13 = 0.023040136322379112
const BITRES = 3
const CELTDecoder = "OpusCustomDecoder"
const CELTEncoder = "OpusCustomEncoder"
const CELTMode = "OpusCustomMode"
const CELT_GET_AND_CLEAR_ERROR_REQUEST = 10007
const CELT_GET_MODE_REQUEST = 10015
const CELT_SET_ANALYSIS_REQUEST = 10022
const CELT_SET_CHANNELS_REQUEST = 10008
const CELT_SET_END_BAND_REQUEST = 10012
const CELT_SET_INPUT_CLIPPING_REQUEST = 10004
const CELT_SET_PREDICTION_REQUEST = 10002
const CELT_SET_SIGNALLING_REQUEST = 10016
const CELT_SET_SILK_INFO_REQUEST = 10028
const CELT_SET_START_BAND_REQUEST = 10010
const CELT_SET_TONALITY_REQUEST = 10018
const CELT_SET_TONALITY_SLOPE_REQUEST = 10020
const CELT_SIG_SCALE = "32768.f"
const COEF_ONE = "1.0f"
const COMBFILTER_MAXPERIOD = 1024
const COMBFILTER_MINPERIOD = 15
const COS_COEFF_A0 = 0.9999999403953552
const COS_COEFF_A4 = 0.2536507546901703
const COS_COEFF_A8 = 0.0008581906440667808
const EC_UINT_BITS = 8
const EPSILON = "1e-15f"
const EXIT_FAILURE = 1
const EXIT_SUCCESS = 0
const EXP2_COEFF_A0 = 0.9999999403953552
const EXP2_COEFF_A1 = 0.6931530833244324
const EXP2_COEFF_A2 = 0.24015361070632935
const EXP2_COEFF_A3 = 0.05582631751894951
const EXP2_COEFF_A4 = 0.00898933969438076
const EXP2_COEFF_A5 = 0.0018775766948238015
const FP_INFINITE1 = 1
const FP_NAN1 = 0
const FP_NORMAL1 = 4
const FP_SUBNORMAL1 = 3
const FP_ZERO1 = 2
const GLOBAL_STACK_SIZE = 120000
const KF_SUFFIX = "_celt_single"
const KISS_FFT_MALLOC = "opus_alloc"
const LEAK_BANDS = 19
const LOG2_COEFF_A0 = 0.08746284246444702
const LOG2_COEFF_A1 = 1.3578295707702637
const LOG2_COEFF_A3 = 0.4019712507724762
const MATH_ERREXCEPT = 2
const MATH_ERRNO = 1
const MAXFACTORS = 8
const MAX_ENCODING_DEPTH = 24
const MB_LEN_MAX = 16
const MODE_CELT_ONLY = 1002
const MODE_HYBRID = 1001
const MODE_SILK_ONLY = 1000
const NORM_SCALING = "1.f"
const OPUS_APPLICATION_AUDIO = 2049
const OPUS_APPLICATION_RESTRICTED_CELT = 2053
const OPUS_APPLICATION_RESTRICTED_LOWDELAY = 2051
const OPUS_APPLICATION_RESTRICTED_SILK = 2052
const OPUS_APPLICATION_VOIP = 2048
const OPUS_ARCHMASK = 0
const OPUS_BANDWIDTH_FULLBAND = 1105
const OPUS_BANDWIDTH_MEDIUMBAND = 1102
const OPUS_BANDWIDTH_NARROWBAND = 1101
const OPUS_BANDWIDTH_SUPERWIDEBAND = 1104
const OPUS_BANDWIDTH_WIDEBAND = 1103
const OPUS_FAST_INT64 = 1
const OPUS_FRAMESIZE_100_MS = 5008
const OPUS_FRAMESIZE_10_MS = 5003
const OPUS_FRAMESIZE_120_MS = 5009
const OPUS_FRAMESIZE_20_MS = 5004
const OPUS_FRAMESIZE_2_5_MS = 5001
const OPUS_FRAMESIZE_40_MS = 5005
const OPUS_FRAMESIZE_5_MS = 5002
const OPUS_FRAMESIZE_60_MS = 5006
const OPUS_FRAMESIZE_80_MS = 5007
const OPUS_FRAMESIZE_ARG = 5000
const OPUS_GET_APPLICATION_REQUEST = 4001
const OPUS_GET_BANDWIDTH_REQUEST = 4009
const OPUS_GET_BITRATE_REQUEST = 4003
const OPUS_GET_COMPLEXITY_REQUEST = 4011
const OPUS_GET_DRED_DURATION_REQUEST = 4051
const OPUS_GET_DTX_REQUEST = 4017
const OPUS_GET_EXPERT_FRAME_DURATION_REQUEST = 4041
const OPUS_GET_FINAL_RANGE_REQUEST = 4031
const OPUS_GET_FORCE_CHANNELS_REQUEST = 4023
const OPUS_GET_GAIN_REQUEST = 4045
const OPUS_GET_IGNORE_EXTENSIONS_REQUEST = 4059
const OPUS_GET_INBAND_FEC_REQUEST = 4013
const OPUS_GET_IN_DTX_REQUEST = 4049
const OPUS_GET_LAST_PACKET_DURATION_REQUEST = 4039
const OPUS_GET_LOOKAHEAD_REQUEST = 4027
const OPUS_GET_LSB_DEPTH_REQUEST = 4037
const OPUS_GET_MAX_BANDWIDTH_REQUEST = 4005
const OPUS_GET_OSCE_BWE_REQUEST = 4055
const OPUS_GET_PACKET_LOSS_PERC_REQUEST = 4015
const OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST = 4047
const OPUS_GET_PITCH_REQUEST = 4033
const OPUS_GET_PREDICTION_DISABLED_REQUEST = 4043
const OPUS_GET_QEXT_REQUEST = 4057
const OPUS_GET_SAMPLE_RATE_REQUEST = 4029
const OPUS_GET_SIGNAL_REQUEST = 4025
const OPUS_GET_VBR_CONSTRAINT_REQUEST = 4021
const OPUS_GET_VBR_REQUEST = 4007
const OPUS_GET_VOICE_RATIO_REQUEST = 11019
const OPUS_INLINE = "inline"
const OPUS_OK = 0
const OPUS_RESET_STATE = 4028
const OPUS_RESTRICT = "restrict"
const OPUS_SET_APPLICATION_REQUEST = 4000
const OPUS_SET_BANDWIDTH_REQUEST = 4008
const OPUS_SET_BITRATE_REQUEST = 4002
const OPUS_SET_COMPLEXITY_REQUEST = 4010
const OPUS_SET_DNN_BLOB_REQUEST = 4052
const OPUS_SET_DRED_DURATION_REQUEST = 4050
const OPUS_SET_DTX_REQUEST = 4016
const OPUS_SET_ENERGY_MASK_REQUEST = 10026
const OPUS_SET_EXPERT_FRAME_DURATION_REQUEST = 4040
const OPUS_SET_FORCE_CHANNELS_REQUEST = 4022
const OPUS_SET_FORCE_MODE_REQUEST = 11002
const OPUS_SET_GAIN_REQUEST = 4034
const OPUS_SET_IGNORE_EXTENSIONS_REQUEST = 4058
const OPUS_SET_INBAND_FEC_REQUEST = 4012
const OPUS_SET_LFE_REQUEST = 10024
const OPUS_SET_LSB_DEPTH_REQUEST = 4036
const OPUS_SET_MAX_BANDWIDTH_REQUEST = 4004
const OPUS_SET_OSCE_BWE_REQUEST = 4054
const OPUS_SET_PACKET_LOSS_PERC_REQUEST = 4014
const OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST = 4046
const OPUS_SET_PREDICTION_DISABLED_REQUEST = 4042
const OPUS_SET_QEXT_REQUEST = 4056
const OPUS_SET_SIGNAL_REQUEST = 4024
const OPUS_SET_VBR_CONSTRAINT_REQUEST = 4020
const OPUS_SET_VBR_REQUEST = 4006
const OPUS_SET_VOICE_RATIO_REQUEST = 11018
const OPUS_SIGNAL_MUSIC = 3002
const OPUS_SIGNAL_VOICE = 3001
const PI = 3.141592653589793
const Q15ONE = "1.0f"
const Q31ONE = "1.0f"
const QEXT_EXTENSION_ID = 124
const RAND_MAX = 2147483647
const VERY_LARGE16 = "1e15f"
const VERY_SMALL = "1e-30f"
const _BITS_LIBM_SIMD_DECL_STUBS_H = 1
const _BITS_STRING_FORTIFIED_H = 1
const _LIBC_LIMITS_H_ = 1
const _MATH_H = 1
const _STDLIB_H = 1
const _STRING_H = 1
const __FP_LOGB0_IS_MIN = 1
const __FP_LOGBNAN_IS_MIN = 1
const __GLIBC_FLT_EVAL_METHOD = "__FLT_EVAL_METHOD__"
const __HAVE_DISTINCT_FLOAT128 = 1
const __HAVE_DISTINCT_FLOAT128X = "__HAVE_FLOAT128X"
const __HAVE_DISTINCT_FLOAT16 = "__HAVE_FLOAT16"
const __HAVE_DISTINCT_FLOAT32 = 0
const __HAVE_DISTINCT_FLOAT32X = 0
const __HAVE_DISTINCT_FLOAT64 = 0
const __HAVE_DISTINCT_FLOAT64X = 0
const __HAVE_FLOAT128 = 1
const __HAVE_FLOAT128X = 0
const __HAVE_FLOAT16 = 0
const __HAVE_FLOAT32 = 1
const __HAVE_FLOAT32X = 1
const __HAVE_FLOAT64 = 1
const __HAVE_FLOAT64X = 1
const __HAVE_FLOAT64X_LONG_DOUBLE = 1
const __HAVE_FLOATN_NOT_TYPEDEF = 1
const __MATH_DECLARE_LDOUBLE = 1
const __STDLIB_MB_LEN_MAX = 16
const __ldiv_t_defined = 1
const __lldiv_t_defined = 1
const _ecintrin_H = 1
const _entcode_H = 1
const _entdec_H = 1
const _entenc_H = 1
const celt_decoder_ctl = "opus_custom_decoder_ctl"
const celt_encoder_ctl = "opus_custom_encoder_ctl"
const celt_exp2_db = "celt_exp2"
const celt_log2_db = "celt_log2"
const celt_maxabs_res = "celt_maxabs16"
const kiss_fft_scalar = "float"
const kiss_twiddle_scalar = "float"
const opus_int = "int"

type OpusT_opus_int8 = int8

type OpusT_opus_uint8 = uint8

type OpusT_opus_int16 = int16

type OpusT_opus_uint16 = uint16

type OpusT_opus_int32 = int32

type OpusT_opus_uint32 = uint32

type OpusT_opus_int64 = int64

type OpusT_opus_uint64 = uint64

type OpusT_OpusRepacketizer = struct {
	Ftoc               uint8
	Fnb_frames         int32
	Fframes            [48]uintptr
	Flen1              [48]OpusT_opus_int16
	Fframesize         int32
	Fpaddings          [48]uintptr
	Fpadding_len       [48]OpusT_opus_int32
	Fpadding_nb_frames [48]uint8
}

type OpusT_opus_val16 = float32

type OpusT_opus_val32 = float32

type OpusT_opus_val64 = float32

type OpusT_celt_sig = float32

type OpusT_celt_norm = float32

type OpusT_celt_ener = float32

type OpusT_celt_glog = float32

type OpusT_opus_res = float32

type OpusT_celt_coef = float32

type OpusT_ptrdiff_t = int64

type OpusT_size_t = uint64

type OpusT_wchar_t = int32

type OpusT_float_t = float32

type OpusT_double_t = float64

const FP_NAN = 0
const FP_INFINITE = 1
const FP_ZERO = 2
const FP_SUBNORMAL = 3
const FP_NORMAL = 4

type OpusT_ec_window = uint32

type OpusT_ec_ctx = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type OpusT_ec_enc = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type ec_ctx = OpusT_ec_enc

type OpusT_ec_dec = struct {
	Fbuf         uintptr
	Fstorage     OpusT_opus_uint32
	Fend_offs    OpusT_opus_uint32
	Fend_window  OpusT_ec_window
	Fnend_bits   int32
	Fnbits_total int32
	Foffs        OpusT_opus_uint32
	Frng         OpusT_opus_uint32
	Fval         OpusT_opus_uint32
	Fext         OpusT_opus_uint32
	Frem         int32
	Ferror1      int32
}

type OpusT_div_t = struct {
	Fquot int32
	Frem  int32
}

type OpusT_ldiv_t = struct {
	Fquot int64
	Frem  int64
}

type OpusT_lldiv_t = struct {
	Fquot int64
	Frem  int64
}

type OpusT___compar_fn_t = uintptr

var log2_x_norm_coeff = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

type OpusT_kiss_fft_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_kiss_twiddle_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_arch_fft_state = struct {
	Fis_supported int32
	Fpriv         uintptr
}

type OpusT_kiss_fft_state = struct {
	Fnfft     int32
	Fscale    OpusT_celt_coef
	Fshift    int32
	Ffactors  [16]OpusT_opus_int16
	Fbitrev   uintptr
	Ftwiddles uintptr
	Farch_fft uintptr
}

type OpusT_AnalysisInfo = struct {
	Fvalid                int32
	Ftonality             float32
	Ftonality_slope       float32
	Fnoisiness            float32
	Factivity             float32
	Fmusic_prob           float32
	Fmusic_prob_min       float32
	Fmusic_prob_max       float32
	Fbandwidth            int32
	Factivity_probability float32
	Fmax_pitch_ratio      float32
	Fleak_boost           [19]uint8
}

type OpusT_SILKInfo = struct {
	FsignalType int32
	Foffset     int32
}

var trim_icdf = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT___gnuc_va_list = uintptr

type OpusT_va_list = uintptr

type OpusRepacketizer = struct {
	Ftoc               uint8
	Fnb_frames         int32
	Fframes            [48]uintptr
	Flen1              [48]OpusT_opus_int16
	Fframesize         int32
	Fpaddings          [48]uintptr
	Fpadding_len       [48]OpusT_opus_int32
	Fpadding_nb_frames [48]uint8
}

type OpusT_OpusExtensionIterator = struct {
	Fdata               uintptr
	Fcurr_data          uintptr
	Frepeat_data        uintptr
	Flast_long          uintptr
	Fsrc_data           uintptr
	Flen1               OpusT_opus_int32
	Fcurr_len           OpusT_opus_int32
	Frepeat_len         OpusT_opus_int32
	Fsrc_len            OpusT_opus_int32
	Ftrailing_short_len OpusT_opus_int32
	Fnb_frames          int32
	Fframe_max          int32
	Fcurr_frame         int32
	Frepeat_frame       int32
	Frepeat_l           uint8
}

type OpusT_opus_extension_data = struct {
	Fid    int32
	Fframe int32
	Fdata  uintptr
	Flen1  OpusT_opus_int32
}

type OpusT_ChannelLayout = struct {
	Fnb_channels        int32
	Fnb_streams         int32
	Fnb_coupled_streams int32
	Fmapping            [256]uint8
}

type OpusT_MappingType = int32

const MAPPING_TYPE_NONE = 0
const MAPPING_TYPE_SURROUND = 1
const MAPPING_TYPE_AMBISONICS = 2

type OpusMSEncoder = struct {
	Flayout            OpusT_ChannelLayout
	Farch              int32
	Flfe_stream        int32
	Fapplication       int32
	FFs                OpusT_opus_int32
	Fvariable_duration int32
	Fmapping_type      OpusT_MappingType
	Fbitrate_bps       OpusT_opus_int32
}

type OpusMSDecoder = struct {
	Flayout OpusT_ChannelLayout
}

type OpusT_opus_copy_channel_in_func = uintptr

type OpusT_opus_copy_channel_out_func = uintptr

type OpusT_downmix_func = uintptr

func Opus_lrintf(tls *libc.TLS, x float32) (r int64) {
	return lrintf_ties_to_even_float(tls, x)
}

func Opus_mapping_matrix_get_data(tls *libc.TLS, matrix uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(12)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return matrix + uintptr(v1)
}

func Opus_mapping_matrix_get_size(tls *libc.TLS, rows int32, cols int32) (r OpusT_opus_int32) {
	var alignment uint32
	var size OpusT_opus_int32
	var v1, v3 int32
	_, _, _, _ = alignment, size, v1, v3
	/* Mapping Matrix must only support up to 255 channels in or out.
	 * Additionally, the total cell count must be <= 65004 octets in order
	 * for the matrix to be stored in an OGG header.
	 */
	if rows > int32(255) || cols > int32(255) {
		return 0
	}
	size = libc.Int32FromUint64(libc.Uint64FromInt32(rows*cols) * uint64(2))
	if size > int32(65004) {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(12)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(size) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	return v1 + v3
}

func Opus_mapping_matrix_init(tls *libc.TLS, matrix uintptr, rows int32, cols int32, gain int32, data uintptr, data_size OpusT_opus_int32) {
	var alignment uint32
	var i1, v1, v3 int32
	var ptr uintptr
	_, _, _, _, _ = alignment, i1, ptr, v1, v3
	_ = data_size
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(data_size) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(libc.Uint64FromInt32(rows*cols)*uint64(2))) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	if !(v1 == v3) {
		Opus_celt_fatal(tls, __ccgo_ts+3390, __ccgo_ts+3468, int32(72))
	}
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows = rows
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols = cols
	(*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fgain = gain
	ptr = Opus_mapping_matrix_get_data(tls, matrix)
	i1 = 0
	for {
		if !(i1 < rows*cols) {
			break
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(ptr + uintptr(i1)*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(data + uintptr(i1)*2))
		goto _5
	_5:
		;
		i1 = i1 + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_float(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp float32
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(98))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))**(*float32)(unsafe.Pointer(input + uintptr(input_rows*i+col)*4)))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_int24(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp OpusT_opus_val64
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(236))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + OpusT_opus_val64(float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))*float32(*(*OpusT_opus_int32)(unsafe.Pointer(input + uintptr(input_rows*i+col)*4))))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = float32(libc.Float32FromFloat32(1) / libc.Float32FromFloat32(32768) / libc.Float32FromFloat32(256) * float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*tmp))
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_in_short(tls *libc.TLS, matrix uintptr, input uintptr, input_rows int32, output uintptr, output_row int32, output_rows int32, frame_size int32) {
	var col, i int32
	var matrix_data uintptr
	var tmp OpusT_opus_val32
	_, _, _, _ = col, i, matrix_data, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(161))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		tmp = libc.Float32FromInt32(0)
		col = 0
		for {
			if !(col < input_rows) {
				break
			}
			tmp = tmp + OpusT_opus_val32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*col+output_row)*2)))*int32(*(*OpusT_opus_int16)(unsafe.Pointer(input + uintptr(input_rows*i+col)*2))))
			goto _2
		_2:
			;
			col = col + 1
		}
		*(*OpusT_opus_res)(unsafe.Pointer(output + uintptr(output_rows*i)*4)) = OpusT_opus_res(libc.Float32FromInt32(1) / float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(32768)) * tmp)
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_out_float(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample, tmp float32
	var matrix_data uintptr
	_, _, _, _, _ = i, input_sample, matrix_data, row, tmp
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(130))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		input_sample = *(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4))
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = float32(float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*float32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2)))) * input_sample)
			*(*float32)(unsafe.Pointer(output + uintptr(output_rows*i+row)*4)) += tmp
			goto _2
		_2:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mapping_matrix_multiply_channel_out_int24(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample OpusT_opus_int32
	var matrix_data, v3 uintptr
	var tmp OpusT_opus_int64
	_, _, _, _, _, _ = i, input_sample, matrix_data, row, tmp, v3
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(271))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		input_sample = int32(Opus_lrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4)))))
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = int64(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2))) * int64(input_sample)
			v3 = output + uintptr(output_rows*i+row)*4
			*(*OpusT_opus_int32)(unsafe.Pointer(v3)) = OpusT_opus_int32(int64(*(*OpusT_opus_int32)(unsafe.Pointer(v3))) + (tmp+libc.Int64FromInt32(16384))>>libc.Int32FromInt32(15))
			goto _2
		_2:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

const LEAKAGE_OFFSET = 2.5
const LEAKAGE_SLOPE = 2
const M_PI = 3.141592653
const NB_TONAL_SKIP_BANDS = 9
const TRANSITION_PENALTY = 10

var log2_x_norm_coeff6 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff6 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf11 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf11 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf11 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var dct_table = [128]float32{
	0:   libc.Float32FromFloat32(0.25),
	1:   libc.Float32FromFloat32(0.25),
	2:   libc.Float32FromFloat32(0.25),
	3:   libc.Float32FromFloat32(0.25),
	4:   libc.Float32FromFloat32(0.25),
	5:   libc.Float32FromFloat32(0.25),
	6:   libc.Float32FromFloat32(0.25),
	7:   libc.Float32FromFloat32(0.25),
	8:   libc.Float32FromFloat32(0.25),
	9:   libc.Float32FromFloat32(0.25),
	10:  libc.Float32FromFloat32(0.25),
	11:  libc.Float32FromFloat32(0.25),
	12:  libc.Float32FromFloat32(0.25),
	13:  libc.Float32FromFloat32(0.25),
	14:  libc.Float32FromFloat32(0.25),
	15:  libc.Float32FromFloat32(0.25),
	16:  libc.Float32FromFloat32(0.351851),
	17:  libc.Float32FromFloat32(0.33833),
	18:  libc.Float32FromFloat32(0.311806),
	19:  libc.Float32FromFloat32(0.2733),
	20:  libc.Float32FromFloat32(0.224292),
	21:  libc.Float32FromFloat32(0.166664),
	22:  libc.Float32FromFloat32(0.102631),
	23:  libc.Float32FromFloat32(0.034654),
	24:  -libc.Float32FromFloat32(0.034654),
	25:  -libc.Float32FromFloat32(0.102631),
	26:  -libc.Float32FromFloat32(0.166664),
	27:  -libc.Float32FromFloat32(0.224292),
	28:  -libc.Float32FromFloat32(0.2733),
	29:  -libc.Float32FromFloat32(0.311806),
	30:  -libc.Float32FromFloat32(0.33833),
	31:  -libc.Float32FromFloat32(0.351851),
	32:  libc.Float32FromFloat32(0.34676),
	33:  libc.Float32FromFloat32(0.293969),
	34:  libc.Float32FromFloat32(0.196424),
	35:  libc.Float32FromFloat32(0.068975),
	36:  -libc.Float32FromFloat32(0.068975),
	37:  -libc.Float32FromFloat32(0.196424),
	38:  -libc.Float32FromFloat32(0.293969),
	39:  -libc.Float32FromFloat32(0.34676),
	40:  -libc.Float32FromFloat32(0.34676),
	41:  -libc.Float32FromFloat32(0.293969),
	42:  -libc.Float32FromFloat32(0.196424),
	43:  -libc.Float32FromFloat32(0.068975),
	44:  libc.Float32FromFloat32(0.068975),
	45:  libc.Float32FromFloat32(0.196424),
	46:  libc.Float32FromFloat32(0.293969),
	47:  libc.Float32FromFloat32(0.34676),
	48:  libc.Float32FromFloat32(0.33833),
	49:  libc.Float32FromFloat32(0.224292),
	50:  libc.Float32FromFloat32(0.034654),
	51:  -libc.Float32FromFloat32(0.166664),
	52:  -libc.Float32FromFloat32(0.311806),
	53:  -libc.Float32FromFloat32(0.351851),
	54:  -libc.Float32FromFloat32(0.2733),
	55:  -libc.Float32FromFloat32(0.102631),
	56:  libc.Float32FromFloat32(0.102631),
	57:  libc.Float32FromFloat32(0.2733),
	58:  libc.Float32FromFloat32(0.351851),
	59:  libc.Float32FromFloat32(0.311806),
	60:  libc.Float32FromFloat32(0.166664),
	61:  -libc.Float32FromFloat32(0.034654),
	62:  -libc.Float32FromFloat32(0.224292),
	63:  -libc.Float32FromFloat32(0.33833),
	64:  libc.Float32FromFloat32(0.326641),
	65:  libc.Float32FromFloat32(0.135299),
	66:  -libc.Float32FromFloat32(0.135299),
	67:  -libc.Float32FromFloat32(0.326641),
	68:  -libc.Float32FromFloat32(0.326641),
	69:  -libc.Float32FromFloat32(0.135299),
	70:  libc.Float32FromFloat32(0.135299),
	71:  libc.Float32FromFloat32(0.326641),
	72:  libc.Float32FromFloat32(0.326641),
	73:  libc.Float32FromFloat32(0.135299),
	74:  -libc.Float32FromFloat32(0.135299),
	75:  -libc.Float32FromFloat32(0.326641),
	76:  -libc.Float32FromFloat32(0.326641),
	77:  -libc.Float32FromFloat32(0.135299),
	78:  libc.Float32FromFloat32(0.135299),
	79:  libc.Float32FromFloat32(0.326641),
	80:  libc.Float32FromFloat32(0.311806),
	81:  libc.Float32FromFloat32(0.034654),
	82:  -libc.Float32FromFloat32(0.2733),
	83:  -libc.Float32FromFloat32(0.33833),
	84:  -libc.Float32FromFloat32(0.102631),
	85:  libc.Float32FromFloat32(0.224292),
	86:  libc.Float32FromFloat32(0.351851),
	87:  libc.Float32FromFloat32(0.166664),
	88:  -libc.Float32FromFloat32(0.166664),
	89:  -libc.Float32FromFloat32(0.351851),
	90:  -libc.Float32FromFloat32(0.224292),
	91:  libc.Float32FromFloat32(0.102631),
	92:  libc.Float32FromFloat32(0.33833),
	93:  libc.Float32FromFloat32(0.2733),
	94:  -libc.Float32FromFloat32(0.034654),
	95:  -libc.Float32FromFloat32(0.311806),
	96:  libc.Float32FromFloat32(0.293969),
	97:  -libc.Float32FromFloat32(0.068975),
	98:  -libc.Float32FromFloat32(0.34676),
	99:  -libc.Float32FromFloat32(0.196424),
	100: libc.Float32FromFloat32(0.196424),
	101: libc.Float32FromFloat32(0.34676),
	102: libc.Float32FromFloat32(0.068975),
	103: -libc.Float32FromFloat32(0.293969),
	104: -libc.Float32FromFloat32(0.293969),
	105: libc.Float32FromFloat32(0.068975),
	106: libc.Float32FromFloat32(0.34676),
	107: libc.Float32FromFloat32(0.196424),
	108: -libc.Float32FromFloat32(0.196424),
	109: -libc.Float32FromFloat32(0.34676),
	110: -libc.Float32FromFloat32(0.068975),
	111: libc.Float32FromFloat32(0.293969),
	112: libc.Float32FromFloat32(0.2733),
	113: -libc.Float32FromFloat32(0.166664),
	114: -libc.Float32FromFloat32(0.33833),
	115: libc.Float32FromFloat32(0.034654),
	116: libc.Float32FromFloat32(0.351851),
	117: libc.Float32FromFloat32(0.102631),
	118: -libc.Float32FromFloat32(0.311806),
	119: -libc.Float32FromFloat32(0.224292),
	120: libc.Float32FromFloat32(0.224292),
	121: libc.Float32FromFloat32(0.311806),
	122: -libc.Float32FromFloat32(0.102631),
	123: -libc.Float32FromFloat32(0.351851),
	124: -libc.Float32FromFloat32(0.034654),
	125: libc.Float32FromFloat32(0.33833),
	126: libc.Float32FromFloat32(0.166664),
	127: -libc.Float32FromFloat32(0.2733),
}

var analysis_window = [240]float32{
	0:   libc.Float32FromFloat32(4.3e-05),
	1:   libc.Float32FromFloat32(0.000171),
	2:   libc.Float32FromFloat32(0.000385),
	3:   libc.Float32FromFloat32(0.000685),
	4:   libc.Float32FromFloat32(0.001071),
	5:   libc.Float32FromFloat32(0.001541),
	6:   libc.Float32FromFloat32(0.002098),
	7:   libc.Float32FromFloat32(0.002739),
	8:   libc.Float32FromFloat32(0.003466),
	9:   libc.Float32FromFloat32(0.004278),
	10:  libc.Float32FromFloat32(0.005174),
	11:  libc.Float32FromFloat32(0.006156),
	12:  libc.Float32FromFloat32(0.007222),
	13:  libc.Float32FromFloat32(0.008373),
	14:  libc.Float32FromFloat32(0.009607),
	15:  libc.Float32FromFloat32(0.010926),
	16:  libc.Float32FromFloat32(0.012329),
	17:  libc.Float32FromFloat32(0.013815),
	18:  libc.Float32FromFloat32(0.015385),
	19:  libc.Float32FromFloat32(0.017037),
	20:  libc.Float32FromFloat32(0.018772),
	21:  libc.Float32FromFloat32(0.02059),
	22:  libc.Float32FromFloat32(0.02249),
	23:  libc.Float32FromFloat32(0.024472),
	24:  libc.Float32FromFloat32(0.026535),
	25:  libc.Float32FromFloat32(0.028679),
	26:  libc.Float32FromFloat32(0.030904),
	27:  libc.Float32FromFloat32(0.03321),
	28:  libc.Float32FromFloat32(0.035595),
	29:  libc.Float32FromFloat32(0.03806),
	30:  libc.Float32FromFloat32(0.040604),
	31:  libc.Float32FromFloat32(0.043227),
	32:  libc.Float32FromFloat32(0.045928),
	33:  libc.Float32FromFloat32(0.048707),
	34:  libc.Float32FromFloat32(0.051564),
	35:  libc.Float32FromFloat32(0.054497),
	36:  libc.Float32FromFloat32(0.057506),
	37:  libc.Float32FromFloat32(0.060591),
	38:  libc.Float32FromFloat32(0.063752),
	39:  libc.Float32FromFloat32(0.066987),
	40:  libc.Float32FromFloat32(0.070297),
	41:  libc.Float32FromFloat32(0.07368),
	42:  libc.Float32FromFloat32(0.077136),
	43:  libc.Float32FromFloat32(0.080665),
	44:  libc.Float32FromFloat32(0.084265),
	45:  libc.Float32FromFloat32(0.087937),
	46:  libc.Float32FromFloat32(0.091679),
	47:  libc.Float32FromFloat32(0.095492),
	48:  libc.Float32FromFloat32(0.099373),
	49:  libc.Float32FromFloat32(0.103323),
	50:  libc.Float32FromFloat32(0.107342),
	51:  libc.Float32FromFloat32(0.111427),
	52:  libc.Float32FromFloat32(0.115579),
	53:  libc.Float32FromFloat32(0.119797),
	54:  libc.Float32FromFloat32(0.12408),
	55:  libc.Float32FromFloat32(0.128428),
	56:  libc.Float32FromFloat32(0.132839),
	57:  libc.Float32FromFloat32(0.137313),
	58:  libc.Float32FromFloat32(0.141849),
	59:  libc.Float32FromFloat32(0.146447),
	60:  libc.Float32FromFloat32(0.151105),
	61:  libc.Float32FromFloat32(0.155823),
	62:  libc.Float32FromFloat32(0.1606),
	63:  libc.Float32FromFloat32(0.165435),
	64:  libc.Float32FromFloat32(0.170327),
	65:  libc.Float32FromFloat32(0.175276),
	66:  libc.Float32FromFloat32(0.18028),
	67:  libc.Float32FromFloat32(0.18534),
	68:  libc.Float32FromFloat32(0.190453),
	69:  libc.Float32FromFloat32(0.195619),
	70:  libc.Float32FromFloat32(0.200838),
	71:  libc.Float32FromFloat32(0.206107),
	72:  libc.Float32FromFloat32(0.211427),
	73:  libc.Float32FromFloat32(0.216797),
	74:  libc.Float32FromFloat32(0.222215),
	75:  libc.Float32FromFloat32(0.22768),
	76:  libc.Float32FromFloat32(0.233193),
	77:  libc.Float32FromFloat32(0.238751),
	78:  libc.Float32FromFloat32(0.244353),
	79:  libc.Float32FromFloat32(0.25),
	80:  libc.Float32FromFloat32(0.255689),
	81:  libc.Float32FromFloat32(0.261421),
	82:  libc.Float32FromFloat32(0.267193),
	83:  libc.Float32FromFloat32(0.273005),
	84:  libc.Float32FromFloat32(0.278856),
	85:  libc.Float32FromFloat32(0.284744),
	86:  libc.Float32FromFloat32(0.29067),
	87:  libc.Float32FromFloat32(0.296632),
	88:  libc.Float32FromFloat32(0.302628),
	89:  libc.Float32FromFloat32(0.308658),
	90:  libc.Float32FromFloat32(0.314721),
	91:  libc.Float32FromFloat32(0.320816),
	92:  libc.Float32FromFloat32(0.326941),
	93:  libc.Float32FromFloat32(0.333097),
	94:  libc.Float32FromFloat32(0.33928),
	95:  libc.Float32FromFloat32(0.345492),
	96:  libc.Float32FromFloat32(0.351729),
	97:  libc.Float32FromFloat32(0.357992),
	98:  libc.Float32FromFloat32(0.36428),
	99:  libc.Float32FromFloat32(0.37059),
	100: libc.Float32FromFloat32(0.376923),
	101: libc.Float32FromFloat32(0.383277),
	102: libc.Float32FromFloat32(0.389651),
	103: libc.Float32FromFloat32(0.396044),
	104: libc.Float32FromFloat32(0.402455),
	105: libc.Float32FromFloat32(0.408882),
	106: libc.Float32FromFloat32(0.415325),
	107: libc.Float32FromFloat32(0.421783),
	108: libc.Float32FromFloat32(0.428254),
	109: libc.Float32FromFloat32(0.434737),
	110: libc.Float32FromFloat32(0.441231),
	111: libc.Float32FromFloat32(0.447736),
	112: libc.Float32FromFloat32(0.454249),
	113: libc.Float32FromFloat32(0.46077),
	114: libc.Float32FromFloat32(0.467298),
	115: libc.Float32FromFloat32(0.473832),
	116: libc.Float32FromFloat32(0.48037),
	117: libc.Float32FromFloat32(0.486912),
	118: libc.Float32FromFloat32(0.493455),
	119: libc.Float32FromFloat32(0.5),
	120: libc.Float32FromFloat32(0.506545),
	121: libc.Float32FromFloat32(0.513088),
	122: libc.Float32FromFloat32(0.51963),
	123: libc.Float32FromFloat32(0.526168),
	124: libc.Float32FromFloat32(0.532702),
	125: libc.Float32FromFloat32(0.53923),
	126: libc.Float32FromFloat32(0.545751),
	127: libc.Float32FromFloat32(0.552264),
	128: libc.Float32FromFloat32(0.558769),
	129: libc.Float32FromFloat32(0.565263),
	130: libc.Float32FromFloat32(0.571746),
	131: libc.Float32FromFloat32(0.578217),
	132: libc.Float32FromFloat32(0.584675),
	133: libc.Float32FromFloat32(0.591118),
	134: libc.Float32FromFloat32(0.597545),
	135: libc.Float32FromFloat32(0.603956),
	136: libc.Float32FromFloat32(0.610349),
	137: libc.Float32FromFloat32(0.616723),
	138: libc.Float32FromFloat32(0.623077),
	139: libc.Float32FromFloat32(0.62941),
	140: libc.Float32FromFloat32(0.63572),
	141: libc.Float32FromFloat32(0.642008),
	142: libc.Float32FromFloat32(0.648271),
	143: libc.Float32FromFloat32(0.654508),
	144: libc.Float32FromFloat32(0.66072),
	145: libc.Float32FromFloat32(0.666903),
	146: libc.Float32FromFloat32(0.673059),
	147: libc.Float32FromFloat32(0.679184),
	148: libc.Float32FromFloat32(0.685279),
	149: libc.Float32FromFloat32(0.691342),
	150: libc.Float32FromFloat32(0.697372),
	151: libc.Float32FromFloat32(0.703368),
	152: libc.Float32FromFloat32(0.70933),
	153: libc.Float32FromFloat32(0.715256),
	154: libc.Float32FromFloat32(0.721144),
	155: libc.Float32FromFloat32(0.726995),
	156: libc.Float32FromFloat32(0.732807),
	157: libc.Float32FromFloat32(0.738579),
	158: libc.Float32FromFloat32(0.744311),
	159: libc.Float32FromFloat32(0.75),
	160: libc.Float32FromFloat32(0.755647),
	161: libc.Float32FromFloat32(0.761249),
	162: libc.Float32FromFloat32(0.766807),
	163: libc.Float32FromFloat32(0.77232),
	164: libc.Float32FromFloat32(0.777785),
	165: libc.Float32FromFloat32(0.783203),
	166: libc.Float32FromFloat32(0.788573),
	167: libc.Float32FromFloat32(0.793893),
	168: libc.Float32FromFloat32(0.799162),
	169: libc.Float32FromFloat32(0.804381),
	170: libc.Float32FromFloat32(0.809547),
	171: libc.Float32FromFloat32(0.81466),
	172: libc.Float32FromFloat32(0.81972),
	173: libc.Float32FromFloat32(0.824724),
	174: libc.Float32FromFloat32(0.829673),
	175: libc.Float32FromFloat32(0.834565),
	176: libc.Float32FromFloat32(0.8394),
	177: libc.Float32FromFloat32(0.844177),
	178: libc.Float32FromFloat32(0.848895),
	179: libc.Float32FromFloat32(0.853553),
	180: libc.Float32FromFloat32(0.858151),
	181: libc.Float32FromFloat32(0.862687),
	182: libc.Float32FromFloat32(0.867161),
	183: libc.Float32FromFloat32(0.871572),
	184: libc.Float32FromFloat32(0.87592),
	185: libc.Float32FromFloat32(0.880203),
	186: libc.Float32FromFloat32(0.884421),
	187: libc.Float32FromFloat32(0.888573),
	188: libc.Float32FromFloat32(0.892658),
	189: libc.Float32FromFloat32(0.896677),
	190: libc.Float32FromFloat32(0.900627),
	191: libc.Float32FromFloat32(0.904508),
	192: libc.Float32FromFloat32(0.908321),
	193: libc.Float32FromFloat32(0.912063),
	194: libc.Float32FromFloat32(0.915735),
	195: libc.Float32FromFloat32(0.919335),
	196: libc.Float32FromFloat32(0.922864),
	197: libc.Float32FromFloat32(0.92632),
	198: libc.Float32FromFloat32(0.929703),
	199: libc.Float32FromFloat32(0.933013),
	200: libc.Float32FromFloat32(0.936248),
	201: libc.Float32FromFloat32(0.939409),
	202: libc.Float32FromFloat32(0.942494),
	203: libc.Float32FromFloat32(0.945503),
	204: libc.Float32FromFloat32(0.948436),
	205: libc.Float32FromFloat32(0.951293),
	206: libc.Float32FromFloat32(0.954072),
	207: libc.Float32FromFloat32(0.956773),
	208: libc.Float32FromFloat32(0.959396),
	209: libc.Float32FromFloat32(0.96194),
	210: libc.Float32FromFloat32(0.964405),
	211: libc.Float32FromFloat32(0.96679),
	212: libc.Float32FromFloat32(0.969096),
	213: libc.Float32FromFloat32(0.971321),
	214: libc.Float32FromFloat32(0.973465),
	215: libc.Float32FromFloat32(0.975528),
	216: libc.Float32FromFloat32(0.97751),
	217: libc.Float32FromFloat32(0.97941),
	218: libc.Float32FromFloat32(0.981228),
	219: libc.Float32FromFloat32(0.982963),
	220: libc.Float32FromFloat32(0.984615),
	221: libc.Float32FromFloat32(0.986185),
	222: libc.Float32FromFloat32(0.987671),
	223: libc.Float32FromFloat32(0.989074),
	224: libc.Float32FromFloat32(0.990393),
	225: libc.Float32FromFloat32(0.991627),
	226: libc.Float32FromFloat32(0.992778),
	227: libc.Float32FromFloat32(0.993844),
	228: libc.Float32FromFloat32(0.994826),
	229: libc.Float32FromFloat32(0.995722),
	230: libc.Float32FromFloat32(0.996534),
	231: libc.Float32FromFloat32(0.997261),
	232: libc.Float32FromFloat32(0.997902),
	233: libc.Float32FromFloat32(0.998459),
	234: libc.Float32FromFloat32(0.998929),
	235: libc.Float32FromFloat32(0.999315),
	236: libc.Float32FromFloat32(0.999615),
	237: libc.Float32FromFloat32(0.999829),
	238: libc.Float32FromFloat32(0.999957),
	239: libc.Float32FromFloat32(1),
}

var tbands = [19]int32{
	0:  int32(4),
	1:  int32(8),
	2:  int32(12),
	3:  int32(16),
	4:  int32(20),
	5:  int32(24),
	6:  int32(28),
	7:  int32(32),
	8:  int32(40),
	9:  int32(48),
	10: int32(56),
	11: int32(64),
	12: int32(80),
	13: int32(96),
	14: int32(112),
	15: int32(136),
	16: int32(160),
	17: int32(192),
	18: int32(240),
}

func Opus_mapping_matrix_multiply_channel_out_short(tls *libc.TLS, matrix uintptr, input uintptr, input_row int32, input_rows int32, output uintptr, output_rows int32, frame_size int32) {
	var i, row int32
	var input_sample, tmp OpusT_opus_int32
	var matrix_data, v8 uintptr
	var v2, v3, v4 float32
	var v5 OpusT_opus_int16
	_, _, _, _, _, _, _, _, _, _ = i, input_sample, matrix_data, row, tmp, v2, v3, v4, v5, v8
	if !(input_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Fcols && output_rows <= (*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows) {
		Opus_celt_fatal(tls, __ccgo_ts+3492, __ccgo_ts+3468, int32(206))
	}
	matrix_data = Opus_mapping_matrix_get_data(tls, matrix)
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		v2 = *(*OpusT_opus_res)(unsafe.Pointer(input + uintptr(input_rows*i)*4))
		v2 = float32(v2 * libc.Float32FromFloat32(32768))
		if v2 > float32(-libc.Int32FromInt32(32768)) {
			v3 = v2
		} else {
			v3 = float32(-libc.Int32FromInt32(32768))
		}
		v2 = v3
		if v2 < float32(libc.Int32FromInt32(32767)) {
			v4 = v2
		} else {
			v4 = float32(libc.Int32FromInt32(32767))
		}
		v2 = v4
		v5 = int16(Opus_lrintf(tls, v2))
		goto _6
	_6:
		input_sample = int32(v5)
		row = 0
		for {
			if !(row < output_rows) {
				break
			}
			tmp = int32(*(*OpusT_opus_int16)(unsafe.Pointer(matrix_data + uintptr((*OpusT_MappingMatrix)(unsafe.Pointer(matrix)).Frows*input_row+row)*2))) * input_sample
			v8 = output + uintptr(output_rows*i+row)*2
			*(*OpusT_opus_int16)(unsafe.Pointer(v8)) = OpusT_opus_int16(int32(*(*OpusT_opus_int16)(unsafe.Pointer(v8))) + (tmp+libc.Int32FromInt32(16384))>>libc.Int32FromInt32(15))
			goto _7
		_7:
			;
			row = row + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_mini_kiss_fft(tls *libc.TLS, cfg OpusT_mini_kiss_fft_cfg, fin uintptr, fout uintptr) {
	Opus_mini_kiss_fft_stride(tls, cfg, fin, fout, int32(1))
}

type OpusT_mini_kiss_fftr_cfg = uintptr

type mini_kiss_fftr_state = struct {
	Fsubstate       OpusT_mini_kiss_fft_cfg
	Ftmpbuf         uintptr
	Fsuper_twiddles uintptr
}

type OpusT_mini_kiss_fftr_state = struct {
	Fsubstate       OpusT_mini_kiss_fft_cfg
	Ftmpbuf         uintptr
	Fsuper_twiddles uintptr
}

func Opus_mini_kiss_fft_alloc(tls *libc.TLS, nfft int32, inverse_fft int32, mem uintptr, lenmem uintptr) (r OpusT_mini_kiss_fft_cfg) {
	var i int32
	var memneeded OpusT_size_t
	var phase, pi float64
	var st OpusT_mini_kiss_fft_cfg
	_, _, _, _, _ = i, memneeded, phase, pi, st
	st = libc.UintptrFromInt32(0)
	memneeded = libc.Uint64FromInt64(272) + libc.Uint64FromInt64(8)*libc.Uint64FromInt32(nfft-libc.Int32FromInt32(1)) /* twiddle factors*/
	if lenmem == libc.UintptrFromInt32(0) {
		st = libc.Xmalloc(tls, memneeded)
	} else {
		if mem != libc.UintptrFromInt32(0) && *(*OpusT_size_t)(unsafe.Pointer(lenmem)) >= memneeded {
			st = mem
		}
		*(*OpusT_size_t)(unsafe.Pointer(lenmem)) = memneeded
	}
	if st != 0 {
		(*mini_kiss_fft_state)(unsafe.Pointer(st)).Fnfft = nfft
		(*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse = inverse_fft
		i = 0
		for {
			if !(i < nfft) {
				break
			}
			pi = float64(3.141592653589793)
			phase = float64(float64(float64(-libc.Int32FromInt32(2))*pi)*float64(i)) / float64(nfft)
			if (*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse != 0 {
				phase = phase * float64(-libc.Int32FromInt32(1))
			}
			(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(i)*8)).Fr = float32(libc.Xcos(tls, phase))
			(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(i)*8)).Fi = float32(libc.Xsin(tls, phase))
			goto _1
		_1:
			;
			i = i + 1
		}
		kf_factor(tls, nfft, st+8)
	}
	return st
}

func Opus_mini_kiss_fft_stride(tls *libc.TLS, st OpusT_mini_kiss_fft_cfg, fin uintptr, fout uintptr, in_stride int32) {
	if !(fin != fout) {
		libc.X__assert_fail(tls, __ccgo_ts+6524, __ccgo_ts+6504, int32(391), uintptr(unsafe.Pointer(&__func__1)))
	}
	kf_work(tls, fout, fin, uint64(1), in_stride, st+8, st)
}

var __func__1 = [21]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', '_', 's', 't', 'r', 'i', 'd', 'e'}

func Opus_mini_kiss_fftr(tls *libc.TLS, st OpusT_mini_kiss_fftr_cfg, timedata uintptr, freqdata uintptr) {
	var f1k, f2k, fpk, fpnk, tdc, tw OpusT_mini_kiss_fft_cpx
	var k, ncfft int32
	var v1 float32
	_, _, _, _, _, _, _, _, _ = f1k, f2k, fpk, fpnk, k, ncfft, tdc, tw, v1
	if !!((*mini_kiss_fft_state)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate)).Finverse != 0) {
		libc.X__assert_fail(tls, __ccgo_ts+6552, __ccgo_ts+6504, int32(453), uintptr(unsafe.Pointer(&__func__3)))
	}
	ncfft = (*mini_kiss_fft_state)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate)).Fnfft
	/*perform the parallel fft of two real signals packed in real,imag*/
	Opus_mini_kiss_fft(tls, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate, timedata, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf)
	/* The real part of the DC element of the frequency spectrum in st->tmpbuf
	 * contains the sum of the even-numbered elements of the input time sequence
	 * The imag part is the sum of the odd-numbered elements
	 *
	 * The sum of tdc.r and tdc.i is the sum of the input time sequence.
	 *      yielding DC of input time sequence
	 * The difference of tdc.r - tdc.i is the sum of the input (dot product) [1,-1,1,-1...
	 *      yielding Nyquist bin of input time sequence
	 */
	tdc.Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf))).Fr
	tdc.Fi = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf))).Fi
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata))).Fr = tdc.Fr + tdc.Fi
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft)*8))).Fr = tdc.Fr - tdc.Fi
	v1 = libc.Float32FromInt32(0)
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata))).Fi = v1
	(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft)*8))).Fi = v1
	k = int32(1)
	for {
		if !(k <= ncfft/int32(2)) {
			break
		}
		fpk = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(k)*8))
		fpnk.Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(ncfft-k)*8))).Fr
		fpnk.Fi = -(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(ncfft-k)*8))).Fi
		f1k.Fr = fpk.Fr + fpnk.Fr
		f1k.Fi = fpk.Fi + fpnk.Fi
		f2k.Fr = fpk.Fr - fpnk.Fr
		f2k.Fi = fpk.Fi - fpnk.Fi
		tw.Fr = float32(f2k.Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fr) - float32(f2k.Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fi)
		tw.Fi = float32(f2k.Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fi) + float32(f2k.Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(k-int32(1))*8))).Fr)
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(k)*8))).Fr = float32((f1k.Fr + tw.Fr) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(k)*8))).Fi = float32((f1k.Fi + tw.Fi) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft-k)*8))).Fr = float32((f1k.Fr - tw.Fr) * libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(freqdata + uintptr(ncfft-k)*8))).Fi = float32((tw.Fi - f1k.Fi) * libc.Float32FromFloat64(0.5))
		goto _2
	_2:
		;
		k = k + 1
	}
}

var __func__3 = [15]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', 'r'}

const DTX_ACTIVITY_THRESHOLD2 = "0.1f"
const EPSILON8 = "1e-15f"
const Q15ONE8 = "1.0f"
const silk_int16_MAX1 = 32767

// C documentation
//
//	/* Generates excitation for CNG LPC synthesis */

func Opus_mini_kiss_fftr_alloc(tls *libc.TLS, nfft int32, inverse_fft int32, mem uintptr, lenmem uintptr) (r OpusT_mini_kiss_fftr_cfg) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i int32
	var memneeded OpusT_size_t
	var phase float64
	var st OpusT_mini_kiss_fftr_cfg
	var _ /* subsize at bp+0 */ OpusT_size_t
	_, _, _, _ = i, memneeded, phase, st
	st = libc.UintptrFromInt32(0)
	*(*OpusT_size_t)(unsafe.Pointer(bp)) = uint64(0)
	if !(nfft&int32(1) == 0) {
		libc.X__assert_fail(tls, __ccgo_ts+6536, __ccgo_ts+6504, int32(416), uintptr(unsafe.Pointer(&__func__2)))
	}
	nfft = nfft >> int32(1)
	Opus_mini_kiss_fft_alloc(tls, nfft, inverse_fft, libc.UintptrFromInt32(0), bp)
	memneeded = uint64(24) + *(*OpusT_size_t)(unsafe.Pointer(bp)) + uint64(8)*libc.Uint64FromInt32(nfft*libc.Int32FromInt32(3)/libc.Int32FromInt32(2))
	if lenmem == libc.UintptrFromInt32(0) {
		st = libc.Xmalloc(tls, memneeded)
	} else {
		if *(*OpusT_size_t)(unsafe.Pointer(lenmem)) >= memneeded {
			st = mem
		}
		*(*OpusT_size_t)(unsafe.Pointer(lenmem)) = memneeded
	}
	if !(st != 0) {
		return libc.UintptrFromInt32(0)
	}
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate = st + libc.UintptrFromInt32(1)*24 /*just beyond kiss_fftr_state struct */
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf = (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate + uintptr(*(*OpusT_size_t)(unsafe.Pointer(bp)))
	(*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles = (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Ftmpbuf + uintptr(nfft)*8
	Opus_mini_kiss_fft_alloc(tls, nfft, inverse_fft, (*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsubstate, bp)
	i = 0
	for {
		if !(i < nfft/int32(2)) {
			break
		}
		phase = float64(-libc.Float64FromFloat64(3.141592653589793) * (float64(i+libc.Int32FromInt32(1))/float64(nfft) + float64(0.5)))
		if inverse_fft != 0 {
			phase = phase * float64(-libc.Int32FromInt32(1))
		}
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(i)*8)).Fr = float32(libc.Xcos(tls, phase))
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer((*mini_kiss_fftr_state)(unsafe.Pointer(st)).Fsuper_twiddles + uintptr(i)*8)).Fi = float32(libc.Xsin(tls, phase))
		goto _1
	_1:
		;
		i = i + 1
	}
	return st
}

var __func__2 = [21]int8{'m', 'i', 'n', 'i', '_', 'k', 'i', 's', 's', '_', 'f', 'f', 't', 'r', '_', 'a', 'l', 'l', 'o', 'c'}

func Opus_normalise_bands(tls *libc.TLS, m uintptr, freq uintptr, X uintptr, bandE uintptr, end int32, C int32, M int32) {
	var N, c, i, j, v1 int32
	var eBands uintptr
	var g OpusT_opus_val16
	_, _, _, _, _, _, _ = N, c, eBands, g, i, j, v1
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	N = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	c = 0
	for {
		i = 0
		for {
			if !(i < end) {
				break
			}
			g = libc.Float32FromFloat32(1) / (libc.Float32FromFloat32(1e-27) + *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)))
			j = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))
			for {
				if !(j < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j+c*N)*4)) = OpusT_celt_norm(*(*OpusT_celt_sig)(unsafe.Pointer(freq + uintptr(j+c*N)*4)) * g)
				goto _4
			_4:
				;
				j = j + 1
			}
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
}

// C documentation
//
//	/* De-normalise the energy to produce the synthesis from the unit-energy bands */

func Opus_op_pvq_search_c(tls *libc.TLS, X uintptr, iy uintptr, K int32, N int32, arch int32) (r OpusT_opus_val16) {
	var Rxy, Ryy, best_den, rcp, tmp, yy, v55 OpusT_opus_val16
	var _saved_stack, signx, st, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var best_id, i, j, pulsesLeft, v53 int32
	var best_num, sum, xy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Rxy, Ryy, _saved_stack, best_den, best_id, best_num, i, j, pulsesLeft, rcp, signx, st, sum, tmp, xy, y, yy, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v53, v55, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	_ = arch
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6239, int32(217))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	y = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6239, int32(218))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	signx = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Get rid of the sign */
	sum = libc.Float32FromInt32(0)
	j = 0
	for {
		*(*int32)(unsafe.Pointer(signx + uintptr(j)*4)) = libc.BoolInt32(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) < libc.Float32FromInt32(0))
		/* OPT: Make sure the compiler doesn't use a branch on ABS16(). */
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = float32(libc.Xfabs(tls, float64(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))))
		*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = 0
		*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) = libc.Float32FromInt32(0)
		goto _54
	_54:
		;
		j = j + 1
		v53 = j
		if !(v53 < N) {
			break
		}
	}
	v55 = libc.Float32FromInt32(0)
	yy = v55
	xy = v55
	pulsesLeft = K
	/* Do a pre-search by projecting on the pyramid */
	if K > N>>int32(1) {
		j = 0
		for {
			sum = sum + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))
			goto _57
		_57:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
		/* If X is too small, just replace it with a pulse at 0 */
		/* Prevents infinities and NaNs from causing too many pulses
		   to be allocated. 64 is an approximation of infinity here. */
		if !(sum > libc.Float32FromFloat32(1e-15) && sum < libc.Float32FromInt32(64)) {
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = libc.Float32FromFloat32(1)
			j = int32(1)
			for {
				*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = libc.Float32FromInt32(0)
				goto _59
			_59:
				;
				j = j + 1
				v53 = j
				if !(v53 < N) {
					break
				}
			}
			sum = libc.Float32FromFloat32(1)
		}
		/* Using K+e with e < 1 guarantees we cannot get more than K pulses. */
		rcp = float32((float32(K) + libc.Float32FromFloat32(0.8)) * (libc.Float32FromFloat32(1) / sum))
		j = 0
		for {
			*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = int32(libc.Xfloor(tls, float64(rcp**(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))))
			*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) = float32(*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)))
			yy = yy + OpusT_opus_val16(*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)))
			xy = xy + OpusT_opus_val32(*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4)) *= libc.Float32FromInt32(2)
			pulsesLeft = pulsesLeft - *(*int32)(unsafe.Pointer(iy + uintptr(j)*4))
			goto _61
		_61:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
	}
	_ = pulsesLeft >= libc.Int32FromInt32(0)
	/* This should never happen, but just in case it does (e.g. on silence)
	   we fill the first bin with pulses. */
	if pulsesLeft > N+int32(3) {
		tmp = float32(pulsesLeft)
		yy = yy + OpusT_opus_val16(tmp*tmp)
		yy = yy + OpusT_opus_val16(tmp**(*OpusT_celt_norm)(unsafe.Pointer(y)))
		*(*int32)(unsafe.Pointer(iy)) += pulsesLeft
		pulsesLeft = 0
	}
	i = 0
	for {
		if !(i < pulsesLeft) {
			break
		}
		best_id = 0
		/* The squared magnitude term gets added anyway, so we might as well
		   add it outside the loop */
		yy = yy + float32(libc.Int32FromInt32(1))
		/* Calculations for position 0 are out of the loop, in part to reduce
		   mispredicted branches (since the if condition is usually false)
		   in the loop. */
		/* Temporary sums of the new pulse(s) */
		Rxy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X))
		/* We're multiplying y[j] by two so we don't have to do it here */
		Ryy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y))
		/* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
		   Rxy is positive because the sign is pre-computed) */
		Rxy = OpusT_opus_val16(Rxy * Rxy)
		best_den = Ryy
		best_num = Rxy
		j = int32(1)
		for {
			/* Temporary sums of the new pulse(s) */
			Rxy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))
			/* We're multiplying y[j] by two so we don't have to do it here */
			Ryy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(j)*4))
			/* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
			   Rxy is positive because the sign is pre-computed) */
			Rxy = OpusT_opus_val16(Rxy * Rxy)
			/* The idea is to check for num/den >= best_num/best_den, but that way
			   we can do it without any division */
			/* OPT: It's not clear whether a cmov is faster than a branch here
			   since the condition is more often false than true and using
			   a cmov introduces data dependencies across iterations. The optimal
			   choice may be architecture-dependent. */
			if libc.BoolInt64(!!(OpusT_opus_val32(best_den*Rxy) > OpusT_opus_val32(Ryy*best_num))) != 0 {
				best_den = Ryy
				best_num = Rxy
				best_id = j
			}
			goto _64
		_64:
			;
			j = j + 1
			v53 = j
			if !(v53 < N) {
				break
			}
		}
		/* Updating the sums of the new pulse(s) */
		xy = xy + *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(best_id)*4))
		/* We're multiplying y[j] by two so we don't have to do it here */
		yy = yy + *(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(best_id)*4))
		/* Only now that we've made the final choice, update y/iy */
		/* Multiplying y[j] by 2 so we don't have to do it everywhere else */
		*(*OpusT_celt_norm)(unsafe.Pointer(y + uintptr(best_id)*4)) += libc.Float32FromInt32(2)
		*(*int32)(unsafe.Pointer(iy + uintptr(best_id)*4)) = *(*int32)(unsafe.Pointer(iy + uintptr(best_id)*4)) + 1
		goto _62
	_62:
		;
		i = i + 1
	}
	/* Put the original sign back */
	j = 0
	for {
		/*iy[j] = signx[j] ? -iy[j] : iy[j];*/
		/* OPT: The is more likely to be compiled without a branch than the code above
		   but has the same performance otherwise. */
		*(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(iy + uintptr(j)*4)) ^ -*(*int32)(unsafe.Pointer(signx + uintptr(j)*4)) + *(*int32)(unsafe.Pointer(signx + uintptr(j)*4))
		goto _66
	_66:
		;
		j = j + 1
		v53 = j
		if !(v53 < N) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _70
_70:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return yy
}

func Opus_opus_custom_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var decode_buffer_size, i int32
	var oldBandE, oldLogE, oldLogE2, value1, value10, value12, value5, value6, value7, value8 uintptr
	var value, value11, value2, value3, value4, value9 OpusT_opus_int32
	var v2 OpusT_celt_glog
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, decode_buffer_size, i, oldBandE, oldLogE, oldLogE2, value, value1, value10, value11, value12, value2, value3, value4, value5, value6, value7, value8, value9, v2
	ap = va
	switch request {
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value = libc.VaInt32(&ap)
		if value < 0 || value > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fcomplexity = value
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value1)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fcomplexity
	case int32(CELT_SET_START_BAND_REQUEST):
		value2 = libc.VaInt32(&ap)
		if value2 < 0 || value2 >= (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart = value2
	case int32(CELT_SET_END_BAND_REQUEST):
		value3 = libc.VaInt32(&ap)
		if value3 < int32(1) || value3 > (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend = value3
	case int32(CELT_SET_CHANNELS_REQUEST):
		value4 = libc.VaInt32(&ap)
		if value4 < int32(1) || value4 > int32(2) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels = value4
	case int32(CELT_GET_AND_CLEAR_ERROR_REQUEST):
		value5 = libc.VaUintptr(&ap)
		if value5 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value5)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Ferror1
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Ferror1 = 0
	case int32(OPUS_GET_LOOKAHEAD_REQUEST):
		value6 = libc.VaUintptr(&ap)
		if value6 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value6)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap / (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample
	case int32(OPUS_RESET_STATE):
		decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
		oldBandE = st + 112 + uintptr((decode_buffer_size+(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap)*(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels)*4
		oldLogE = oldBandE + uintptr(int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		oldLogE2 = oldLogE + uintptr(int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		libc.Xmemset(tls, st+48, 0, libc.Uint64FromInt64(int64(opus_custom_decoder_get_size(tls, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels))-(int64(st+48)-int64(st)))*uint64(1))
		i = 0
		for {
			if !(i < int32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FnbEBands) {
				break
			}
			v2 = -libc.Float32FromFloat32(28)
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(i)*4)) = v2
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4)) = v2
			goto _1
		_1:
			;
			i = i + 1
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fskip_plc = int32(1)
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Flast_frame_type = FRAME_NONE
	case int32(OPUS_GET_PITCH_REQUEST):
		value7 = libc.VaUintptr(&ap)
		if value7 == libc.UintptrFromInt32(0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value7)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fpostfilter_period
	case int32(CELT_GET_MODE_REQUEST):
		value8 = libc.VaUintptr(&ap)
		if value8 == uintptr(0) {
			goto bad_arg
		}
		*(*uintptr)(unsafe.Pointer(value8)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode
	case int32(CELT_SET_SIGNALLING_REQUEST):
		value9 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fsignalling = value9
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value10 = libc.VaUintptr(&ap)
		if value10 == uintptr(0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value10)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Frng
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value11 = libc.VaInt32(&ap)
		if value11 < 0 || value11 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv = value11
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value12 = libc.VaUintptr(&ap)
		if !(value12 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value12)) = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv
	default:
		goto bad_request
	}
	_ = ap
	return OPUS_OK
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
	goto bad_request
bad_request:
	;
	_ = ap
	return -int32(5)
}

const CELT_SIG_SCALE8 = "32768.f"
const Q15ONE4 = "1.0f"
const Q31ONE4 = "1.0f"
const VERY_SMALL4 = "1e-30f"

var log2_x_norm_coeff11 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff11 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2003-2008 Jean-Marc Valin
   Copyright (c) 2007-2008 CSIRO
   Copyright (c) 2007-2009 Xiph.Org Foundation
   Written by Jean-Marc Valin */
/**
  @file arch.h
  @brief Various architecture definitions for CELT
*/
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*Although derived separately, the pulse vector coding scheme is equivalent to
   a Pyramid Vector Quantizer \cite{Fis86}.
  Some additional notes about an early version appear at
   https://people.xiph.org/~tterribe/notes/cwrs.html, but the codebook ordering
   and the definitions of some terms have evolved since that was written.

  The conversion from a pulse vector to an integer index (encoding) and back
   (decoding) is governed by two related functions, V(N,K) and U(N,K).

  V(N,K) = the number of combinations, with replacement, of N items, taken K
   at a time, when a sign bit is added to each item taken at least once (i.e.,
   the number of N-dimensional unit pulse vectors with K pulses).
  One way to compute this is via
    V(N,K) = K>0 ? sum(k=1...K,2**k*choose(N,k)*choose(K-1,k-1)) : 1,
   where choose() is the binomial function.
  A table of values for N<10 and K<10 looks like:
  V[10][10] = {
    {1,  0,   0,    0,    0,     0,     0,      0,      0,       0},
    {1,  2,   2,    2,    2,     2,     2,      2,      2,       2},
    {1,  4,   8,   12,   16,    20,    24,     28,     32,      36},
    {1,  6,  18,   38,   66,   102,   146,    198,    258,     326},
    {1,  8,  32,   88,  192,   360,   608,    952,   1408,    1992},
    {1, 10,  50,  170,  450,  1002,  1970,   3530,   5890,    9290},
    {1, 12,  72,  292,  912,  2364,  5336,  10836,  20256,   35436},
    {1, 14,  98,  462, 1666,  4942, 12642,  28814,  59906,  115598},
    {1, 16, 128,  688, 2816,  9424, 27008,  68464, 157184,  332688},
    {1, 18, 162,  978, 4482, 16722, 53154, 148626, 374274,  864146}
  };

  U(N,K) = the number of such combinations wherein N-1 objects are taken at
   most K-1 at a time.
  This is given by
    U(N,K) = sum(k=0...K-1,V(N-1,k))
           = K>0 ? (V(N-1,K-1) + V(N,K-1))/2 : 0.
  The latter expression also makes clear that U(N,K) is half the number of such
   combinations wherein the first object is taken at least once.
  Although it may not be clear from either of these definitions, U(N,K) is the
   natural function to work with when enumerating the pulse vector codebooks,
   not V(N,K).
  U(N,K) is not well-defined for N=0, but with the extension
    U(0,K) = K>0 ? 0 : 1,
   the function becomes symmetric: U(N,K) = U(K,N), with a similar table:
  U[10][10] = {
    {1, 0,  0,   0,    0,    0,     0,     0,      0,      0},
    {0, 1,  1,   1,    1,    1,     1,     1,      1,      1},
    {0, 1,  3,   5,    7,    9,    11,    13,     15,     17},
    {0, 1,  5,  13,   25,   41,    61,    85,    113,    145},
    {0, 1,  7,  25,   63,  129,   231,   377,    575,    833},
    {0, 1,  9,  41,  129,  321,   681,  1289,   2241,   3649},
    {0, 1, 11,  61,  231,  681,  1683,  3653,   7183,  13073},
    {0, 1, 13,  85,  377, 1289,  3653,  8989,  19825,  40081},
    {0, 1, 15, 113,  575, 2241,  7183, 19825,  48639, 108545},
    {0, 1, 17, 145,  833, 3649, 13073, 40081, 108545, 265729}
  };

  With this extension, V(N,K) may be written in terms of U(N,K):
    V(N,K) = U(N,K) + U(N,K+1)
   for all N>=0, K>=0.
  Thus U(N,K+1) represents the number of combinations where the first element
   is positive or zero, and U(N,K) represents the number of combinations where
   it is negative.
  With a large enough table of U(N,K) values, we could write O(N) encoding
   and O(min(N*log(K),N+K)) decoding routines, but such a table would be
   prohibitively large for small embedded devices (K may be as large as 32767
   for small N, and N may be as large as 200).

  Both functions obey the same recurrence relation:
    V(N,K) = V(N-1,K) + V(N,K-1) + V(N-1,K-1),
    U(N,K) = U(N-1,K) + U(N,K-1) + U(N-1,K-1),
   for all N>0, K>0, with different initial conditions at N=0 or K=0.
  This allows us to construct a row of one of the tables above given the
   previous row or the next row.
  Thus we can derive O(NK) encoding and decoding routines with O(K) memory
   using only addition and subtraction.

  When encoding, we build up from the U(2,K) row and work our way forwards.
  When decoding, we need to start at the U(N,K) row and work our way backwards,
   which requires a means of computing U(N,K).
  U(N,K) may be computed from two previous values with the same N:
    U(N,K) = ((2*N-1)*U(N,K-1) - U(N,K-2))/(K-1) + U(N,K-2)
   for all N>1, and since U(N,K) is symmetric, a similar relation holds for two
   previous values with the same K:
    U(N,K>1) = ((2*K-1)*U(N-1,K) - U(N-2,K))/(N-1) + U(N-2,K)
   for all K>1.
  This allows us to construct an arbitrary row of the U(N,K) table by starting
   with the first two values, which are constants.
  This saves roughly 2/3 the work in our O(NK) decoding routine, but costs O(K)
   multiplications.
  Similar relations can be derived for V(N,K), but are not used here.

  For N>0 and K>0, U(N,K) and V(N,K) take on the form of an (N-1)-degree
   polynomial for fixed N.
  The first few are
    U(1,K) = 1,
    U(2,K) = 2*K-1,
    U(3,K) = (2*K-2)*K+1,
    U(4,K) = (((4*K-6)*K+8)*K-3)/3,
    U(5,K) = ((((2*K-4)*K+10)*K-8)*K+3)/3,
   and
    V(1,K) = 2,
    V(2,K) = 4*K,
    V(3,K) = 4*K*K+2,
    V(4,K) = 8*(K*K+2)*K/3,
    V(5,K) = ((4*K*K+20)*K*K+6)/3,
   for all K>0.
  This allows us to derive O(N) encoding and O(N*log(K)) decoding routines for
   small N (and indeed decoding is also O(N) for N<3).

  @ARTICLE{Fis86,
    author="Thomas R. Fischer",
    title="A Pyramid Vector Quantizer",
    journal="IEEE Transactions on Information Theory",
    volume="IT-32",
    number=4,
    pages="568--583",
    month=Jul,
    year=1986
  }*/

/*U(N,K) = U(K,N) := N>0?K>0?U(N-1,K)+U(N,K-1)+U(N-1,K-1):0:K>0?1:0*/
/*V(N,K) := U(N,K)+U(N,K+1) = the number of PVQ codewords for a band of size N
  with K pulses allocated to it.*/

// C documentation
//
//	/*For each V(N,K) supported, we will access element U(min(N,K+1),max(N,K+1)).
//	  Thus, the number of entries in row I is the larger of the maximum number of
//	   pulses we will ever allocate for a given N=I (K=128, or however many fit in
//	   32 bits, whichever is smaller), plus one, and the maximum N for which
//	   K=I-1 pulses fit in 32 bits.
//	  The largest band size in an Opus Custom mode is 208.
//	  Otherwise, we can limit things to the set of N which can be achieved by
//	   splitting a band from a standard Opus mode: 176, 144, 96, 88, 72, 64, 48,
//	   44, 36, 32, 24, 22, 18, 16, 8, 4, 2).*/
var CELT_PVQ_U_DATA = [1272]OpusT_opus_uint32{
	0:    uint32(1),
	177:  uint32(1),
	178:  uint32(1),
	179:  uint32(1),
	180:  uint32(1),
	181:  uint32(1),
	182:  uint32(1),
	183:  uint32(1),
	184:  uint32(1),
	185:  uint32(1),
	186:  uint32(1),
	187:  uint32(1),
	188:  uint32(1),
	189:  uint32(1),
	190:  uint32(1),
	191:  uint32(1),
	192:  uint32(1),
	193:  uint32(1),
	194:  uint32(1),
	195:  uint32(1),
	196:  uint32(1),
	197:  uint32(1),
	198:  uint32(1),
	199:  uint32(1),
	200:  uint32(1),
	201:  uint32(1),
	202:  uint32(1),
	203:  uint32(1),
	204:  uint32(1),
	205:  uint32(1),
	206:  uint32(1),
	207:  uint32(1),
	208:  uint32(1),
	209:  uint32(1),
	210:  uint32(1),
	211:  uint32(1),
	212:  uint32(1),
	213:  uint32(1),
	214:  uint32(1),
	215:  uint32(1),
	216:  uint32(1),
	217:  uint32(1),
	218:  uint32(1),
	219:  uint32(1),
	220:  uint32(1),
	221:  uint32(1),
	222:  uint32(1),
	223:  uint32(1),
	224:  uint32(1),
	225:  uint32(1),
	226:  uint32(1),
	227:  uint32(1),
	228:  uint32(1),
	229:  uint32(1),
	230:  uint32(1),
	231:  uint32(1),
	232:  uint32(1),
	233:  uint32(1),
	234:  uint32(1),
	235:  uint32(1),
	236:  uint32(1),
	237:  uint32(1),
	238:  uint32(1),
	239:  uint32(1),
	240:  uint32(1),
	241:  uint32(1),
	242:  uint32(1),
	243:  uint32(1),
	244:  uint32(1),
	245:  uint32(1),
	246:  uint32(1),
	247:  uint32(1),
	248:  uint32(1),
	249:  uint32(1),
	250:  uint32(1),
	251:  uint32(1),
	252:  uint32(1),
	253:  uint32(1),
	254:  uint32(1),
	255:  uint32(1),
	256:  uint32(1),
	257:  uint32(1),
	258:  uint32(1),
	259:  uint32(1),
	260:  uint32(1),
	261:  uint32(1),
	262:  uint32(1),
	263:  uint32(1),
	264:  uint32(1),
	265:  uint32(1),
	266:  uint32(1),
	267:  uint32(1),
	268:  uint32(1),
	269:  uint32(1),
	270:  uint32(1),
	271:  uint32(1),
	272:  uint32(1),
	273:  uint32(1),
	274:  uint32(1),
	275:  uint32(1),
	276:  uint32(1),
	277:  uint32(1),
	278:  uint32(1),
	279:  uint32(1),
	280:  uint32(1),
	281:  uint32(1),
	282:  uint32(1),
	283:  uint32(1),
	284:  uint32(1),
	285:  uint32(1),
	286:  uint32(1),
	287:  uint32(1),
	288:  uint32(1),
	289:  uint32(1),
	290:  uint32(1),
	291:  uint32(1),
	292:  uint32(1),
	293:  uint32(1),
	294:  uint32(1),
	295:  uint32(1),
	296:  uint32(1),
	297:  uint32(1),
	298:  uint32(1),
	299:  uint32(1),
	300:  uint32(1),
	301:  uint32(1),
	302:  uint32(1),
	303:  uint32(1),
	304:  uint32(1),
	305:  uint32(1),
	306:  uint32(1),
	307:  uint32(1),
	308:  uint32(1),
	309:  uint32(1),
	310:  uint32(1),
	311:  uint32(1),
	312:  uint32(1),
	313:  uint32(1),
	314:  uint32(1),
	315:  uint32(1),
	316:  uint32(1),
	317:  uint32(1),
	318:  uint32(1),
	319:  uint32(1),
	320:  uint32(1),
	321:  uint32(1),
	322:  uint32(1),
	323:  uint32(1),
	324:  uint32(1),
	325:  uint32(1),
	326:  uint32(1),
	327:  uint32(1),
	328:  uint32(1),
	329:  uint32(1),
	330:  uint32(1),
	331:  uint32(1),
	332:  uint32(1),
	333:  uint32(1),
	334:  uint32(1),
	335:  uint32(1),
	336:  uint32(1),
	337:  uint32(1),
	338:  uint32(1),
	339:  uint32(1),
	340:  uint32(1),
	341:  uint32(1),
	342:  uint32(1),
	343:  uint32(1),
	344:  uint32(1),
	345:  uint32(1),
	346:  uint32(1),
	347:  uint32(1),
	348:  uint32(1),
	349:  uint32(1),
	350:  uint32(1),
	351:  uint32(1),
	352:  uint32(1),
	353:  uint32(3),
	354:  uint32(5),
	355:  uint32(7),
	356:  uint32(9),
	357:  uint32(11),
	358:  uint32(13),
	359:  uint32(15),
	360:  uint32(17),
	361:  uint32(19),
	362:  uint32(21),
	363:  uint32(23),
	364:  uint32(25),
	365:  uint32(27),
	366:  uint32(29),
	367:  uint32(31),
	368:  uint32(33),
	369:  uint32(35),
	370:  uint32(37),
	371:  uint32(39),
	372:  uint32(41),
	373:  uint32(43),
	374:  uint32(45),
	375:  uint32(47),
	376:  uint32(49),
	377:  uint32(51),
	378:  uint32(53),
	379:  uint32(55),
	380:  uint32(57),
	381:  uint32(59),
	382:  uint32(61),
	383:  uint32(63),
	384:  uint32(65),
	385:  uint32(67),
	386:  uint32(69),
	387:  uint32(71),
	388:  uint32(73),
	389:  uint32(75),
	390:  uint32(77),
	391:  uint32(79),
	392:  uint32(81),
	393:  uint32(83),
	394:  uint32(85),
	395:  uint32(87),
	396:  uint32(89),
	397:  uint32(91),
	398:  uint32(93),
	399:  uint32(95),
	400:  uint32(97),
	401:  uint32(99),
	402:  uint32(101),
	403:  uint32(103),
	404:  uint32(105),
	405:  uint32(107),
	406:  uint32(109),
	407:  uint32(111),
	408:  uint32(113),
	409:  uint32(115),
	410:  uint32(117),
	411:  uint32(119),
	412:  uint32(121),
	413:  uint32(123),
	414:  uint32(125),
	415:  uint32(127),
	416:  uint32(129),
	417:  uint32(131),
	418:  uint32(133),
	419:  uint32(135),
	420:  uint32(137),
	421:  uint32(139),
	422:  uint32(141),
	423:  uint32(143),
	424:  uint32(145),
	425:  uint32(147),
	426:  uint32(149),
	427:  uint32(151),
	428:  uint32(153),
	429:  uint32(155),
	430:  uint32(157),
	431:  uint32(159),
	432:  uint32(161),
	433:  uint32(163),
	434:  uint32(165),
	435:  uint32(167),
	436:  uint32(169),
	437:  uint32(171),
	438:  uint32(173),
	439:  uint32(175),
	440:  uint32(177),
	441:  uint32(179),
	442:  uint32(181),
	443:  uint32(183),
	444:  uint32(185),
	445:  uint32(187),
	446:  uint32(189),
	447:  uint32(191),
	448:  uint32(193),
	449:  uint32(195),
	450:  uint32(197),
	451:  uint32(199),
	452:  uint32(201),
	453:  uint32(203),
	454:  uint32(205),
	455:  uint32(207),
	456:  uint32(209),
	457:  uint32(211),
	458:  uint32(213),
	459:  uint32(215),
	460:  uint32(217),
	461:  uint32(219),
	462:  uint32(221),
	463:  uint32(223),
	464:  uint32(225),
	465:  uint32(227),
	466:  uint32(229),
	467:  uint32(231),
	468:  uint32(233),
	469:  uint32(235),
	470:  uint32(237),
	471:  uint32(239),
	472:  uint32(241),
	473:  uint32(243),
	474:  uint32(245),
	475:  uint32(247),
	476:  uint32(249),
	477:  uint32(251),
	478:  uint32(253),
	479:  uint32(255),
	480:  uint32(257),
	481:  uint32(259),
	482:  uint32(261),
	483:  uint32(263),
	484:  uint32(265),
	485:  uint32(267),
	486:  uint32(269),
	487:  uint32(271),
	488:  uint32(273),
	489:  uint32(275),
	490:  uint32(277),
	491:  uint32(279),
	492:  uint32(281),
	493:  uint32(283),
	494:  uint32(285),
	495:  uint32(287),
	496:  uint32(289),
	497:  uint32(291),
	498:  uint32(293),
	499:  uint32(295),
	500:  uint32(297),
	501:  uint32(299),
	502:  uint32(301),
	503:  uint32(303),
	504:  uint32(305),
	505:  uint32(307),
	506:  uint32(309),
	507:  uint32(311),
	508:  uint32(313),
	509:  uint32(315),
	510:  uint32(317),
	511:  uint32(319),
	512:  uint32(321),
	513:  uint32(323),
	514:  uint32(325),
	515:  uint32(327),
	516:  uint32(329),
	517:  uint32(331),
	518:  uint32(333),
	519:  uint32(335),
	520:  uint32(337),
	521:  uint32(339),
	522:  uint32(341),
	523:  uint32(343),
	524:  uint32(345),
	525:  uint32(347),
	526:  uint32(349),
	527:  uint32(351),
	528:  uint32(13),
	529:  uint32(25),
	530:  uint32(41),
	531:  uint32(61),
	532:  uint32(85),
	533:  uint32(113),
	534:  uint32(145),
	535:  uint32(181),
	536:  uint32(221),
	537:  uint32(265),
	538:  uint32(313),
	539:  uint32(365),
	540:  uint32(421),
	541:  uint32(481),
	542:  uint32(545),
	543:  uint32(613),
	544:  uint32(685),
	545:  uint32(761),
	546:  uint32(841),
	547:  uint32(925),
	548:  uint32(1013),
	549:  uint32(1105),
	550:  uint32(1201),
	551:  uint32(1301),
	552:  uint32(1405),
	553:  uint32(1513),
	554:  uint32(1625),
	555:  uint32(1741),
	556:  uint32(1861),
	557:  uint32(1985),
	558:  uint32(2113),
	559:  uint32(2245),
	560:  uint32(2381),
	561:  uint32(2521),
	562:  uint32(2665),
	563:  uint32(2813),
	564:  uint32(2965),
	565:  uint32(3121),
	566:  uint32(3281),
	567:  uint32(3445),
	568:  uint32(3613),
	569:  uint32(3785),
	570:  uint32(3961),
	571:  uint32(4141),
	572:  uint32(4325),
	573:  uint32(4513),
	574:  uint32(4705),
	575:  uint32(4901),
	576:  uint32(5101),
	577:  uint32(5305),
	578:  uint32(5513),
	579:  uint32(5725),
	580:  uint32(5941),
	581:  uint32(6161),
	582:  uint32(6385),
	583:  uint32(6613),
	584:  uint32(6845),
	585:  uint32(7081),
	586:  uint32(7321),
	587:  uint32(7565),
	588:  uint32(7813),
	589:  uint32(8065),
	590:  uint32(8321),
	591:  uint32(8581),
	592:  uint32(8845),
	593:  uint32(9113),
	594:  uint32(9385),
	595:  uint32(9661),
	596:  uint32(9941),
	597:  uint32(10225),
	598:  uint32(10513),
	599:  uint32(10805),
	600:  uint32(11101),
	601:  uint32(11401),
	602:  uint32(11705),
	603:  uint32(12013),
	604:  uint32(12325),
	605:  uint32(12641),
	606:  uint32(12961),
	607:  uint32(13285),
	608:  uint32(13613),
	609:  uint32(13945),
	610:  uint32(14281),
	611:  uint32(14621),
	612:  uint32(14965),
	613:  uint32(15313),
	614:  uint32(15665),
	615:  uint32(16021),
	616:  uint32(16381),
	617:  uint32(16745),
	618:  uint32(17113),
	619:  uint32(17485),
	620:  uint32(17861),
	621:  uint32(18241),
	622:  uint32(18625),
	623:  uint32(19013),
	624:  uint32(19405),
	625:  uint32(19801),
	626:  uint32(20201),
	627:  uint32(20605),
	628:  uint32(21013),
	629:  uint32(21425),
	630:  uint32(21841),
	631:  uint32(22261),
	632:  uint32(22685),
	633:  uint32(23113),
	634:  uint32(23545),
	635:  uint32(23981),
	636:  uint32(24421),
	637:  uint32(24865),
	638:  uint32(25313),
	639:  uint32(25765),
	640:  uint32(26221),
	641:  uint32(26681),
	642:  uint32(27145),
	643:  uint32(27613),
	644:  uint32(28085),
	645:  uint32(28561),
	646:  uint32(29041),
	647:  uint32(29525),
	648:  uint32(30013),
	649:  uint32(30505),
	650:  uint32(31001),
	651:  uint32(31501),
	652:  uint32(32005),
	653:  uint32(32513),
	654:  uint32(33025),
	655:  uint32(33541),
	656:  uint32(34061),
	657:  uint32(34585),
	658:  uint32(35113),
	659:  uint32(35645),
	660:  uint32(36181),
	661:  uint32(36721),
	662:  uint32(37265),
	663:  uint32(37813),
	664:  uint32(38365),
	665:  uint32(38921),
	666:  uint32(39481),
	667:  uint32(40045),
	668:  uint32(40613),
	669:  uint32(41185),
	670:  uint32(41761),
	671:  uint32(42341),
	672:  uint32(42925),
	673:  uint32(43513),
	674:  uint32(44105),
	675:  uint32(44701),
	676:  uint32(45301),
	677:  uint32(45905),
	678:  uint32(46513),
	679:  uint32(47125),
	680:  uint32(47741),
	681:  uint32(48361),
	682:  uint32(48985),
	683:  uint32(49613),
	684:  uint32(50245),
	685:  uint32(50881),
	686:  uint32(51521),
	687:  uint32(52165),
	688:  uint32(52813),
	689:  uint32(53465),
	690:  uint32(54121),
	691:  uint32(54781),
	692:  uint32(55445),
	693:  uint32(56113),
	694:  uint32(56785),
	695:  uint32(57461),
	696:  uint32(58141),
	697:  uint32(58825),
	698:  uint32(59513),
	699:  uint32(60205),
	700:  uint32(60901),
	701:  uint32(61601),
	702:  uint32(63),
	703:  uint32(129),
	704:  uint32(231),
	705:  uint32(377),
	706:  uint32(575),
	707:  uint32(833),
	708:  uint32(1159),
	709:  uint32(1561),
	710:  uint32(2047),
	711:  uint32(2625),
	712:  uint32(3303),
	713:  uint32(4089),
	714:  uint32(4991),
	715:  uint32(6017),
	716:  uint32(7175),
	717:  uint32(8473),
	718:  uint32(9919),
	719:  uint32(11521),
	720:  uint32(13287),
	721:  uint32(15225),
	722:  uint32(17343),
	723:  uint32(19649),
	724:  uint32(22151),
	725:  uint32(24857),
	726:  uint32(27775),
	727:  uint32(30913),
	728:  uint32(34279),
	729:  uint32(37881),
	730:  uint32(41727),
	731:  uint32(45825),
	732:  uint32(50183),
	733:  uint32(54809),
	734:  uint32(59711),
	735:  uint32(64897),
	736:  uint32(70375),
	737:  uint32(76153),
	738:  uint32(82239),
	739:  uint32(88641),
	740:  uint32(95367),
	741:  uint32(102425),
	742:  uint32(109823),
	743:  uint32(117569),
	744:  uint32(125671),
	745:  uint32(134137),
	746:  uint32(142975),
	747:  uint32(152193),
	748:  uint32(161799),
	749:  uint32(171801),
	750:  uint32(182207),
	751:  uint32(193025),
	752:  uint32(204263),
	753:  uint32(215929),
	754:  uint32(228031),
	755:  uint32(240577),
	756:  uint32(253575),
	757:  uint32(267033),
	758:  uint32(280959),
	759:  uint32(295361),
	760:  uint32(310247),
	761:  uint32(325625),
	762:  uint32(341503),
	763:  uint32(357889),
	764:  uint32(374791),
	765:  uint32(392217),
	766:  uint32(410175),
	767:  uint32(428673),
	768:  uint32(447719),
	769:  uint32(467321),
	770:  uint32(487487),
	771:  uint32(508225),
	772:  uint32(529543),
	773:  uint32(551449),
	774:  uint32(573951),
	775:  uint32(597057),
	776:  uint32(620775),
	777:  uint32(645113),
	778:  uint32(670079),
	779:  uint32(695681),
	780:  uint32(721927),
	781:  uint32(748825),
	782:  uint32(776383),
	783:  uint32(804609),
	784:  uint32(833511),
	785:  uint32(863097),
	786:  uint32(893375),
	787:  uint32(924353),
	788:  uint32(956039),
	789:  uint32(988441),
	790:  uint32(1021567),
	791:  uint32(1055425),
	792:  uint32(1090023),
	793:  uint32(1125369),
	794:  uint32(1161471),
	795:  uint32(1198337),
	796:  uint32(1235975),
	797:  uint32(1274393),
	798:  uint32(1313599),
	799:  uint32(1353601),
	800:  uint32(1394407),
	801:  uint32(1436025),
	802:  uint32(1478463),
	803:  uint32(1521729),
	804:  uint32(1565831),
	805:  uint32(1610777),
	806:  uint32(1656575),
	807:  uint32(1703233),
	808:  uint32(1750759),
	809:  uint32(1799161),
	810:  uint32(1848447),
	811:  uint32(1898625),
	812:  uint32(1949703),
	813:  uint32(2001689),
	814:  uint32(2054591),
	815:  uint32(2108417),
	816:  uint32(2163175),
	817:  uint32(2218873),
	818:  uint32(2275519),
	819:  uint32(2333121),
	820:  uint32(2391687),
	821:  uint32(2451225),
	822:  uint32(2511743),
	823:  uint32(2573249),
	824:  uint32(2635751),
	825:  uint32(2699257),
	826:  uint32(2763775),
	827:  uint32(2829313),
	828:  uint32(2895879),
	829:  uint32(2963481),
	830:  uint32(3032127),
	831:  uint32(3101825),
	832:  uint32(3172583),
	833:  uint32(3244409),
	834:  uint32(3317311),
	835:  uint32(3391297),
	836:  uint32(3466375),
	837:  uint32(3542553),
	838:  uint32(3619839),
	839:  uint32(3698241),
	840:  uint32(3777767),
	841:  uint32(3858425),
	842:  uint32(3940223),
	843:  uint32(4023169),
	844:  uint32(4107271),
	845:  uint32(4192537),
	846:  uint32(4278975),
	847:  uint32(4366593),
	848:  uint32(4455399),
	849:  uint32(4545401),
	850:  uint32(4636607),
	851:  uint32(4729025),
	852:  uint32(4822663),
	853:  uint32(4917529),
	854:  uint32(5013631),
	855:  uint32(5110977),
	856:  uint32(5209575),
	857:  uint32(5309433),
	858:  uint32(5410559),
	859:  uint32(5512961),
	860:  uint32(5616647),
	861:  uint32(5721625),
	862:  uint32(5827903),
	863:  uint32(5935489),
	864:  uint32(6044391),
	865:  uint32(6154617),
	866:  uint32(6266175),
	867:  uint32(6379073),
	868:  uint32(6493319),
	869:  uint32(6608921),
	870:  uint32(6725887),
	871:  uint32(6844225),
	872:  uint32(6963943),
	873:  uint32(7085049),
	874:  uint32(7207551),
	875:  uint32(321),
	876:  uint32(681),
	877:  uint32(1289),
	878:  uint32(2241),
	879:  uint32(3649),
	880:  uint32(5641),
	881:  uint32(8361),
	882:  uint32(11969),
	883:  uint32(16641),
	884:  uint32(22569),
	885:  uint32(29961),
	886:  uint32(39041),
	887:  uint32(50049),
	888:  uint32(63241),
	889:  uint32(78889),
	890:  uint32(97281),
	891:  uint32(118721),
	892:  uint32(143529),
	893:  uint32(172041),
	894:  uint32(204609),
	895:  uint32(241601),
	896:  uint32(283401),
	897:  uint32(330409),
	898:  uint32(383041),
	899:  uint32(441729),
	900:  uint32(506921),
	901:  uint32(579081),
	902:  uint32(658689),
	903:  uint32(746241),
	904:  uint32(842249),
	905:  uint32(947241),
	906:  uint32(1061761),
	907:  uint32(1186369),
	908:  uint32(1321641),
	909:  uint32(1468169),
	910:  uint32(1626561),
	911:  uint32(1797441),
	912:  uint32(1981449),
	913:  uint32(2179241),
	914:  uint32(2391489),
	915:  uint32(2618881),
	916:  uint32(2862121),
	917:  uint32(3121929),
	918:  uint32(3399041),
	919:  uint32(3694209),
	920:  uint32(4008201),
	921:  uint32(4341801),
	922:  uint32(4695809),
	923:  uint32(5071041),
	924:  uint32(5468329),
	925:  uint32(5888521),
	926:  uint32(6332481),
	927:  uint32(6801089),
	928:  uint32(7295241),
	929:  uint32(7815849),
	930:  uint32(8363841),
	931:  uint32(8940161),
	932:  uint32(9545769),
	933:  uint32(10181641),
	934:  uint32(10848769),
	935:  uint32(11548161),
	936:  uint32(12280841),
	937:  uint32(13047849),
	938:  uint32(13850241),
	939:  uint32(14689089),
	940:  uint32(15565481),
	941:  uint32(16480521),
	942:  uint32(17435329),
	943:  uint32(18431041),
	944:  uint32(19468809),
	945:  uint32(20549801),
	946:  uint32(21675201),
	947:  uint32(22846209),
	948:  uint32(24064041),
	949:  uint32(25329929),
	950:  uint32(26645121),
	951:  uint32(28010881),
	952:  uint32(29428489),
	953:  uint32(30899241),
	954:  uint32(32424449),
	955:  uint32(34005441),
	956:  uint32(35643561),
	957:  uint32(37340169),
	958:  uint32(39096641),
	959:  uint32(40914369),
	960:  uint32(42794761),
	961:  uint32(44739241),
	962:  uint32(46749249),
	963:  uint32(48826241),
	964:  uint32(50971689),
	965:  uint32(53187081),
	966:  uint32(55473921),
	967:  uint32(57833729),
	968:  uint32(60268041),
	969:  uint32(62778409),
	970:  uint32(65366401),
	971:  uint32(68033601),
	972:  uint32(70781609),
	973:  uint32(73612041),
	974:  uint32(76526529),
	975:  uint32(79526721),
	976:  uint32(82614281),
	977:  uint32(85790889),
	978:  uint32(89058241),
	979:  uint32(92418049),
	980:  uint32(95872041),
	981:  uint32(99421961),
	982:  uint32(103069569),
	983:  uint32(106816641),
	984:  uint32(110664969),
	985:  uint32(114616361),
	986:  uint32(118672641),
	987:  uint32(122835649),
	988:  uint32(127107241),
	989:  uint32(131489289),
	990:  uint32(135983681),
	991:  uint32(140592321),
	992:  uint32(145317129),
	993:  uint32(150160041),
	994:  uint32(155123009),
	995:  uint32(160208001),
	996:  uint32(165417001),
	997:  uint32(170752009),
	998:  uint32(176215041),
	999:  uint32(181808129),
	1000: uint32(187533321),
	1001: uint32(193392681),
	1002: uint32(199388289),
	1003: uint32(205522241),
	1004: uint32(211796649),
	1005: uint32(218213641),
	1006: uint32(224775361),
	1007: uint32(231483969),
	1008: uint32(238341641),
	1009: uint32(245350569),
	1010: uint32(252512961),
	1011: uint32(259831041),
	1012: uint32(267307049),
	1013: uint32(274943241),
	1014: uint32(282741889),
	1015: uint32(290705281),
	1016: uint32(298835721),
	1017: uint32(307135529),
	1018: uint32(315607041),
	1019: uint32(324252609),
	1020: uint32(333074601),
	1021: uint32(342075401),
	1022: uint32(351257409),
	1023: uint32(360623041),
	1024: uint32(370174729),
	1025: uint32(379914921),
	1026: uint32(389846081),
	1027: uint32(399970689),
	1028: uint32(410291241),
	1029: uint32(420810249),
	1030: uint32(431530241),
	1031: uint32(442453761),
	1032: uint32(453583369),
	1033: uint32(464921641),
	1034: uint32(476471169),
	1035: uint32(488234561),
	1036: uint32(500214441),
	1037: uint32(512413449),
	1038: uint32(524834241),
	1039: uint32(537479489),
	1040: uint32(550351881),
	1041: uint32(563454121),
	1042: uint32(576788929),
	1043: uint32(590359041),
	1044: uint32(604167209),
	1045: uint32(618216201),
	1046: uint32(632508801),
	1047: uint32(1683),
	1048: uint32(3653),
	1049: uint32(7183),
	1050: uint32(13073),
	1051: uint32(22363),
	1052: uint32(36365),
	1053: uint32(56695),
	1054: uint32(85305),
	1055: uint32(124515),
	1056: uint32(177045),
	1057: uint32(246047),
	1058: uint32(335137),
	1059: uint32(448427),
	1060: uint32(590557),
	1061: uint32(766727),
	1062: uint32(982729),
	1063: uint32(1244979),
	1064: uint32(1560549),
	1065: uint32(1937199),
	1066: uint32(2383409),
	1067: uint32(2908411),
	1068: uint32(3522221),
	1069: uint32(4235671),
	1070: uint32(5060441),
	1071: uint32(6009091),
	1072: uint32(7095093),
	1073: uint32(8332863),
	1074: uint32(9737793),
	1075: uint32(11326283),
	1076: uint32(13115773),
	1077: uint32(15124775),
	1078: uint32(17372905),
	1079: uint32(19880915),
	1080: uint32(22670725),
	1081: uint32(25765455),
	1082: uint32(29189457),
	1083: uint32(32968347),
	1084: uint32(37129037),
	1085: uint32(41699767),
	1086: uint32(46710137),
	1087: uint32(52191139),
	1088: uint32(58175189),
	1089: uint32(64696159),
	1090: uint32(71789409),
	1091: uint32(79491819),
	1092: uint32(87841821),
	1093: uint32(96879431),
	1094: uint32(106646281),
	1095: uint32(117185651),
	1096: uint32(128542501),
	1097: uint32(140763503),
	1098: uint32(153897073),
	1099: uint32(167993403),
	1100: uint32(183104493),
	1101: uint32(199284183),
	1102: uint32(216588185),
	1103: uint32(235074115),
	1104: uint32(254801525),
	1105: uint32(275831935),
	1106: uint32(298228865),
	1107: uint32(322057867),
	1108: uint32(347386557),
	1109: uint32(374284647),
	1110: uint32(402823977),
	1111: uint32(433078547),
	1112: uint32(465124549),
	1113: uint32(499040399),
	1114: uint32(534906769),
	1115: uint32(572806619),
	1116: uint32(612825229),
	1117: uint32(655050231),
	1118: uint32(699571641),
	1119: uint32(746481891),
	1120: uint32(795875861),
	1121: uint32(847850911),
	1122: uint32(902506913),
	1123: uint32(959946283),
	1124: uint32(1020274013),
	1125: uint32(1083597703),
	1126: uint32(1150027593),
	1127: uint32(1219676595),
	1128: uint32(1292660325),
	1129: uint32(1369097135),
	1130: uint32(1449108145),
	1131: uint32(1532817275),
	1132: uint32(1620351277),
	1133: uint32(1711839767),
	1134: uint32(1807415257),
	1135: uint32(1907213187),
	1136: uint32(2011371957),
	1137: uint32(2120032959),
	1138: uint32(8989),
	1139: uint32(19825),
	1140: uint32(40081),
	1141: uint32(75517),
	1142: uint32(134245),
	1143: uint32(227305),
	1144: uint32(369305),
	1145: uint32(579125),
	1146: uint32(880685),
	1147: uint32(1303777),
	1148: uint32(1884961),
	1149: uint32(2668525),
	1150: uint32(3707509),
	1151: uint32(5064793),
	1152: uint32(6814249),
	1153: uint32(9041957),
	1154: uint32(11847485),
	1155: uint32(15345233),
	1156: uint32(19665841),
	1157: uint32(24957661),
	1158: uint32(31388293),
	1159: uint32(39146185),
	1160: uint32(48442297),
	1161: uint32(59511829),
	1162: uint32(72616013),
	1163: uint32(88043969),
	1164: uint32(106114625),
	1165: uint32(127178701),
	1166: uint32(151620757),
	1167: uint32(179861305),
	1168: uint32(212358985),
	1169: uint32(249612805),
	1170: uint32(292164445),
	1171: uint32(340600625),
	1172: uint32(395555537),
	1173: uint32(457713341),
	1174: uint32(527810725),
	1175: uint32(606639529),
	1176: uint32(695049433),
	1177: uint32(793950709),
	1178: uint32(904317037),
	1179: uint32(1027188385),
	1180: uint32(1163673953),
	1181: uint32(1314955181),
	1182: uint32(1482288821),
	1183: uint32(1667010073),
	1184: uint32(1870535785),
	1185: uint32(2094367717),
	1186: uint32(48639),
	1187: uint32(108545),
	1188: uint32(224143),
	1189: uint32(433905),
	1190: uint32(795455),
	1191: uint32(1392065),
	1192: uint32(2340495),
	1193: uint32(3800305),
	1194: uint32(5984767),
	1195: uint32(9173505),
	1196: uint32(13726991),
	1197: uint32(20103025),
	1198: uint32(28875327),
	1199: uint32(40754369),
	1200: uint32(56610575),
	1201: uint32(77500017),
	1202: uint32(104692735),
	1203: uint32(139703809),
	1204: uint32(184327311),
	1205: uint32(240673265),
	1206: uint32(311207743),
	1207: uint32(398796225),
	1208: uint32(506750351),
	1209: uint32(638878193),
	1210: uint32(799538175),
	1211: uint32(993696769),
	1212: uint32(1226990095),
	1213: uint32(1505789553),
	1214: uint32(1837271615),
	1215: uint32(2229491905),
	1216: uint32(265729),
	1217: uint32(598417),
	1218: uint32(1256465),
	1219: uint32(2485825),
	1220: uint32(4673345),
	1221: uint32(8405905),
	1222: uint32(14546705),
	1223: uint32(24331777),
	1224: uint32(39490049),
	1225: uint32(62390545),
	1226: uint32(96220561),
	1227: uint32(145198913),
	1228: uint32(214828609),
	1229: uint32(312193553),
	1230: uint32(446304145),
	1231: uint32(628496897),
	1232: uint32(872893441),
	1233: uint32(1196924561),
	1234: uint32(1621925137),
	1235: uint32(2173806145),
	1236: uint32(1462563),
	1237: uint32(3317445),
	1238: uint32(7059735),
	1239: uint32(14218905),
	1240: uint32(27298155),
	1241: uint32(50250765),
	1242: uint32(89129247),
	1243: uint32(152951073),
	1244: uint32(254831667),
	1245: uint32(413442773),
	1246: uint32(654862247),
	1247: uint32(1014889769),
	1248: uint32(1541911931),
	1249: uint32(2300409629),
	1250: uint32(3375210671),
	1251: uint32(8097453),
	1252: uint32(18474633),
	1253: uint32(39753273),
	1254: uint32(81270333),
	1255: uint32(158819253),
	1256: uint32(298199265),
	1257: uint32(540279585),
	1258: uint32(948062325),
	1259: uint32(1616336765),
	1260: uint32(45046719),
	1261: uint32(103274625),
	1262: uint32(224298231),
	1263: uint32(464387817),
	1264: uint32(921406335),
	1265: uint32(1759885185),
	1266: uint32(3248227095),
	1267: uint32(251595969),
	1268: uint32(579168825),
	1269: uint32(1267854873),
	1270: uint32(2653649025),
	1271: uint32(1409933619),
}

var CELT_PVQ_U_ROW = [15]uintptr{
	0:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(0)*4,
	1:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(176)*4,
	2:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(351)*4,
	3:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(525)*4,
	4:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(698)*4,
	5:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(870)*4,
	6:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1041)*4,
	7:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1131)*4,
	8:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1178)*4,
	9:  uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1207)*4,
	10: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1226)*4,
	11: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1240)*4,
	12: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1248)*4,
	13: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1254)*4,
	14: uintptr(unsafe.Pointer(&CELT_PVQ_U_DATA)) + uintptr(1257)*4,
}

func Opus_opus_custom_encoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var i, value, value3, value4, v1 int32
	var info, info1, oldBandE, oldLogE, oldLogE2, value10, value12, value14, value15, value17 uintptr
	var value1, value11, value13, value16, value2, value5, value6, value7, value8, value9 OpusT_opus_int32
	var v3 OpusT_celt_glog
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, i, info, info1, oldBandE, oldLogE, oldLogE2, value, value1, value10, value11, value12, value13, value14, value15, value16, value17, value2, value3, value4, value5, value6, value7, value8, value9, v1, v3
	ap = va
	switch request {
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value = libc.VaInt32(&ap)
		if value < 0 || value > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fcomplexity = value
	case int32(CELT_SET_START_BAND_REQUEST):
		value1 = libc.VaInt32(&ap)
		if value1 < 0 || value1 >= (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fstart = value1
	case int32(CELT_SET_END_BAND_REQUEST):
		value2 = libc.VaInt32(&ap)
		if value2 < int32(1) || value2 > (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FnbEBands {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fend = value2
	case int32(CELT_SET_PREDICTION_REQUEST):
		value3 = libc.VaInt32(&ap)
		if value3 < 0 || value3 > int32(2) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fdisable_pf = libc.BoolInt32(value3 <= int32(1))
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fforce_intra = libc.BoolInt32(value3 == 0)
	case int32(OPUS_SET_PACKET_LOSS_PERC_REQUEST):
		value4 = libc.VaInt32(&ap)
		if value4 < 0 || value4 > int32(100) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Floss_rate = value4
	case int32(OPUS_SET_VBR_CONSTRAINT_REQUEST):
		value5 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fconstrained_vbr = value5
	case int32(OPUS_SET_VBR_REQUEST):
		value6 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fvbr = value6
	case int32(OPUS_SET_BITRATE_REQUEST):
		value7 = libc.VaInt32(&ap)
		if value7 <= int32(500) && value7 != -int32(1) {
			goto bad_arg
		}
		if value7 < int32(750000)*(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels {
			v1 = value7
		} else {
			v1 = int32(750000) * (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels
		}
		value7 = v1
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fbitrate = value7
	case int32(CELT_SET_CHANNELS_REQUEST):
		value8 = libc.VaInt32(&ap)
		if value8 < int32(1) || value8 > int32(2) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fstream_channels = value8
	case int32(OPUS_SET_LSB_DEPTH_REQUEST):
		value9 = libc.VaInt32(&ap)
		if value9 < int32(8) || value9 > int32(24) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Flsb_depth = value9
	case int32(OPUS_GET_LSB_DEPTH_REQUEST):
		value10 = libc.VaUintptr(&ap)
		*(*OpusT_opus_int32)(unsafe.Pointer(value10)) = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Flsb_depth
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value11 = libc.VaInt32(&ap)
		if value11 < 0 || value11 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fdisable_inv = value11
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value12 = libc.VaUintptr(&ap)
		if !(value12 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value12)) = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fdisable_inv
	case int32(OPUS_RESET_STATE):
		oldBandE = st + 252 + uintptr((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels*((*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).Foverlap+libc.Int32FromInt32(COMBFILTER_MAXPERIOD)))*4
		oldLogE = oldBandE + uintptr((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		oldLogE2 = oldLogE + uintptr((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FnbEBands)*4
		libc.Xmemset(tls, st+80, 0, libc.Uint64FromInt64(int64(opus_custom_encoder_get_size(tls, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels))-(int64(st+80)-int64(st)))*uint64(1))
		i = 0
		for {
			if !(i < (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels*(*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FnbEBands) {
				break
			}
			v3 = -libc.Float32FromFloat32(28)
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE2 + uintptr(i)*4)) = v3
			*(*OpusT_celt_glog)(unsafe.Pointer(oldLogE + uintptr(i)*4)) = v3
			goto _2
		_2:
			;
			i = i + 1
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fvbr_offset = 0
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).FdelayedIntra = libc.Float32FromInt32(1)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fspread_decision = int32(SPREAD_NORMAL)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Ftonal_average = int32(256)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fhf_average = 0
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Ftapset_decision = 0
	case int32(CELT_SET_SIGNALLING_REQUEST):
		value13 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fsignalling = value13
	case int32(CELT_SET_ANALYSIS_REQUEST):
		info = libc.VaUintptr(&ap)
		if info != 0 {
			libc.Xmemcpy(tls, st+124, info, libc.Uint64FromInt32(libc.Int32FromInt32(1))*libc.Uint64FromInt64(64)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(st+124)-int64(info))/64)))
		}
	case int32(CELT_SET_SILK_INFO_REQUEST):
		info1 = libc.VaUintptr(&ap)
		if info1 != 0 {
			libc.Xmemcpy(tls, st+188, info1, libc.Uint64FromInt32(libc.Int32FromInt32(1))*libc.Uint64FromInt64(8)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(st+188)-int64(info1))/8)))
		}
	case int32(CELT_GET_MODE_REQUEST):
		value14 = libc.VaUintptr(&ap)
		if value14 == uintptr(0) {
			goto bad_arg
		}
		*(*uintptr)(unsafe.Pointer(value14)) = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value15 = libc.VaUintptr(&ap)
		if value15 == uintptr(0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value15)) = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Frng
	case int32(OPUS_SET_LFE_REQUEST):
		value16 = libc.VaInt32(&ap)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Flfe = value16
	case int32(OPUS_SET_ENERGY_MASK_REQUEST):
		value17 = libc.VaUintptr(&ap)
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fenergy_mask = value17
	default:
		goto bad_request
	}
	_ = ap
	return OPUS_OK
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
	goto bad_request
bad_request:
	;
	_ = ap
	return -int32(5)
}

const DECODER_RESET_START = "rng"
const DECODE_BUFFER_SIZE = "DEC_PITCH_BUF_SIZE"
const EPSILON6 = "1e-15f"
const FRAME_DRED = 5
const FRAME_NONE = 0
const FRAME_NORMAL = 1
const FRAME_PLC_NEURAL = 4
const FRAME_PLC_NOISE = 2
const FRAME_PLC_PERIODIC = 3
const PLC_PITCH_LAG_MAX = 720
const PLC_PITCH_LAG_MIN = 100
const PLC_UPDATE_FRAMES = 4
const Q15ONE3 = 1
const Q31ONE3 = 1
const VERY_SMALL3 = 1e-30
const qext_bytes = 0

type OpusT_OpusCustomDecoder = struct {
	Fmode                  uintptr
	Foverlap               int32
	Fchannels              int32
	Fstream_channels       int32
	Fdownsample            int32
	Fstart                 int32
	Fend                   int32
	Fsignalling            int32
	Fdisable_inv           int32
	Fcomplexity            int32
	Farch                  int32
	Frng                   OpusT_opus_uint32
	Ferror1                int32
	Flast_pitch_index      int32
	Floss_duration         int32
	Fplc_duration          int32
	Flast_frame_type       int32
	Fskip_plc              int32
	Fpostfilter_period     int32
	Fpostfilter_period_old int32
	Fpostfilter_gain       OpusT_opus_val16
	Fpostfilter_gain_old   OpusT_opus_val16
	Fpostfilter_tapset     int32
	Fpostfilter_tapset_old int32
	Fprefilter_and_fold    int32
	Fpreemph_memD          [2]OpusT_celt_sig
	F_decode_mem           [1]OpusT_celt_sig
}

var trim_icdf15 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf15 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf15 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff10 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff10 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The maximum pitch lag to allow in the pitch-based PLC. It's possible to save
   CPU time in the PLC pitch search by making this smaller than MAX_PERIOD. The
   current value corresponds to a pitch of 66.67 Hz. */
/* The minimum pitch lag to allow in the pitch-based PLC. This corresponds to a
   pitch of 480 Hz. */

/**********************************************************************/
/*                                                                    */
/*                             DECODER                                */
/*                                                                    */
/**********************************************************************/

/*
  - Decoder state
    @brief Decoder state
*/
type OpusCustomDecoder = struct {
	Fmode                  uintptr
	Foverlap               int32
	Fchannels              int32
	Fstream_channels       int32
	Fdownsample            int32
	Fstart                 int32
	Fend                   int32
	Fsignalling            int32
	Fdisable_inv           int32
	Fcomplexity            int32
	Farch                  int32
	Frng                   OpusT_opus_uint32
	Ferror1                int32
	Flast_pitch_index      int32
	Floss_duration         int32
	Fplc_duration          int32
	Flast_frame_type       int32
	Fskip_plc              int32
	Fpostfilter_period     int32
	Fpostfilter_period_old int32
	Fpostfilter_gain       OpusT_opus_val16
	Fpostfilter_gain_old   OpusT_opus_val16
	Fpostfilter_tapset     int32
	Fpostfilter_tapset_old int32
	Fprefilter_and_fold    int32
	Fpreemph_memD          [2]OpusT_celt_sig
	F_decode_mem           [1]OpusT_celt_sig
}

// C documentation
//
//	/* Make basic checks on the CELT state to ensure we don't end
//	   up writing all over memory. */

func Opus_opus_custom_mode_create(tls *libc.TLS, Fs OpusT_opus_int32, frame_size int32, error1 uintptr) (r uintptr) {
	var i, j int32
	_, _ = i, j
	i = 0
	for {
		if !(i < int32(TOTAL_MODES)) {
			break
		}
		j = 0
		for {
			if !(j < int32(4)) {
				break
			}
			if Fs == (*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FFs && frame_size<<j == (*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FshortMdctSize*(*OpusT_OpusCustomMode)(unsafe.Pointer(static_mode_list[i])).FnbShortMdcts {
				if error1 != 0 {
					*(*int32)(unsafe.Pointer(error1)) = OPUS_OK
				}
				return static_mode_list[i]
			}
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = -int32(1)
	}
	return libc.UintptrFromInt32(0)
}

const Q15ONE5 = 1

var trim_icdf17 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf17 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf17 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff17 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff17 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

func Opus_opus_decode(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	var _saved_stack, out, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var nb_samples, ret, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, nb_samples, out, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if data != libc.UintptrFromInt32(0) && len1 > 0 && !(decode_fec != 0) {
		nb_samples = Opus_opus_decoder_get_nb_samples(tls, st1, data, len1)
		if nb_samples > 0 {
			if frame_size < nb_samples {
				v31 = frame_size
			} else {
				v31 = nb_samples
			}
			frame_size = v31
		} else {
			return -int32(4)
		}
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(917))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(918))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	out = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	ret = Opus_opus_decode_native(tls, st1, data, len1, out, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), int32(OPTIONAL_CLIP), libc.UintptrFromInt32(0), 0)
	if ret > 0 {
		_ = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Farch
		Opus_celt_float2int16_c(tls, out, pcm, ret*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _59
_59:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_decode24(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	var _saved_stack, out, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var i, nb_samples, ret, v31 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, i, nb_samples, out, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if data != libc.UintptrFromInt32(0) && len1 > 0 && !(decode_fec != 0) {
		nb_samples = Opus_opus_decoder_get_nb_samples(tls, st1, data, len1)
		if nb_samples > 0 {
			if frame_size < nb_samples {
				v31 = frame_size
			} else {
				v31 = nb_samples
			}
			frame_size = v31
		} else {
			return -int32(4)
		}
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(966))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(967))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	out = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	ret = Opus_opus_decode_native(tls, st1, data, len1, out, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), 0, libc.UintptrFromInt32(0), 0)
	if ret > 0 {
		nb_samples = ret * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		i = 0
		for {
			if !(i < nb_samples) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(pcm + uintptr(i)*4)) = int32(Opus_lrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i)*4)))))
			goto _56
		_56:
			;
			i = i + 1
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _60
_60:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	if frame_size <= 0 {
		return -int32(1)
	}
	return Opus_opus_decode_native(tls, st, data, len1, pcm, frame_size, decode_fec, 0, libc.UintptrFromInt32(0), 0, libc.UintptrFromInt32(0), 0)
}

func Opus_opus_decode_native(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32, self_delimited int32, packet_offset uintptr, soft_clip int32, dred uintptr, dred_offset OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var count, duration_copy, i, nb_samples, packet_bandwidth, packet_frame_size, packet_mode, packet_stream_channels, pcm_count, ret, ret1, ret2, v1 int32
	var v8 OpusT_opus_val16
	var _ /* iter at bp+120 */ OpusT_OpusExtensionIterator
	var _ /* offset at bp+0 */ int32
	var _ /* padding at bp+104 */ uintptr
	var _ /* padding_len at bp+112 */ OpusT_opus_int32
	var _ /* size at bp+6 */ [48]OpusT_opus_int16
	var _ /* toc at bp+4 */ uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = count, duration_copy, i, nb_samples, packet_bandwidth, packet_frame_size, packet_mode, packet_stream_channels, pcm_count, ret, ret1, ret2, v1, v8
	validate_opus_decoder(tls, st)
	if decode_fec < 0 || decode_fec > int32(1) {
		return -int32(1)
	}
	/* For FEC/PLC, frame_size has to be to have a multiple of 2.5 ms */
	if (decode_fec != 0 || len1 == 0 || data == libc.UintptrFromInt32(0)) && frame_size%((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs/int32(400)) != 0 {
		return -int32(1)
	}
	_ = dred
	_ = dred_offset
	if len1 == 0 || data == libc.UintptrFromInt32(0) {
		pcm_count = 0
		for cond := true; cond; cond = pcm_count < frame_size {
			ret = opus_decode_frame(tls, st, libc.UintptrFromInt32(0), 0, pcm+uintptr(pcm_count*(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels)*4, frame_size-pcm_count, 0)
			if ret < 0 {
				return ret
			}
			pcm_count = pcm_count + ret
		}
		if !(pcm_count == frame_size) {
			Opus_celt_fatal(tls, __ccgo_ts+1955, __ccgo_ts+57, int32(773))
		}
		v1 = 0
		goto _2
	_2:
		if v1 != 0 {
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = pcm_count
		return pcm_count
	} else {
		if len1 < 0 {
			return -int32(1)
		}
	}
	packet_mode = opus_packet_get_mode(tls, data)
	packet_bandwidth = Opus_opus_packet_get_bandwidth(tls, data)
	packet_frame_size = Opus_opus_packet_get_samples_per_frame(tls, data, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs)
	packet_stream_channels = Opus_opus_packet_get_nb_channels(tls, data)
	count = Opus_opus_packet_parse_impl(tls, data, len1, self_delimited, bp+4, libc.UintptrFromInt32(0), bp+6, bp, packet_offset, bp+104, bp+112)
	if (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions != 0 {
		*(*uintptr)(unsafe.Pointer(bp + 104)) = libc.UintptrFromInt32(0)
		*(*OpusT_opus_int32)(unsafe.Pointer(bp + 112)) = 0
	}
	if count < 0 {
		return count
	}
	Opus_opus_extension_iterator_init(tls, bp+120, *(*uintptr)(unsafe.Pointer(bp + 104)), *(*OpusT_opus_int32)(unsafe.Pointer(bp + 112)), count)
	data = data + uintptr(*(*int32)(unsafe.Pointer(bp)))
	if decode_fec != 0 {
		/* If no FEC can be present, run the PLC (recursive call) */
		if frame_size < packet_frame_size || packet_mode == int32(MODE_CELT_ONLY) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode == int32(MODE_CELT_ONLY) {
			return Opus_opus_decode_native(tls, st, libc.UintptrFromInt32(0), 0, pcm, frame_size, 0, 0, libc.UintptrFromInt32(0), soft_clip, libc.UintptrFromInt32(0), 0)
		}
		/* Otherwise, run the PLC on everything except the size for which we might have FEC */
		duration_copy = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration
		if frame_size-packet_frame_size != 0 {
			ret1 = Opus_opus_decode_native(tls, st, libc.UintptrFromInt32(0), 0, pcm, frame_size-packet_frame_size, 0, 0, libc.UintptrFromInt32(0), soft_clip, libc.UintptrFromInt32(0), 0)
			if ret1 < 0 {
				(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = duration_copy
				return ret1
			}
			if !(ret1 == frame_size-packet_frame_size) {
				Opus_celt_fatal(tls, __ccgo_ts+1997, __ccgo_ts+57, int32(815))
			}
		}
		/* Complete with FEC */
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode = packet_mode
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth = packet_bandwidth
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = packet_frame_size
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = packet_stream_channels
		ret1 = opus_decode_frame(tls, st, data, int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[0]), pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels*(frame_size-packet_frame_size))*4, packet_frame_size, int32(1))
		if ret1 < 0 {
			return ret1
		} else {
			v1 = 0
			goto _4
		_4:
			if v1 != 0 {
			}
			(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = frame_size
			return frame_size
		}
	}
	if count*packet_frame_size > frame_size {
		return -int32(2)
	}
	/* Update the state as the last step to avoid updating it on an invalid packet */
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fmode = packet_mode
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth = packet_bandwidth
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = packet_frame_size
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = packet_stream_channels
	nb_samples = 0
	i = 0
	for {
		if !(i < count) {
			break
		}
		ret2 = opus_decode_frame(tls, st, data, int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[i]), pcm+uintptr(nb_samples*(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels)*4, frame_size-nb_samples, 0)
		if ret2 < 0 {
			return ret2
		}
		if !(ret2 == packet_frame_size) {
			Opus_celt_fatal(tls, __ccgo_ts+2049, __ccgo_ts+57, int32(865))
		}
		data = data + uintptr((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 6)))[i])
		nb_samples = nb_samples + ret2
		goto _5
	_5:
		;
		i = i + 1
	}
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration = nb_samples
	v1 = 0
	goto _7
_7:
	if v1 != 0 {
	}
	if soft_clip != 0 {
		Opus_opus_pcm_soft_clip_impl(tls, pcm, nb_samples, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels, st+88, (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch)
	} else {
		v8 = libc.Float32FromInt32(0)
		*(*OpusT_opus_val16)(unsafe.Pointer(st + 88 + 1*4)) = v8
		*(*OpusT_opus_val16)(unsafe.Pointer(st + 88)) = v8
	}
	return nb_samples
}

func Opus_opus_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, error1 uintptr) (r uintptr) {
	var ret int32
	var st, v1 uintptr
	_, _, _ = ret, st, v1
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_decoder_get_size(tls, channels)))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_decoder_init(tls, st, Fs, channels)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	return st
}

func Opus_opus_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap OpusT_va_list
	var celt_dec, silk_dec, value, value10, value12, value2, value3, value4, value5, value6, value8 uintptr
	var ret int32
	var value1, value11, value7, value9 OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, celt_dec, ret, silk_dec, value, value1, value10, value11, value12, value2, value3, value4, value5, value6, value7, value8, value9
	ret = OPUS_OK
	silk_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset)
	celt_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset)
	ap = va
	switch request {
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		value = libc.VaUintptr(&ap)
		if !(value != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fbandwidth
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value1 = libc.VaInt32(&ap)
		if value1 < 0 || value1 > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity = value1
		_ = value1 == libc.Int32FromInt32(0)
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_SET_COMPLEXITY_REQUEST), libc.VaList(bp+8, value1))
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		value2 = libc.VaUintptr(&ap)
		if !(value2 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value2)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value3 = libc.VaUintptr(&ap)
		if !(value3 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value3)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FrangeFinal
	case int32(OPUS_RESET_STATE):
		libc.Xmemset(tls, st+60, 0, (uint64(100)-libc.Uint64FromInt64(int64(st+60)-int64(st)))*uint64(1))
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0)
		Opus_silk_ResetDecoder(tls, silk_dec)
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs / int32(400)
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		value4 = libc.VaUintptr(&ap)
		if !(value4 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value4)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs
	case int32(OPUS_GET_PITCH_REQUEST):
		value5 = libc.VaUintptr(&ap)
		if !(value5 != 0) {
			goto bad_arg
		}
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fprev_mode == int32(MODE_CELT_ONLY) {
			ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_PITCH_REQUEST), libc.VaList(bp+8, value5+uintptr((int64(value5)-int64(value5))/4)*4))
		} else {
			*(*OpusT_opus_int32)(unsafe.Pointer(value5)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FprevPitchLag
		}
	case int32(OPUS_GET_GAIN_REQUEST):
		value6 = libc.VaUintptr(&ap)
		if !(value6 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value6)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fdecode_gain
	case int32(OPUS_SET_GAIN_REQUEST):
		value7 = libc.VaInt32(&ap)
		if value7 < -int32(32768) || value7 > int32(32767) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fdecode_gain = value7
	case int32(OPUS_GET_LAST_PACKET_DURATION_REQUEST):
		value8 = libc.VaUintptr(&ap)
		if !(value8 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value8)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Flast_packet_duration
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value9 = libc.VaInt32(&ap)
		if value9 < 0 || value9 > int32(1) {
			goto bad_arg
		}
		_ = value9 == libc.Int32FromInt32(0)
		ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+8, value9))
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value10 = libc.VaUintptr(&ap)
		if !(value10 != 0) {
			goto bad_arg
		}
		ret = Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+8, value10+uintptr((int64(value10)-int64(value10))/4)*4))
	case int32(OPUS_SET_IGNORE_EXTENSIONS_REQUEST):
		value11 = libc.VaInt32(&ap)
		if value11 < 0 || value11 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions = value11
	case int32(OPUS_GET_IGNORE_EXTENSIONS_REQUEST):
		value12 = libc.VaUintptr(&ap)
		if !(value12 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value12)) = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fignore_extensions
	default:
		/*fprintf(stderr, "unknown opus_decoder_ctl() request: %d", request);*/
		ret = -int32(5)
		break
	}
	_ = ap
	return ret
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
}

func Opus_opus_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

func Opus_opus_decoder_dred_decode(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

func Opus_opus_decoder_dred_decode24(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

func Opus_opus_decoder_dred_decode_float(tls *libc.TLS, st uintptr, dred uintptr, dred_offset OpusT_opus_int32, pcm uintptr, frame_size OpusT_opus_int32) (r int32) {
	_ = st
	_ = dred
	_ = dred_offset
	_ = pcm
	_ = frame_size
	return -int32(5)
}

const ANALYSIS_BUF_SIZE = 720
const ANALYSIS_COUNT_MAX = 10000
const BANDWIDTH_EXPANSION = "0.94f"
const BG_SNR_DECR_dB = "2.0f"
const BITRESERVOIR_DECAY_TIME_MS = 500
const BWE_COEF = 0.99
const COEF_ONE2 = "1.0f"
const DETECT_SIZE = 100
const DTX_ACTIVITY_THRESHOLD1 = 0.1
const ENERGY_VARIATION_THRESHOLD_QNT_OFFSET = "0.6f"
const EPSILON1 = 1e-15
const FIND_LPC_COND_FAC = "1e-5f"
const FIND_PITCH_BANDWIDTH_EXPANSION = "0.99f"
const FIND_PITCH_WHITE_NOISE_FRACTION = "1e-3f"
const HARMONIC_SHAPING = "0.3f"
const HARM_HP_NOISE_COEF = "0.35f"
const HARM_SNR_INCR_dB = "2.0f"
const HIGH_RATE_INPUT_TILT = "0.1f"
const HIGH_RATE_OR_LOW_QUALITY_HARMONIC_SHAPING = "0.2f"
const HP_NOISE_COEF = "0.25f"
const INPUT_TILT = "0.05f"
const LAMBDA_OFFSET = "1.2f"
const LAMBDA_QUANT_OFFSET = "0.8f"
const LBRR_SPEECH_ACTIVITY_THRES = "0.3f"
const LOG2_INV_LPC_GAIN_HIGH_THRES = 3
const LOG2_INV_LPC_GAIN_LOW_THRES = 8
const LOW_FREQ_SHAPING = "4.0f"
const LOW_QUALITY_LOW_FREQ_SHAPING_DECR = "0.5f"
const LTP_CORR_INV_MAX = "0.03f"
const MAX_BANDWIDTH_SWITCH_DELAY_MS = 5000
const MAX_ENCODER_BUFFER = 480
const MAX_NEURONS = 32
const MAX_PITCH_LAG_MS = 18
const MAX_SUM_LOG_GAIN_DB = "250.0f"
const NB_FRAMES = 8
const NB_TBANDS = 18
const OPUS_ENCODER_RESET_START = "stream_channels"
const PITCH_DRIFT_FAC_Q16 = 655
const PSEUDO_SNR_THRESHOLD = 316.23
const Q15ONE1 = 1
const RAND_BUF_SIZE = 128
const REDUCE_BITRATE_10_MS_BPS = 2200
const SHAPE_WHITE_NOISE_FRACTION = "3e-5f"
const SILK_DEBUG = 0
const SILK_TIC_TOC = 0
const SPARSE_SNR_INCR_dB = "2.0f"
const SPEECH_ACTIVITY_DTX_THRES = "0.05f"
const SUBFR_SMTH_COEF = "0.4f"
const TONALITY_ANALYSIS_RESET_START = "angle"
const VARIABLE_HP_MAX_CUTOFF_HZ = 100
const VARIABLE_HP_MAX_DELTA_FREQ = "0.4f"
const VARIABLE_HP_MIN_CUTOFF_HZ = 60
const VARIABLE_HP_SMTH_COEF1 = "0.1f"
const VARIABLE_HP_SMTH_COEF2 = 0.015
const VERY_SMALL1 = 1e-30
const V_PITCH_GAIN_START_MAX_Q14 = 15565
const V_PITCH_GAIN_START_MIN_Q14 = 11469
const WARPING_MULTIPLIER = "0.015f"
const celt_pitch_xcorr = "celt_pitch_xcorr_c"

var trim_icdf2 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf2 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf2 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusEncoder = struct {
	Fcelt_enc_offset         int32
	Fsilk_enc_offset         int32
	Fsilk_mode               OpusT_silk_EncControlStruct
	Fapplication             int32
	Fchannels                int32
	Fdelay_compensation      int32
	Fforce_channels          int32
	Fsignal_type             int32
	Fuser_bandwidth          int32
	Fmax_bandwidth           int32
	Fuser_forced_mode        int32
	Fvoice_ratio             int32
	FFs                      OpusT_opus_int32
	Fuse_vbr                 int32
	Fvbr_constraint          int32
	Fvariable_duration       int32
	Fbitrate_bps             OpusT_opus_int32
	Fuser_bitrate_bps        OpusT_opus_int32
	Flsb_depth               int32
	Fencoder_buffer          int32
	Flfe                     int32
	Farch                    int32
	Fuse_dtx                 int32
	Ffec_config              int32
	Fanalysis                OpusT_TonalityAnalysisState
	Fstream_channels         int32
	Fhybrid_stereo_width_Q14 OpusT_opus_int16
	Fvariable_HP_smth2_Q15   OpusT_opus_int32
	Fprev_HB_gain            OpusT_opus_val16
	Fhp_mem                  [4]OpusT_opus_val32
	Fmode                    int32
	Fprev_mode               int32
	Fprev_channels           int32
	Fprev_framesize          int32
	Fbandwidth               int32
	Fauto_bandwidth          int32
	Fsilk_bw_switch          int32
	Ffirst                   int32
	Fenergy_masking          uintptr
	Fwidth_mem               OpusT_StereoWidthState
	Fdetected_bandwidth      int32
	Fnb_no_activity_ms_Q1    int32
	Fpeak_signal_energy      OpusT_opus_val32
	Fnonfinal_frame          int32
	FrangeFinal              OpusT_opus_uint32
	Fdelay_buffer            [960]OpusT_opus_res
}

type OpusT_AnalysisDenseLayer = struct {
	Fbias          uintptr
	Finput_weights uintptr
	Fnb_inputs     int32
	Fnb_neurons    int32
	Fsigmoid       int32
}

type OpusT_AnalysisGRULayer = struct {
	Fbias              uintptr
	Finput_weights     uintptr
	Frecurrent_weights uintptr
	Fnb_inputs         int32
	Fnb_neurons        int32
}

type OpusT_TonalityAnalysisState = struct {
	Farch               int32
	Fapplication        int32
	FFs                 OpusT_opus_int32
	Fangle              [240]float32
	Fd_angle            [240]float32
	Fd2_angle           [240]float32
	Finmem              [720]OpusT_opus_val32
	Fmem_fill           int32
	Fprev_band_tonality [18]float32
	Fprev_tonality      float32
	Fprev_bandwidth     int32
	FE                  [8][18]float32
	FlogE               [8][18]float32
	FlowE               [18]float32
	FhighE              [18]float32
	FmeanE              [19]float32
	Fmem                [32]float32
	Fcmean              [8]float32
	Fstd                [9]float32
	FEtracker           float32
	FlowECount          float32
	FE_count            int32
	Fcount              int32
	Fanalysis_offset    int32
	Fwrite_pos          int32
	Fread_pos           int32
	Fread_subframe      int32
	Fhp_ener_accum      float32
	Finitialized        int32
	Frnn_state          [32]float32
	Fdownmix_state      [3]OpusT_opus_val32
	Finfo               [100]OpusT_AnalysisInfo
}

var log2_x_norm_coeff2 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff2 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

type OpusT_silk_shape_state_FLP = struct {
	FLastGainIndex      OpusT_opus_int8
	FHarmShapeGain_smth float32
	FTilt_smth          float32
}

type OpusT_silk_encoder_state_FLP = struct {
	FsCmn    OpusT_silk_encoder_state
	FsShape  OpusT_silk_shape_state_FLP
	Fx_buf   [720]float32
	FLTPCorr float32
}

type OpusT_silk_encoder_control_FLP = struct {
	FGains             [4]float32
	FPredCoef          [2][16]float32
	FLTPCoef           [20]float32
	FLTP_scale         float32
	FpitchL            [4]int32
	FAR                [96]float32
	FLF_MA_shp         [4]float32
	FLF_AR_shp         [4]float32
	FTilt              [4]float32
	FHarmShapeGain     [4]float32
	FLambda            float32
	Finput_quality     float32
	Fcoding_quality    float32
	FpredGain          float32
	FLTPredCodGain     float32
	FResNrg            [4]float32
	FGainsUnq_Q16      [4]OpusT_opus_int32
	FlastGainIndexPrev OpusT_opus_int8
}

type OpusT_silk_encoder = struct {
	FsStereo                   OpusT_stereo_enc_state
	FnBitsUsedLBRR             OpusT_opus_int32
	FnBitsExceeded             OpusT_opus_int32
	FnChannelsAPI              int32
	FnChannelsInternal         int32
	FnPrevChannelsInternal     int32
	FtimeSinceSwitchAllowed_ms int32
	FallowBandwidthSwitch      int32
	Fprev_decode_only_middle   int32
	Fstate_Fxx                 [2]OpusT_silk_encoder_state_FLP
}

type OpusT_StereoWidthState = struct {
	FXX             OpusT_opus_val32
	FXY             OpusT_opus_val32
	FYY             OpusT_opus_val32
	Fsmoothed_width OpusT_opus_val16
	Fmax_follower   OpusT_opus_val16
}

type OpusEncoder = struct {
	Fcelt_enc_offset         int32
	Fsilk_enc_offset         int32
	Fsilk_mode               OpusT_silk_EncControlStruct
	Fapplication             int32
	Fchannels                int32
	Fdelay_compensation      int32
	Fforce_channels          int32
	Fsignal_type             int32
	Fuser_bandwidth          int32
	Fmax_bandwidth           int32
	Fuser_forced_mode        int32
	Fvoice_ratio             int32
	FFs                      OpusT_opus_int32
	Fuse_vbr                 int32
	Fvbr_constraint          int32
	Fvariable_duration       int32
	Fbitrate_bps             OpusT_opus_int32
	Fuser_bitrate_bps        OpusT_opus_int32
	Flsb_depth               int32
	Fencoder_buffer          int32
	Flfe                     int32
	Farch                    int32
	Fuse_dtx                 int32
	Ffec_config              int32
	Fanalysis                OpusT_TonalityAnalysisState
	Fstream_channels         int32
	Fhybrid_stereo_width_Q14 OpusT_opus_int16
	Fvariable_HP_smth2_Q15   OpusT_opus_int32
	Fprev_HB_gain            OpusT_opus_val16
	Fhp_mem                  [4]OpusT_opus_val32
	Fmode                    int32
	Fprev_mode               int32
	Fprev_channels           int32
	Fprev_framesize          int32
	Fbandwidth               int32
	Fauto_bandwidth          int32
	Fsilk_bw_switch          int32
	Ffirst                   int32
	Fenergy_masking          uintptr
	Fwidth_mem               OpusT_StereoWidthState
	Fdetected_bandwidth      int32
	Fnb_no_activity_ms_Q1    int32
	Fpeak_signal_energy      OpusT_opus_val32
	Fnonfinal_frame          int32
	FrangeFinal              OpusT_opus_uint32
	Fdelay_buffer            [960]OpusT_opus_res
}

// C documentation
//
//	/* Transition tables for the voice and music. First column is the
//	   middle (memoriless) threshold. The second column is the hysteresis
//	   (difference with the middle) */
var mono_voice_bandwidth_thresholds = [8]OpusT_opus_int32{
	0: int32(9000),
	1: int32(700),
	2: int32(9000),
	3: int32(700),
	4: int32(13500),
	5: int32(1000),
	6: int32(14000),
	7: int32(2000),
}
var mono_music_bandwidth_thresholds = [8]OpusT_opus_int32{
	0: int32(9000),
	1: int32(700),
	2: int32(9000),
	3: int32(700),
	4: int32(11000),
	5: int32(1000),
	6: int32(12000),
	7: int32(2000),
}
var stereo_voice_bandwidth_thresholds = [8]OpusT_opus_int32{
	0: int32(9000),
	1: int32(700),
	2: int32(9000),
	3: int32(700),
	4: int32(13500),
	5: int32(1000),
	6: int32(14000),
	7: int32(2000),
}
var stereo_music_bandwidth_thresholds = [8]OpusT_opus_int32{
	0: int32(9000),
	1: int32(700),
	2: int32(9000),
	3: int32(700),
	4: int32(11000),
	5: int32(1000),
	6: int32(12000),
	7: int32(2000),
}

// C documentation
//
//	/* Threshold bit-rates for switching between mono and stereo */
var stereo_voice_threshold = int32(19000)
var stereo_music_threshold = int32(17000)

// C documentation
//
//	/* Threshold bit-rate for switching between SILK/hybrid and CELT-only */
var mode_thresholds = [2][2]OpusT_opus_int32{
	0: {
		0: int32(64000),
		1: int32(10000),
	},
	1: {
		0: int32(44000),
		1: int32(10000),
	},
}

var fec_thresholds = [10]OpusT_opus_int32{
	0: int32(12000),
	1: int32(1000),
	2: int32(14000),
	3: int32(1000),
	4: int32(16000),
	5: int32(1000),
	6: int32(20000),
	7: int32(1000),
	8: int32(22000),
	9: int32(1000),
}

func Opus_opus_decoder_get_nb_samples(tls *libc.TLS, dec uintptr, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	return Opus_opus_packet_get_nb_samples(tls, packet, len1, (*OpusT_OpusDecoder)(unsafe.Pointer(dec)).FFs)
}

type OpusDREDDecoder = struct {
	Floaded int32
	Farch   int32
	Fmagic  OpusT_opus_uint32
}

func Opus_opus_decoder_get_size(tls *libc.TLS, channels int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var alignment uint32
	var celtDecSizeBytes, ret, v1 int32
	var _ /* silkDecSizeBytes at bp+0 */ int32
	_, _, _, _ = alignment, celtDecSizeBytes, ret, v1
	if channels < int32(1) || channels > int32(2) {
		return 0
	}
	ret = Opus_silk_Get_Decoder_Size(tls, bp)
	if ret != 0 {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	*(*int32)(unsafe.Pointer(bp)) = v1
	celtDecSizeBytes = Opus_celt_decoder_get_size(tls, channels)
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(100)) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	return v1 + *(*int32)(unsafe.Pointer(bp)) + celtDecSizeBytes
}

func Opus_opus_decoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var celt_dec, silk_dec uintptr
	var ret, v1 int32
	var _ /* silkDecSizeBytes at bp+0 */ int32
	_, _, _, _, _ = alignment, celt_dec, ret, silk_dec, v1
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) {
		return -int32(1)
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(Opus_opus_decoder_get_size(tls, channels))*uint64(1))
	/* Initialize SILK decoder */
	ret = Opus_silk_Get_Decoder_Size(tls, bp)
	if ret != 0 {
		return -int32(3)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	*(*int32)(unsafe.Pointer(bp)) = v1
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(100)) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset + *(*int32)(unsafe.Pointer(bp))
	silk_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fsilk_dec_offset)
	celt_dec = st + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcelt_dec_offset)
	v1 = channels
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fcomplexity = 0
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs = Fs
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FAPI_sampleRate = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsAPI = (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels
	/* Reset decoder */
	ret = Opus_silk_InitDecoder(tls, silk_dec)
	if ret != 0 {
		return -int32(3)
	}
	/* Initialize CELT decoder */
	ret = Opus_celt_decoder_init(tls, celt_dec, Fs, channels)
	if ret != OPUS_OK {
		return -int32(3)
	}
	_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
	Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_SIGNALLING_REQUEST), libc.VaList(bp+16, libc.Int32FromInt32(0)))
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fprev_mode = 0
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fframe_size = Fs / int32(400)
	v1 = 0
	goto _7
_7:
	(*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch = v1
	return OPUS_OK
}

func Opus_opus_dred_alloc(tls *libc.TLS, error1 uintptr) (r uintptr) {
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = -int32(5)
	}
	return libc.UintptrFromInt32(0)
}

func Opus_opus_dred_decoder_create(tls *libc.TLS, error1 uintptr) (r uintptr) {
	var dec, v1 uintptr
	var ret int32
	_, _, _ = dec, ret, v1
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_dred_decoder_get_size(tls)))
	goto _2
_2:
	dec = v1
	if dec == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_dred_decoder_init(tls, dec)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, dec)
		dec = libc.UintptrFromInt32(0)
	}
	return dec
}

func Opus_opus_dred_decoder_ctl(tls *libc.TLS, dred_dec uintptr, request int32, va uintptr) (r int32) {
	_ = dred_dec
	_ = request
	return -int32(5)
}

func Opus_opus_dred_decoder_destroy(tls *libc.TLS, dec uintptr) {
	if dec != 0 {
		(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Fmagic = uint32(0xDE57801D)
	}
	libc.Xfree(tls, dec)
}

func Opus_opus_dred_decoder_get_size(tls *libc.TLS) (r int32) {
	return int32(12)
}

func Opus_opus_dred_decoder_init(tls *libc.TLS, dec uintptr) (r int32) {
	var ret, v1 int32
	_, _ = ret, v1
	ret = 0
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Floaded = 0
	v1 = 0
	goto _2
_2:
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Farch = v1
	/* To make sure nobody forgets to init, use a magic number. */
	(*OpusT_OpusDREDDecoder)(unsafe.Pointer(dec)).Fmagic = uint32(0xD8EDDEC0)
	if ret == 0 {
		v1 = OPUS_OK
	} else {
		v1 = -int32(5)
	}
	return v1
}

func Opus_opus_dred_free(tls *libc.TLS, dec uintptr) {
	_ = dec
}

func Opus_opus_dred_get_size(tls *libc.TLS) (r int32) {
	return 0
}

func Opus_opus_dred_parse(tls *libc.TLS, dred_dec uintptr, dred uintptr, data uintptr, len1 OpusT_opus_int32, max_dred_samples OpusT_opus_int32, sampling_rate OpusT_opus_int32, dred_end uintptr, defer_processing int32) (r int32) {
	_ = dred_dec
	_ = dred
	_ = data
	_ = len1
	_ = max_dred_samples
	_ = sampling_rate
	_ = defer_processing
	_ = dred_end
	return -int32(5)
}

func Opus_opus_dred_process(tls *libc.TLS, dred_dec uintptr, src uintptr, dst uintptr) (r int32) {
	_ = dred_dec
	_ = src
	_ = dst
	return -int32(5)
}

func Opus_opus_encode(tls *libc.TLS, st1 uintptr, pcm uintptr, analysis_frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r OpusT_opus_int32) {
	var _saved_stack, in, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var frame_size, i, ret int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, frame_size, i, in, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	frame_size = Opus_frame_size_select(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication, analysis_frame_size, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_duration, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(2685))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _54
_54:
	in = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) {
			break
		}
		*(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(pcm + uintptr(i)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
		goto _55
	_55:
		;
		i = i + 1
	}
	ret = Opus_opus_encode_native(tls, st1, in, frame_size, data, max_data_bytes, int32(16), pcm, analysis_frame_size, 0, -int32(2), (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, __ccgo_fp(Opus_downmix_int), int32(1))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _59
_59:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_encode24(tls *libc.TLS, st1 uintptr, pcm uintptr, analysis_frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r OpusT_opus_int32) {
	var _saved_stack, in, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var frame_size, i, ret int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, frame_size, i, in, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	frame_size = Opus_frame_size_select(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication, analysis_frame_size, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_duration, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(2720))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _54
_54:
	in = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < frame_size*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) {
			break
		}
		*(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i)*4)) = float32(libc.Float32FromFloat32(1) / libc.Float32FromFloat32(32768) / libc.Float32FromFloat32(256) * float32(*(*OpusT_opus_int32)(unsafe.Pointer(pcm + uintptr(i)*4))))
		goto _55
	_55:
		;
		i = i + 1
	}
	ret = Opus_opus_encode_native(tls, st1, in, frame_size, data, max_data_bytes, int32(MAX_ENCODING_DEPTH), pcm, analysis_frame_size, 0, -int32(2), (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, __ccgo_fp(Opus_downmix_int24), int32(1))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _59
_59:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_encode_float(tls *libc.TLS, st uintptr, pcm uintptr, analysis_frame_size int32, data uintptr, out_data_bytes OpusT_opus_int32) (r OpusT_opus_int32) {
	var frame_size int32
	_ = frame_size
	frame_size = Opus_frame_size_select(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication, analysis_frame_size, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_duration, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs)
	return Opus_opus_encode_native(tls, st, pcm, frame_size, data, out_data_bytes, int32(MAX_ENCODING_DEPTH), pcm, analysis_frame_size, 0, -int32(2), (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels, __ccgo_fp(Opus_downmix_float), int32(1))
}

func Opus_opus_encode_native(tls *libc.TLS, st1 uintptr, pcm uintptr, frame_size2 int32, data uintptr, out_data_bytes OpusT_opus_int32, lsb_depth int32, analysis_pcm uintptr, analysis_size OpusT_opus_int32, c1 int32, c2 int32, analysis_channels int32, __ccgo_fp_downmix OpusT_downmix_func, float_api int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	var _saved_stack, celt_enc, curr_data, music_bandwidth_thresholds, rp, silk_enc, st, tmp_data, voice_bandwidth_thresholds, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var analysis_bandwidth, analysis_read_pos_bak, analysis_read_subframe_bak, bak_to_mono, bandwidth, bw, celt_to_silk, curr_bandwidth, dtx_count, enc_frame_size, first_frame, frame_rate, frame_redundancy, frame_to_celt, hysteresis, i, is_silence, max_header_bytes, min_detected_bandwidth, nb_frames, num_multiframes, packet_code, packet_size_cap, prefill, redundancy, ret, threshold1, tmp_len, to_celt, tocmode, voice_est, v27 int32
	var bandwidth_thresholds [8]OpusT_opus_int32
	var cbr_bytes, curr_max, equiv_rate, max_data_bytes, max_len_sum, max_rate, mode_music, mode_voice, repacketize_len, stereo_threshold, threshold, tot_size, v39, v41 OpusT_opus_int32
	var prob, v37 float32
	var stereo_width OpusT_opus_val16
	var _ /* analysis_info at bp+8 */ OpusT_AnalysisInfo
	var _ /* celt_mode at bp+0 */ uintptr
	var _ /* dummy at bp+72 */ OpusT_silk_EncControlStruct
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, analysis_bandwidth, analysis_read_pos_bak, analysis_read_subframe_bak, bak_to_mono, bandwidth, bandwidth_thresholds, bw, cbr_bytes, celt_enc, celt_to_silk, curr_bandwidth, curr_data, curr_max, dtx_count, enc_frame_size, equiv_rate, first_frame, frame_rate, frame_redundancy, frame_to_celt, hysteresis, i, is_silence, max_data_bytes, max_header_bytes, max_len_sum, max_rate, min_detected_bandwidth, mode_music, mode_voice, music_bandwidth_thresholds, nb_frames, num_multiframes, packet_code, packet_size_cap, prefill, prob, redundancy, repacketize_len, ret, rp, silk_enc, st, stereo_threshold, stereo_width, threshold, threshold1, tmp_data, tmp_len, to_celt, tocmode, tot_size, voice_bandwidth_thresholds, voice_est, v1, v10, v11, v13, v15, v17, v19, v21, v27, v3, v37, v39, v41, v5, v6, v8
	silk_enc = libc.UintptrFromInt32(0)
	celt_enc = libc.UintptrFromInt32(0)
	ret = 0
	prefill = 0
	redundancy = 0
	celt_to_silk = 0
	to_celt = 0 /* Max number of bytes we're allowed to use */
	cbr_bytes = -int32(1)
	*(*uintptr)(unsafe.Pointer(bp)) = libc.UintptrFromInt32(0)
	packet_size_cap = int32(1276)
	analysis_read_pos_bak = -int32(1)
	analysis_read_subframe_bak = -int32(1)
	is_silence = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Just avoid insane packet sizes here, but the real bounds are applied later on. */
	if packet_size_cap*int32(6) < out_data_bytes {
		v27 = packet_size_cap * int32(6)
	} else {
		v27 = out_data_bytes
	}
	max_data_bytes = v27
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
	if frame_size2 <= 0 || max_data_bytes <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _29
		_29:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _31
	_31:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Cannot encode 100 ms in 1 byte */
	if max_data_bytes == int32(1) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs == frame_size2*int32(10) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _33
		_33:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _35
	_35:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(2)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		silk_enc = st1 + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_enc_offset)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		celt_enc = st1 + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fcelt_enc_offset)
	}
	if lsb_depth < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Flsb_depth {
		v27 = lsb_depth
	} else {
		v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Flsb_depth
	}
	lsb_depth = v27
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+184, bp+uintptr((OpusT___predefined_ptrdiff_t(bp)-int64(bp))/8)*8))
	}
	is_silence = Opus_is_digital_silence(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, lsb_depth)
	(*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fvalid = 0
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.Fcomplexity >= int32(7) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs >= int32(16000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs <= int32(48000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		analysis_read_pos_bak = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fanalysis.Fread_pos
		analysis_read_subframe_bak = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fanalysis.Fread_subframe
		Opus_run_analysis(tls, st1+196, *(*uintptr)(unsafe.Pointer(bp)), analysis_pcm, analysis_size, frame_size2, c1, c2, analysis_channels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs, lsb_depth, __ccgo_fp_downmix, bp+8)
	} else {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fanalysis.Finitialized != 0 {
			Opus_tonality_analysis_reset(tls, st1+196)
		}
	}
	/* Reset voice_ratio if this frame is not silent or if analysis is disabled.
	 * Otherwise, preserve voice_ratio from the last non-silent frame */
	if !(is_silence != 0) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvoice_ratio = -int32(1)
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = 0
	if (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fvalid != 0 {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsignal_type == -int32(1000) {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode == 0 {
				prob = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fmusic_prob
			} else {
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) {
					prob = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fmusic_prob_max
				} else {
					prob = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fmusic_prob_min
				}
			}
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvoice_ratio = int32(libc.Xfloor(tls, float64(0.5)+float64(libc.Float32FromInt32(100)*(libc.Float32FromInt32(1)-prob))))
		}
		analysis_bandwidth = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fbandwidth
		if analysis_bandwidth <= int32(12) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
		} else {
			if analysis_bandwidth <= int32(14) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND)
			} else {
				if analysis_bandwidth <= int32(16) {
					(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
				} else {
					if analysis_bandwidth <= int32(18) {
						(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
					} else {
						(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
					}
				}
			}
		}
	}
	/* Track the peak signal energy */
	if !((*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fvalid != 0) || (*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Factivity_probability > libc.Float32FromFloat32(0.1) {
		if !(is_silence != 0) {
			if float32(libc.Float32FromFloat32(0.999)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fpeak_signal_energy) > compute_frame_energy(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch) {
				v37 = float32(libc.Float32FromFloat32(0.999) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fpeak_signal_energy)
			} else {
				v37 = compute_frame_energy(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch)
			}
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fpeak_signal_energy = v37
		}
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels == int32(2) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fforce_channels != int32(1) {
		stereo_width = Opus_compute_stereo_width(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs, st1+14272)
	} else {
		stereo_width = libc.Float32FromInt32(0)
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps = user_bitrate_to_bitrate(tls, st1, frame_size2, max_data_bytes)
	frame_rate = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2
	if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0) {
		v39 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
		goto _40
	_40:
		if (v39+int32(4))/int32(8) < max_data_bytes {
			v41 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
			goto _42
		_42:
			v27 = (v41 + int32(4)) / int32(8)
		} else {
			v27 = max_data_bytes
		}
		cbr_bytes = v27
		v39 = cbr_bytes * int32(8) * (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2) / int32(6)
		goto _44
	_44:
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps = v39
		/* Make sure we provide at least one byte to avoid failing. */
		if int32(1) > cbr_bytes {
			v27 = int32(1)
		} else {
			v27 = cbr_bytes
		}
		max_data_bytes = v27
	}
	if max_data_bytes < int32(3) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps < int32(3)*frame_rate*int32(8) || frame_rate < int32(50) && (max_data_bytes*frame_rate < int32(300) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps < int32(2400)) {
		/*If the space is too low to do something useful, emit 'PLC' frames.*/
		tocmode = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == 0 {
			v27 = int32(OPUS_BANDWIDTH_NARROWBAND)
		} else {
			v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth
		}
		bw = v27
		packet_code = 0
		num_multiframes = 0
		if tocmode == 0 {
			tocmode = int32(MODE_SILK_ONLY)
		}
		if frame_rate > int32(100) {
			tocmode = int32(MODE_CELT_ONLY)
		}
		/* 40 ms -> 2 x 20 ms if in CELT_ONLY or HYBRID mode */
		if frame_rate == int32(25) && tocmode != int32(MODE_SILK_ONLY) {
			frame_rate = int32(50)
			packet_code = int32(1)
		}
		/* >= 60 ms frames */
		if frame_rate <= int32(16) {
			/* 1 x 60 ms, 2 x 40 ms, 2 x 60 ms */
			if out_data_bytes == int32(1) || tocmode == int32(MODE_SILK_ONLY) && frame_rate != int32(10) {
				tocmode = int32(MODE_SILK_ONLY)
				packet_code = libc.BoolInt32(frame_rate <= int32(12))
				if frame_rate == int32(12) {
					v27 = int32(25)
				} else {
					v27 = int32(16)
				}
				frame_rate = v27
			} else {
				num_multiframes = int32(50) / frame_rate
				frame_rate = int32(50)
				packet_code = int32(3)
			}
		}
		if tocmode == int32(MODE_SILK_ONLY) && bw > int32(OPUS_BANDWIDTH_WIDEBAND) {
			bw = int32(OPUS_BANDWIDTH_WIDEBAND)
		} else {
			if tocmode == int32(MODE_CELT_ONLY) && bw == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
				bw = int32(OPUS_BANDWIDTH_NARROWBAND)
			} else {
				if tocmode == int32(MODE_HYBRID) && bw <= int32(OPUS_BANDWIDTH_SUPERWIDEBAND) {
					bw = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
				}
			}
		}
		*(*uint8)(unsafe.Pointer(data)) = gen_toc(tls, tocmode, frame_rate, bw, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
		v1 = data
		*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(v1))) | packet_code)
		if packet_code <= int32(1) {
			v27 = int32(1)
		} else {
			v27 = int32(2)
		}
		ret = v27
		if max_data_bytes > ret {
			v27 = max_data_bytes
		} else {
			v27 = ret
		}
		max_data_bytes = v27
		if packet_code == int32(3) {
			*(*uint8)(unsafe.Pointer(data + 1)) = libc.Uint8FromInt32(num_multiframes)
		}
		if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0) {
			ret = Opus_opus_packet_pad(tls, data, ret, max_data_bytes)
			if ret == OPUS_OK {
				ret = max_data_bytes
			} else {
				ret = -int32(3)
			}
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _52
		_52:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _54
	_54:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	v39 = max_data_bytes * int32(8) * (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2) / int32(6)
	goto _56
_56:
	max_rate = v39
	/* Equivalent 20-ms rate for mode/channel/bandwidth decisions */
	equiv_rate = compute_equiv_rate(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr, 0, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.Fcomplexity, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpacketLossPercentage)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsignal_type == int32(OPUS_SIGNAL_VOICE) {
		voice_est = int32(127)
	} else {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsignal_type == int32(OPUS_SIGNAL_MUSIC) {
			voice_est = 0
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvoice_ratio >= 0 {
				voice_est = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvoice_ratio * int32(327) >> int32(8)
				/* For AUDIO, never be more than 90% confident of having speech */
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_AUDIO) {
					if voice_est < int32(115) {
						v27 = voice_est
					} else {
						v27 = int32(115)
					}
					voice_est = v27
				}
			} else {
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_VOIP) {
					voice_est = int32(115)
				} else {
					voice_est = int32(48)
				}
			}
		}
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fforce_channels != -int32(1000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels == int32(2) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fforce_channels
	} else {
		/* Rate-dependent mono-stereo decision */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels == int32(2) {
			stereo_threshold = stereo_music_threshold + voice_est*voice_est*(stereo_voice_threshold-stereo_music_threshold)>>int32(14)
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels == int32(2) {
				stereo_threshold = stereo_threshold - int32(1000)
			} else {
				stereo_threshold = stereo_threshold + int32(1000)
			}
			if equiv_rate > stereo_threshold {
				v27 = int32(2)
			} else {
				v27 = int32(1)
			}
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels = v27
		} else {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels
		}
	}
	/* Update equivalent rate for channels decision. */
	equiv_rate = compute_equiv_rate(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr, 0, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.Fcomplexity, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpacketLossPercentage)
	/* Allow SILK DTX if DTX is enabled but the generalized DTX cannot be used,
	   e.g. because of the complexity setting or sample rate. */
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseDTX = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_dtx != 0 && !((*(*OpusT_AnalysisInfo)(unsafe.Pointer(bp + 8))).Fvalid != 0 || is_silence != 0))
	/* Mode selection depending on application and signal type */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_SILK_ONLY)
	} else {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_CELT) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_CELT_ONLY)
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_forced_mode == -int32(1000) {
				/* Interpolate based on stereo width */
				mode_voice = int32(float32((libc.Float32FromFloat32(1)-stereo_width)*float32(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&mode_thresholds)))))) + OpusT_opus_val16(stereo_width*float32(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&mode_thresholds)) + 1*8)))))
				mode_music = int32(float32((libc.Float32FromFloat32(1)-stereo_width)*float32(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&mode_thresholds)) + 1*8 + 1*4)))) + OpusT_opus_val16(stereo_width*float32(*(*OpusT_opus_int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&mode_thresholds)) + 1*8 + 1*4)))))
				/* Interpolate based on speech/music probability */
				threshold = mode_music + voice_est*voice_est*(mode_voice-mode_music)>>int32(14)
				/* Bias towards SILK for VoIP because of some useful features */
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_VOIP) {
					threshold = threshold + int32(8000)
				}
				/*printf("%f %d\n", stereo_width/(float)Q15ONE, threshold);*/
				/* Hysteresis */
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) {
					threshold = threshold - int32(4000)
				} else {
					if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode > 0 {
						threshold = threshold + int32(4000)
					}
				}
				if equiv_rate >= threshold {
					v27 = int32(MODE_CELT_ONLY)
				} else {
					v27 = int32(MODE_SILK_ONLY)
				}
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = v27
				/* When FEC is enabled and there's enough packet loss, use SILK.
				   Unless the FEC is set to 2, in which case we don't switch to SILK if we're confident we have music. */
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseInBandFEC != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpacketLossPercentage > (int32(128)-voice_est)>>int32(4) && ((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Ffec_config != int32(2) || voice_est > int32(25)) {
					(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_SILK_ONLY)
				}
				/* When encoding voice and DTX is enabled but the generalized DTX cannot be used,
				   use SILK in order to make use of its DTX. */
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseDTX != 0 && voice_est > int32(100) {
					(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_SILK_ONLY)
				}
				/* If max_data_bytes represents less than 6 kb/s, switch to CELT-only mode */
				if frame_rate > int32(50) {
					v27 = int32(9000)
				} else {
					v27 = int32(6000)
				}
				v39 = v27 * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
				goto _62
			_62:
				if max_data_bytes < v39/int32(8) {
					(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_CELT_ONLY)
				}
			} else {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_forced_mode
			}
		}
	}
	/* Override the chosen mode to make sure we meet the requested frame size */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && frame_size2 < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(100) {
		if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != libc.Int32FromInt32(OPUS_APPLICATION_RESTRICTED_SILK)) {
			Opus_celt_fatal(tls, __ccgo_ts+2090, __ccgo_ts+2160, int32(1535))
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_CELT_ONLY)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Flfe != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_CELT_ONLY)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && ((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_CELT_ONLY)) {
		redundancy = int32(1)
		celt_to_silk = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY))
		if !(celt_to_silk != 0) {
			/* Switch to SILK/hybrid if frame size is 10 ms or more*/
			if frame_size2 >= (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(100) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode
				to_celt = int32(1)
			} else {
				redundancy = 0
			}
		}
	}
	/* When encoding multiframes, we can ask for a switch to CELT only in the last frame. This switch
	 * is processed above as the requested mode shouldn't interrupt stereo->mono transition. */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels == int32(1) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_channels == int32(2) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono == 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_CELT_ONLY) {
		/* Delay stereo->mono transition by two frames so that SILK can do a smooth downmix */
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono = int32(1)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels = int32(2)
	} else {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono = 0
	}
	/* Update equivalent rate with mode decision. */
	equiv_rate = compute_equiv_rate(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.Fcomplexity, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpacketLossPercentage)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) {
		Opus_silk_InitEncoder(tls, silk_enc, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch, bp+72)
		prefill = int32(1)
	}
	/* Automatic (rate-dependent) bandwidth selection */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Ffirst != 0 || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FallowBandwidthSwitch != 0 {
		bandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels == int32(2) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fforce_channels != int32(1) {
			voice_bandwidth_thresholds = uintptr(unsafe.Pointer(&stereo_voice_bandwidth_thresholds))
			music_bandwidth_thresholds = uintptr(unsafe.Pointer(&stereo_music_bandwidth_thresholds))
		} else {
			voice_bandwidth_thresholds = uintptr(unsafe.Pointer(&mono_voice_bandwidth_thresholds))
			music_bandwidth_thresholds = uintptr(unsafe.Pointer(&mono_music_bandwidth_thresholds))
		}
		/* Interpolate bandwidth thresholds depending on voice estimation */
		i = 0
		for {
			if !(i < int32(8)) {
				break
			}
			bandwidth_thresholds[i] = *(*OpusT_opus_int32)(unsafe.Pointer(music_bandwidth_thresholds + uintptr(i)*4)) + voice_est*voice_est*(*(*OpusT_opus_int32)(unsafe.Pointer(voice_bandwidth_thresholds + uintptr(i)*4))-*(*OpusT_opus_int32)(unsafe.Pointer(music_bandwidth_thresholds + uintptr(i)*4)))>>int32(14)
			goto _63
		_63:
			;
			i = i + 1
		}
		for {
			threshold1 = bandwidth_thresholds[int32(2)*(bandwidth-int32(OPUS_BANDWIDTH_MEDIUMBAND))]
			hysteresis = bandwidth_thresholds[int32(2)*(bandwidth-int32(OPUS_BANDWIDTH_MEDIUMBAND))+int32(1)]
			if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Ffirst != 0) {
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fauto_bandwidth >= bandwidth {
					threshold1 = threshold1 - hysteresis
				} else {
					threshold1 = threshold1 + hysteresis
				}
			}
			if equiv_rate >= threshold1 {
				break
			}
			goto _65
		_65:
			;
			bandwidth = bandwidth - 1
			v27 = bandwidth
			if !(v27 > int32(OPUS_BANDWIDTH_NARROWBAND)) {
				break
			}
		}
		/* We don't use mediumband anymore, except when explicitly requested or during
		   mode transitions. */
		if bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
			bandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
		}
		v27 = bandwidth
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fauto_bandwidth = v27
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = v27
		/* Prevents any transition to SWB/FB until the SILK layer has fully
		   switched to WB mode and turned the variable LP filter off */
		if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Ffirst != 0) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FinWBmodeWithoutVariableLP != 0) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > int32(OPUS_BANDWIDTH_WIDEBAND) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
		}
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmax_bandwidth {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmax_bandwidth
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_bandwidth != -int32(1000) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_bandwidth
	}
	/* This prevents us from using hybrid at unsafe CBR/max rates */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) && max_rate < int32(15000) {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth < int32(OPUS_BANDWIDTH_WIDEBAND) {
			v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth
		} else {
			v27 = int32(OPUS_BANDWIDTH_WIDEBAND)
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = v27
	}
	/* Prevents Opus from wasting bits on frequencies that are above
	   the Nyquist rate of the input signal */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs <= int32(24000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > int32(OPUS_BANDWIDTH_SUPERWIDEBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs <= int32(16000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > int32(OPUS_BANDWIDTH_WIDEBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs <= int32(12000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > int32(OPUS_BANDWIDTH_MEDIUMBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs <= int32(8000) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth > int32(OPUS_BANDWIDTH_NARROWBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
	}
	/* Use detected bandwidth to reduce the encoded bandwidth. */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_bandwidth == -int32(1000) {
		/* Makes bandwidth detection more conservative just in case the detector
		   gets it wrong when we could have coded a high bandwidth transparently.
		   When operating in SILK/hybrid mode, we don't go below wideband to avoid
		   more complicated switches that require redundancy. */
		if equiv_rate <= int32(18000)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) {
			min_detected_bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
		} else {
			if equiv_rate <= int32(24000)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) {
				min_detected_bandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND)
			} else {
				if equiv_rate <= int32(30000)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels {
					min_detected_bandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
				} else {
					if equiv_rate <= int32(44000)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels {
						min_detected_bandwidth = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
					} else {
						min_detected_bandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
					}
				}
			}
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth > min_detected_bandwidth {
			v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth
		} else {
			v27 = min_detected_bandwidth
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth = v27
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth {
			v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth
		} else {
			v27 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdetected_bandwidth
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = v27
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FLBRR_coded = decide_fec(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseInBandFEC, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpacketLossPercentage, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FLBRR_coded, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode, st1+14248, equiv_rate)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		_ = lsb_depth == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_LSB_DEPTH_REQUEST), libc.VaList(bp+184, lsb_depth))
	}
	/* CELT mode doesn't support mediumband, use wideband instead */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Flfe != 0 {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
	}
	curr_bandwidth = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_SILK) && curr_bandwidth > int32(OPUS_BANDWIDTH_WIDEBAND) {
		v27 = libc.Int32FromInt32(OPUS_BANDWIDTH_WIDEBAND)
		curr_bandwidth = v27
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth = v27
	}
	/* Chooses the appropriate mode for speech
	 *NEVER* switch to/from CELT-only mode here as this will invalidate some assumptions */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) && curr_bandwidth > int32(OPUS_BANDWIDTH_WIDEBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_HYBRID)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) && curr_bandwidth <= int32(OPUS_BANDWIDTH_WIDEBAND) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode = int32(MODE_SILK_ONLY)
	}
	/* Can't support higher than >60 ms frames, and >20 ms when in Hybrid or CELT-only modes */
	if frame_size2 > (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(50) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_SILK_ONLY) || frame_size2 > int32(3)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(50) {
		tot_size = 0
		dtx_count = 0
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) {
			if frame_size2 == int32(2)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(25) { /* 80 ms -> 2x 40 ms */
				enc_frame_size = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(25)
			} else {
				if frame_size2 == int32(3)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(25) { /* 120 ms -> 2x 60 ms */
					enc_frame_size = int32(3) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(50)
				} else { /* 100 ms -> 5x 20 ms */
					enc_frame_size = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(50)
				}
			}
		} else {
			enc_frame_size = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(50)
		}
		nb_frames = frame_size2 / enc_frame_size
		if analysis_read_pos_bak != -int32(1) {
			/* Reset analysis position to the beginning of the first frame so we
			   can use it one frame at a time. */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fanalysis.Fread_pos = analysis_read_pos_bak
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fanalysis.Fread_subframe = analysis_read_subframe_bak
		}
		/* Worst cases:
		 * 2 frames: Code 2 with different compressed sizes
		 * >2 frames: Code 3 VBR */
		if nb_frames == int32(2) {
			v27 = int32(3)
		} else {
			v27 = int32(2) + (nb_frames-int32(1))*int32(2)
		}
		max_header_bytes = v27
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0 || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuser_bitrate_bps == -int32(1) {
			repacketize_len = out_data_bytes
		} else {
			if !(cbr_bytes >= libc.Int32FromInt32(0)) {
				Opus_celt_fatal(tls, __ccgo_ts+2182, __ccgo_ts+2160, int32(1752))
			}
			if cbr_bytes < out_data_bytes {
				v27 = cbr_bytes
			} else {
				v27 = out_data_bytes
			}
			repacketize_len = v27
		}
		max_len_sum = nb_frames + repacketize_len - max_header_bytes
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _74
		_74:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _76
	_76:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _78
		_78:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v6 = st
		goto _80
	_80:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v8 = libc.Xmalloc(tls, uint64(16))
			goto _82
		_82:
			st = v8
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _84
	_84:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _86
		_86:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _88
	_88:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(max_len_sum)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(1757))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _90
		_90:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _92
	_92:
		*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(max_len_sum) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _94
		_94:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _96
	_96:
		tmp_data = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(max_len_sum)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
		curr_data = tmp_data
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _98
		_98:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _100
	_100:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _102
		_102:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v6 = st
		goto _104
	_104:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(8) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(8) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v8 = libc.Xmalloc(tls, uint64(16))
			goto _106
		_106:
			st = v8
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _108
	_108:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _110
		_110:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _112
	_112:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(1120)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(1759))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _114
		_114:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _116
	_116:
		*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(1120) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _118
		_118:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _120
	_120:
		rp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(1))*(libc.Uint64FromInt64(1120)/libc.Uint64FromInt64(1)))
		Opus_opus_repacketizer_init(tls, rp)
		bak_to_mono = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono
		if bak_to_mono != 0 {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fforce_channels = int32(1)
		} else {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_channels = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels
		}
		i = 0
		for {
			if !(i < nb_frames) {
				break
			}
			/* Attempt DRED encoding until we have a non-DTX frame. In case of DTX refresh,
			   that allows for DRED not to be in the first frame. */
			first_frame = libc.BoolInt32(i == 0 || i == dtx_count)
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono = 0
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fnonfinal_frame = libc.BoolInt32(i < nb_frames-int32(1))
			/* When switching from SILK/Hybrid to CELT, only ask for a switch at the last frame */
			frame_to_celt = libc.BoolInt32(to_celt != 0 && i == nb_frames-int32(1))
			frame_redundancy = libc.BoolInt32(redundancy != 0 && (frame_to_celt != 0 || !(to_celt != 0) && i == 0))
			v39 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / enc_frame_size)
			goto _124
		_124:
			if v39/int32(8) < max_len_sum/nb_frames {
				v41 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / enc_frame_size)
				goto _126
			_126:
				v27 = v41 / int32(8)
			} else {
				v27 = max_len_sum / nb_frames
			}
			curr_max = v27
			if max_len_sum-tot_size < curr_max {
				v27 = max_len_sum - tot_size
			} else {
				v27 = curr_max
			}
			curr_max = v27
			if analysis_read_pos_bak != -int32(1) {
				/* Get analysis for current frame. */
				Opus_tonality_get_info(tls, st1+196, bp+8, enc_frame_size)
			}
			is_silence = Opus_is_digital_silence(tls, pcm+uintptr(i*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*enc_frame_size))*4, enc_frame_size, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, lsb_depth)
			tmp_len = opus_encode_frame_native(tls, st1, pcm+uintptr(i*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*enc_frame_size))*4, enc_frame_size, curr_data, curr_max, float_api, first_frame, bp+8, is_silence, frame_redundancy, celt_to_silk, prefill, equiv_rate, frame_to_celt)
			if tmp_len < 0 {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _129
				_129:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _131
			_131:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(3)
			} else {
				if tmp_len == int32(1) {
					dtx_count = dtx_count + 1
				}
			}
			ret = Opus_opus_repacketizer_cat(tls, rp, curr_data, tmp_len)
			if ret < 0 {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _133
				_133:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _135
			_135:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(3)
			}
			tot_size = tot_size + tmp_len
			curr_data = curr_data + uintptr(tmp_len)
			goto _121
		_121:
			;
			i = i + 1
		}
		ret = Opus_opus_repacketizer_out_range_impl(tls, rp, 0, nb_frames, data, repacketize_len, 0, libc.BoolInt32(!((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0) && dtx_count != nb_frames), libc.UintptrFromInt32(0), 0)
		if ret < 0 {
			ret = -int32(3)
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FtoMono = bak_to_mono
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _137
		_137:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _139
	_139:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	} else {
		ret = opus_encode_frame_native(tls, st1, pcm, frame_size2, data, max_data_bytes, float_api, int32(1), bp+8, is_silence, redundancy, celt_to_silk, prefill, equiv_rate, to_celt)
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _141
		_141:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _143
	_143:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return ret
	}
	return r
}

func Opus_opus_encoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, application int32, error1 uintptr) (r uintptr) {
	var ret, size1 int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) || application != int32(OPUS_APPLICATION_VOIP) && application != int32(OPUS_APPLICATION_AUDIO) && application != int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) && application != int32(OPUS_APPLICATION_RESTRICTED_SILK) && application != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	size1 = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), Fs, channels, application)
	if size1 <= 0 {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(3)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_encoder_init(tls, st, Fs, channels, application)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	return st
}

func Opus_opus_encoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var ap OpusT_va_list
	var celt_enc, silk_enc, silk_enc1, start, value1, value11, value13, value15, value17, value19, value21, value23, value25, value26, value27, value28, value3, value30, value32, value34, value36, value39, value40, value41, value5, value7, value9 uintptr
	var ret int32
	var value, value10, value12, value14, value16, value18, value2, value20, value22, value24, value29, value31, value33, value35, value37, value38, value4, value6, value8 OpusT_opus_int32
	var _ /* dummy at bp+0 */ OpusT_silk_EncControlStruct
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, celt_enc, ret, silk_enc, silk_enc1, start, value, value1, value10, value11, value12, value13, value14, value15, value16, value17, value18, value19, value2, value20, value21, value22, value23, value24, value25, value26, value27, value28, value29, value3, value30, value31, value32, value33, value34, value35, value36, value37, value38, value39, value4, value40, value41, value5, value6, value7, value8, value9
	celt_enc = libc.UintptrFromInt32(0)
	ret = OPUS_OK
	ap = va
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		celt_enc = st + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fcelt_enc_offset)
	}
	switch request {
	case int32(OPUS_SET_APPLICATION_REQUEST):
		value = libc.VaInt32(&ap)
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_SILK) || (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_CELT) {
			ret = -int32(1)
			break
		}
		if value != int32(OPUS_APPLICATION_VOIP) && value != int32(OPUS_APPLICATION_AUDIO) && value != int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) || !((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Ffirst != 0) && (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != value {
			ret = -int32(1)
			break
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication = value
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fanalysis.Fapplication = value
	case int32(OPUS_GET_APPLICATION_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value1)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication
	case int32(OPUS_SET_BITRATE_REQUEST):
		value2 = libc.VaInt32(&ap)
		if value2 != -int32(1000) && value2 != -int32(1) {
			if value2 <= 0 {
				goto bad_arg
			} else {
				if value2 <= int32(500) {
					value2 = int32(500)
				} else {
					if value2 > libc.Int32FromInt32(750000)*(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels {
						value2 = libc.Int32FromInt32(750000) * (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels
					}
				}
			}
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bitrate_bps = value2
	case int32(OPUS_GET_BITRATE_REQUEST):
		value3 = libc.VaUintptr(&ap)
		if !(value3 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value3)) = user_bitrate_to_bitrate(tls, st, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fprev_framesize, int32(1276))
	case int32(OPUS_SET_FORCE_CHANNELS_REQUEST):
		value4 = libc.VaInt32(&ap)
		if (value4 < int32(1) || value4 > (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels) && value4 != -int32(1000) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fforce_channels = value4
	case int32(OPUS_GET_FORCE_CHANNELS_REQUEST):
		value5 = libc.VaUintptr(&ap)
		if !(value5 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value5)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fforce_channels
	case int32(OPUS_SET_MAX_BANDWIDTH_REQUEST):
		value6 = libc.VaInt32(&ap)
		if value6 < int32(OPUS_BANDWIDTH_NARROWBAND) || value6 > int32(OPUS_BANDWIDTH_FULLBAND) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmax_bandwidth = value6
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmax_bandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(8000)
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmax_bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(12000)
			} else {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(16000)
			}
		}
	case int32(OPUS_GET_MAX_BANDWIDTH_REQUEST):
		value7 = libc.VaUintptr(&ap)
		if !(value7 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value7)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmax_bandwidth
	case int32(OPUS_SET_BANDWIDTH_REQUEST):
		value8 = libc.VaInt32(&ap)
		if (value8 < int32(OPUS_BANDWIDTH_NARROWBAND) || value8 > int32(OPUS_BANDWIDTH_FULLBAND)) && value8 != -int32(1000) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bandwidth = value8
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(8000)
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(12000)
			} else {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(16000)
			}
		}
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		value9 = libc.VaUintptr(&ap)
		if !(value9 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value9)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fbandwidth
	case int32(OPUS_SET_DTX_REQUEST):
		value10 = libc.VaInt32(&ap)
		if value10 < 0 || value10 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_dtx = value10
	case int32(OPUS_GET_DTX_REQUEST):
		value11 = libc.VaUintptr(&ap)
		if !(value11 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value11)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_dtx
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		value12 = libc.VaInt32(&ap)
		if value12 < 0 || value12 > int32(10) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.Fcomplexity = value12
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			_ = value12 == libc.Int32FromInt32(0)
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_COMPLEXITY_REQUEST), libc.VaList(bp+112, value12))
		}
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		value13 = libc.VaUintptr(&ap)
		if !(value13 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value13)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.Fcomplexity
	case int32(OPUS_SET_INBAND_FEC_REQUEST):
		value14 = libc.VaInt32(&ap)
		if value14 < 0 || value14 > int32(2) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Ffec_config = value14
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseInBandFEC = libc.BoolInt32(value14 != 0)
	case int32(OPUS_GET_INBAND_FEC_REQUEST):
		value15 = libc.VaUintptr(&ap)
		if !(value15 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value15)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Ffec_config
	case int32(OPUS_SET_PACKET_LOSS_PERC_REQUEST):
		value16 = libc.VaInt32(&ap)
		if value16 < 0 || value16 > int32(100) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FpacketLossPercentage = value16
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			_ = value16 == libc.Int32FromInt32(0)
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_PACKET_LOSS_PERC_REQUEST), libc.VaList(bp+112, value16))
		}
	case int32(OPUS_GET_PACKET_LOSS_PERC_REQUEST):
		value17 = libc.VaUintptr(&ap)
		if !(value17 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value17)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FpacketLossPercentage
	case int32(OPUS_SET_VBR_REQUEST):
		value18 = libc.VaInt32(&ap)
		if value18 < 0 || value18 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_vbr = value18
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseCBR = int32(1) - value18
	case int32(OPUS_GET_VBR_REQUEST):
		value19 = libc.VaUintptr(&ap)
		if !(value19 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value19)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_vbr
	case int32(OPUS_SET_VOICE_RATIO_REQUEST):
		value20 = libc.VaInt32(&ap)
		if value20 < -int32(1) || value20 > int32(100) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvoice_ratio = value20
	case int32(OPUS_GET_VOICE_RATIO_REQUEST):
		value21 = libc.VaUintptr(&ap)
		if !(value21 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value21)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvoice_ratio
	case int32(OPUS_SET_VBR_CONSTRAINT_REQUEST):
		value22 = libc.VaInt32(&ap)
		if value22 < 0 || value22 > int32(1) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvbr_constraint = value22
	case int32(OPUS_GET_VBR_CONSTRAINT_REQUEST):
		value23 = libc.VaUintptr(&ap)
		if !(value23 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value23)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvbr_constraint
	case int32(OPUS_SET_SIGNAL_REQUEST):
		value24 = libc.VaInt32(&ap)
		if value24 != -int32(1000) && value24 != int32(OPUS_SIGNAL_VOICE) && value24 != int32(OPUS_SIGNAL_MUSIC) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsignal_type = value24
	case int32(OPUS_GET_SIGNAL_REQUEST):
		value25 = libc.VaUintptr(&ap)
		if !(value25 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value25)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsignal_type
	case int32(OPUS_GET_LOOKAHEAD_REQUEST):
		value26 = libc.VaUintptr(&ap)
		if !(value26 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value26)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs / int32(400)
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
			*(*OpusT_opus_int32)(unsafe.Pointer(value26)) += (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fdelay_compensation
		}
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		value27 = libc.VaUintptr(&ap)
		if !(value27 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value27)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value28 = libc.VaUintptr(&ap)
		if !(value28 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value28)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FrangeFinal
	case int32(OPUS_SET_LSB_DEPTH_REQUEST):
		value29 = libc.VaInt32(&ap)
		if value29 < int32(8) || value29 > int32(24) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Flsb_depth = value29
	case int32(OPUS_GET_LSB_DEPTH_REQUEST):
		value30 = libc.VaUintptr(&ap)
		if !(value30 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value30)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Flsb_depth
	case int32(OPUS_SET_EXPERT_FRAME_DURATION_REQUEST):
		value31 = libc.VaInt32(&ap)
		if value31 != int32(OPUS_FRAMESIZE_ARG) && value31 != int32(OPUS_FRAMESIZE_2_5_MS) && value31 != int32(OPUS_FRAMESIZE_5_MS) && value31 != int32(OPUS_FRAMESIZE_10_MS) && value31 != int32(OPUS_FRAMESIZE_20_MS) && value31 != int32(OPUS_FRAMESIZE_40_MS) && value31 != int32(OPUS_FRAMESIZE_60_MS) && value31 != int32(OPUS_FRAMESIZE_80_MS) && value31 != int32(OPUS_FRAMESIZE_100_MS) && value31 != int32(OPUS_FRAMESIZE_120_MS) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_duration = value31
	case int32(OPUS_GET_EXPERT_FRAME_DURATION_REQUEST):
		value32 = libc.VaUintptr(&ap)
		if !(value32 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value32)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_duration
	case int32(OPUS_SET_PREDICTION_DISABLED_REQUEST):
		value33 = libc.VaInt32(&ap)
		if value33 > int32(1) || value33 < 0 {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FreducedDependency = value33
	case int32(OPUS_GET_PREDICTION_DISABLED_REQUEST):
		value34 = libc.VaUintptr(&ap)
		if !(value34 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value34)) = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FreducedDependency
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		value35 = libc.VaInt32(&ap)
		if value35 < 0 || value35 > int32(1) {
			goto bad_arg
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			_ = value35 == libc.Int32FromInt32(0)
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+112, value35))
		}
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		value36 = libc.VaUintptr(&ap)
		if !(value36 != 0) {
			goto bad_arg
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST), libc.VaList(bp+112, value36+uintptr((int64(value36)-int64(value36))/4)*4))
		} else {
			*(*OpusT_opus_int32)(unsafe.Pointer(value36)) = 0
		}
	case int32(OPUS_RESET_STATE):
		silk_enc = st + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset)
		Opus_tonality_analysis_reset(tls, st+196)
		start = st + 14200
		libc.Xmemset(tls, start, 0, libc.Uint64FromInt64(int64((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset)-(int64(start)-int64(st)))*uint64(1))
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_RESET_STATE), 0)
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
			Opus_silk_InitEncoder(tls, silk_enc, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Farch, bp)
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fstream_channels = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fhybrid_stereo_width_Q14 = int16(libc.Int32FromInt32(1) << libc.Int32FromInt32(14))
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fprev_HB_gain = libc.Float32FromFloat32(1)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Ffirst = int32(1)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmode = int32(MODE_HYBRID)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fbandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_HP_smth2_Q15 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ))) << libc.Int32FromInt32(8))
	case int32(OPUS_SET_FORCE_MODE_REQUEST):
		value37 = libc.VaInt32(&ap)
		if (value37 < int32(MODE_SILK_ONLY) || value37 > int32(MODE_CELT_ONLY)) && value37 != -int32(1000) {
			goto bad_arg
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_forced_mode = value37
	case int32(OPUS_SET_LFE_REQUEST):
		value38 = libc.VaInt32(&ap)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Flfe = value38
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			_ = value38 == libc.Int32FromInt32(0)
			ret = Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_LFE_REQUEST), libc.VaList(bp+112, value38))
		}
	case int32(OPUS_SET_ENERGY_MASK_REQUEST):
		value39 = libc.VaUintptr(&ap)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fenergy_masking = value39
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			ret = Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_ENERGY_MASK_REQUEST), libc.VaList(bp+112, value39+uintptr((int64(value39)-int64(value39))/4)*4))
		}
	case int32(OPUS_GET_IN_DTX_REQUEST):
		value40 = libc.VaUintptr(&ap)
		if !(value40 != 0) {
			goto bad_arg
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseDTX != 0 && ((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fprev_mode == int32(MODE_SILK_ONLY) || (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fprev_mode == int32(MODE_HYBRID)) {
			/* DTX determined by Silk. */
			silk_enc1 = st + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset)
			*(*OpusT_opus_int32)(unsafe.Pointer(value40)) = libc.BoolInt32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(silk_enc1 + 88))).FsCmn.FnoSpeechCounter >= int32(NB_SPEECH_FRAMES_BEFORE_DTX))
			/* Stereo: check second channel unless only the middle channel was encoded. */
			if *(*OpusT_opus_int32)(unsafe.Pointer(value40)) == int32(1) && (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FnChannelsInternal == int32(2) && (*OpusT_silk_encoder)(unsafe.Pointer(silk_enc1)).Fprev_decode_only_middle == 0 {
				*(*OpusT_opus_int32)(unsafe.Pointer(value40)) = libc.BoolInt32((*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(silk_enc1 + 88 + 1*10184))).FsCmn.FnoSpeechCounter >= int32(NB_SPEECH_FRAMES_BEFORE_DTX))
			}
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_dtx != 0 {
				/* DTX determined by Opus. */
				*(*OpusT_opus_int32)(unsafe.Pointer(value40)) = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fnb_no_activity_ms_Q1 >= libc.Int32FromInt32(NB_SPEECH_FRAMES_BEFORE_DTX)*libc.Int32FromInt32(20)*libc.Int32FromInt32(2))
			} else {
				*(*OpusT_opus_int32)(unsafe.Pointer(value40)) = 0
			}
		}
	case int32(CELT_GET_MODE_REQUEST):
		value41 = libc.VaUintptr(&ap)
		if !(value41 != 0) {
			goto bad_arg
		}
		if !(celt_enc != libc.UintptrFromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+2360, __ccgo_ts+2160, int32(3346))
		}
		ret = Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+112, value41+uintptr((int64(value41)-int64(value41))/8)*8))
	default:
		/* fprintf(stderr, "unknown opus_encoder_ctl() request: %d", request);*/
		ret = -int32(5)
		break
	}
	_ = ap
	return ret
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
}

func Opus_opus_encoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

const CELT_SIG_SCALE2 = "32768.f"
const EPSILON2 = "1e-15f"
const Q15ONE2 = "1.0f"
const VERY_SMALL2 = "1e-30f"

var trim_icdf3 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf3 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf3 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

// C documentation
//
//	/* Given an extension payload (i.e., excluding the initial ID byte), advance
//	    data to the next extension and return the length of the remaining
//	    extensions.
//	   N.B., a "Repeat These Extensions" extension (ID==2) does not advance past
//	    the repeated extension payloads.
//	   That requires higher-level logic. */

func Opus_opus_encoder_get_size(tls *libc.TLS, channels int32) (r int32) {
	var ret int32
	_ = ret
	ret = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), int32(48000), channels, int32(OPUS_APPLICATION_AUDIO))
	if ret < 0 {
		return 0
	} else {
		return ret
	}
	return r
}

func Opus_opus_encoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, application int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var base_size, celtEncSizeBytes, err, ret, tot_size, v1 int32
	var celt_enc, silk_enc uintptr
	var _ /* silkEncSizeBytes at bp+0 */ int32
	_, _, _, _, _, _, _, _, _ = alignment, base_size, celtEncSizeBytes, celt_enc, err, ret, silk_enc, tot_size, v1
	silk_enc = libc.UintptrFromInt32(0)
	celt_enc = libc.UintptrFromInt32(0)
	celtEncSizeBytes = 0
	if Fs != int32(48000) && Fs != int32(24000) && Fs != int32(16000) && Fs != int32(12000) && Fs != int32(8000) || channels != int32(1) && channels != int32(2) || application != int32(OPUS_APPLICATION_VOIP) && application != int32(OPUS_APPLICATION_AUDIO) && application != int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) && application != int32(OPUS_APPLICATION_RESTRICTED_SILK) && application != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		return -int32(1)
	}
	/* Create SILK encoder */
	ret = Opus_silk_Get_Encoder_Size(tls, bp, channels)
	if ret != 0 {
		return -int32(1)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	*(*int32)(unsafe.Pointer(bp)) = v1
	if application == int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		*(*int32)(unsafe.Pointer(bp)) = 0
	}
	if application != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		celtEncSizeBytes = Opus_celt_encoder_get_size(tls, channels)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(18152)) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	base_size = v1
	if application == int32(OPUS_APPLICATION_RESTRICTED_SILK) || application == int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(libc.Uint64FromInt32(base_size)-libc.Uint64FromInt32(libc.Int32FromInt32(MAX_ENCODER_BUFFER)*libc.Int32FromInt32(2))*libc.Uint64FromInt64(4))) + alignment - uint32(1)) / alignment * alignment)
		goto _6
	_6:
		base_size = v1
	} else {
		if channels == int32(1) {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(libc.Uint64FromInt32(base_size)-libc.Uint64FromInt32(MAX_ENCODER_BUFFER)*libc.Uint64FromInt64(4))) + alignment - uint32(1)) / alignment * alignment)
			goto _8
		_8:
			base_size = v1
		}
	}
	tot_size = base_size + *(*int32)(unsafe.Pointer(bp)) + celtEncSizeBytes
	if st == libc.UintptrFromInt32(0) {
		return tot_size
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(tot_size)*uint64(1))
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset = base_size
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fcelt_enc_offset = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset + *(*int32)(unsafe.Pointer(bp))
	v1 = channels
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs = Fs
	v1 = 0
	goto _11
_11:
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Farch = v1
	if application != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		silk_enc = st + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_enc_offset)
		ret = Opus_silk_InitEncoder(tls, silk_enc, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Farch, st+8)
	}
	if ret != 0 {
		return -int32(3)
	}
	/* default SILK parameters */
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FnChannelsAPI = channels
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FnChannelsInternal = channels
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FAPI_sampleRate = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FmaxInternalSampleRate = int32(16000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FminInternalSampleRate = int32(8000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FdesiredInternalSampleRate = int32(16000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FpayloadSize_ms = int32(20)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FbitRate = int32(25000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FpacketLossPercentage = 0
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.Fcomplexity = int32(9)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseInBandFEC = 0
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseDRED = 0
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseDTX = 0
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FuseCBR = 0
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.FreducedDependency = 0
	/* Create CELT encoder */
	/* Initialize CELT encoder */
	if application != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		celt_enc = st + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fcelt_enc_offset)
		err = Opus_celt_encoder_init(tls, celt_enc, Fs, channels, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Farch)
		if err != OPUS_OK {
			return -int32(3)
		}
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_SIGNALLING_REQUEST), libc.VaList(bp+16, libc.Int32FromInt32(0)))
		_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.Fcomplexity == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_COMPLEXITY_REQUEST), libc.VaList(bp+16, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsilk_mode.Fcomplexity))
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuse_vbr = int32(1)
	/* Makes constrained VBR the default (safer for real-time use) */
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvbr_constraint = int32(1)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bitrate_bps = -int32(1000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fbitrate_bps = int32(3000) + Fs*channels
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication = application
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fsignal_type = -int32(1000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bandwidth = -int32(1000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmax_bandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fforce_channels = -int32(1000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_forced_mode = -int32(1000)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvoice_ratio = -int32(1)
	if application != int32(OPUS_APPLICATION_RESTRICTED_CELT) && application != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fencoder_buffer = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs / int32(100)
	} else {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fencoder_buffer = 0
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Flsb_depth = int32(24)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_duration = int32(OPUS_FRAMESIZE_ARG)
	/* Delay compensation of 4 ms (2.5 ms for SILK's extra look-ahead
	   + 1.5 ms for SILK resamplers and stereo prediction) */
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fdelay_compensation = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs / int32(250)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fhybrid_stereo_width_Q14 = int16(libc.Int32FromInt32(1) << libc.Int32FromInt32(14))
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fprev_HB_gain = libc.Float32FromFloat32(1)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fvariable_HP_smth2_Q15 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ))) << libc.Int32FromInt32(8))
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Ffirst = int32(1)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fmode = int32(MODE_HYBRID)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fbandwidth = int32(OPUS_BANDWIDTH_FULLBAND)
	Opus_tonality_analysis_init(tls, st+196, (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs)
	(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fanalysis.Fapplication = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fapplication
	return OPUS_OK
}

func Opus_opus_extension_iterator_find(tls *libc.TLS, iter uintptr, ext uintptr, id int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ret int32
	var _ /* curr_ext at bp+0 */ OpusT_opus_extension_data
	_ = ret
	for {
		ret = Opus_opus_extension_iterator_next(tls, iter, bp)
		if ret <= 0 {
			return ret
		}
		if (*(*OpusT_opus_extension_data)(unsafe.Pointer(bp))).Fid == id {
			*(*OpusT_opus_extension_data)(unsafe.Pointer(ext)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp))
			return ret
		}
		goto _1
	_1:
	}
	return r
}

// C documentation
//
//	/* Count the number of extensions, excluding real padding, separators, and
//	    repeat indicators, but including the repeated extensions. */

func Opus_opus_extension_iterator_init(tls *libc.TLS, iter uintptr, data uintptr, len1 OpusT_opus_int32, nb_frames OpusT_opus_int32) {
	var v1, v2 uintptr
	var v4 OpusT_opus_int32
	var v6 int32
	_, _, _, _ = v1, v2, v4, v6
	if !(len1 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2395, __ccgo_ts+2422, int32(122))
	}
	if !(data != libc.UintptrFromInt32(0) || len1 == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2442, __ccgo_ts+2422, int32(123))
	}
	if !(nb_frames >= 0 && nb_frames <= int32(48)) {
		Opus_celt_fatal(tls, __ccgo_ts+2485, __ccgo_ts+2422, int32(124))
	}
	v2 = data
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata = v2
	v1 = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = v1
	v1 = libc.UintptrFromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = v1
	v4 = len1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1 = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = v4
	v4 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len = v4
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
	v6 = nb_frames
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max = v6
	v6 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = v6
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l = uint8(0)
}

// C documentation
//
//	/* Reset the iterator so it can start iterating again from the first
//	    extension. */

func Opus_opus_extension_iterator_next(tls *libc.TLS, iter uintptr, ext uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var L, id, ret, ret1 int32
	var curr_data0 uintptr
	var _ /* header_size at bp+0 */ OpusT_opus_int32
	_, _, _, _, _ = L, curr_data0, id, ret, ret1
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
		return -int32(4)
	}
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame > 0 {
		/* We are in the process of repeating some extensions. */
		ret = opus_extension_iterator_next_repeat(tls, iter, ext)
		if ret != 0 {
			return ret
		}
	}
	/* Checking this here allows opus_extension_iterator_set_frame_max() to be
	   called at any point. */
	if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
		return 0
	}
	for (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len > 0 {
		curr_data0 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
		id = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0))) >> int32(1)
		L = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0))) & int32(1)
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = skip_extension(tls, iter+8, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len, bp)
		if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
			return -int32(4)
		}
		if !(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data)-int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata) == int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1-(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len)) {
			Opus_celt_fatal(tls, __ccgo_ts+2615, __ccgo_ts+2422, int32(255))
		}
		if id == int32(1) {
			if L == 0 {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + 1
			} else {
				/* A frame increment of 0 is a no-op. */
				if !(*(*uint8)(unsafe.Pointer(curr_data0 + 1)) != 0) {
					continue
				}
				*(*int32)(unsafe.Pointer(iter + 68)) += libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(curr_data0 + 1)))
			}
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = -int32(1)
				return -int32(4)
			}
			/* If we were asked to stop at frame_max, skip extensions for later
			   frames. */
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = 0
			}
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
		} else {
			if id == int32(2) {
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l = libc.Uint8FromInt32(L)
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + int32(1)
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len = int32(int64(curr_data0) - int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data))
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data
				(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len
				ret1 = opus_extension_iterator_next_repeat(tls, iter, ext)
				if ret1 != 0 {
					return ret1
				}
			} else {
				if id > int32(2) {
					/* Update the location of the last long extension.
					   This lets us know when we need to modify the last L flag if we
					    repeat these extensions with L=0. */
					if id >= int32(32) {
						(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
						(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
					} else {
						*(*OpusT_opus_int32)(unsafe.Pointer(iter + 56)) += L
					}
					if ext != libc.UintptrFromInt32(0) {
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid = id
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fframe = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata = curr_data0 + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp)))
						(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 = int32(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data) - int64(curr_data0) - int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp))))
					}
					return int32(1)
				}
			}
		}
	}
	return 0
}

func Opus_opus_extension_iterator_reset(tls *libc.TLS, iter uintptr) {
	var v1 uintptr
	var v2 int32
	_, _ = v1, v2
	v1 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = v1
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1
	v2 = libc.Int32FromInt32(0)
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = v2
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len = 0
}

// C documentation
//
//	/* Tell the iterator not to return any extensions for frames of index
//	    frame_max or larger.
//	   This can allow it to stop iterating early if these extensions are not
//	    needed. */

func Opus_opus_extension_iterator_set_frame_max(tls *libc.TLS, iter uintptr, frame_max int32) {
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max = frame_max
}

// C documentation
//
//	/* Return the next repeated extension.
//	   The return value is non-zero if one is found, negative on error, or 0 if we
//	    have finished repeating extensions. */

func Opus_opus_fft_c(tls *libc.TLS, st uintptr, fin uintptr, fout uintptr) {
	var i int32
	var scale OpusT_celt_coef
	var x OpusT_kiss_fft_cpx
	_, _, _ = i, scale, x
	scale = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fscale
	if !(fin != fout) {
		Opus_celt_fatal(tls, __ccgo_ts+5584, __ccgo_ts+5565, int32(626))
	}
	/* Bit-reverse the input */
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		x = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fin + uintptr(i)*8))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8))).Fr = float32(x.Fr * scale)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8))).Fi = float32(x.Fi * scale)
		goto _1
	_1:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, st, fout)
}

func Opus_opus_fft_impl(tls *libc.TLS, st uintptr, fout uintptr) {
	var L, i, m, m2, p, shift, v1 int32
	var fstride [8]int32
	_, _, _, _, _, _, _, _ = L, fstride, i, m, m2, p, shift, v1
	/* st->shift can be -1 */
	if (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fshift > 0 {
		v1 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fshift
	} else {
		v1 = 0
	}
	shift = v1
	fstride[0] = int32(1)
	L = 0
	for cond := true; cond; cond = m != int32(1) {
		p = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L)*2)))
		m = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L+int32(1))*2)))
		fstride[L+int32(1)] = fstride[L] * p
		L = L + 1
	}
	m = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*L-int32(1))*2)))
	i = L - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		if i != 0 {
			m2 = int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*i-int32(1))*2)))
		} else {
			m2 = int32(1)
		}
		switch int32(*(*OpusT_opus_int16)(unsafe.Pointer(st + 12 + uintptr(int32(2)*i)*2))) {
		case int32(2):
			kf_bfly2(tls, fout, m, fstride[i])
		case int32(4):
			kf_bfly4(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
		case int32(3):
			kf_bfly3(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
		case int32(5):
			kf_bfly5(tls, fout, libc.Uint64FromInt32(fstride[i]<<shift), st, m, fstride[i], m2)
			break
		}
		m = m2
		goto _2
	_2:
		;
		i = i - 1
	}
}

func Opus_opus_get_version_string(tls *libc.TLS) (r uintptr) {
	return __ccgo_ts + 4070
}

const COEF_ONE4 = "1.0f"
const ENCODER_RESET_START = "rng"
const EPSILON5 = 1e-15

type OpusT_OpusCustomEncoder = struct {
	Fmode             uintptr
	Fchannels         int32
	Fstream_channels  int32
	Fforce_intra      int32
	Fclip             int32
	Fdisable_pf       int32
	Fcomplexity       int32
	Fupsample         int32
	Fstart            int32
	Fend              int32
	Fbitrate          OpusT_opus_int32
	Fvbr              int32
	Fsignalling       int32
	Fconstrained_vbr  int32
	Floss_rate        int32
	Flsb_depth        int32
	Flfe              int32
	Fdisable_inv      int32
	Farch             int32
	Frng              OpusT_opus_uint32
	Fspread_decision  int32
	FdelayedIntra     OpusT_opus_val32
	Ftonal_average    int32
	FlastCodedBands   int32
	Fhf_average       int32
	Ftapset_decision  int32
	Fprefilter_period int32
	Fprefilter_gain   OpusT_opus_val16
	Fprefilter_tapset int32
	Fconsec_transient int32
	Fanalysis         OpusT_AnalysisInfo
	Fsilk_info        OpusT_SILKInfo
	Fpreemph_memE     [2]OpusT_opus_val32
	Fpreemph_memD     [2]OpusT_opus_val32
	Fvbr_reservoir    OpusT_opus_int32
	Fvbr_drift        OpusT_opus_int32
	Fvbr_offset       OpusT_opus_int32
	Fvbr_count        OpusT_opus_int32
	Foverlap_max      OpusT_opus_val32
	Fstereo_saving    OpusT_opus_val16
	Fintensity        int32
	Fenergy_mask      uintptr
	Fspec_avg         OpusT_celt_glog
	Fin_mem           [1]OpusT_celt_sig
}

var trim_icdf14 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf14 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf14 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

var log2_x_norm_coeff9 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff9 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/*
  - Encoder state
    @brief Encoder state
*/
type OpusCustomEncoder = struct {
	Fmode             uintptr
	Fchannels         int32
	Fstream_channels  int32
	Fforce_intra      int32
	Fclip             int32
	Fdisable_pf       int32
	Fcomplexity       int32
	Fupsample         int32
	Fstart            int32
	Fend              int32
	Fbitrate          OpusT_opus_int32
	Fvbr              int32
	Fsignalling       int32
	Fconstrained_vbr  int32
	Floss_rate        int32
	Flsb_depth        int32
	Flfe              int32
	Fdisable_inv      int32
	Farch             int32
	Frng              OpusT_opus_uint32
	Fspread_decision  int32
	FdelayedIntra     OpusT_opus_val32
	Ftonal_average    int32
	FlastCodedBands   int32
	Fhf_average       int32
	Ftapset_decision  int32
	Fprefilter_period int32
	Fprefilter_gain   OpusT_opus_val16
	Fprefilter_tapset int32
	Fconsec_transient int32
	Fanalysis         OpusT_AnalysisInfo
	Fsilk_info        OpusT_SILKInfo
	Fpreemph_memE     [2]OpusT_opus_val32
	Fpreemph_memD     [2]OpusT_opus_val32
	Fvbr_reservoir    OpusT_opus_int32
	Fvbr_drift        OpusT_opus_int32
	Fvbr_offset       OpusT_opus_int32
	Fvbr_count        OpusT_opus_int32
	Foverlap_max      OpusT_opus_val32
	Fstereo_saving    OpusT_opus_val16
	Fintensity        int32
	Fenergy_mask      uintptr
	Fspec_avg         OpusT_celt_glog
	Fin_mem           [1]OpusT_celt_sig
}

func Opus_opus_ifft_c(tls *libc.TLS, st uintptr, fin uintptr, fout uintptr) {
	var i int32
	_ = i
	if !(fin != fout) {
		Opus_celt_fatal(tls, __ccgo_ts+5584, __ccgo_ts+5565, int32(641))
	}
	/* Bit-reverse the input */
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fbitrev + uintptr(i)*2)))*8)) = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fin + uintptr(i)*8))
		goto _1
	_1:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi
		goto _2
	_2:
		;
		i = i + 1
	}
	Opus_opus_fft_impl(tls, st, fout)
	i = 0
	for {
		if !(i < (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Fnfft) {
			break
		}
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(fout + uintptr(i)*8))).Fi
		goto _3
	_3:
		;
		i = i + 1
	}
}

const LAPLACE_LOG_MINP = 0
const LAPLACE_NMIN = 16

var log2_x_norm_coeff13 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff13 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* The minimum probability of an energy delta (out of 32768). */
/* The minimum number of guaranteed representable energy deltas (in one
   direction). */

// C documentation
//
//	/* When called, decay is positive and at most 11456. */

func Opus_opus_limit2_checkwithin1_c(tls *libc.TLS, samples uintptr, cnt int32) (r int32) {
	var clippedVal, v2 float32
	var i int32
	_, _, _ = clippedVal, i, v2
	if cnt <= 0 {
		return int32(1)
	}
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		clippedVal = *(*float32)(unsafe.Pointer(samples + uintptr(i)*4))
		if -libc.Float32FromFloat32(2) > clippedVal {
			v2 = -libc.Float32FromFloat32(2)
		} else {
			v2 = clippedVal
		}
		clippedVal = v2
		if libc.Float32FromFloat32(2) < clippedVal {
			v2 = libc.Float32FromFloat32(2)
		} else {
			v2 = clippedVal
		}
		clippedVal = v2
		*(*float32)(unsafe.Pointer(samples + uintptr(i)*4)) = clippedVal
		goto _1
	_1:
		;
		i = i + 1
	}
	/* C implementation can't provide quick hint. Assume it might exceed -1/+1. */
	return 0
}

const CELT_SIG_SCALE10 = "32768.f"

var log2_x_norm_coeff15 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff15 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

// C documentation
//
//	/* Forward MDCT trashes the input array */

func Opus_opus_multistream_decode(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_short), frame_size, decode_fec, int32(OPTIONAL_CLIP), libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decode24(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_int24), frame_size, decode_fec, 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, st, data, len1, pcm, __ccgo_fp(opus_copy_channel_out_float), frame_size, decode_fec, 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_decode_native(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, __ccgo_fp_copy_channel_out OpusT_opus_copy_channel_out_func, frame_size int32, decode_fec int32, soft_clip int32, user_data uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _saved_stack, buf, dec, ptr, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var alignment uint32
	var c, chan1, chan11, coupled_size, do_plc, mono_size, prev, prev1, ret, ret1, s, v31, v56, v75 int32
	var _ /* Fs at bp+0 */ OpusT_opus_int32
	var _ /* packet_offset at bp+4 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, alignment, buf, c, chan1, chan11, coupled_size, dec, do_plc, mono_size, prev, prev1, ptr, ret, ret1, s, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v31, v5, v56, v6, v75, v8
	do_plc = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	validate_ms_decoder(tls, st1)
	if frame_size <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Limit frame_size to avoid excessive stack allocations. */
	if !(Opus_opus_multistream_decoder_ctl(tls, st1, int32(OPUS_GET_SAMPLE_RATE_REQUEST), libc.VaList(bp+16, bp+uintptr((OpusT___predefined_ptrdiff_t(bp)-int64(bp))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+3118, __ccgo_ts+3228, int32(206))
	}
	if frame_size < *(*OpusT_opus_int32)(unsafe.Pointer(bp))/int32(25)*int32(3) {
		v31 = frame_size
	} else {
		v31 = *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / int32(25) * int32(3)
	}
	frame_size = v31
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _35
_35:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _39
_39:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _41
	_41:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _43
_43:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _45
	_45:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _47
_47:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3228, int32(208))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _51
_51:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _55
_55:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v31 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _57
_57:
	ptr = st1 + uintptr(v31)
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	if len1 == 0 {
		do_plc = int32(1)
	}
	if len1 < 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _59
		_59:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _61
	_61:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	if !(do_plc != 0) && len1 < int32(2)*(*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _63
		_63:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _65
	_65:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(4)
	}
	if !(do_plc != 0) {
		ret = opus_multistream_packet_validate(tls, data, len1, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams, *(*OpusT_opus_int32)(unsafe.Pointer(bp)))
		if ret < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _67
			_67:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _69
		_69:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return ret
		} else {
			if ret > frame_size {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _71
				_71:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _73
			_73:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(2)
			}
		}
	}
	s = 0
	for {
		if !(s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams) {
			break
		}
		dec = ptr
		if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v56 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _77
		_77:
			v31 = v56
		} else {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v75 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _79
		_79:
			v31 = v75
		}
		ptr = ptr + uintptr(v31)
		if !(do_plc != 0) && len1 <= 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _81
			_81:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _83
		_83:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)) = 0
		ret1 = Opus_opus_decode_native(tls, dec, data, len1, buf, frame_size, decode_fec, libc.BoolInt32(s != (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1)), bp+4, soft_clip, libc.UintptrFromInt32(0), 0)
		if !(do_plc != 0) {
			data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 4)))
			len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 4))
		}
		if ret1 <= 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _85
			_85:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _87
		_87:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return ret1
		}
		frame_size = ret1
		if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			prev = -int32(1)
			/* Copy "left" audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_left_channel(tls, st1, s, prev)
				chan1 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan1, buf, int32(2), frame_size, user_data)
				prev = chan1
			}
			prev = -int32(1)
			/* Copy "right" audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_right_channel(tls, st1, s, prev)
				chan1 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan1, buf+uintptr(1)*4, int32(2), frame_size, user_data)
				prev = chan1
			}
		} else {
			prev1 = -int32(1)
			/* Copy audio to the channel(s) where it belongs */
			for {
				v31 = Opus_get_mono_channel(tls, st1, s, prev1)
				chan11 = v31
				if !(v31 != -int32(1)) {
					break
				}
				(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan11, buf, int32(1), frame_size, user_data)
				prev1 = chan11
			}
		}
		goto _74
	_74:
		;
		s = s + 1
	}
	/* Handle muted channels */
	c = 0
	for {
		if !(c < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(st1 + 12 + uintptr(c)))) == int32(255) {
			(*(*func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_out})))(tls, pcm, (*OpusT_OpusMSDecoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, c, libc.UintptrFromInt32(0), 0, frame_size, user_data)
		}
		goto _91
	_91:
		;
		c = c + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _93
	_93:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _95
_95:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return frame_size
}

func Opus_opus_multistream_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr, error1 uintptr) (r uintptr) {
	var ret int32
	var st, v1 uintptr
	_, _, _ = ret, st, v1
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_multistream_decoder_get_size(tls, streams, coupled_streams)))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_multistream_decoder_init(tls, st, Fs, channels, streams, coupled_streams, mapping)
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	return st
}

func Opus_opus_multistream_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Opus_opus_multistream_decoder_ctl_va_list(tls, st, request, ap)
	_ = ap
	return ret
}

func Opus_opus_multistream_decoder_ctl_va_list(tls *libc.TLS, st uintptr, request int32, ap OpusT_va_list) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var coupled_size, mono_size, ret, s, s1, s2, s3, v1 int32
	var dec, dec1, dec2, dec3, ptr, value, value1, value2 uintptr
	var stream_id, value3 OpusT_opus_int32
	var _ /* tmp at bp+0 */ OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alignment, coupled_size, dec, dec1, dec2, dec3, mono_size, ptr, ret, s, s1, s2, s3, stream_id, value, value1, value2, value3, v1
	ret = OPUS_OK
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	switch request {
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		fallthrough
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		fallthrough
	case int32(OPUS_GET_GAIN_REQUEST):
		fallthrough
	case int32(OPUS_GET_LAST_PACKET_DURATION_REQUEST):
		fallthrough
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		/* For int32* GET params, just query the first stream */
		value = libc.VaUintptr(&ap)
		dec = ptr
		ret = Opus_opus_decoder_ctl(tls, dec, request, libc.VaList(bp+16, value))
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value1)) = uint32(0)
		s = 0
		for {
			if !(s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec1 = ptr
			if s < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _5
			_5:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _7
			_7:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec1, request, libc.VaList(bp+16, bp))
			if ret != OPUS_OK {
				break
			}
			*(*OpusT_opus_uint32)(unsafe.Pointer(value1)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp))
			goto _3
		_3:
			;
			s = s + 1
		}
	case int32(OPUS_RESET_STATE):
		s1 = 0
		for {
			if !(s1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec2 = ptr
			if s1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _10
			_10:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _12
			_12:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec2, int32(OPUS_RESET_STATE), 0)
			if ret != OPUS_OK {
				break
			}
			goto _8
		_8:
			;
			s1 = s1 + 1
		}
	case int32(OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST):
		stream_id = libc.VaInt32(&ap)
		if stream_id < 0 || stream_id >= (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams {
			goto bad_arg
		}
		value2 = libc.VaUintptr(&ap)
		if !(value2 != 0) {
			goto bad_arg
		}
		s2 = 0
		for {
			if !(s2 < stream_id) {
				break
			}
			if s2 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _15
			_15:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _17
			_17:
				ptr = ptr + uintptr(v1)
			}
			goto _13
		_13:
			;
			s2 = s2 + 1
		}
		*(*uintptr)(unsafe.Pointer(value2)) = ptr
	case int32(OPUS_SET_GAIN_REQUEST):
		fallthrough
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		fallthrough
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		/* This works for int32 params */
		value3 = libc.VaInt32(&ap)
		s3 = 0
		for {
			if !(s3 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			dec3 = ptr
			if s3 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _20
			_20:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _22
			_22:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_decoder_ctl(tls, dec3, request, libc.VaList(bp+16, value3))
			if ret != OPUS_OK {
				break
			}
			goto _18
		_18:
			;
			s3 = s3 + 1
		}
	default:
		ret = -int32(5)
		break
	}
	return ret
	goto bad_arg
bad_arg:
	;
	return -int32(1)
	return r
}

func Opus_opus_multistream_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

const CELT_SIG_SCALE4 = "32768.f"

var trim_icdf7 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf7 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf7 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

func Opus_opus_multistream_decoder_get_size(tls *libc.TLS, nb_streams int32, nb_coupled_streams int32) (r OpusT_opus_int32) {
	var alignment uint32
	var coupled_size, mono_size, v1, v3, v5 int32
	_, _, _, _, _, _ = alignment, coupled_size, mono_size, v1, v3, v5
	if nb_streams < int32(1) || nb_coupled_streams > nb_streams || nb_coupled_streams < 0 {
		return 0
	}
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v5 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
	goto _6
_6:
	return v1 + nb_coupled_streams*v3 + (nb_streams-nb_coupled_streams)*v5
}

func Opus_opus_multistream_decoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr) (r int32) {
	var alignment uint32
	var coupled_size, i1, mono_size, ret, v2 int32
	var ptr uintptr
	_, _, _, _, _, _, _ = alignment, coupled_size, i1, mono_size, ptr, ret, v2
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams {
		return -int32(1)
	}
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_channels = channels
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams = streams
	(*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams = coupled_streams
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_channels) {
			break
		}
		*(*uint8)(unsafe.Pointer(st + 12 + uintptr(i1))) = *(*uint8)(unsafe.Pointer(mapping + uintptr(i1)))
		goto _1
	_1:
		;
		i1 = i1 + 1
	}
	if !(Opus_validate_layout(tls, st) != 0) {
		return -int32(1)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v2 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(268)) + alignment - uint32(1)) / alignment * alignment)
	goto _3
_3:
	ptr = st + uintptr(v2)
	coupled_size = Opus_opus_decoder_get_size(tls, int32(2))
	mono_size = Opus_opus_decoder_get_size(tls, int32(1))
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams) {
			break
		}
		ret = Opus_opus_decoder_init(tls, ptr, Fs, int32(2))
		if ret != OPUS_OK {
			return ret
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v2 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
		goto _6
	_6:
		ptr = ptr + uintptr(v2)
		goto _4
	_4:
		;
		i1 = i1 + 1
	}
	for {
		if !(i1 < (*OpusT_OpusMSDecoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		ret = Opus_opus_decoder_init(tls, ptr, Fs, int32(1))
		if ret != OPUS_OK {
			return ret
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v2 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
		goto _9
	_9:
		ptr = ptr + uintptr(v2)
		goto _7
	_7:
		;
		i1 = i1 + 1
	}
	return OPUS_OK
}

func Opus_opus_multistream_encode(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, st, __ccgo_fp(opus_copy_channel_in_short), pcm, frame_size, data, max_data_bytes, int32(16), __ccgo_fp(Opus_downmix_int), 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_encode24(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, st, __ccgo_fp(opus_copy_channel_in_int24), pcm, frame_size, data, max_data_bytes, int32(MAX_ENCODING_DEPTH), __ccgo_fp(Opus_downmix_int24), 0, libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_encode_float(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, st, __ccgo_fp(opus_copy_channel_in_float), pcm, frame_size, data, max_data_bytes, int32(MAX_ENCODING_DEPTH), __ccgo_fp(Opus_downmix_float), int32(1), libc.UintptrFromInt32(0))
}

func Opus_opus_multistream_encode_native(tls *libc.TLS, st1 uintptr, __ccgo_fp_copy_channel_in OpusT_opus_copy_channel_in_func, pcm uintptr, analysis_frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32, lsb_depth int32, __ccgo_fp_downmix OpusT_downmix_func, float_api int32, user_data uintptr) (r int32) {
	bp := tls.Alloc(10016)
	defer tls.Free(10016)
	var _saved_stack, bandSMR, buf, enc, enc1, mem, preemph_mem, ptr, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var alignment uint32
	var c1, c2, chan1, coupled_size, curr_max, frame_size2, i1, i2, left, len1, mono_size, ret, right, s, tot_size, v27, v85, v90 int32
	var equiv_rate, rate_sum, smallest_packet, v86, v88, v92, v94 OpusT_opus_int32
	var _ /* Fs at bp+0 */ OpusT_opus_int32
	var _ /* bandLogE at bp+9832 */ [42]OpusT_celt_glog
	var _ /* bitrates at bp+8808 */ [256]OpusT_opus_int32
	var _ /* celt_mode at bp+8800 */ uintptr
	var _ /* rp at bp+7672 */ OpusT_OpusRepacketizer
	var _ /* tmp_data at bp+4 */ [7662]uint8
	var _ /* vbr at bp+8792 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, alignment, bandSMR, buf, c1, c2, chan1, coupled_size, curr_max, enc, enc1, equiv_rate, frame_size2, i1, i2, left, len1, mem, mono_size, preemph_mem, ptr, rate_sum, ret, right, s, smallest_packet, st, tot_size, v1, v10, v11, v13, v15, v17, v19, v21, v27, v3, v5, v6, v8, v85, v86, v88, v90, v92, v94
	*(*uintptr)(unsafe.Pointer(bp + 8800)) = libc.UintptrFromInt32(0)
	mem = libc.UintptrFromInt32(0)
	preemph_mem = libc.UintptrFromInt32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) {
		preemph_mem = ms_get_preemph_mem(tls, st1)
		mem = ms_get_window_mem(tls, st1)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v27 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _28
_28:
	ptr = st1 + uintptr(v27)
	Opus_opus_encoder_ctl(tls, ptr, int32(OPUS_GET_SAMPLE_RATE_REQUEST), libc.VaList(bp+10008, bp+uintptr((OpusT___predefined_ptrdiff_t(bp)-int64(bp))/4)*4))
	Opus_opus_encoder_ctl(tls, ptr, int32(OPUS_GET_VBR_REQUEST), libc.VaList(bp+10008, bp+8792+uintptr((OpusT___predefined_ptrdiff_t(bp+8792)-int64(bp+8792))/4)*4))
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		Opus_opus_encoder_ctl(tls, ptr, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+10008, bp+8800+uintptr((OpusT___predefined_ptrdiff_t(bp+8800)-int64(bp+8800))/8)*8))
	}
	frame_size2 = Opus_frame_size_select(tls, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication, analysis_frame_size, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fvariable_duration, *(*OpusT_opus_int32)(unsafe.Pointer(bp)))
	if frame_size2 <= 0 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _30
		_30:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _32
	_32:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Smallest packet the encoder can produce. */
	smallest_packet = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams*int32(2) - int32(1)
	/* 100 ms needs an extra byte per stream for the ToC. */
	if *(*OpusT_opus_int32)(unsafe.Pointer(bp))/frame_size2 == int32(10) {
		smallest_packet = smallest_packet + (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams
	}
	if max_data_bytes < smallest_packet {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _34
		_34:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _36
	_36:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(2)
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _44
_44:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _48
_48:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _52
_52:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3032, int32(905))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _56
_56:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size2) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _60
_60:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(2)*frame_size2)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	coupled_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).FFs, int32(2), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication)
	mono_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).FFs, int32(1), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _68
_68:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _72
_72:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _76
_76:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(21)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3032, int32(909))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _78
	_78:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _80
_80:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(21)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _82
	_82:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _84
_84:
	bandSMR = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(21)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) && (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		Opus_surround_analysis(tls, *(*uintptr)(unsafe.Pointer(bp + 8800)), pcm, bandSMR, mem, preemph_mem, frame_size2, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8800)))).Foverlap, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, *(*OpusT_opus_int32)(unsafe.Pointer(bp)), __ccgo_fp_copy_channel_in, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Farch)
	}
	/* Compute bitrate allocation between streams (this could be a lot better) */
	rate_sum = rate_allocation(tls, st1, bp+8808, frame_size2)
	if !(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 8792)) != 0) {
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps == -int32(1000) {
			v86 = rate_sum * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
			goto _87
		_87:
			if max_data_bytes < (v86+int32(4))/int32(8) {
				v27 = max_data_bytes
			} else {
				v88 = rate_sum * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
				goto _89
			_89:
				v27 = (v88 + int32(4)) / int32(8)
			}
			max_data_bytes = v27
		} else {
			if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps != -int32(1) {
				v86 = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
				goto _93
			_93:
				if smallest_packet > (v86+int32(4))/int32(8) {
					v85 = smallest_packet
				} else {
					v88 = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
					goto _95
				_95:
					v85 = (v88 + int32(4)) / int32(8)
				}
				if max_data_bytes < v85 {
					v27 = max_data_bytes
				} else {
					v92 = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
					goto _98
				_98:
					if smallest_packet > (v92+int32(4))/int32(8) {
						v90 = smallest_packet
					} else {
						v94 = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2)
						goto _100
					_100:
						v90 = (v94 + int32(4)) / int32(8)
					}
					v27 = v90
				}
				max_data_bytes = v27
			}
		}
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v27 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _102
_102:
	ptr = st1 + uintptr(v27)
	s = 0
	for {
		if !(s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams) {
			break
		}
		enc = ptr
		if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v27 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _105
		_105:
			ptr = ptr + uintptr(v27)
		} else {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v27 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _107
		_107:
			ptr = ptr + uintptr(v27)
		}
		_ = (*(*[256]OpusT_opus_int32)(unsafe.Pointer(bp + 8808)))[s] == libc.Int32FromInt32(0)
		Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+10008, (*(*[256]OpusT_opus_int32)(unsafe.Pointer(bp + 8808)))[s]))
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) {
			equiv_rate = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fbitrate_bps
			if frame_size2*int32(50) < *(*OpusT_opus_int32)(unsafe.Pointer(bp)) {
				equiv_rate = equiv_rate - int32(60)*(*(*OpusT_opus_int32)(unsafe.Pointer(bp))/frame_size2-int32(50))*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels
			}
			if equiv_rate > int32(10000)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels {
				_ = libc.Int32FromInt32(OPUS_BANDWIDTH_FULLBAND) == libc.Int32FromInt32(0)
				Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_BANDWIDTH_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(OPUS_BANDWIDTH_FULLBAND)))
			} else {
				if equiv_rate > int32(7000)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels {
					_ = libc.Int32FromInt32(OPUS_BANDWIDTH_SUPERWIDEBAND) == libc.Int32FromInt32(0)
					Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_BANDWIDTH_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(OPUS_BANDWIDTH_SUPERWIDEBAND)))
				} else {
					if equiv_rate > int32(5000)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels {
						_ = libc.Int32FromInt32(OPUS_BANDWIDTH_WIDEBAND) == libc.Int32FromInt32(0)
						Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_BANDWIDTH_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(OPUS_BANDWIDTH_WIDEBAND)))
					} else {
						_ = libc.Int32FromInt32(OPUS_BANDWIDTH_NARROWBAND) == libc.Int32FromInt32(0)
						Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_BANDWIDTH_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(OPUS_BANDWIDTH_NARROWBAND)))
					}
				}
			}
			if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
				/* To preserve the spatial image, force stereo CELT on coupled streams */
				_ = libc.Int32FromInt32(MODE_CELT_ONLY) == libc.Int32FromInt32(0)
				Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_FORCE_MODE_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(MODE_CELT_ONLY)))
				_ = libc.Int32FromInt32(2) == libc.Int32FromInt32(0)
				Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_FORCE_CHANNELS_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(2)))
			}
		} else {
			if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_AMBISONICS) {
				_ = libc.Int32FromInt32(MODE_CELT_ONLY) == libc.Int32FromInt32(0)
				Opus_opus_encoder_ctl(tls, enc, int32(OPUS_SET_FORCE_MODE_REQUEST), libc.VaList(bp+10008, libc.Int32FromInt32(MODE_CELT_ONLY)))
			}
		}
		goto _103
	_103:
		;
		s = s + 1
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v27 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _109
_109:
	ptr = st1 + uintptr(v27)
	/* Counting ToC */
	tot_size = 0
	s = 0
	for {
		if !(s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams) {
			break
		}
		Opus_opus_repacketizer_init(tls, bp+7672)
		enc1 = ptr
		if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_coupled_streams {
			left = Opus_get_left_channel(tls, st1, s, -int32(1))
			right = Opus_get_right_channel(tls, st1, s, -int32(1))
			(*(*func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_in})))(tls, buf, int32(2), pcm, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, left, frame_size2, user_data)
			(*(*func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_in})))(tls, buf+uintptr(1)*4, int32(2), pcm, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, right, frame_size2, user_data)
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v27 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _112
		_112:
			ptr = ptr + uintptr(v27)
			if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) && (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
				i1 = 0
				for {
					if !(i1 < int32(21)) {
						break
					}
					(*(*[42]OpusT_celt_glog)(unsafe.Pointer(bp + 9832)))[i1] = *(*OpusT_celt_glog)(unsafe.Pointer(bandSMR + uintptr(int32(21)*left+i1)*4))
					(*(*[42]OpusT_celt_glog)(unsafe.Pointer(bp + 9832)))[int32(21)+i1] = *(*OpusT_celt_glog)(unsafe.Pointer(bandSMR + uintptr(int32(21)*right+i1)*4))
					goto _113
				_113:
					;
					i1 = i1 + 1
				}
			}
			c1 = left
			c2 = right
		} else {
			chan1 = Opus_get_mono_channel(tls, st1, s, -int32(1))
			(*(*func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_in})))(tls, buf, int32(1), pcm, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, chan1, frame_size2, user_data)
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v27 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _115
		_115:
			ptr = ptr + uintptr(v27)
			if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) && (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
				i2 = 0
				for {
					if !(i2 < int32(21)) {
						break
					}
					(*(*[42]OpusT_celt_glog)(unsafe.Pointer(bp + 9832)))[i2] = *(*OpusT_celt_glog)(unsafe.Pointer(bandSMR + uintptr(int32(21)*chan1+i2)*4))
					goto _116
				_116:
					;
					i2 = i2 + 1
				}
			}
			c1 = chan1
			c2 = -int32(1)
		}
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) && (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			Opus_opus_encoder_ctl(tls, enc1, int32(OPUS_SET_ENERGY_MASK_REQUEST), libc.VaList(bp+10008, bp+9832+uintptr((OpusT___predefined_ptrdiff_t(bp+9832)-int64(bp+9832))/4)*4))
		}
		/* number of bytes left (+Toc) */
		curr_max = max_data_bytes - tot_size
		/* Reserve one byte for the last stream and two for the others */
		if 0 > int32(2)*((*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-s-int32(1))-int32(1) {
			v27 = 0
		} else {
			v27 = int32(2)*((*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-s-int32(1)) - int32(1)
		}
		curr_max = curr_max - v27
		/* For 100 ms, reserve an extra byte per stream for the ToC */
		if *(*OpusT_opus_int32)(unsafe.Pointer(bp))/frame_size2 == int32(10) {
			curr_max = curr_max - ((*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams - s - int32(1))
		}
		if curr_max < libc.Int32FromInt32(6)*libc.Int32FromInt32(1275)+libc.Int32FromInt32(12) {
			v27 = curr_max
		} else {
			v27 = libc.Int32FromInt32(6)*libc.Int32FromInt32(1275) + libc.Int32FromInt32(12)
		}
		curr_max = v27
		/* Repacketizer will add one or two bytes for self-delimited frames */
		if s != (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1) {
			if curr_max > int32(253) {
				v27 = int32(2)
			} else {
				v27 = int32(1)
			}
			curr_max = curr_max - v27
		}
		if !(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 8792)) != 0) && s == (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1) {
			v86 = curr_max * int32(8) * (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2) / int32(6)
			goto _121
		_121:
			_ = v86 == libc.Int32FromInt32(0)
			v88 = curr_max * int32(8) * (int32(6) * *(*OpusT_opus_int32)(unsafe.Pointer(bp)) / frame_size2) / int32(6)
			goto _123
		_123:
			Opus_opus_encoder_ctl(tls, enc1, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+10008, v88))
		}
		len1 = Opus_opus_encode_native(tls, enc1, buf, frame_size2, bp+4, curr_max, lsb_depth, pcm, analysis_frame_size, c1, c2, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_channels, __ccgo_fp_downmix, float_api)
		if len1 < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _125
			_125:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _127
		_127:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return len1
		}
		/* We need to use the repacketizer to add the self-delimiting lengths
		   while taking into account the fact that the encoder can now return
		   more than one frame at a time (e.g. 60 ms CELT-only) */
		ret = Opus_opus_repacketizer_cat(tls, bp+7672, bp+4, len1)
		/* If the opus_repacketizer_cat() fails, then something's seriously wrong
		   with the encoder. */
		if ret != OPUS_OK {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _129
			_129:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _131
		_131:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		len1 = Opus_opus_repacketizer_out_range_impl(tls, bp+7672, 0, Opus_opus_repacketizer_get_nb_frames(tls, bp+7672), data, max_data_bytes-tot_size, libc.BoolInt32(s != (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1)), libc.BoolInt32(!(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 8792)) != 0) && s == (*OpusT_OpusMSEncoder)(unsafe.Pointer(st1)).Flayout.Fnb_streams-int32(1)), libc.UintptrFromInt32(0), 0)
		data = data + uintptr(len1)
		tot_size = tot_size + len1
		goto _110
	_110:
		;
		s = s + 1
	}
	/*printf("\n");*/
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _133
	_133:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _135
_135:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return tot_size
}

func Opus_opus_multistream_encoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr, application int32, error1 uintptr) (r uintptr) {
	var ret int32
	var size1 OpusT_opus_int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams || streams+coupled_streams > channels {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	size1 = Opus_opus_multistream_encoder_init(tls, libc.UintptrFromInt32(0), Fs, channels, streams, coupled_streams, mapping, application)
	if size1 < 0 {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = size1
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_multistream_encoder_init(tls, st, Fs, channels, streams, coupled_streams, mapping, application)
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	return st
}

func Opus_opus_multistream_encoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Opus_opus_multistream_encoder_ctl_va_list(tls, st, request, ap)
	_ = ap
	return ret
}

func Opus_opus_multistream_encoder_ctl_va_list(tls *libc.TLS, st uintptr, request int32, ap OpusT_va_list) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var coupled_size, mono_size, ret, s, s1, s2, s3, s4, v1, v3, v4 int32
	var enc, enc1, enc2, enc3, enc4, ptr, value1, value2, value3, value5, value7 uintptr
	var stream_id, value, value4, value6 OpusT_opus_int32
	var _ /* rate at bp+0 */ OpusT_opus_int32
	var _ /* tmp at bp+4 */ OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alignment, coupled_size, enc, enc1, enc2, enc3, enc4, mono_size, ptr, ret, s, s1, s2, s3, s4, stream_id, value, value1, value2, value3, value4, value5, value6, value7, v1, v3, v4
	ret = OPUS_OK
	coupled_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(2), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	mono_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(1), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	switch request {
	case int32(OPUS_SET_BITRATE_REQUEST):
		value = libc.VaInt32(&ap)
		if value != -int32(1000) && value != -int32(1) {
			if value <= 0 {
				goto bad_arg
			}
			if int32(500)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels > value {
				v3 = int32(500) * (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels
			} else {
				v3 = value
			}
			if int32(750000)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels < v3 {
				v1 = int32(750000) * (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels
			} else {
				if int32(500)*(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels > value {
					v4 = int32(500) * (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels
				} else {
					v4 = value
				}
				v1 = v4
			}
			value = v1
		}
		(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps = value
	case int32(OPUS_GET_BITRATE_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value1)) = 0
		s = 0
		for {
			if !(s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			enc = ptr
			if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _8
			_8:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _10
			_10:
				ptr = ptr + uintptr(v1)
			}
			Opus_opus_encoder_ctl(tls, enc, request, libc.VaList(bp+16, bp))
			*(*OpusT_opus_int32)(unsafe.Pointer(value1)) += *(*OpusT_opus_int32)(unsafe.Pointer(bp))
			goto _6
		_6:
			;
			s = s + 1
		}
	case int32(OPUS_GET_LSB_DEPTH_REQUEST):
		fallthrough
	case int32(OPUS_GET_VBR_REQUEST):
		fallthrough
	case int32(OPUS_GET_APPLICATION_REQUEST):
		fallthrough
	case int32(OPUS_GET_BANDWIDTH_REQUEST):
		fallthrough
	case int32(OPUS_GET_COMPLEXITY_REQUEST):
		fallthrough
	case int32(OPUS_GET_PACKET_LOSS_PERC_REQUEST):
		fallthrough
	case int32(OPUS_GET_DTX_REQUEST):
		fallthrough
	case int32(OPUS_GET_VOICE_RATIO_REQUEST):
		fallthrough
	case int32(OPUS_GET_VBR_CONSTRAINT_REQUEST):
		fallthrough
	case int32(OPUS_GET_SIGNAL_REQUEST):
		fallthrough
	case int32(OPUS_GET_LOOKAHEAD_REQUEST):
		fallthrough
	case int32(OPUS_GET_SAMPLE_RATE_REQUEST):
		fallthrough
	case int32(OPUS_GET_INBAND_FEC_REQUEST):
		fallthrough
	case int32(OPUS_GET_FORCE_CHANNELS_REQUEST):
		fallthrough
	case int32(OPUS_GET_PREDICTION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_GET_QEXT_REQUEST):
		/* For int32* GET params, just query the first stream */
		value2 = libc.VaUintptr(&ap)
		enc1 = ptr
		ret = Opus_opus_encoder_ctl(tls, enc1, request, libc.VaList(bp+16, value2))
	case int32(OPUS_GET_FINAL_RANGE_REQUEST):
		value3 = libc.VaUintptr(&ap)
		if !(value3 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_uint32)(unsafe.Pointer(value3)) = uint32(0)
		s1 = 0
		for {
			if !(s1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			enc2 = ptr
			if s1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _13
			_13:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _15
			_15:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_encoder_ctl(tls, enc2, request, libc.VaList(bp+16, bp+4))
			if ret != OPUS_OK {
				break
			}
			*(*OpusT_opus_uint32)(unsafe.Pointer(value3)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4))
			goto _11
		_11:
			;
			s1 = s1 + 1
		}
	case int32(OPUS_SET_LSB_DEPTH_REQUEST):
		fallthrough
	case int32(OPUS_SET_COMPLEXITY_REQUEST):
		fallthrough
	case int32(OPUS_SET_VBR_REQUEST):
		fallthrough
	case int32(OPUS_SET_VBR_CONSTRAINT_REQUEST):
		fallthrough
	case int32(OPUS_SET_MAX_BANDWIDTH_REQUEST):
		fallthrough
	case int32(OPUS_SET_BANDWIDTH_REQUEST):
		fallthrough
	case int32(OPUS_SET_SIGNAL_REQUEST):
		fallthrough
	case int32(OPUS_SET_APPLICATION_REQUEST):
		fallthrough
	case int32(OPUS_SET_INBAND_FEC_REQUEST):
		fallthrough
	case int32(OPUS_SET_PACKET_LOSS_PERC_REQUEST):
		fallthrough
	case int32(OPUS_SET_DTX_REQUEST):
		fallthrough
	case int32(OPUS_SET_FORCE_MODE_REQUEST):
		fallthrough
	case int32(OPUS_SET_FORCE_CHANNELS_REQUEST):
		fallthrough
	case int32(OPUS_SET_PREDICTION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST):
		fallthrough
	case int32(OPUS_SET_QEXT_REQUEST):
		/* This works for int32 params */
		value4 = libc.VaInt32(&ap)
		s2 = 0
		for {
			if !(s2 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			enc3 = ptr
			if s2 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _18
			_18:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _20
			_20:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_encoder_ctl(tls, enc3, request, libc.VaList(bp+16, value4))
			if ret != OPUS_OK {
				break
			}
			goto _16
		_16:
			;
			s2 = s2 + 1
		}
	case int32(OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST):
		stream_id = libc.VaInt32(&ap)
		if stream_id < 0 || stream_id >= (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams {
			goto bad_arg
		}
		value5 = libc.VaUintptr(&ap)
		if !(value5 != 0) {
			goto bad_arg
		}
		s3 = 0
		for {
			if !(s3 < stream_id) {
				break
			}
			if s3 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _23
			_23:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _25
			_25:
				ptr = ptr + uintptr(v1)
			}
			goto _21
		_21:
			;
			s3 = s3 + 1
		}
		*(*uintptr)(unsafe.Pointer(value5)) = ptr
	case int32(OPUS_SET_EXPERT_FRAME_DURATION_REQUEST):
		value6 = libc.VaInt32(&ap)
		(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fvariable_duration = value6
	case int32(OPUS_GET_EXPERT_FRAME_DURATION_REQUEST):
		value7 = libc.VaUintptr(&ap)
		if !(value7 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value7)) = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fvariable_duration
	case int32(OPUS_RESET_STATE):
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fmapping_type == int32(MAPPING_TYPE_SURROUND) {
			libc.Xmemset(tls, ms_get_preemph_mem(tls, st), 0, libc.Uint64FromInt32((*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels)*uint64(4))
			libc.Xmemset(tls, ms_get_window_mem(tls, st), 0, libc.Uint64FromInt32((*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels*libc.Int32FromInt32(MAX_OVERLAP))*uint64(4))
		}
		s4 = 0
		for {
			if !(s4 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
				break
			}
			enc4 = ptr
			if s4 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
				goto _28
			_28:
				ptr = ptr + uintptr(v1)
			} else {
				alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
				v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
				goto _30
			_30:
				ptr = ptr + uintptr(v1)
			}
			ret = Opus_opus_encoder_ctl(tls, enc4, int32(OPUS_RESET_STATE), 0)
			if ret != OPUS_OK {
				break
			}
			goto _26
		_26:
			;
			s4 = s4 + 1
		}
	default:
		ret = -int32(5)
		break
	}
	return ret
	goto bad_arg
bad_arg:
	;
	return -int32(1)
	return r
}

func Opus_opus_multistream_encoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

var trim_icdf6 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf6 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf6 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

/* DECODER */

func Opus_opus_multistream_encoder_get_size(tls *libc.TLS, nb_streams int32, nb_coupled_streams int32) (r OpusT_opus_int32) {
	var alignment uint32
	var coupled_size, mono_size, v1, v3, v5 int32
	_, _, _, _, _, _ = alignment, coupled_size, mono_size, v1, v3, v5
	if nb_streams < int32(1) || nb_coupled_streams > nb_streams || nb_coupled_streams < 0 {
		return 0
	}
	coupled_size = Opus_opus_encoder_get_size(tls, int32(2))
	mono_size = Opus_opus_encoder_get_size(tls, int32(1))
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v3 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
	goto _4
_4:
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v5 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
	goto _6
_6:
	return v1 + nb_coupled_streams*v3 + (nb_streams-nb_coupled_streams)*v5
}

func Opus_opus_multistream_encoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr, application int32) (r int32) {
	return opus_multistream_encoder_init_impl(tls, st, Fs, channels, streams, coupled_streams, mapping, application, int32(MAPPING_TYPE_NONE))
}

func Opus_opus_multistream_packet_pad(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, new_len OpusT_opus_int32, nb_streams int32) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var amount OpusT_opus_int32
	var count, s int32
	var _ /* packet_offset at bp+100 */ OpusT_opus_int32
	var _ /* size at bp+2 */ [48]OpusT_opus_int16
	var _ /* toc at bp+0 */ uint8
	_, _, _ = amount, count, s
	if len1 < int32(1) {
		return -int32(1)
	}
	if len1 == new_len {
		return OPUS_OK
	} else {
		if len1 > new_len {
			return -int32(1)
		}
	}
	amount = new_len - len1
	/* Seek to last stream */
	s = 0
	for {
		if !(s < nb_streams-int32(1)) {
			break
		}
		if len1 <= 0 {
			return -int32(4)
		}
		count = Opus_opus_packet_parse_impl(tls, data, len1, int32(1), bp, libc.UintptrFromInt32(0), bp+2, libc.UintptrFromInt32(0), bp+100, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
		if count < 0 {
			return count
		}
		data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)))
		len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100))
		goto _1
	_1:
		;
		s = s + 1
	}
	return Opus_opus_packet_pad(tls, data, len1, len1+amount)
}

func Opus_opus_multistream_packet_unpad(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_streams int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(1232)
	defer tls.Free(1232)
	var dst uintptr
	var dst_len, ret OpusT_opus_int32
	var i, s, self_delimited int32
	var _ /* packet_offset at bp+100 */ OpusT_opus_int32
	var _ /* rp at bp+104 */ OpusT_OpusRepacketizer
	var _ /* size at bp+2 */ [48]OpusT_opus_int16
	var _ /* toc at bp+0 */ uint8
	_, _, _, _, _, _ = dst, dst_len, i, ret, s, self_delimited
	if len1 < int32(1) {
		return -int32(1)
	}
	dst = data
	dst_len = 0
	/* Unpad all frames */
	s = 0
	for {
		if !(s < nb_streams) {
			break
		}
		self_delimited = libc.BoolInt32(s != nb_streams-int32(1))
		if len1 <= 0 {
			return -int32(4)
		}
		Opus_opus_repacketizer_init(tls, bp+104)
		ret = Opus_opus_packet_parse_impl(tls, data, len1, self_delimited, bp, libc.UintptrFromInt32(0), bp+2, libc.UintptrFromInt32(0), bp+100, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
		if ret < 0 {
			return ret
		}
		ret = opus_repacketizer_cat_impl(tls, bp+104, data, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)), self_delimited)
		if ret < 0 {
			return ret
		}
		/* Discard all padding and extensions. */
		i = 0
		for {
			if !(i < (*(*OpusT_OpusRepacketizer)(unsafe.Pointer(bp + 104))).Fnb_frames) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 104 + 880 + uintptr(i)*4)) = 0
			*(*uintptr)(unsafe.Pointer(bp + 104 + 496 + uintptr(i)*8)) = libc.UintptrFromInt32(0)
			goto _2
		_2:
			;
			i = i + 1
		}
		ret = Opus_opus_repacketizer_out_range_impl(tls, bp+104, 0, (*(*OpusT_OpusRepacketizer)(unsafe.Pointer(bp + 104))).Fnb_frames, dst, len1, self_delimited, 0, libc.UintptrFromInt32(0), 0)
		if ret < 0 {
			return ret
		} else {
			dst_len = dst_len + ret
		}
		dst = dst + uintptr(ret)
		data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)))
		len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100))
		goto _1
	_1:
		;
		s = s + 1
	}
	return dst_len
}

const OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST = 6001
const OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST = 6005
const OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST = 6003

var log2_x_norm_coeff4 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff4 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf8 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf8 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf8 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusProjectionEncoder = struct {
	Fmixing_matrix_size_in_bytes   OpusT_opus_int32
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

type OpusT_MappingMatrix = struct {
	Frows int32
	Fcols int32
	Fgain int32
}

type OpusProjectionEncoder = struct {
	Fmixing_matrix_size_in_bytes   OpusT_opus_int32
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

func Opus_opus_multistream_surround_encoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, mapping_family int32, streams uintptr, coupled_streams uintptr, mapping uintptr, application int32, error1 uintptr) (r uintptr) {
	var ret int32
	var size1 OpusT_opus_int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	if channels > int32(255) || channels < int32(1) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(1)
		}
		return libc.UintptrFromInt32(0)
	}
	size1 = Opus_opus_multistream_surround_encoder_init(tls, libc.UintptrFromInt32(0), Fs, channels, mapping_family, streams, coupled_streams, mapping, application)
	if size1 < 0 {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = size1
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if st == libc.UintptrFromInt32(0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	ret = Opus_opus_multistream_surround_encoder_init(tls, st, Fs, channels, mapping_family, streams, coupled_streams, mapping, application)
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	return st
}

func Opus_opus_multistream_surround_encoder_get_size(tls *libc.TLS, channels int32, mapping_family int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var size OpusT_opus_int32
	var _ /* nb_coupled_streams at bp+4 */ int32
	var _ /* nb_streams at bp+0 */ int32
	_ = size
	if mapping_family == 0 {
		if channels == int32(1) {
			*(*int32)(unsafe.Pointer(bp)) = int32(1)
			*(*int32)(unsafe.Pointer(bp + 4)) = 0
		} else {
			if channels == int32(2) {
				*(*int32)(unsafe.Pointer(bp)) = int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = int32(1)
			} else {
				return 0
			}
		}
	} else {
		if mapping_family == int32(1) && channels <= int32(8) && channels >= int32(1) {
			*(*int32)(unsafe.Pointer(bp)) = vorbis_mappings[channels-int32(1)].Fnb_streams
			*(*int32)(unsafe.Pointer(bp + 4)) = vorbis_mappings[channels-int32(1)].Fnb_coupled_streams
		} else {
			if mapping_family == int32(255) {
				*(*int32)(unsafe.Pointer(bp)) = channels
				*(*int32)(unsafe.Pointer(bp + 4)) = 0
			} else {
				if mapping_family == int32(2) {
					if !(validate_ambisonics(tls, channels, bp, bp+4) != 0) {
						return 0
					}
				} else {
					return 0
				}
			}
		}
	}
	size = Opus_opus_multistream_encoder_get_size(tls, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	if channels > int32(2) {
		size = libc.Int32FromUint64(uint64(size) + libc.Uint64FromInt32(channels)*(libc.Uint64FromInt32(MAX_OVERLAP)*libc.Uint64FromInt64(4)+libc.Uint64FromInt64(4)))
	}
	return size
}

func Opus_opus_multistream_surround_encoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, mapping_family int32, streams uintptr, coupled_streams uintptr, mapping uintptr, application int32) (r int32) {
	var i, i1, i2, lfe_stream int32
	var mapping_type OpusT_MappingType
	_, _, _, _, _ = i, i1, i2, lfe_stream, mapping_type
	if channels > int32(255) || channels < int32(1) {
		return -int32(1)
	}
	lfe_stream = -int32(1)
	if mapping_family == 0 {
		if channels == int32(1) {
			*(*int32)(unsafe.Pointer(streams)) = int32(1)
			*(*int32)(unsafe.Pointer(coupled_streams)) = 0
			*(*uint8)(unsafe.Pointer(mapping)) = uint8(0)
		} else {
			if channels == int32(2) {
				*(*int32)(unsafe.Pointer(streams)) = int32(1)
				*(*int32)(unsafe.Pointer(coupled_streams)) = int32(1)
				*(*uint8)(unsafe.Pointer(mapping)) = uint8(0)
				*(*uint8)(unsafe.Pointer(mapping + 1)) = uint8(1)
			} else {
				return -int32(5)
			}
		}
	} else {
		if mapping_family == int32(1) && channels <= int32(8) && channels >= int32(1) {
			*(*int32)(unsafe.Pointer(streams)) = vorbis_mappings[channels-int32(1)].Fnb_streams
			*(*int32)(unsafe.Pointer(coupled_streams)) = vorbis_mappings[channels-int32(1)].Fnb_coupled_streams
			i = 0
			for {
				if !(i < channels) {
					break
				}
				*(*uint8)(unsafe.Pointer(mapping + uintptr(i))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&vorbis_mappings)) + uintptr(channels-int32(1))*16 + 8 + uintptr(i)))
				goto _1
			_1:
				;
				i = i + 1
			}
			if channels >= int32(6) {
				lfe_stream = *(*int32)(unsafe.Pointer(streams)) - int32(1)
			}
		} else {
			if mapping_family == int32(255) {
				*(*int32)(unsafe.Pointer(streams)) = channels
				*(*int32)(unsafe.Pointer(coupled_streams)) = 0
				i1 = 0
				for {
					if !(i1 < channels) {
						break
					}
					*(*uint8)(unsafe.Pointer(mapping + uintptr(i1))) = libc.Uint8FromInt32(i1)
					goto _2
				_2:
					;
					i1 = i1 + 1
				}
			} else {
				if mapping_family == int32(2) {
					if !(validate_ambisonics(tls, channels, streams, coupled_streams) != 0) {
						return -int32(1)
					}
					i2 = 0
					for {
						if !(i2 < *(*int32)(unsafe.Pointer(streams))-*(*int32)(unsafe.Pointer(coupled_streams))) {
							break
						}
						*(*uint8)(unsafe.Pointer(mapping + uintptr(i2))) = libc.Uint8FromInt32(i2 + *(*int32)(unsafe.Pointer(coupled_streams))*int32(2))
						goto _3
					_3:
						;
						i2 = i2 + 1
					}
					i2 = 0
					for {
						if !(i2 < *(*int32)(unsafe.Pointer(coupled_streams))*int32(2)) {
							break
						}
						*(*uint8)(unsafe.Pointer(mapping + uintptr(i2+(*(*int32)(unsafe.Pointer(streams))-*(*int32)(unsafe.Pointer(coupled_streams)))))) = libc.Uint8FromInt32(i2)
						goto _4
					_4:
						;
						i2 = i2 + 1
					}
				} else {
					return -int32(5)
				}
			}
		}
	}
	if channels > int32(2) && mapping_family == int32(1) {
		mapping_type = int32(MAPPING_TYPE_SURROUND)
	} else {
		if mapping_family == int32(2) {
			mapping_type = int32(MAPPING_TYPE_AMBISONICS)
		} else {
			mapping_type = int32(MAPPING_TYPE_NONE)
		}
	}
	if st != libc.UintptrFromInt32(0) {
		(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream = lfe_stream
	}
	return opus_multistream_encoder_init_impl(tls, st, Fs, channels, *(*int32)(unsafe.Pointer(streams)), *(*int32)(unsafe.Pointer(coupled_streams)), mapping, application, mapping_type)
}

func Opus_opus_packet_extensions_count(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var count int32
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_ = count
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		if !(Opus_opus_extension_iterator_next(tls, bp, libc.UintptrFromInt32(0)) > 0) {
			break
		}
		goto _1
	_1:
		;
		count = count + 1
	}
	return count
}

// C documentation
//
//	/* Count the number of extensions for each frame, excluding real padding and
//	    separators and repeat indicators, but including the repeated extensions. */

func Opus_opus_packet_extensions_count_ext(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_frame_exts uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count int32
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_ = count
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	libc.Xmemset(tls, nb_frame_exts, 0, libc.Uint64FromInt32(nb_frames)*uint64(4))
	count = 0
	for {
		if !(Opus_opus_extension_iterator_next(tls, bp, bp+80) > 0) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4)) = *(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4)) + 1
		goto _1
	_1:
		;
		count = count + 1
	}
	return count
}

// C documentation
//
//	/* Extract extensions from Opus padding (excluding real padding, separators,
//	    and repeat indicators, but including the repeated extensions) in bitstream
//	    order.
//	   Due to the extension repetition mechanism, extensions are not necessarily
//	    returned in frame order. */

func Opus_opus_packet_extensions_generate(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions OpusT_opus_int32, nb_frames int32, pad int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(192)
	defer tls.Free(192)
	var curr_frame, diff, f, g, g1, j, j1, last, nb_repeated, repeat_count, v3 int32
	var frame_min_idx, frame_repeat_idx [48]OpusT_opus_int32
	var i, last_long_idx, padding, pos, written OpusT_opus_int32
	var _ /* frame_max_idx at bp+0 */ [48]OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = curr_frame, diff, f, frame_min_idx, frame_repeat_idx, g, g1, i, j, j1, last, last_long_idx, nb_repeated, padding, pos, repeat_count, written, v3
	curr_frame = 0
	pos = 0
	written = 0
	if !(len1 >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2395, __ccgo_ts+2422, int32(484))
	}
	if nb_frames > int32(48) {
		return -int32(1)
	}
	/* Do a little work up-front to make this O(nb_extensions) instead of
	   O(nb_extensions*nb_frames) so long as the extensions are in frame
	   order (without requiring that they be in frame order). */
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		frame_min_idx[f] = nb_extensions
		goto _1
	_1:
		;
		f = f + 1
	}
	libc.Xmemset(tls, bp, 0, libc.Uint64FromInt32(nb_frames)*uint64(4))
	i = 0
	for {
		if !(i < nb_extensions) {
			break
		}
		f = (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe
		if f < 0 || f >= nb_frames {
			return -int32(1)
		}
		if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid < int32(3) || (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid > int32(127) {
			return -int32(1)
		}
		if frame_min_idx[f] < i {
			v3 = frame_min_idx[f]
		} else {
			v3 = i
		}
		frame_min_idx[f] = v3
		if (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f] > i+int32(1) {
			v3 = (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]
		} else {
			v3 = i + int32(1)
		}
		(*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f] = v3
		goto _2
	_2:
		;
		i = i + 1
	}
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		frame_repeat_idx[f] = frame_min_idx[f]
		goto _5
	_5:
		;
		f = f + 1
	}
	f = 0
	for {
		if !(f < nb_frames) {
			break
		}
		repeat_count = 0
		last_long_idx = -int32(1)
		if f+int32(1) < nb_frames {
			i = frame_min_idx[f]
			for {
				if !(i < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]) {
					break
				}
				if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe == f {
					/* Test if we can repeat this extension in future frames. */
					g = f + int32(1)
					for {
						if !(g < nb_frames) {
							break
						}
						if frame_repeat_idx[g] >= (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[g] {
							break
						}
						if !((*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fframe == g) {
							Opus_celt_fatal(tls, __ccgo_ts+2928, __ccgo_ts+2422, int32(518))
						}
						if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fid != (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid {
							break
						}
						if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Fid < int32(32) && (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(frame_repeat_idx[g])*24))).Flen1 != (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Flen1 {
							break
						}
						goto _8
					_8:
						;
						g = g + 1
					}
					if g < nb_frames {
						break
					}
					/* We can! */
					/* If this is a long extension, save the index of the last
					   instance, so we can modify its L flag. */
					if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fid >= int32(32) {
						last_long_idx = frame_repeat_idx[nb_frames-int32(1)]
					}
					/* Using the repeat mechanism almost always makes the
					    encoding smaller (or at least no larger).
					   However, there's one case where that might not be true: if
					    the last repeated long extension in the last frame was
					    previously the last extension, but using the repeat
					    mechanism makes that no longer true (because there are other
					    non-repeated extensions in earlier frames that must now be
					    coded after it), and coding its length requires more bytes
					    than the repeat mechanism saves.
					   This can only be true if its length is at least 255 bytes
					    (although sometimes it requires even more).
					   Currently we do not check for that, and just always use the
					    repeat mechanism if we can.
					   See git history for code that does the check. */
					/* Advance the repeat pointers. */
					g = f + int32(1)
					for {
						if !(g < nb_frames) {
							break
						}
						j = frame_repeat_idx[g] + int32(1)
						for {
							if !(j < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[g] && (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(j)*24))).Fframe != g) {
								break
							}
							goto _10
						_10:
							;
							j = j + 1
						}
						frame_repeat_idx[g] = j
						goto _9
					_9:
						;
						g = g + 1
					}
					repeat_count = repeat_count + 1
					/* Point the repeat pointer for this frame to the current
					   extension, so we know when to trigger the repeats. */
					frame_repeat_idx[f] = i
				}
				goto _7
			_7:
				;
				i = i + 1
			}
		}
		i = frame_min_idx[f]
		for {
			if !(i < (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f]) {
				break
			}
			if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(i)*24))).Fframe == f {
				/* Insert separator when needed. */
				if f != curr_frame {
					diff = f - curr_frame
					if len1-pos < int32(2) {
						return -int32(2)
					}
					if diff == int32(1) {
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(0x02)
						}
						pos = pos + 1
					} else {
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(0x03)
						}
						pos = pos + 1
						if data != 0 {
							*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32(diff)
						}
						pos = pos + 1
					}
					curr_frame = f
				}
				pos = write_extension(tls, data, len1, pos, extensions+uintptr(i)*24, libc.BoolInt32(written == nb_extensions-int32(1)))
				if pos < 0 {
					return pos
				}
				written = written + 1
				if repeat_count > 0 && frame_repeat_idx[f] == i {
					/* Add the repeat indicator. */
					nb_repeated = repeat_count * (nb_frames - (f + int32(1)))
					last = libc.BoolInt32(written+nb_repeated == nb_extensions || last_long_idx < 0 && i+int32(1) >= (*(*[48]OpusT_opus_int32)(unsafe.Pointer(bp)))[f])
					if len1-pos < int32(1) {
						return -int32(2)
					}
					if data != 0 {
						*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32(int32(0x04) + libc.BoolInt32(!(last != 0)))
					}
					pos = pos + 1
					g1 = f + int32(1)
					for {
						if !(g1 < nb_frames) {
							break
						}
						j1 = frame_min_idx[g1]
						for {
							if !(j1 < frame_repeat_idx[g1]) {
								break
							}
							if (*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(j1)*24))).Fframe == g1 {
								pos = write_extension_payload(tls, data, len1, pos, extensions+uintptr(j1)*24, libc.BoolInt32(last != 0 && j1 == last_long_idx))
								if pos < 0 {
									return pos
								}
								written = written + 1
							}
							goto _13
						_13:
							;
							j1 = j1 + 1
						}
						frame_min_idx[g1] = j1
						goto _12
					_12:
						;
						g1 = g1 + 1
					}
					if last != 0 {
						curr_frame = curr_frame + 1
					}
				}
			}
			goto _11
		_11:
			;
			i = i + 1
		}
		goto _6
	_6:
		;
		f = f + 1
	}
	if !(written == nb_extensions) {
		Opus_celt_fatal(tls, __ccgo_ts+2989, __ccgo_ts+2422, int32(624))
	}
	/* If we need to pad, just prepend 0x01 bytes. Even better would be to fill the
	   end with zeros, but that requires checking that turning the last extension into
	   an L=1 case still fits. */
	if pad != 0 && pos < len1 {
		padding = len1 - pos
		if data != 0 {
			libc.Xmemmove(tls, data+uintptr(padding), data, libc.Uint64FromInt32(pos)*uint64(1)+libc.Uint64FromInt64(0*(int64(data+uintptr(padding))-int64(data))))
			i = 0
			for {
				if !(i < padding) {
					break
				}
				*(*uint8)(unsafe.Pointer(data + uintptr(i))) = uint8(0x01)
				goto _14
			_14:
				;
				i = i + 1
			}
		}
		pos = pos + padding
	}
	return pos
}

const CELT_SIG_SCALE3 = 32768
const OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST = 5122
const OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST = 5120

type OpusT_OpusMSEncoder = struct {
	Flayout            OpusT_ChannelLayout
	Farch              int32
	Flfe_stream        int32
	Fapplication       int32
	FFs                OpusT_opus_int32
	Fvariable_duration int32
	Fmapping_type      OpusT_MappingType
	Fbitrate_bps       OpusT_opus_int32
}

type OpusT_OpusMSDecoder = struct {
	Flayout OpusT_ChannelLayout
}

var trim_icdf4 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf4 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf4 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

/* Copyright (C) 2007 Jean-Marc Valin

   File: os_support.h
   This is the (tiny) OS abstraction layer. Aside from math.h, this is the
   only place where system headers are allowed.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
   STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
*/

func Opus_opus_packet_extensions_parse(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count, ret int32
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	_, _ = count, ret
	if !(nb_extensions != libc.UintptrFromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2692, __ccgo_ts+2422, int32(365))
	}
	if !(extensions != libc.UintptrFromInt32(0) || *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2732, __ccgo_ts+2422, int32(366))
	}
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		ret = Opus_opus_extension_iterator_next(tls, bp, bp+80)
		if ret <= 0 {
			break
		}
		if count == *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) {
			return -int32(2)
		}
		*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(count)*24)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))
		goto _1
	_1:
		;
		count = count + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) = count
	return ret
}

// C documentation
//
//	/* Extract extensions from Opus padding (excluding real padding, separators,
//	    and repeat indicators, but including the repeated extensions) in frame
//	    order.
//	   nb_frame_exts must be filled with the output of
//	    opus_packet_extensions_count_ext(). */

func Opus_opus_packet_extensions_parse_ext(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, extensions uintptr, nb_extensions uintptr, nb_frame_exts uintptr, nb_frames int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var count, prev_total, ret, total int32
	var idx, v3 OpusT_opus_int32
	var v4 uintptr
	var _ /* ext at bp+80 */ OpusT_opus_extension_data
	var _ /* iter at bp+0 */ OpusT_OpusExtensionIterator
	var _ /* nb_frames_cum at bp+104 */ [49]OpusT_opus_int32
	_, _, _, _, _, _, _ = count, idx, prev_total, ret, total, v3, v4
	if !(nb_extensions != libc.UintptrFromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2692, __ccgo_ts+2422, int32(395))
	}
	if !(extensions != libc.UintptrFromInt32(0) || *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) == 0) {
		Opus_celt_fatal(tls, __ccgo_ts+2732, __ccgo_ts+2422, int32(396))
	}
	if !(nb_frames <= libc.Int32FromInt32(48)) {
		Opus_celt_fatal(tls, __ccgo_ts+2792, __ccgo_ts+2422, int32(397))
	}
	/* Convert the frame extension count array to a cumulative sum. */
	prev_total = 0
	count = 0
	for {
		if !(count < nb_frames) {
			break
		}
		total = *(*OpusT_opus_int32)(unsafe.Pointer(nb_frame_exts + uintptr(count)*4)) + prev_total
		(*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[count] = prev_total
		prev_total = total
		goto _1
	_1:
		;
		count = count + 1
	}
	(*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[count] = prev_total
	Opus_opus_extension_iterator_init(tls, bp, data, len1, nb_frames)
	count = 0
	for {
		ret = Opus_opus_extension_iterator_next(tls, bp, bp+80)
		if ret <= 0 {
			break
		}
		v4 = bp + 104 + uintptr((*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe)*4
		v3 = *(*OpusT_opus_int32)(unsafe.Pointer(v4))
		*(*OpusT_opus_int32)(unsafe.Pointer(v4)) = *(*OpusT_opus_int32)(unsafe.Pointer(v4)) + 1
		idx = v3
		if idx >= *(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) {
			return -int32(2)
		}
		if !(idx < (*(*[49]OpusT_opus_int32)(unsafe.Pointer(bp + 104)))[(*(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))).Fframe+int32(1)]) {
			Opus_celt_fatal(tls, __ccgo_ts+2826, __ccgo_ts+2422, int32(416))
		}
		*(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(idx)*24)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(bp + 80))
		goto _2
	_2:
		;
		count = count + 1
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(nb_extensions)) = count
	return ret
}

func Opus_opus_packet_get_bandwidth(tls *libc.TLS, data uintptr) (r int32) {
	var bandwidth, v1 int32
	_, _ = bandwidth, v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		bandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))>>int32(5)&int32(0x3)
		if bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
			bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
		}
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x10) != 0 {
				v1 = int32(OPUS_BANDWIDTH_FULLBAND)
			} else {
				v1 = int32(OPUS_BANDWIDTH_SUPERWIDEBAND)
			}
			bandwidth = v1
		} else {
			bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))>>int32(5)&int32(0x3)
		}
	}
	return bandwidth
}

func Opus_opus_packet_get_nb_channels(tls *libc.TLS, data uintptr) (r int32) {
	var v1 int32
	_ = v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x4) != 0 {
		v1 = int32(2)
	} else {
		v1 = int32(1)
	}
	return v1
}

func Opus_opus_packet_get_nb_frames(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	var count int32
	_ = count
	if len1 < int32(1) {
		return -int32(1)
	}
	count = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(packet))) & int32(0x3)
	if count == 0 {
		return int32(1)
	} else {
		if count != int32(3) {
			return int32(2)
		} else {
			if len1 < int32(2) {
				return -int32(4)
			} else {
				return libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(packet + 1))) & int32(0x3F)
			}
		}
	}
	return r
}

func Opus_opus_packet_get_nb_samples(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32, Fs OpusT_opus_int32) (r int32) {
	var count, samples int32
	_, _ = count, samples
	count = Opus_opus_packet_get_nb_frames(tls, packet, len1)
	if count < 0 {
		return count
	}
	samples = count * Opus_opus_packet_get_samples_per_frame(tls, packet, Fs)
	/* Can't have more than 120 ms */
	if samples*int32(25) > Fs*int32(3) {
		return -int32(4)
	} else {
		return samples
	}
	return r
}

func Opus_opus_packet_get_samples_per_frame(tls *libc.TLS, data uintptr, Fs OpusT_opus_int32) (r int32) {
	var audiosize, v1 int32
	_, _ = audiosize, v1
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		audiosize = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) >> int32(3) & int32(0x3)
		audiosize = Fs << audiosize / int32(400)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x08) != 0 {
				v1 = Fs / int32(50)
			} else {
				v1 = Fs / int32(100)
			}
			audiosize = v1
		} else {
			audiosize = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) >> int32(3) & int32(0x3)
			if audiosize == int32(3) {
				audiosize = Fs * int32(60) / int32(1000)
			} else {
				audiosize = Fs << audiosize / int32(100)
			}
		}
	}
	return audiosize
}

func Opus_opus_packet_has_lbrr(tls *libc.TLS, packet uintptr, len1 OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(480)
	defer tls.Free(480)
	var lbrr, nb_frames, packet_frame_size, packet_mode, packet_stream_channels, ret int32
	var _ /* frames at bp+0 */ [48]uintptr
	var _ /* size at bp+384 */ [48]OpusT_opus_int16
	_, _, _, _, _, _ = lbrr, nb_frames, packet_frame_size, packet_mode, packet_stream_channels, ret
	nb_frames = int32(1)
	packet_mode = opus_packet_get_mode(tls, packet)
	if packet_mode == int32(MODE_CELT_ONLY) {
		return 0
	}
	packet_frame_size = Opus_opus_packet_get_samples_per_frame(tls, packet, int32(48000))
	if packet_frame_size > int32(960) {
		nb_frames = packet_frame_size / int32(960)
	}
	packet_stream_channels = Opus_opus_packet_get_nb_channels(tls, packet)
	ret = Opus_opus_packet_parse(tls, packet, len1, libc.UintptrFromInt32(0), bp, bp+384, libc.UintptrFromInt32(0))
	if ret <= 0 {
		return ret
	}
	if int32((*(*[48]OpusT_opus_int16)(unsafe.Pointer(bp + 384)))[0]) == 0 {
		return 0
	}
	lbrr = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*(*[48]uintptr)(unsafe.Pointer(bp)))[0]))) >> (int32(7) - nb_frames) & int32(0x1)
	if packet_stream_channels == int32(2) {
		lbrr = libc.BoolInt32(lbrr != 0 || libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*(*[48]uintptr)(unsafe.Pointer(bp)))[0])))>>(int32(6)-int32(2)*nb_frames)&int32(0x1) != 0)
	}
	return lbrr
}

func Opus_opus_packet_pad(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, new_len OpusT_opus_int32) (r int32) {
	var _saved_stack, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var ret OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, ret, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	ret = Opus_opus_packet_pad_impl(tls, data, len1, new_len, int32(1), libc.UintptrFromInt32(0), 0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _30
_30:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	if ret > 0 {
		return OPUS_OK
	} else {
		return ret
	}
	return r
}

func Opus_opus_packet_pad_impl(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, new_len OpusT_opus_int32, pad int32, extensions uintptr, nb_extensions int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(1120)
	defer tls.Free(1120)
	var _saved_stack, copy1, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var ret OpusT_opus_int32
	var _ /* rp at bp+0 */ OpusT_OpusRepacketizer
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, copy1, ret, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if len1 < int32(1) {
		return -int32(1)
	}
	if len1 == new_len {
		return OPUS_OK
	} else {
		if len1 > new_len {
			return -int32(1)
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3262, int32(347))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	copy1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
	Opus_opus_repacketizer_init(tls, bp)
	/* Moving payload to the end of the packet so we can do in-place padding */
	libc.Xmemcpy(tls, copy1, data, libc.Uint64FromInt32(len1)*uint64(1)+libc.Uint64FromInt64(0*(int64(copy1)-int64(data))))
	ret = Opus_opus_repacketizer_cat(tls, bp, copy1, len1)
	if ret != OPUS_OK {
		return ret
	}
	ret = Opus_opus_repacketizer_out_range_impl(tls, bp, 0, (*(*OpusT_OpusRepacketizer)(unsafe.Pointer(bp))).Fnb_frames, data, new_len, 0, pad, extensions, nb_extensions)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_packet_parse(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, out_toc uintptr, frames uintptr, size uintptr, payload_offset uintptr) (r int32) {
	return Opus_opus_packet_parse_impl(tls, data, len1, 0, out_toc, frames, size, payload_offset, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
}

const ALLOC_NONE = 0
const BWE_AFTER_LOSS_Q16 = 63570
const CELT_SIG_SCALE1 = 32768
const CNG_BUF_MASK_MAX = 255
const CNG_GAIN_SMTH_Q16 = 4634
const CNG_GAIN_SMTH_THRESHOLD_Q16 = 46396
const CNG_NLSF_SMTH_Q16 = 16348
const CODE_CONDITIONALLY = 2
const CODE_INDEPENDENTLY = 0
const CODE_INDEPENDENTLY_NO_LTP_SCALING = 1
const COEF_ONE1 = 1
const DECISION_DELAY = 40
const DECODER_NUM_CHANNELS = 2
const DEC_PITCH_BUF_SIZE = 2048
const DTX_ACTIVITY_THRESHOLD = "0.1f"
const ENCODER_NUM_CHANNELS = 2
const FLAG_DECODE_LBRR = 2
const FLAG_DECODE_NORMAL = 0
const FLAG_PACKET_LOST = 1
const HARM_SHAPE_FIR_TAPS = 3
const LA_PITCH_MS = 2
const LA_SHAPE_MS = 5
const LBRR_MB_MIN_RATE_BPS = 14000
const LBRR_NB_MIN_RATE_BPS = 12000
const LBRR_WB_MIN_RATE_BPS = 16000
const LOG2_SHELL_CODEC_FRAME_LENGTH = 4
const LSF_COS_TAB_SZ_FIX = 128
const LTP_BUF_LENGTH = 512
const LTP_MEM_LENGTH_MS = 20
const LTP_ORDER = 5
const MAX_API_FS_KHZ = 48
const MAX_CONSECUTIVE_DTX = 20
const MAX_DELTA_GAIN_QUANT = 36
const MAX_DEL_DEC_STATES = 4
const MAX_FIND_PITCH_LPC_ORDER = 16
const MAX_FRAMES_PER_PACKET = 3
const MAX_FS_KHZ = 16
const MAX_LPC_ORDER = 16
const MAX_LPC_STABILIZE_ITERATIONS = 16
const MAX_MATRIX_SIZE = "MAX_LPC_ORDER"
const MAX_NB_SUBFR = 4
const MAX_PERIOD = 1024
const MAX_PREDICTION_POWER_GAIN = "1e4f"
const MAX_PREDICTION_POWER_GAIN_AFTER_RESET = "1e2f"
const MAX_QGAIN_DB = 88
const MAX_SHAPE_LPC_ORDER = 24
const MAX_TARGET_RATE_BPS = 80000
const MIN_LPC_ORDER = 10
const MIN_QGAIN_DB = 2
const MIN_TARGET_RATE_BPS = 5000
const NB_LTP_CBKS = 3
const NB_SPEECH_FRAMES_BEFORE_DTX = 10
const NLSF_QUANT_DEL_DEC_STATES_LOG2 = 2
const NLSF_QUANT_LEVEL_ADJ = 0.1
const NLSF_QUANT_MAX_AMPLITUDE = 4
const NLSF_QUANT_MAX_AMPLITUDE_EXT = 10
const NLSF_VQ_MAX_VECTORS = 32
const NLSF_W_Q = 2
const NSQ_LPC_BUF_LENGTH = "MAX_LPC_ORDER"
const N_LEVELS_QGAIN = 64
const N_RATE_LEVELS = 10
const OFFSET_UVH_Q10 = 240
const OFFSET_UVL_Q10 = 100
const OFFSET_VH_Q10 = 100
const OFFSET_VL_Q10 = 32
const OPTIONAL_CLIP = 1
const OPUS_CCGO_PSEUDOSTACK_KEY = 1869641075
const OPUS_DECODER_RESET_START = "stream_channels"
const OPUS_FPRINTF = "void"
const PITCH_EST_MAX_LAG_MS = 18
const PITCH_EST_MIN_LAG_MS = 2
const PTHREAD_ONCE_INIT = 0
const QUANT_LEVEL_ADJUST_Q10 = 80
const RAND_INCREMENT = 907633515
const RAND_MULTIPLIER = 196314165
const SCHED_FIFO = 1
const SCHED_OTHER = 0
const SCHED_RR = 2
const SHELL_CODEC_FRAME_LENGTH = 16
const SILK_DECODER_STATE_RESET_START = "prev_gain_Q16"
const SILK_MAX_FRAMES_PER_PACKET = 3
const SILK_MAX_ORDER_LPC = 24
const SILK_MAX_PULSES = 16
const SILK_NO_ERROR = 0
const SILK_RESAMPLER_MAX_FIR_ORDER = 36
const SILK_RESAMPLER_MAX_IIR_ORDER = 6
const STEREO_INTERP_LEN_MS = 8
const STEREO_QUANT_SUB_STEPS = 5
const STEREO_QUANT_TAB_SIZE = 16
const STEREO_RATIO_SMOOTH_COEF = 0.01
const SUB_FRAME_LENGTH_MS = 5
const TRANSITION_INT_NUM = 5
const TRANSITION_NA = 2
const TRANSITION_NB = 3
const TRANSITION_TIME_MS = 5120
const TYPE_NO_VOICE_ACTIVITY = 0
const TYPE_UNVOICED = 1
const TYPE_VOICED = 2
const USE_HARM_SHAPING = 1
const VAD_ACTIVITY = 1
const VAD_INTERNAL_SUBFRAMES_LOG2 = 2
const VAD_NEGATIVE_OFFSET_Q5 = 128
const VAD_NOISE_LEVELS_BIAS = 50
const VAD_NOISE_LEVEL_SMOOTH_COEF_Q16 = 1024
const VAD_NO_ACTIVITY = 0
const VAD_N_BANDS = 4
const VAD_SNR_FACTOR_Q16 = 45000
const VAD_SNR_SMOOTH_COEF_Q18 = 4096
const _BITS_CPU_SET_H = 1
const _BITS_ENDIANNESS_H = 1
const _BITS_ENDIAN_H = 1
const _BITS_PTHREADTYPES_ARCH_H = 1
const _BITS_PTHREADTYPES_COMMON_H = 1
const _BITS_SCHED_H = 1
const _BITS_SETJMP_H = 1
const _BITS_TIME_H = 1
const _BITS_TYPES_STRUCT_SCHED_PARAM = 1
const _ISOC99_SOURCE = 1
const _ISOC9X_SOURCE = 1
const _PTHREAD_H = 1
const _SCHED_H = 1
const _STRUCT_TIMESPEC = 1
const _THREAD_MUTEX_INTERNAL_H = 1
const _THREAD_SHARED_TYPES_H = 1
const _TIME_H = 1
const __BIG_ENDIAN = 4321
const __BYTE_ORDER = "__LITTLE_ENDIAN"
const __CPU_SETSIZE = 1024
const __FLOAT_WORD_ORDER = "__BYTE_ORDER"
const __LITTLE_ENDIAN = 1234
const __PDP_ENDIAN = 3412
const __PTHREAD_MUTEX_HAVE_PREV = 1
const __SIZEOF_PTHREAD_ATTR_T = 56
const __SIZEOF_PTHREAD_BARRIERATTR_T = 4
const __SIZEOF_PTHREAD_BARRIER_T = 32
const __SIZEOF_PTHREAD_CONDATTR_T = 4
const __SIZEOF_PTHREAD_COND_T = 48
const __SIZEOF_PTHREAD_MUTEXATTR_T = 4
const __SIZEOF_PTHREAD_MUTEX_T = 40
const __SIZEOF_PTHREAD_RWLOCKATTR_T = 8
const __SIZEOF_PTHREAD_RWLOCK_T = 56
const __USE_ISOC9X = 1
const __clock_t_defined = 1
const __have_pthread_attr_t = 1
const __jmp_buf_tag_defined = 1
const __sched_priority = "sched_priority"
const __struct_tm_defined = 1
const __time_t_defined = 1
const silk_FALSE = 0
const silk_LIMIT_16 = "silk_LIMIT"
const silk_LIMIT_32 = "silk_LIMIT"
const silk_LIMIT_int = "silk_LIMIT"
const silk_TRUE = 1
const silk_float = "float"
const silk_float_MAX = "FLT_MAX"
const silk_int16_MAX = 0x7FFF
const silk_int32_MAX = 2147483647
const silk_int8_MAX = 0x7F
const silk_uint8_MAX = 0xFF

type OpusT_OpusCustomMode = struct {
	FFs             OpusT_opus_int32
	Foverlap        int32
	FnbEBands       int32
	FeffEBands      int32
	Fpreemph        [4]OpusT_opus_val16
	FeBands         uintptr
	FmaxLM          int32
	FnbShortMdcts   int32
	FshortMdctSize  int32
	FnbAllocVectors int32
	FallocVectors   uintptr
	FlogN           uintptr
	Fwindow         uintptr
	Fmdct           OpusT_mdct_lookup
	Fcache          OpusT_PulseCache
}

var trim_icdf1 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf1 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf1 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusDecoder = struct {
	Fcelt_dec_offset      int32
	Fsilk_dec_offset      int32
	Fchannels             int32
	FFs                   OpusT_opus_int32
	FDecControl           OpusT_silk_DecControlStruct
	Fdecode_gain          int32
	Fcomplexity           int32
	Fignore_extensions    int32
	Farch                 int32
	Fstream_channels      int32
	Fbandwidth            int32
	Fmode                 int32
	Fprev_mode            int32
	Fframe_size           int32
	Fprev_redundancy      int32
	Flast_packet_duration int32
	Fsoftclip_mem         [2]OpusT_opus_val16
	FrangeFinal           OpusT_opus_uint32
}

type OpusT_OpusDREDDecoder = struct {
	Floaded int32
	Farch   int32
	Fmagic  OpusT_opus_uint32
}

type OpusT_mdct_lookup = struct {
	Fn        int32
	Fmaxshift int32
	Fkfft     [4]uintptr
	Ftrig     uintptr
}

type OpusT_PulseCache = struct {
	Fsize  int32
	Findex uintptr
	Fbits  uintptr
	Fcaps  uintptr
}

type OpusCustomMode = struct {
	FFs             OpusT_opus_int32
	Foverlap        int32
	FnbEBands       int32
	FeffEBands      int32
	Fpreemph        [4]OpusT_opus_val16
	FeBands         uintptr
	FmaxLM          int32
	FnbShortMdcts   int32
	FshortMdctSize  int32
	FnbAllocVectors int32
	FallocVectors   uintptr
	FlogN           uintptr
	Fwindow         uintptr
	Fmdct           OpusT_mdct_lookup
	Fcache          OpusT_PulseCache
}

type OpusT_silk_EncControlStruct = struct {
	FnChannelsAPI              OpusT_opus_int32
	FnChannelsInternal         OpusT_opus_int32
	FAPI_sampleRate            OpusT_opus_int32
	FmaxInternalSampleRate     OpusT_opus_int32
	FminInternalSampleRate     OpusT_opus_int32
	FdesiredInternalSampleRate OpusT_opus_int32
	FpayloadSize_ms            int32
	FbitRate                   OpusT_opus_int32
	FpacketLossPercentage      int32
	Fcomplexity                int32
	FuseInBandFEC              int32
	FuseDRED                   int32
	FLBRR_coded                int32
	FuseDTX                    int32
	FuseCBR                    int32
	FmaxBits                   int32
	FtoMono                    int32
	FopusCanSwitch             int32
	FreducedDependency         int32
	FinternalSampleRate        OpusT_opus_int32
	FallowBandwidthSwitch      int32
	FinWBmodeWithoutVariableLP int32
	FstereoWidth_Q14           int32
	FswitchReady               int32
	FsignalType                int32
	Foffset                    int32
}

type OpusT_silk_DecControlStruct = struct {
	FnChannelsAPI       OpusT_opus_int32
	FnChannelsInternal  OpusT_opus_int32
	FAPI_sampleRate     OpusT_opus_int32
	FinternalSampleRate OpusT_opus_int32
	FpayloadSize_ms     int32
	FprevPitchLag       int32
	Fenable_deep_plc    int32
}

type OpusT_silk_TOC_struct = struct {
	FVADFlag       int32
	FVADFlags      [3]int32
	FinbandFECFlag int32
}

type OpusT_time_t = int64

type timespec = struct {
	Ftv_sec  OpusT___time_t
	Ftv_nsec OpusT___syscall_slong_t
}

type OpusT_clock_t = int64

type tm = struct {
	Ftm_sec      int32
	Ftm_min      int32
	Ftm_hour     int32
	Ftm_mday     int32
	Ftm_mon      int32
	Ftm_year     int32
	Ftm_wday     int32
	Ftm_yday     int32
	Ftm_isdst    int32
	F__tm_gmtoff int64
	F__tm_zone   uintptr
}

type OpusT_pid_t = int32

type sched_param = struct {
	Fsched_priority int32
}

type OpusT___cpu_mask = uint64

type OpusT_cpu_set_t = struct {
	F__bits [16]OpusT___cpu_mask
}

type OpusT___atomic_wide_counter = struct {
	F__value32 [0]struct {
		F__low  uint32
		F__high uint32
	}
	F__value64 uint64
}

type OpusT___pthread_list_t = struct {
	F__prev uintptr
	F__next uintptr
}

type __pthread_internal_list = OpusT___pthread_list_t

type OpusT___pthread_slist_t = struct {
	F__next uintptr
}

type __pthread_internal_slist = OpusT___pthread_slist_t

type __pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    OpusT___pthread_list_t
}

type __pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint64
	F__flags         uint32
}

type __pthread_cond_s = struct {
	F__wseq         OpusT___atomic_wide_counter
	F__g1_start     OpusT___atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
}

type OpusT___tss_t = uint32

type OpusT___thrd_t = uint64

type OpusT___once_flag = struct {
	F__data int32
}

type OpusT_pthread_t = uint64

type OpusT_pthread_mutexattr_t = struct {
	F__align [0]int32
	F__size  [4]int8
}

type OpusT_pthread_condattr_t = struct {
	F__align [0]int32
	F__size  [4]int8
}

type OpusT_pthread_key_t = uint32

type OpusT_pthread_once_t = int32

type pthread_attr_t = struct {
	F__align [0]int64
	F__size  [56]int8
}

type OpusT_pthread_attr_t = struct {
	F__align [0]int64
	F__size  [56]int8
}

type OpusT_pthread_mutex_t = struct {
	F__size  [0][40]int8
	F__align [0]int64
	F__data  __pthread_mutex_s
}

type OpusT_pthread_cond_t = struct {
	F__size  [0][48]int8
	F__align [0]int64
	F__data  __pthread_cond_s
}

type OpusT___jmp_buf = [8]int64

type OpusT___sigset_t = struct {
	F__val [16]uint64
}

type __jmp_buf_tag = struct {
	F__jmpbuf         OpusT___jmp_buf
	F__mask_was_saved int32
	F__saved_mask     OpusT___sigset_t
}

const PTHREAD_CREATE_JOINABLE = 0
const PTHREAD_CREATE_DETACHED = 1
const PTHREAD_MUTEX_TIMED_NP = 0
const PTHREAD_MUTEX_RECURSIVE_NP = 1
const PTHREAD_MUTEX_ERRORCHECK_NP = 2
const PTHREAD_MUTEX_ADAPTIVE_NP = 3
const PTHREAD_INHERIT_SCHED = 0
const PTHREAD_EXPLICIT_SCHED = 1
const PTHREAD_SCOPE_SYSTEM = 0
const PTHREAD_SCOPE_PROCESS = 1
const PTHREAD_PROCESS_PRIVATE = 0
const PTHREAD_PROCESS_SHARED = 1

type _pthread_cleanup_buffer = struct {
	F__routine    uintptr
	F__arg        uintptr
	F__canceltype int32
	F__prev       uintptr
}

const PTHREAD_CANCEL_ENABLE = 0
const PTHREAD_CANCEL_DISABLE = 1
const PTHREAD_CANCEL_DEFERRED = 0
const PTHREAD_CANCEL_ASYNCHRONOUS = 1

type __cancel_jmp_buf_tag = struct {
	F__cancel_jmp_buf OpusT___jmp_buf
	F__mask_was_saved int32
}

type OpusT___pthread_unwind_buf_t = struct {
	F__cancel_jmp_buf [1]__cancel_jmp_buf_tag
	F__pad            [4]uintptr
}

type __pthread_cleanup_frame = struct {
	F__cancel_routine uintptr
	F__cancel_arg     uintptr
	F__do_it          int32
	F__cancel_type    int32
}

type OpusT_opus_ccgo_pseudostack_state = struct {
	Fscratch_ptr  uintptr
	Fglobal_stack uintptr
}

type OpusT_silk_resampler_state_struct = struct {
	FsIIR [6]OpusT_opus_int32
	FsFIR struct {
		Fi16 [0][36]OpusT_opus_int16
		Fi32 [36]OpusT_opus_int32
	}
	FdelayBuf           [96]OpusT_opus_int16
	Fresampler_function int32
	FbatchSize          int32
	FinvRatio_Q16       OpusT_opus_int32
	FFIR_Order          int32
	FFIR_Fracs          int32
	FFs_in_kHz          int32
	FFs_out_kHz         int32
	FinputDelay         int32
	FCoefs              uintptr
}

type _silk_resampler_state_struct = OpusT_silk_resampler_state_struct

type OpusT_silk_nsq_state = struct {
	Fxq               [640]OpusT_opus_int16
	FsLTP_shp_Q14     [640]OpusT_opus_int32
	FsLPC_Q14         [96]OpusT_opus_int32
	FsAR2_Q14         [24]OpusT_opus_int32
	FsLF_AR_shp_Q14   OpusT_opus_int32
	FsDiff_shp_Q14    OpusT_opus_int32
	FlagPrev          int32
	FsLTP_buf_idx     int32
	FsLTP_shp_buf_idx int32
	Frand_seed        OpusT_opus_int32
	Fprev_gain_Q16    OpusT_opus_int32
	Frewhite_flag     int32
}

type OpusT_silk_VAD_state = struct {
	FAnaState        [2]OpusT_opus_int32
	FAnaState1       [2]OpusT_opus_int32
	FAnaState2       [2]OpusT_opus_int32
	FXnrgSubfr       [4]OpusT_opus_int32
	FNrgRatioSmth_Q8 [4]OpusT_opus_int32
	FHPstate         OpusT_opus_int16
	FNL              [4]OpusT_opus_int32
	Finv_NL          [4]OpusT_opus_int32
	FNoiseLevelBias  [4]OpusT_opus_int32
	Fcounter         OpusT_opus_int32
}

type OpusT_silk_LP_state = struct {
	FIn_LP_State         [2]OpusT_opus_int32
	Ftransition_frame_no OpusT_opus_int32
	Fmode                int32
	Fsaved_fs_kHz        OpusT_opus_int32
}

type OpusT_silk_NLSF_CB_struct = struct {
	FnVectors            OpusT_opus_int16
	Forder               OpusT_opus_int16
	FquantStepSize_Q16   OpusT_opus_int16
	FinvQuantStepSize_Q6 OpusT_opus_int16
	FCB1_NLSF_Q8         uintptr
	FCB1_Wght_Q9         uintptr
	FCB1_iCDF            uintptr
	Fpred_Q8             uintptr
	Fec_sel              uintptr
	Fec_iCDF             uintptr
	Fec_Rates_Q5         uintptr
	FdeltaMin_Q15        uintptr
}

type OpusT_stereo_enc_state = struct {
	Fpred_prev_Q13   [2]OpusT_opus_int16
	FsMid            [2]OpusT_opus_int16
	FsSide           [2]OpusT_opus_int16
	Fmid_side_amp_Q0 [4]OpusT_opus_int32
	Fsmth_width_Q14  OpusT_opus_int16
	Fwidth_prev_Q14  OpusT_opus_int16
	Fsilent_side_len OpusT_opus_int16
	FpredIx          [3][2][3]OpusT_opus_int8
	Fmid_only_flags  [3]OpusT_opus_int8
}

type OpusT_stereo_dec_state = struct {
	Fpred_prev_Q13 [2]OpusT_opus_int16
	FsMid          [2]OpusT_opus_int16
	FsSide         [2]OpusT_opus_int16
}

type OpusT_SideInfoIndices = struct {
	FGainsIndices      [4]OpusT_opus_int8
	FLTPIndex          [4]OpusT_opus_int8
	FNLSFIndices       [17]OpusT_opus_int8
	FlagIndex          OpusT_opus_int16
	FcontourIndex      OpusT_opus_int8
	FsignalType        OpusT_opus_int8
	FquantOffsetType   OpusT_opus_int8
	FNLSFInterpCoef_Q2 OpusT_opus_int8
	FPERIndex          OpusT_opus_int8
	FLTP_scaleIndex    OpusT_opus_int8
	FSeed              OpusT_opus_int8
}

type OpusT_silk_encoder_state = struct {
	FIn_HP_State                   [2]OpusT_opus_int32
	Fvariable_HP_smth1_Q15         OpusT_opus_int32
	Fvariable_HP_smth2_Q15         OpusT_opus_int32
	FsLP                           OpusT_silk_LP_state
	FsVAD                          OpusT_silk_VAD_state
	FsNSQ                          OpusT_silk_nsq_state
	Fprev_NLSFq_Q15                [16]OpusT_opus_int16
	Fspeech_activity_Q8            int32
	Fallow_bandwidth_switch        int32
	FLBRRprevLastGainIndex         OpusT_opus_int8
	FprevSignalType                OpusT_opus_int8
	FprevLag                       int32
	Fpitch_LPC_win_length          int32
	Fmax_pitch_lag                 int32
	FAPI_fs_Hz                     OpusT_opus_int32
	Fprev_API_fs_Hz                OpusT_opus_int32
	FmaxInternal_fs_Hz             int32
	FminInternal_fs_Hz             int32
	FdesiredInternal_fs_Hz         int32
	Ffs_kHz                        int32
	Fnb_subfr                      int32
	Fframe_length                  int32
	Fsubfr_length                  int32
	Fltp_mem_length                int32
	Fla_pitch                      int32
	Fla_shape                      int32
	FshapeWinLength                int32
	FTargetRate_bps                OpusT_opus_int32
	FPacketSize_ms                 int32
	FPacketLoss_perc               int32
	FframeCounter                  OpusT_opus_int32
	FComplexity                    int32
	FnStatesDelayedDecision        int32
	FuseInterpolatedNLSFs          int32
	FshapingLPCOrder               int32
	FpredictLPCOrder               int32
	FpitchEstimationComplexity     int32
	FpitchEstimationLPCOrder       int32
	FpitchEstimationThreshold_Q16  OpusT_opus_int32
	Fsum_log_gain_Q7               OpusT_opus_int32
	FNLSF_MSVQ_Survivors           int32
	Ffirst_frame_after_reset       int32
	Fcontrolled_since_last_payload int32
	Fwarping_Q16                   int32
	FuseCBR                        int32
	FprefillFlag                   int32
	Fpitch_lag_low_bits_iCDF       uintptr
	Fpitch_contour_iCDF            uintptr
	FpsNLSF_CB                     uintptr
	Finput_quality_bands_Q15       [4]int32
	Finput_tilt_Q15                int32
	FSNR_dB_Q7                     int32
	FVAD_flags                     [3]OpusT_opus_int8
	FLBRR_flag                     OpusT_opus_int8
	FLBRR_flags                    [3]int32
	Findices                       OpusT_SideInfoIndices
	Fpulses                        [320]OpusT_opus_int8
	Farch                          int32
	FinputBuf                      [322]OpusT_opus_int16
	FinputBufIx                    int32
	FnFramesPerPacket              int32
	FnFramesEncoded                int32
	FnChannelsAPI                  int32
	FnChannelsInternal             int32
	FchannelNb                     int32
	Fframes_since_onset            int32
	Fec_prevSignalType             int32
	Fec_prevLagIndex               OpusT_opus_int16
	Fresampler_state               OpusT_silk_resampler_state_struct
	FuseDTX                        int32
	FinDTX                         int32
	FnoSpeechCounter               int32
	FuseInBandFEC                  int32
	FLBRR_enabled                  int32
	FLBRR_GainIncreases            int32
	Findices_LBRR                  [3]OpusT_SideInfoIndices
	Fpulses_LBRR                   [3][320]OpusT_opus_int8
}

type OpusT_silk_PLC_struct = struct {
	FpitchL_Q8         OpusT_opus_int32
	FLTPCoef_Q14       [5]OpusT_opus_int16
	FprevLPC_Q12       [16]OpusT_opus_int16
	Flast_frame_lost   int32
	Frand_seed         OpusT_opus_int32
	FrandScale_Q14     OpusT_opus_int16
	Fconc_energy       OpusT_opus_int32
	Fconc_energy_shift int32
	FprevLTP_scale_Q14 OpusT_opus_int16
	FprevGain_Q16      [2]OpusT_opus_int32
	Ffs_kHz            int32
	Fnb_subfr          int32
	Fsubfr_length      int32
	Fenable_deep_plc   int32
}

type OpusT_silk_CNG_struct = struct {
	FCNG_exc_buf_Q14   [320]OpusT_opus_int32
	FCNG_smth_NLSF_Q15 [16]OpusT_opus_int16
	FCNG_synth_state   [16]OpusT_opus_int32
	FCNG_smth_Gain_Q16 OpusT_opus_int32
	Frand_seed         OpusT_opus_int32
	Ffs_kHz            int32
}

type OpusT_silk_decoder_state = struct {
	Fprev_gain_Q16           OpusT_opus_int32
	Fexc_Q14                 [320]OpusT_opus_int32
	FsLPC_Q14_buf            [16]OpusT_opus_int32
	FoutBuf                  [480]OpusT_opus_int16
	FlagPrev                 int32
	FLastGainIndex           OpusT_opus_int8
	Ffs_kHz                  int32
	Ffs_API_hz               OpusT_opus_int32
	Fnb_subfr                int32
	Fframe_length            int32
	Fsubfr_length            int32
	Fltp_mem_length          int32
	FLPC_order               int32
	FprevNLSF_Q15            [16]OpusT_opus_int16
	Ffirst_frame_after_reset int32
	Fpitch_lag_low_bits_iCDF uintptr
	Fpitch_contour_iCDF      uintptr
	FnFramesDecoded          int32
	FnFramesPerPacket        int32
	Fec_prevSignalType       int32
	Fec_prevLagIndex         OpusT_opus_int16
	FVAD_flags               [3]int32
	FLBRR_flag               int32
	FLBRR_flags              [3]int32
	Fresampler_state         OpusT_silk_resampler_state_struct
	FpsNLSF_CB               uintptr
	Findices                 OpusT_SideInfoIndices
	FsCNG                    OpusT_silk_CNG_struct
	FlossCnt                 int32
	FprevSignalType          int32
	Farch                    int32
	FsPLC                    OpusT_silk_PLC_struct
}

type OpusT_silk_decoder_control = struct {
	FpitchL        [4]int32
	FGains_Q16     [4]OpusT_opus_int32
	FPredCoef_Q12  [2][16]OpusT_opus_int16
	FLTPCoef_Q14   [20]OpusT_opus_int16
	FLTP_scale_Q14 int32
}

var log2_x_norm_coeff1 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff1 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

/* Copyright (c) 2010 Xiph.Org Foundation
 * Copyright (c) 2013 Parrot */
/*
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

type OpusDecoder = struct {
	Fcelt_dec_offset      int32
	Fsilk_dec_offset      int32
	Fchannels             int32
	FFs                   OpusT_opus_int32
	FDecControl           OpusT_silk_DecControlStruct
	Fdecode_gain          int32
	Fcomplexity           int32
	Fignore_extensions    int32
	Farch                 int32
	Fstream_channels      int32
	Fbandwidth            int32
	Fmode                 int32
	Fprev_mode            int32
	Fframe_size           int32
	Fprev_redundancy      int32
	Flast_packet_duration int32
	Fsoftclip_mem         [2]OpusT_opus_val16
	FrangeFinal           OpusT_opus_uint32
}

func Opus_opus_packet_parse_impl(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, self_delimited int32, out_toc uintptr, frames uintptr, size uintptr, payload_offset uintptr, packet_offset uintptr, padding uintptr, padding_len uintptr) (r int32) {
	var bytes, cbr, count, framesize, i, p, tmp, v4 int32
	var ch, toc uint8
	var data0, v1 uintptr
	var last_size, pad OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = bytes, cbr, ch, count, data0, framesize, i, last_size, p, pad, tmp, toc, v1, v4
	pad = 0
	data0 = data
	/* Make sure we return NULL/0 on error. */
	if padding != libc.UintptrFromInt32(0) {
		*(*uintptr)(unsafe.Pointer(padding)) = libc.UintptrFromInt32(0)
		*(*OpusT_opus_int32)(unsafe.Pointer(padding_len)) = 0
	}
	if size == libc.UintptrFromInt32(0) || len1 < 0 {
		return -int32(1)
	}
	if len1 == 0 {
		return -int32(4)
	}
	framesize = Opus_opus_packet_get_samples_per_frame(tls, data, int32(48000))
	cbr = 0
	v1 = data
	data = data + 1
	toc = *(*uint8)(unsafe.Pointer(v1))
	len1 = len1 - 1
	last_size = len1
	switch libc.Int32FromUint8(toc) & libc.Int32FromInt32(0x3) {
	/* One frame */
	case 0:
		count = int32(1)
		break
		/* Two CBR frames */
		fallthrough
	case int32(1):
		count = int32(2)
		cbr = int32(1)
		if !(self_delimited != 0) {
			if len1&int32(0x1) != 0 {
				return -int32(4)
			}
			last_size = len1 / int32(2)
			/* If last_size doesn't fit in size[0], we'll catch it later */
			*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(last_size)
		}
		break
		/* Two VBR frames */
		fallthrough
	case int32(2):
		count = int32(2)
		bytes = parse_size(tls, data, len1, size)
		len1 = len1 - bytes
		if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size))) > len1 {
			return -int32(4)
		}
		data = data + uintptr(bytes)
		last_size = len1 - int32(*(*OpusT_opus_int16)(unsafe.Pointer(size)))
		break
		/* Multiple CBR/VBR frames (from 0 to 120 ms) */
		fallthrough
	default: /*case 3:*/
		if len1 < int32(1) {
			return -int32(4)
		}
		/* Number of frames encoded in bits 0 to 5 */
		v1 = data
		data = data + 1
		ch = *(*uint8)(unsafe.Pointer(v1))
		count = libc.Int32FromUint8(ch) & int32(0x3F)
		if count <= 0 || framesize*count > int32(5760) {
			return -int32(4)
		}
		len1 = len1 - 1
		/* Padding flag is bit 6 */
		if libc.Int32FromUint8(ch)&int32(0x40) != 0 {
			for cond := true; cond; cond = p == int32(255) {
				if len1 <= 0 {
					return -int32(4)
				}
				v1 = data
				data = data + 1
				p = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
				len1 = len1 - 1
				if p == int32(255) {
					v4 = int32(254)
				} else {
					v4 = p
				}
				tmp = v4
				len1 = len1 - tmp
				pad = pad + tmp
			}
		}
		if len1 < 0 {
			return -int32(4)
		}
		/* VBR flag is bit 7 */
		cbr = libc.BoolInt32(!(libc.Int32FromUint8(ch)&libc.Int32FromInt32(0x80) != 0))
		if !(cbr != 0) {
			/* VBR case */
			last_size = len1
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				bytes = parse_size(tls, data, len1, size+uintptr(i)*2)
				len1 = len1 - bytes
				if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))) > len1 {
					return -int32(4)
				}
				data = data + uintptr(bytes)
				last_size = last_size - (bytes + int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2))))
				goto _5
			_5:
				;
				i = i + 1
			}
			if last_size < 0 {
				return -int32(4)
			}
		} else {
			if !(self_delimited != 0) {
				/* CBR case */
				last_size = len1 / count
				if last_size*count != len1 {
					return -int32(4)
				}
				i = 0
				for {
					if !(i < count-int32(1)) {
						break
					}
					*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)) = int16(last_size)
					goto _6
				_6:
					;
					i = i + 1
				}
			}
		}
		break
	}
	/* Self-delimited framing has an extra size for the last frame. */
	if self_delimited != 0 {
		bytes = parse_size(tls, data, len1, size+uintptr(count)*2-uintptr(1)*2)
		len1 = len1 - bytes
		if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) < 0 || int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) > len1 {
			return -int32(4)
		}
		data = data + uintptr(bytes)
		/* For CBR packets, apply the size to all the frames. */
		if cbr != 0 {
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2)))*count > len1 {
				return -int32(4)
			}
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)) = *(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))
				goto _7
			_7:
				;
				i = i + 1
			}
		} else {
			if bytes+int32(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2))) > last_size {
				return -int32(4)
			}
		}
	} else {
		/* Because it's not encoded explicitly, it's possible the size of the
		   last packet (or all the packets, for the CBR case) is larger than
		   1275. Reject them here.*/
		if last_size > int32(1275) {
			return -int32(4)
		}
		*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(count-int32(1))*2)) = int16(last_size)
	}
	if payload_offset != 0 {
		*(*int32)(unsafe.Pointer(payload_offset)) = int32(int64(data) - int64(data0))
	}
	i = 0
	for {
		if !(i < count) {
			break
		}
		if frames != 0 {
			*(*uintptr)(unsafe.Pointer(frames + uintptr(i)*8)) = data
		}
		data = data + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer(size + uintptr(i)*2)))
		goto _8
	_8:
		;
		i = i + 1
	}
	if padding != libc.UintptrFromInt32(0) {
		*(*uintptr)(unsafe.Pointer(padding)) = data
		*(*OpusT_opus_int32)(unsafe.Pointer(padding_len)) = pad
	}
	if packet_offset != 0 {
		*(*OpusT_opus_int32)(unsafe.Pointer(packet_offset)) = pad + int32(int64(data)-int64(data0))
	}
	if out_toc != 0 {
		*(*uint8)(unsafe.Pointer(out_toc)) = toc
	}
	return count
}

func Opus_opus_packet_unpad(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(1120)
	defer tls.Free(1120)
	var i int32
	var ret OpusT_opus_int32
	var _ /* rp at bp+0 */ OpusT_OpusRepacketizer
	_, _ = i, ret
	if len1 < int32(1) {
		return -int32(1)
	}
	Opus_opus_repacketizer_init(tls, bp)
	ret = Opus_opus_repacketizer_cat(tls, bp, data, len1)
	if ret < 0 {
		return ret
	}
	/* Discard all padding and extensions. */
	i = 0
	for {
		if !(i < (*(*OpusT_OpusRepacketizer)(unsafe.Pointer(bp))).Fnb_frames) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(bp + 880 + uintptr(i)*4)) = 0
		*(*uintptr)(unsafe.Pointer(bp + 496 + uintptr(i)*8)) = libc.UintptrFromInt32(0)
		goto _1
	_1:
		;
		i = i + 1
	}
	ret = Opus_opus_repacketizer_out_range_impl(tls, bp, 0, (*(*OpusT_OpusRepacketizer)(unsafe.Pointer(bp))).Fnb_frames, data, len1, 0, 0, libc.UintptrFromInt32(0), 0)
	if !(ret > 0 && ret <= len1) {
		Opus_celt_fatal(tls, __ccgo_ts+3317, __ccgo_ts+3262, int32(388))
	}
	return ret
}

func Opus_opus_pcm_soft_clip(tls *libc.TLS, _x uintptr, N int32, C int32, declip_mem uintptr) {
	Opus_opus_pcm_soft_clip_impl(tls, _x, N, C, declip_mem, 0)
}

func Opus_opus_pcm_soft_clip_impl(tls *libc.TLS, _x uintptr, N int32, C int32, declip_mem uintptr, arch int32) {
	var a, delta, maxval, offset, x0, v7, v8, v9 float32
	var all_within_neg1pos1, c, curr, end, i, peak_pos, special, start, v4 int32
	var x uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, all_within_neg1pos1, c, curr, delta, end, i, maxval, offset, peak_pos, special, start, x, x0, v4, v7, v8, v9
	if C < int32(1) || N < int32(1) || !(_x != 0) || !(declip_mem != 0) {
		return
	}
	/* Clamp everything within the range [-2, +2] which is the domain of the soft
	      clipping non-linearity. Outside the defined range the derivative will be zero,
	      therefore there is no discontinuity introduced here. The implementation
	      might provide a hint if all input samples are within the [-1, +1] range.
	   `opus_limit2_checkwithin1()`:
	      - Clamps all samples within the valid range [-2, +2].
	      - Generic C implementation:
	         * Does not attempt early detection whether samples are within hinted range.
	         * Always returns 0.
	      - Architecture specific implementation:
	         * Uses SIMD instructions to efficiently detect if all samples are
	           within the hinted range [-1, +1].
	         * Returns 1 if no samples exceed the hinted range, 0 otherwise.
	   `all_within_neg1pos1`:
	      - Optimization hint to skip per-sample out-of-bound checks.
	        If true, the check can be skipped. */
	_ = arch
	all_within_neg1pos1 = Opus_opus_limit2_checkwithin1_c(tls, _x, N*C)
	c = 0
	for {
		if !(c < C) {
			break
		}
		x = _x + uintptr(c)*4
		a = *(*float32)(unsafe.Pointer(declip_mem + uintptr(c)*4))
		/* Continue applying the non-linearity from the previous frame to avoid
		   any discontinuity. */
		i = 0
		for {
			if !(i < N) {
				break
			}
			if float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))*a) >= libc.Float32FromInt32(0) {
				break
			}
			*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) + float32(float32(a**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		curr = 0
		x0 = *(*float32)(unsafe.Pointer(x))
		for int32(1) != 0 {
			special = 0
			/* Detection for early exit can be skipped if hinted by `all_within_neg1pos1` */
			if all_within_neg1pos1 != 0 {
				i = N
			} else {
				i = curr
				for {
					if !(i < N) {
						break
					}
					if *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) > libc.Float32FromInt32(1) || *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) < float32(-libc.Int32FromInt32(1)) {
						break
					}
					goto _3
				_3:
					;
					i = i + 1
				}
			}
			if i == N {
				a = libc.Float32FromInt32(0)
				break
			}
			peak_pos = i
			v4 = i
			end = v4
			start = v4
			maxval = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))))
			/* Look for first zero crossing before clipping */
			for start > 0 && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x + uintptr((start-int32(1))*C)*4))) >= libc.Float32FromInt32(0) {
				start = start - 1
			}
			/* Look for first zero crossing after clipping */
			for end < N && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x + uintptr(end*C)*4))) >= libc.Float32FromInt32(0) {
				/* Look for other peaks until the next zero-crossing. */
				if float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(end*C)*4))))) > maxval {
					maxval = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(x + uintptr(end*C)*4)))))
					peak_pos = end
				}
				end = end + 1
			}
			/* Detect the special case where we clip before the first zero crossing */
			special = libc.BoolInt32(start == 0 && float32(*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))**(*float32)(unsafe.Pointer(x))) >= libc.Float32FromInt32(0))
			/* Compute a such that maxval + a*maxval^2 = 1 */
			a = (maxval - libc.Float32FromInt32(1)) / float32(maxval*maxval)
			/* Slightly boost "a" by 2^-22. This is just enough to ensure -ffast-math
			   does not cause output values larger than +/-1, but small enough not
			   to matter even for 24-bit output.  */
			a = a + float32(a*libc.Float32FromFloat32(2.4e-07))
			if *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) > libc.Float32FromInt32(0) {
				a = -a
			}
			/* Apply soft clipping */
			i = start
			for {
				if !(i < end) {
					break
				}
				*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) + float32(float32(a**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))**(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)))
				goto _5
			_5:
				;
				i = i + 1
			}
			if special != 0 && peak_pos >= int32(2) {
				offset = x0 - *(*float32)(unsafe.Pointer(x))
				delta = offset / float32(peak_pos)
				i = curr
				for {
					if !(i < peak_pos) {
						break
					}
					offset = offset - delta
					*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) += offset
					if libc.Float32FromFloat32(1) < *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) {
						v8 = libc.Float32FromFloat32(1)
					} else {
						v8 = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))
					}
					if -libc.Float32FromFloat32(1) > v8 {
						v7 = -libc.Float32FromFloat32(1)
					} else {
						if libc.Float32FromFloat32(1) < *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) {
							v9 = libc.Float32FromFloat32(1)
						} else {
							v9 = *(*float32)(unsafe.Pointer(x + uintptr(i*C)*4))
						}
						v7 = v9
					}
					*(*float32)(unsafe.Pointer(x + uintptr(i*C)*4)) = v7
					goto _6
				_6:
					;
					i = i + 1
				}
			}
			curr = end
			if curr == N {
				break
			}
		}
		*(*float32)(unsafe.Pointer(declip_mem + uintptr(c)*4)) = a
		goto _1
	_1:
		;
		c = c + 1
	}
}

func Opus_opus_projection_ambisonics_encoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, mapping_family int32, streams uintptr, coupled_streams uintptr, application int32, error1 uintptr) (r uintptr) {
	var ret, size1 int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	/* Allocate space for the projection encoder. */
	size1 = Opus_opus_projection_ambisonics_encoder_get_size(tls, channels, mapping_family)
	if !(size1 != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if !(st != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	/* Initialize projection encoder with provided settings. */
	ret = Opus_opus_projection_ambisonics_encoder_init(tls, st, Fs, channels, mapping_family, streams, coupled_streams, application)
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	return st
}

func Opus_opus_projection_ambisonics_encoder_get_size(tls *libc.TLS, channels int32, mapping_family int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var alignment uint32
	var demixing_matrix_cols, demixing_matrix_rows, mixing_matrix_cols, mixing_matrix_rows, ret, v1 int32
	var demixing_matrix_size, encoder_size, mixing_matrix_size OpusT_opus_int32
	var _ /* nb_coupled_streams at bp+4 */ int32
	var _ /* nb_streams at bp+0 */ int32
	var _ /* order_plus_one at bp+8 */ int32
	_, _, _, _, _, _, _, _, _, _ = alignment, demixing_matrix_cols, demixing_matrix_rows, demixing_matrix_size, encoder_size, mixing_matrix_cols, mixing_matrix_rows, mixing_matrix_size, ret, v1
	ret = get_streams_from_channels(tls, channels, mapping_family, bp, bp+4, bp+8)
	if ret != OPUS_OK {
		return 0
	}
	if *(*int32)(unsafe.Pointer(bp + 8)) == int32(2) {
		mixing_matrix_rows = Opus_mapping_matrix_foa_mixing.Frows
		mixing_matrix_cols = Opus_mapping_matrix_foa_mixing.Fcols
		demixing_matrix_rows = Opus_mapping_matrix_foa_demixing.Frows
		demixing_matrix_cols = Opus_mapping_matrix_foa_demixing.Fcols
	} else {
		if *(*int32)(unsafe.Pointer(bp + 8)) == int32(3) {
			mixing_matrix_rows = Opus_mapping_matrix_soa_mixing.Frows
			mixing_matrix_cols = Opus_mapping_matrix_soa_mixing.Fcols
			demixing_matrix_rows = Opus_mapping_matrix_soa_demixing.Frows
			demixing_matrix_cols = Opus_mapping_matrix_soa_demixing.Fcols
		} else {
			if *(*int32)(unsafe.Pointer(bp + 8)) == int32(4) {
				mixing_matrix_rows = Opus_mapping_matrix_toa_mixing.Frows
				mixing_matrix_cols = Opus_mapping_matrix_toa_mixing.Fcols
				demixing_matrix_rows = Opus_mapping_matrix_toa_demixing.Frows
				demixing_matrix_cols = Opus_mapping_matrix_toa_demixing.Fcols
			} else {
				if *(*int32)(unsafe.Pointer(bp + 8)) == int32(5) {
					mixing_matrix_rows = Opus_mapping_matrix_fourthoa_mixing.Frows
					mixing_matrix_cols = Opus_mapping_matrix_fourthoa_mixing.Fcols
					demixing_matrix_rows = Opus_mapping_matrix_fourthoa_demixing.Frows
					demixing_matrix_cols = Opus_mapping_matrix_fourthoa_demixing.Fcols
				} else {
					if *(*int32)(unsafe.Pointer(bp + 8)) == int32(6) {
						mixing_matrix_rows = Opus_mapping_matrix_fifthoa_mixing.Frows
						mixing_matrix_cols = Opus_mapping_matrix_fifthoa_mixing.Fcols
						demixing_matrix_rows = Opus_mapping_matrix_fifthoa_demixing.Frows
						demixing_matrix_cols = Opus_mapping_matrix_fifthoa_demixing.Fcols
					} else {
						return 0
					}
				}
			}
		}
	}
	mixing_matrix_size = Opus_mapping_matrix_get_size(tls, mixing_matrix_rows, mixing_matrix_cols)
	if !(mixing_matrix_size != 0) {
		return 0
	}
	demixing_matrix_size = Opus_mapping_matrix_get_size(tls, demixing_matrix_rows, demixing_matrix_cols)
	if !(demixing_matrix_size != 0) {
		return 0
	}
	encoder_size = Opus_opus_multistream_encoder_get_size(tls, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)))
	if !(encoder_size != 0) {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(8)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return v1 + mixing_matrix_size + demixing_matrix_size + encoder_size
}

func Opus_opus_projection_ambisonics_encoder_init(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, mapping_family int32, streams uintptr, coupled_streams uintptr, application int32) (r int32) {
	bp := tls.Alloc(272)
	defer tls.Free(272)
	var demixing_matrix, mixing_matrix, ms_encoder uintptr
	var i, ret int32
	var _ /* mapping at bp+4 */ [255]uint8
	var _ /* order_plus_one at bp+0 */ int32
	_, _, _, _, _ = demixing_matrix, i, mixing_matrix, ms_encoder, ret
	if streams == libc.UintptrFromInt32(0) || coupled_streams == libc.UintptrFromInt32(0) {
		return -int32(1)
	}
	if get_streams_from_channels(tls, channels, mapping_family, streams, coupled_streams, bp) != OPUS_OK {
		return -int32(1)
	}
	if mapping_family == int32(3) {
		/* Assign mixing matrix based on available pre-computed matrices. */
		mixing_matrix = get_mixing_matrix(tls, st)
		if *(*int32)(unsafe.Pointer(bp)) == int32(2) {
			Opus_mapping_matrix_init(tls, mixing_matrix, Opus_mapping_matrix_foa_mixing.Frows, Opus_mapping_matrix_foa_mixing.Fcols, Opus_mapping_matrix_foa_mixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_foa_mixing_data)), int32(72))
		} else {
			if *(*int32)(unsafe.Pointer(bp)) == int32(3) {
				Opus_mapping_matrix_init(tls, mixing_matrix, Opus_mapping_matrix_soa_mixing.Frows, Opus_mapping_matrix_soa_mixing.Fcols, Opus_mapping_matrix_soa_mixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_soa_mixing_data)), int32(242))
			} else {
				if *(*int32)(unsafe.Pointer(bp)) == int32(4) {
					Opus_mapping_matrix_init(tls, mixing_matrix, Opus_mapping_matrix_toa_mixing.Frows, Opus_mapping_matrix_toa_mixing.Fcols, Opus_mapping_matrix_toa_mixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_toa_mixing_data)), int32(648))
				} else {
					if *(*int32)(unsafe.Pointer(bp)) == int32(5) {
						Opus_mapping_matrix_init(tls, mixing_matrix, Opus_mapping_matrix_fourthoa_mixing.Frows, Opus_mapping_matrix_fourthoa_mixing.Fcols, Opus_mapping_matrix_fourthoa_mixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_fourthoa_mixing_data)), int32(1458))
					} else {
						if *(*int32)(unsafe.Pointer(bp)) == int32(6) {
							Opus_mapping_matrix_init(tls, mixing_matrix, Opus_mapping_matrix_fifthoa_mixing.Frows, Opus_mapping_matrix_fifthoa_mixing.Fcols, Opus_mapping_matrix_fifthoa_mixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_fifthoa_mixing_data)), int32(2888))
						} else {
							return -int32(1)
						}
					}
				}
			}
		}
		(*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fmixing_matrix_size_in_bytes = Opus_mapping_matrix_get_size(tls, (*OpusT_MappingMatrix)(unsafe.Pointer(mixing_matrix)).Frows, (*OpusT_MappingMatrix)(unsafe.Pointer(mixing_matrix)).Fcols)
		if !((*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fmixing_matrix_size_in_bytes != 0) {
			return -int32(1)
		}
		/* Assign demixing matrix based on available pre-computed matrices. */
		demixing_matrix = get_enc_demixing_matrix(tls, st)
		if *(*int32)(unsafe.Pointer(bp)) == int32(2) {
			Opus_mapping_matrix_init(tls, demixing_matrix, Opus_mapping_matrix_foa_demixing.Frows, Opus_mapping_matrix_foa_demixing.Fcols, Opus_mapping_matrix_foa_demixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_foa_demixing_data)), int32(72))
		} else {
			if *(*int32)(unsafe.Pointer(bp)) == int32(3) {
				Opus_mapping_matrix_init(tls, demixing_matrix, Opus_mapping_matrix_soa_demixing.Frows, Opus_mapping_matrix_soa_demixing.Fcols, Opus_mapping_matrix_soa_demixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_soa_demixing_data)), int32(242))
			} else {
				if *(*int32)(unsafe.Pointer(bp)) == int32(4) {
					Opus_mapping_matrix_init(tls, demixing_matrix, Opus_mapping_matrix_toa_demixing.Frows, Opus_mapping_matrix_toa_demixing.Fcols, Opus_mapping_matrix_toa_demixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_toa_demixing_data)), int32(648))
				} else {
					if *(*int32)(unsafe.Pointer(bp)) == int32(5) {
						Opus_mapping_matrix_init(tls, demixing_matrix, Opus_mapping_matrix_fourthoa_demixing.Frows, Opus_mapping_matrix_fourthoa_demixing.Fcols, Opus_mapping_matrix_fourthoa_demixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_fourthoa_demixing_data)), int32(1458))
					} else {
						if *(*int32)(unsafe.Pointer(bp)) == int32(6) {
							Opus_mapping_matrix_init(tls, demixing_matrix, Opus_mapping_matrix_fifthoa_demixing.Frows, Opus_mapping_matrix_fifthoa_demixing.Fcols, Opus_mapping_matrix_fifthoa_demixing.Fgain, uintptr(unsafe.Pointer(&Opus_mapping_matrix_fifthoa_demixing_data)), int32(2888))
						} else {
							return -int32(1)
						}
					}
				}
			}
		}
		(*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fdemixing_matrix_size_in_bytes = Opus_mapping_matrix_get_size(tls, (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Frows, (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Fcols)
		if !((*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fdemixing_matrix_size_in_bytes != 0) {
			return -int32(1)
		}
	} else {
		return -int32(5)
	}
	/* Ensure matrices are large enough for desired coding scheme. */
	if *(*int32)(unsafe.Pointer(streams))+*(*int32)(unsafe.Pointer(coupled_streams)) > (*OpusT_MappingMatrix)(unsafe.Pointer(mixing_matrix)).Frows || channels > (*OpusT_MappingMatrix)(unsafe.Pointer(mixing_matrix)).Fcols || channels > (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Frows || *(*int32)(unsafe.Pointer(streams))+*(*int32)(unsafe.Pointer(coupled_streams)) > (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Fcols {
		return -int32(1)
	}
	/* Set trivial mapping so each input channel pairs with a matrix column. */
	i = 0
	for {
		if !(i < channels) {
			break
		}
		(*(*[255]uint8)(unsafe.Pointer(bp + 4)))[i] = libc.Uint8FromInt32(i)
		goto _1
	_1:
		;
		i = i + 1
	}
	/* Initialize multistream encoder with provided settings. */
	ms_encoder = get_multistream_encoder(tls, st)
	ret = Opus_opus_multistream_encoder_init(tls, ms_encoder, Fs, channels, *(*int32)(unsafe.Pointer(streams)), *(*int32)(unsafe.Pointer(coupled_streams)), bp+4, application)
	return ret
}

func Opus_opus_projection_decode(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_short), frame_size, decode_fec, int32(OPTIONAL_CLIP), get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decode24(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_int24), frame_size, decode_fec, 0, get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decode_float(tls *libc.TLS, st uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	return Opus_opus_multistream_decode_native(tls, get_multistream_decoder(tls, st), data, len1, pcm, __ccgo_fp(opus_projection_copy_channel_out_float), frame_size, decode_fec, 0, get_dec_demixing_matrix(tls, st))
}

func Opus_opus_projection_decoder_create(tls *libc.TLS, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, demixing_matrix uintptr, demixing_matrix_size OpusT_opus_int32, error1 uintptr) (r uintptr) {
	var ret, size1 int32
	var st, v1 uintptr
	_, _, _, _ = ret, size1, st, v1
	/* Allocate space for the projection decoder. */
	size1 = Opus_opus_projection_decoder_get_size(tls, channels, streams, coupled_streams)
	if !(size1 != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(size1))
	goto _2
_2:
	st = v1
	if !(st != 0) {
		if error1 != 0 {
			*(*int32)(unsafe.Pointer(error1)) = -int32(7)
		}
		return libc.UintptrFromInt32(0)
	}
	/* Initialize projection decoder with provided settings. */
	ret = Opus_opus_projection_decoder_init(tls, st, Fs, channels, streams, coupled_streams, demixing_matrix, demixing_matrix_size)
	if ret != OPUS_OK {
		libc.Xfree(tls, st)
		st = libc.UintptrFromInt32(0)
	}
	if error1 != 0 {
		*(*int32)(unsafe.Pointer(error1)) = ret
	}
	return st
}

func Opus_opus_projection_decoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var ret int32
	_, _ = ap, ret
	ret = OPUS_OK
	ap = va
	ret = Opus_opus_multistream_decoder_ctl_va_list(tls, get_multistream_decoder(tls, st), request, ap)
	_ = ap
	return ret
}

func Opus_opus_projection_decoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

const CELT_SIG_SCALE5 = 32768

var trim_icdf10 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf10 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf10 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

func Opus_opus_projection_decoder_get_size(tls *libc.TLS, channels int32, streams int32, coupled_streams int32) (r OpusT_opus_int32) {
	var alignment uint32
	var decoder_size, matrix_size OpusT_opus_int32
	var v1 int32
	_, _, _, _ = alignment, decoder_size, matrix_size, v1
	matrix_size = Opus_mapping_matrix_get_size(tls, streams+coupled_streams, channels)
	if !(matrix_size != 0) {
		return 0
	}
	decoder_size = Opus_opus_multistream_decoder_get_size(tls, streams, coupled_streams)
	if !(decoder_size != 0) {
		return 0
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(4)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return v1 + matrix_size + decoder_size
}

func Opus_opus_projection_decoder_init(tls *libc.TLS, st1 uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, demixing_matrix uintptr, demixing_matrix_size OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var _saved_stack, buf, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var expected_matrix_size OpusT_opus_int32
	var i, nb_input_streams, ret, s int32
	var _ /* mapping at bp+0 */ [255]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, buf, expected_matrix_size, i, nb_input_streams, ret, s, st, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Verify supplied matrix size. */
	nb_input_streams = streams + coupled_streams
	expected_matrix_size = libc.Int32FromUint64(libc.Uint64FromInt32(nb_input_streams*channels) * uint64(2))
	if expected_matrix_size != demixing_matrix_size {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	/* Convert demixing matrix input into internal format. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(2) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(2) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nb_input_streams*channels)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3357, int32(167))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(nb_input_streams*channels) * (libc.Uint64FromInt64(2) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _54
_54:
	buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nb_input_streams*channels)*(libc.Uint64FromInt64(2)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < nb_input_streams*channels) {
			break
		}
		s = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(demixing_matrix + uintptr(int32(2)*i+int32(1)))))<<int32(8) | libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(demixing_matrix + uintptr(int32(2)*i))))
		s = s&int32(0xFFFF) ^ int32(0x8000) - int32(0x8000)
		*(*OpusT_opus_int16)(unsafe.Pointer(buf + uintptr(i)*2)) = int16(s)
		goto _55
	_55:
		;
		i = i + 1
	}
	/* Assign demixing matrix. */
	(*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st1)).Fdemixing_matrix_size_in_bytes = Opus_mapping_matrix_get_size(tls, channels, nb_input_streams)
	if !((*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st1)).Fdemixing_matrix_size_in_bytes != 0) {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _57
		_57:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _59
	_59:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	Opus_mapping_matrix_init(tls, get_dec_demixing_matrix(tls, st1), channels, nb_input_streams, 0, buf, demixing_matrix_size)
	/* Set trivial mapping so each input channel pairs with a matrix column. */
	i = 0
	for {
		if !(i < channels) {
			break
		}
		(*(*[255]uint8)(unsafe.Pointer(bp)))[i] = libc.Uint8FromInt32(i)
		goto _60
	_60:
		;
		i = i + 1
	}
	ret = Opus_opus_multistream_decoder_init(tls, get_multistream_decoder(tls, st1), Fs, channels, streams, coupled_streams, bp)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _64
_64:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func Opus_opus_projection_encode(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, get_multistream_encoder(tls, st), __ccgo_fp(opus_projection_copy_channel_in_short), pcm, frame_size, data, max_data_bytes, int32(16), __ccgo_fp(Opus_downmix_int), 0, get_mixing_matrix(tls, st))
}

func Opus_opus_projection_encode24(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, get_multistream_encoder(tls, st), __ccgo_fp(opus_projection_copy_channel_in_int24), pcm, frame_size, data, max_data_bytes, int32(MAX_ENCODING_DEPTH), __ccgo_fp(Opus_downmix_int), 0, get_mixing_matrix(tls, st))
}

func Opus_opus_projection_encode_float(tls *libc.TLS, st uintptr, pcm uintptr, frame_size int32, data uintptr, max_data_bytes OpusT_opus_int32) (r int32) {
	return Opus_opus_multistream_encode_native(tls, get_multistream_encoder(tls, st), __ccgo_fp(opus_projection_copy_channel_in_float), pcm, frame_size, data, max_data_bytes, int32(MAX_ENCODING_DEPTH), __ccgo_fp(Opus_downmix_float), int32(1), get_mixing_matrix(tls, st))
}

func Opus_opus_projection_encoder_ctl(tls *libc.TLS, st uintptr, request int32, va uintptr) (r int32) {
	var ap OpusT_va_list
	var demixing_matrix, external_char, internal_short, ms_encoder, value, value1 uintptr
	var external_size, internal_size OpusT_opus_int32
	var i, j, k, l, nb_input_streams, nb_output_streams, ret int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ap, demixing_matrix, external_char, external_size, i, internal_short, internal_size, j, k, l, ms_encoder, nb_input_streams, nb_output_streams, ret, value, value1
	ret = OPUS_OK
	ms_encoder = get_multistream_encoder(tls, st)
	demixing_matrix = get_enc_demixing_matrix(tls, st)
	ap = va
	switch request {
	case int32(OPUS_PROJECTION_GET_DEMIXING_MATRIX_SIZE_REQUEST):
		value = libc.VaUintptr(&ap)
		if !(value != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value)) = libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_channels*((*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_streams+(*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_coupled_streams)) * uint64(2))
	case int32(OPUS_PROJECTION_GET_DEMIXING_MATRIX_GAIN_REQUEST):
		value1 = libc.VaUintptr(&ap)
		if !(value1 != 0) {
			goto bad_arg
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(value1)) = (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Fgain
	case int32(OPUS_PROJECTION_GET_DEMIXING_MATRIX_REQUEST):
		/* (I/O is in relation to the decoder's perspective). */
		nb_input_streams = (*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_streams + (*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_coupled_streams
		nb_output_streams = (*OpusT_OpusMSEncoder)(unsafe.Pointer(ms_encoder)).Flayout.Fnb_channels
		external_char = libc.VaUintptr(&ap)
		external_size = libc.VaInt32(&ap)
		if !(external_char != 0) {
			goto bad_arg
		}
		internal_short = Opus_mapping_matrix_get_data(tls, demixing_matrix)
		internal_size = libc.Int32FromUint64(libc.Uint64FromInt32(nb_input_streams*nb_output_streams) * uint64(2))
		if external_size != internal_size {
			goto bad_arg
		}
		/* Copy demixing matrix subset to output destination. */
		l = 0
		i = 0
		for {
			if !(i < nb_input_streams) {
				break
			}
			j = 0
			for {
				if !(j < nb_output_streams) {
					break
				}
				k = (*OpusT_MappingMatrix)(unsafe.Pointer(demixing_matrix)).Frows*i + j
				*(*uint8)(unsafe.Pointer(external_char + uintptr(int32(2)*l))) = libc.Uint8FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(internal_short + uintptr(k)*2)))
				*(*uint8)(unsafe.Pointer(external_char + uintptr(int32(2)*l+int32(1)))) = libc.Uint8FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(internal_short + uintptr(k)*2))) >> libc.Int32FromInt32(8))
				l = l + 1
				goto _2
			_2:
				;
				j = j + 1
			}
			goto _1
		_1:
			;
			i = i + 1
		}
	default:
		ret = Opus_opus_multistream_encoder_ctl_va_list(tls, ms_encoder, request, ap)
		break
	}
	_ = ap
	return ret
	goto bad_arg
bad_arg:
	;
	_ = ap
	return -int32(1)
}

var log2_x_norm_coeff5 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff5 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf9 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf9 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf9 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

type OpusT_OpusProjectionDecoder = struct {
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

type OpusProjectionDecoder = struct {
	Fdemixing_matrix_size_in_bytes OpusT_opus_int32
}

func Opus_opus_projection_encoder_destroy(tls *libc.TLS, st uintptr) {
	libc.Xfree(tls, st)
}

func Opus_opus_repacketizer_cat(tls *libc.TLS, rp uintptr, data uintptr, len1 OpusT_opus_int32) (r int32) {
	return opus_repacketizer_cat_impl(tls, rp, data, len1, 0)
}

func Opus_opus_repacketizer_create(tls *libc.TLS) (r uintptr) {
	var rp, v1 uintptr
	_, _ = rp, v1
	v1 = libc.Xmalloc(tls, libc.Uint64FromInt32(Opus_opus_repacketizer_get_size(tls)))
	goto _2
_2:
	rp = v1
	if rp == libc.UintptrFromInt32(0) {
		return libc.UintptrFromInt32(0)
	}
	return Opus_opus_repacketizer_init(tls, rp)
}

func Opus_opus_repacketizer_destroy(tls *libc.TLS, rp uintptr) {
	libc.Xfree(tls, rp)
}

func Opus_opus_repacketizer_get_nb_frames(tls *libc.TLS, rp uintptr) (r int32) {
	return (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames
}

func Opus_opus_repacketizer_get_size(tls *libc.TLS) (r int32) {
	return int32(1120)
}

func Opus_opus_repacketizer_init(tls *libc.TLS, rp uintptr) (r uintptr) {
	(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames = 0
	return rp
}

func Opus_opus_repacketizer_out(tls *libc.TLS, rp uintptr, data uintptr, maxlen OpusT_opus_int32) (r OpusT_opus_int32) {
	return Opus_opus_repacketizer_out_range_impl(tls, rp, 0, (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames, data, maxlen, 0, 0, libc.UintptrFromInt32(0), 0)
}

func Opus_opus_repacketizer_out_range(tls *libc.TLS, rp uintptr, begin int32, end int32, data uintptr, maxlen OpusT_opus_int32) (r OpusT_opus_int32) {
	return Opus_opus_repacketizer_out_range_impl(tls, rp, begin, end, data, maxlen, 0, 0, libc.UintptrFromInt32(0), 0)
}

func Opus_opus_repacketizer_out_range_impl(tls *libc.TLS, rp uintptr, begin int32, end int32, data uintptr, maxlen OpusT_opus_int32, self_delimited int32, pad int32, extensions uintptr, nb_extensions int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, all_extensions, frames, len1, ptr, st, v1, v10, v12, v14, v16, v19, v21, v23, v25, v3, v5, v7 uintptr
	var count, ext_begin, ext_count, ext_len, i, j, n, nb_255s, ones_begin, ones_end, pad_amount, ret, ret1, sdlen, total_ext_count, vbr, v18, v31, v36 int32
	var tot_size OpusT_opus_int32
	var _ /* frame_ext_count at bp+0 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, all_extensions, count, ext_begin, ext_count, ext_len, frames, i, j, len1, n, nb_255s, ones_begin, ones_end, pad_amount, ptr, ret, ret1, sdlen, st, tot_size, total_ext_count, vbr, v1, v10, v12, v14, v16, v18, v19, v21, v23, v25, v3, v31, v36, v5, v7
	ones_begin = 0
	ones_end = 0
	ext_begin = 0
	ext_len = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if begin < 0 || begin >= end || end > (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames {
		/*fprintf(stderr, "%d %d %d\n", begin, end, rp->nb_frames);*/
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _6
		_6:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _8
	_8:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	}
	count = end - begin
	len1 = rp + 392 + uintptr(begin)*2
	frames = rp + 8 + uintptr(begin)*8
	if self_delimited != 0 {
		tot_size = int32(1) + libc.BoolInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(count-int32(1))*2))) >= int32(252))
	} else {
		tot_size = 0
	}
	/* figure out total number of extensions */
	total_ext_count = nb_extensions
	i = begin
	for {
		if !(i < end) {
			break
		}
		n = Opus_opus_packet_extensions_count(tls, *(*uintptr)(unsafe.Pointer(rp + 496 + uintptr(i)*8)), *(*OpusT_opus_int32)(unsafe.Pointer(rp + 880 + uintptr(i)*4)), libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(rp + 1072 + uintptr(i)))))
		if n > 0 {
			total_ext_count = total_ext_count + n
		}
		goto _9
	_9:
		;
		i = i + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _13
_13:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _17
_17:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(8) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(8) - libc.Uint64FromInt32(1)))
	if total_ext_count != 0 {
		v18 = total_ext_count
	} else {
		v18 = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _20
	_20:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _22
_22:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _26
_26:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(v18)*(libc.Uint64FromInt64(24)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3262, int32(151))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _30
_30:
	if total_ext_count != 0 {
		v31 = total_ext_count
	} else {
		v31 = ALLOC_NONE
	}
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(v31) * (libc.Uint64FromInt64(24) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _33
	_33:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _35
_35:
	if total_ext_count != 0 {
		v36 = total_ext_count
	} else {
		v36 = ALLOC_NONE
	}
	all_extensions = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(v36)*(libc.Uint64FromInt64(24)/libc.Uint64FromInt64(1)))
	/* copy over any extensions that were passed in */
	ext_count = 0
	for {
		if !(ext_count < nb_extensions) {
			break
		}
		*(*OpusT_opus_extension_data)(unsafe.Pointer(all_extensions + uintptr(ext_count)*24)) = *(*OpusT_opus_extension_data)(unsafe.Pointer(extensions + uintptr(ext_count)*24))
		goto _37
	_37:
		;
		ext_count = ext_count + 1
	}
	/* incorporate any extensions from the repacketizer padding */
	i = begin
	for {
		if !(i < end) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(bp)) = total_ext_count - ext_count
		ret = Opus_opus_packet_extensions_parse(tls, *(*uintptr)(unsafe.Pointer(rp + 496 + uintptr(i)*8)), *(*OpusT_opus_int32)(unsafe.Pointer(rp + 880 + uintptr(i)*4)), all_extensions+uintptr(ext_count)*24, bp, libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(rp + 1072 + uintptr(i)))))
		if ret < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _40
			_40:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _42
		_42:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		/* renumber the extension frame numbers */
		j = 0
		for {
			if !(j < *(*OpusT_opus_int32)(unsafe.Pointer(bp))) {
				break
			}
			(*(*OpusT_opus_extension_data)(unsafe.Pointer(all_extensions + uintptr(ext_count+j)*24))).Fframe += i - begin
			goto _43
		_43:
			;
			j = j + 1
		}
		ext_count = ext_count + *(*OpusT_opus_int32)(unsafe.Pointer(bp))
		goto _38
	_38:
		;
		i = i + 1
	}
	ptr = data
	if count == int32(1) {
		/* Code 0 */
		tot_size = tot_size + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) + int32(1))
		if tot_size > maxlen {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _45
			_45:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _47
		_47:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(2)
		}
		v1 = ptr
		ptr = ptr + 1
		*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc) & int32(0xFC))
	} else {
		if count == int32(2) {
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + 1*2))) == int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) {
				/* Code 1 */
				tot_size = tot_size + (int32(2)*int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) + int32(1))
				if tot_size > maxlen {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _50
					_50:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _52
				_52:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return -int32(2)
				}
				v1 = ptr
				ptr = ptr + 1
				*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc)&int32(0xFC) | int32(0x1))
			} else {
				/* Code 2 */
				tot_size = tot_size + (int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + 1*2))) + int32(2) + libc.BoolInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) >= int32(252)))
				if tot_size > maxlen {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _55
					_55:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _57
				_57:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return -int32(2)
				}
				v1 = ptr
				ptr = ptr + 1
				*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc)&int32(0xFC) | int32(0x2))
				ptr = ptr + uintptr(Opus_encode_size(tls, int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))), ptr))
			}
		}
	}
	if count > int32(2) || pad != 0 && tot_size < maxlen || ext_count > 0 {
		pad_amount = 0
		/* Restart the process for the padding case */
		ptr = data
		if self_delimited != 0 {
			tot_size = int32(1) + libc.BoolInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(count-int32(1))*2))) >= int32(252))
		} else {
			tot_size = 0
		}
		vbr = 0
		i = int32(1)
		for {
			if !(i < count) {
				break
			}
			if int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2))) != int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) {
				vbr = int32(1)
				break
			}
			goto _59
		_59:
			;
			i = i + 1
		}
		if vbr != 0 {
			tot_size = tot_size + int32(2)
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				tot_size = tot_size + (int32(1) + libc.BoolInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2))) >= int32(252)) + int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2))))
				goto _60
			_60:
				;
				i = i + 1
			}
			tot_size = tot_size + int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(count-int32(1))*2)))
			if tot_size > maxlen {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _62
				_62:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _64
			_64:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(2)
			}
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc)&int32(0xFC) | int32(0x3))
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(count | int32(0x80))
		} else {
			tot_size = tot_size + (count*int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1))) + int32(2))
			if tot_size > maxlen {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _68
				_68:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _70
			_70:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(2)
			}
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc)&int32(0xFC) | int32(0x3))
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(count)
		}
		if pad != 0 {
			v18 = maxlen - tot_size
		} else {
			v18 = 0
		}
		pad_amount = v18
		if ext_count > 0 {
			/* figure out how much space we need for the extensions */
			ext_len = Opus_opus_packet_extensions_generate(tls, libc.UintptrFromInt32(0), maxlen-tot_size, all_extensions, ext_count, count, 0)
			if ext_len < 0 {
				return ext_len
			}
			if !(pad != 0) {
				if ext_len != 0 {
					v18 = (ext_len + int32(253)) / int32(254)
				} else {
					v18 = int32(1)
				}
				pad_amount = ext_len + v18
			}
		}
		if pad_amount != 0 {
			v1 = data + 1
			*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(v1))) | libc.Int32FromInt32(0x40))
			nb_255s = (pad_amount - int32(1)) / int32(255)
			if tot_size+ext_len+nb_255s+int32(1) > maxlen {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _77
				_77:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _79
			_79:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(2)
			}
			ext_begin = tot_size + pad_amount - ext_len
			/* Prepend 0x01 padding */
			ones_begin = tot_size + nb_255s + int32(1)
			ones_end = tot_size + pad_amount - ext_len
			i = 0
			for {
				if !(i < nb_255s) {
					break
				}
				v1 = ptr
				ptr = ptr + 1
				*(*uint8)(unsafe.Pointer(v1)) = uint8(255)
				goto _80
			_80:
				;
				i = i + 1
			}
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = libc.Uint8FromInt32(pad_amount - int32(255)*nb_255s - int32(1))
			tot_size = tot_size + pad_amount
		}
		if vbr != 0 {
			i = 0
			for {
				if !(i < count-int32(1)) {
					break
				}
				ptr = ptr + uintptr(Opus_encode_size(tls, int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2))), ptr))
				goto _83
			_83:
				;
				i = i + 1
			}
		}
	}
	if self_delimited != 0 {
		sdlen = Opus_encode_size(tls, int32(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(count-int32(1))*2))), ptr)
		ptr = ptr + uintptr(sdlen)
	}
	/* Copy the actual data */
	i = 0
	for {
		if !(i < count) {
			break
		}
		/* Using OPUS_MOVE() instead of OPUS_COPY() in case we're doing in-place
		   padding from opus_packet_pad or opus_packet_unpad(). */
		/* assert disabled because it's not valid in C. */
		/* celt_assert(frames[i] + len[i] <= data || ptr <= frames[i]); */
		libc.Xmemmove(tls, ptr, *(*uintptr)(unsafe.Pointer(frames + uintptr(i)*8)), libc.Uint64FromInt16(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2)))*uint64(1)+libc.Uint64FromInt64(0*(int64(ptr)-int64(*(*uintptr)(unsafe.Pointer(frames + uintptr(i)*8))))))
		ptr = ptr + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer(len1 + uintptr(i)*2)))
		goto _84
	_84:
		;
		i = i + 1
	}
	if ext_len > 0 {
		ret1 = Opus_opus_packet_extensions_generate(tls, data+uintptr(ext_begin), ext_len, all_extensions, ext_count, count, 0)
		if !(ret1 == ext_len) {
			Opus_celt_fatal(tls, __ccgo_ts+3284, __ccgo_ts+3262, int32(311))
		}
	}
	i = ones_begin
	for {
		if !(i < ones_end) {
			break
		}
		*(*uint8)(unsafe.Pointer(data + uintptr(i))) = uint8(0x01)
		goto _85
	_85:
		;
		i = i + 1
	}
	if pad != 0 && ext_count == 0 {
		/* Fill padding with zeros. */
		for ptr < data+uintptr(maxlen) {
			v1 = ptr
			ptr = ptr + 1
			*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _88
	_88:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _90
_90:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return tot_size
}

func Opus_opus_strerror(tls *libc.TLS, error1 int32) (r uintptr) {
	if error1 > 0 || error1 < -int32(7) {
		return __ccgo_ts + 4056
	} else {
		return error_strings[-error1]
	}
	return r
}

var error_strings = [8]uintptr{
	0: __ccgo_ts + 3919,
	1: __ccgo_ts + 3927,
	2: __ccgo_ts + 3944,
	3: __ccgo_ts + 3961,
	4: __ccgo_ts + 3976,
	5: __ccgo_ts + 3993,
	6: __ccgo_ts + 4017,
	7: __ccgo_ts + 4031,
}

func Opus_pitch_downsample(tls *libc.TLS, x uintptr, x_lp uintptr, len1 int32, C int32, factor int32, arch int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var c1, tmp OpusT_opus_val16
	var i, offset int32
	var _ /* ac at bp+0 */ [5]OpusT_opus_val32
	var _ /* lpc at bp+20 */ [4]OpusT_opus_val16
	var _ /* lpc2 at bp+36 */ [5]OpusT_opus_val16
	_, _, _, _ = c1, i, offset, tmp
	tmp = libc.Float32FromFloat32(1)
	c1 = libc.Float32FromFloat32(0.8)
	offset = factor / int32(2)
	i = int32(1)
	for {
		if !(i < len1) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i-offset)*4))) + float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i+offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(factor*i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	*(*OpusT_opus_val16)(unsafe.Pointer(x_lp)) = float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)) + uintptr(offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x)))))
	if C == int32(2) {
		i = int32(1)
		for {
			if !(i < len1) {
				break
			}
			*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4)) += float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i-offset)*4))) + float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i+offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(factor*i)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp)) += float32(libc.Float32FromFloat32(0.25)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)) + uintptr(offset)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(x + 1*8)))))
	}
	Opus__celt_autocorr(tls, x_lp, bp, libc.UintptrFromInt32(0), 0, int32(4), len1, arch)
	/* Noise floor -40 dB */
	*(*OpusT_opus_val32)(unsafe.Pointer(bp)) *= libc.Float32FromFloat32(1.0001)
	/* Lag windowing */
	i = int32(1)
	for {
		if !(i <= int32(4)) {
			break
		}
		/*ac[i] *= exp(-.5*(2*M_PI*.002*i)*(2*M_PI*.002*i));*/
		*(*OpusT_opus_val32)(unsafe.Pointer(bp + uintptr(i)*4)) -= OpusT_opus_val32(OpusT_opus_val32((*(*[5]OpusT_opus_val32)(unsafe.Pointer(bp)))[i]*float32(libc.Float32FromFloat32(0.008)*float32(i))) * float32(libc.Float32FromFloat32(0.008)*float32(i)))
		goto _3
	_3:
		;
		i = i + 1
	}
	Opus__celt_lpc(tls, bp+20, bp, int32(4))
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		tmp = float32(libc.Float32FromFloat32(0.9) * tmp)
		(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[i] = OpusT_opus_val16((*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[i] * tmp)
		goto _4
	_4:
		;
		i = i + 1
	}
	/* Add a zero */
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[0] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[0] + libc.Float32FromFloat32(0.8)
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(1)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(1)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[0])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(2)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(2)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(1)])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(3)] = (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(3)] + OpusT_opus_val16(c1*(*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(2)])
	(*(*[5]OpusT_opus_val16)(unsafe.Pointer(bp + 36)))[int32(4)] = OpusT_opus_val16(c1 * (*(*[4]OpusT_opus_val16)(unsafe.Pointer(bp + 20)))[int32(3)])
	celt_fir5(tls, x_lp, bp+36, len1)
}

// C documentation
//
//	/* Pure C implementation. */

func Opus_pitch_search(tls *libc.TLS, x_lp uintptr, y1 uintptr, len1 int32, max_pitch int32, pitch uintptr, arch int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, st, x_lp4, xcorr, y_lp4, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var a, b, c, sum, xy, v81 OpusT_opus_val32
	var i, i1, j, lag, offset int32
	var _ /* best_pitch at bp+0 */ [2]int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, a, b, c, i, i1, j, lag, offset, st, sum, x_lp4, xcorr, xy, y_lp4, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v81, v9
	*(*[2]int32)(unsafe.Pointer(bp)) = [2]int32{}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !(len1 > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5906, __ccgo_ts+5849, int32(325))
	}
	if !(max_pitch > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5819, __ccgo_ts+5849, int32(326))
	}
	lag = len1 + max_pitch
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5849, int32(329))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	x_lp4 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5849, int32(330))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	y_lp4 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(lag>>libc.Int32FromInt32(2))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5849, int32(331))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	xcorr = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(max_pitch>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Downsample by 2 again */
	j = 0
	for {
		if !(j < len1>>int32(2)) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(x_lp4 + uintptr(j)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(int32(2)*j)*4))
		goto _77
	_77:
		;
		j = j + 1
	}
	j = 0
	for {
		if !(j < lag>>int32(2)) {
			break
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(y_lp4 + uintptr(j)*4)) = *(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(int32(2)*j)*4))
		goto _78
	_78:
		;
		j = j + 1
	}
	/* Coarse search with 4x decimation */
	Opus_celt_pitch_xcorr_c(tls, x_lp4, y_lp4, xcorr, len1>>int32(2), max_pitch>>int32(2), arch)
	find_best_pitch(tls, xcorr, y_lp4, len1>>int32(2), max_pitch>>int32(2), bp)
	/* Finer search with 2x decimation */
	i1 = 0
	for {
		if !(i1 < max_pitch>>int32(1)) {
			break
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = libc.Float32FromInt32(0)
		if libc.Xabs(tls, i1-int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[0]) > int32(2) && libc.Xabs(tls, i1-int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[int32(1)]) > int32(2) {
			goto _79
		}
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < len1>>int32(1)) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x_lp + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y1 + uintptr(i1)*4 + uintptr(i)*4)))
			goto _80
		_80:
			;
			i = i + 1
		}
		v81 = xy
		goto _82
	_82:
		sum = v81
		if float32(-libc.Int32FromInt32(1)) > sum {
			v81 = float32(-libc.Int32FromInt32(1))
		} else {
			v81 = sum
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i1)*4)) = v81
		goto _79
	_79:
		;
		i1 = i1 + 1
	}
	find_best_pitch(tls, xcorr, y1, len1>>int32(1), max_pitch>>int32(1), bp)
	/* Refine by pseudo-interpolation */
	if (*(*[2]int32)(unsafe.Pointer(bp)))[0] > 0 && (*(*[2]int32)(unsafe.Pointer(bp)))[0] < max_pitch>>int32(1)-int32(1) {
		a = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0]-int32(1))*4))
		b = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0])*4))
		c = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr((*(*[2]int32)(unsafe.Pointer(bp)))[0]+int32(1))*4))
		if c-a > float32(libc.Float32FromFloat32(0.7)*(b-a)) {
			offset = int32(1)
		} else {
			if a-c > float32(libc.Float32FromFloat32(0.7)*(b-c)) {
				offset = -int32(1)
			} else {
				offset = 0
			}
		}
	} else {
		offset = 0
	}
	*(*int32)(unsafe.Pointer(pitch)) = int32(2)*(*(*[2]int32)(unsafe.Pointer(bp)))[0] - offset
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _85
	_85:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _87
_87:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_quant_all_bands(tls *libc.TLS, encode int32, m uintptr, start int32, end int32, X_ uintptr, Y_ uintptr, collapse_masks uintptr, bandE uintptr, pulses uintptr, shortBlocks int32, spread int32, dual_stereo int32, intensity int32, tf_res uintptr, total_bits OpusT_opus_int32, balance OpusT_opus_int32, ec uintptr, LM int32, codedBands int32, seed uintptr, complexity int32, arch int32, disable_inv int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var B, C, M, N1, b, effective_lowband, fold_end, fold_i, fold_start, i, i1, j, last, lowband_offset, nend_bytes, norm_offset, nstart_bytes, resynth, resynth_alloc, save_bytes, tf_change, theta_rdo, update_lowband, v1, v183, v196, v201, v203, v207, v6 int32
	var X, X_save, X_save2, Y, Y_save, Y_save2, _lowband_scratch, _norm, _saved_stack, bytes_buf, bytes_save, eBands, lowband_scratch, norm, norm2, norm_save2, st, v11, v13, v15, v17, v19, v2, v21, v23, v25, v4, v7, v9 uintptr
	var cm, cm2, x_cm, y_cm, v217 uint32
	var ctx_save, ctx_save2 band_ctx
	var curr_balance, remaining_bits, tell, v204, v205 OpusT_opus_int32
	var dist0, dist1, xy, v229, v232 OpusT_opus_val32
	var ec_save, ec_save2 OpusT_ec_ctx
	var _ /* ctx at bp+0 */ band_ctx
	var _ /* w at bp+80 */ [2]OpusT_opus_val16
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B, C, M, N1, X, X_save, X_save2, Y, Y_save, Y_save2, _lowband_scratch, _norm, _saved_stack, b, bytes_buf, bytes_save, cm, cm2, ctx_save, ctx_save2, curr_balance, dist0, dist1, eBands, ec_save, ec_save2, effective_lowband, fold_end, fold_i, fold_start, i, i1, j, last, lowband_offset, lowband_scratch, nend_bytes, norm, norm2, norm_offset, norm_save2, nstart_bytes, remaining_bits, resynth, resynth_alloc, save_bytes, st, tell, tf_change, theta_rdo, update_lowband, x_cm, xy, y_cm, v1, v11, v13, v15, v17, v183, v19, v196, v2, v201, v203, v204, v205, v207, v21, v217, v229, v23, v232, v25, v4, v6, v7, v9
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	update_lowband = int32(1)
	if Y_ != libc.UintptrFromInt32(0) {
		v1 = int32(2)
	} else {
		v1 = int32(1)
	}
	C = v1
	theta_rdo = libc.BoolInt32(encode != 0 && Y_ != libc.UintptrFromInt32(0) && !(dual_stereo != 0) && complexity >= int32(8))
	resynth = libc.BoolInt32(!(encode != 0) || theta_rdo != 0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _3
	_3:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _5
_5:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v4)).Fglobal_stack
	M = int32(1) << LM
	if shortBlocks != 0 {
		v1 = M
	} else {
		v1 = int32(1)
	}
	B = v1
	norm_offset = M * int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2)))
	/* No need to allocate norm for the last band because we don't need an
	   output in that band. */
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _8
	_8:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _10
_10:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _12
	_12:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _14
_14:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _16
	_16:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _18
_18:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _20
	_20:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _22
_22:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1638))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _26
_26:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _30
_30:
	_norm = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2)))-norm_offset))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	norm = _norm
	norm2 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2))))*4 - uintptr(norm_offset)*4
	/* For decoding, we can use the last band as scratch space because we don't need that
	   scratch space for the last band and we don't care about the data there until we're
	   decoding the last band. */
	if encode != 0 && resynth != 0 {
		resynth_alloc = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(1))*2))))
	} else {
		resynth_alloc = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _34
_34:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _38
_38:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _46
_46:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1649))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _50
_50:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _54
_54:
	_lowband_scratch = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if encode != 0 && resynth != 0 {
		lowband_scratch = _lowband_scratch
	} else {
		lowband_scratch = X_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeffEBands-int32(1))*2))))*4
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _56
	_56:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _58
_58:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _60
	_60:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _62
_62:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _64
	_64:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _66
_66:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _70
_70:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1654))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _72
	_72:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _74
_74:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _76
	_76:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _78
_78:
	X_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _82
_82:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _86
_86:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _88
	_88:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _90
_90:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _92
	_92:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _94
_94:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1655))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _96
	_96:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _98
_98:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _100
	_100:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _102
_102:
	Y_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _104
	_104:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _106
_106:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _108
	_108:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _110
_110:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _112
	_112:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _114
_114:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _116
	_116:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _118
_118:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1656))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _120
	_120:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _122
_122:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _126
_126:
	X_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _128
	_128:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _130
_130:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _132
	_132:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _134
_134:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _136
	_136:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _138
_138:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _140
	_140:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _142
_142:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1657))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _144
	_144:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _146
_146:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _148
	_148:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _150
_150:
	Y_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _152
	_152:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _154
_154:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _156
	_156:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _158
_158:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _160
	_160:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _162
_162:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _164
	_164:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _166
_166:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1658))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _168
	_168:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _170
_170:
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(resynth_alloc) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _172
	_172:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _174
_174:
	norm_save2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(resynth_alloc)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	lowband_offset = 0
	(*(*band_ctx)(unsafe.Pointer(bp))).FbandE = bandE
	(*(*band_ctx)(unsafe.Pointer(bp))).Fec = ec
	(*(*band_ctx)(unsafe.Pointer(bp))).Fencode = encode
	(*(*band_ctx)(unsafe.Pointer(bp))).Fintensity = intensity
	(*(*band_ctx)(unsafe.Pointer(bp))).Fm = m
	(*(*band_ctx)(unsafe.Pointer(bp))).Fseed = *(*OpusT_opus_uint32)(unsafe.Pointer(seed))
	(*(*band_ctx)(unsafe.Pointer(bp))).Fspread = spread
	(*(*band_ctx)(unsafe.Pointer(bp))).Farch = arch
	(*(*band_ctx)(unsafe.Pointer(bp))).Fdisable_inv = disable_inv
	(*(*band_ctx)(unsafe.Pointer(bp))).Fresynth = resynth
	(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _176
	_176:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _178
_178:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v7 = libc.Xmalloc(tls, uint64(16))
		goto _180
	_180:
		st = v7
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v9 = st
	goto _182
_182:
	*(*uintptr)(unsafe.Pointer(v4 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v9)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
	if theta_rdo != 0 {
		v1 = int32(1275)
	} else {
		v1 = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _185
	_185:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _187
_187:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _189
	_189:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _191
_191:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(v1)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(1679))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _193
	_193:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _195
_195:
	if theta_rdo != 0 {
		v6 = int32(1275)
	} else {
		v6 = ALLOC_NONE
	}
	*(*uintptr)(unsafe.Pointer(v21 + 8)) += uintptr(libc.Uint64FromInt32(v6) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _198
	_198:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _200
_200:
	if theta_rdo != 0 {
		v183 = int32(1275)
	} else {
		v183 = ALLOC_NONE
	}
	bytes_save = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v25)).Fglobal_stack - uintptr(libc.Uint64FromInt32(v183)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
	/* Avoid injecting noise in the first band on transients. */
	(*(*band_ctx)(unsafe.Pointer(bp))).Favoid_split_noise = libc.BoolInt32(B > int32(1))
	i1 = start
	for {
		if !(i1 < end) {
			break
		}
		effective_lowband = -int32(1)
		tf_change = 0
		(*(*band_ctx)(unsafe.Pointer(bp))).Fi = i1
		last = libc.BoolInt32(i1 == end-int32(1))
		X = X_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4
		if Y_ != libc.UintptrFromInt32(0) {
			Y = Y_ + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4
		} else {
			Y = libc.UintptrFromInt32(0)
		}
		N1 = M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1+int32(1))*2))) - M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))
		if !(N1 > libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+3837, __ccgo_ts+3661, int32(1705))
		}
		tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec))
		/* Compute how many bits we want to allocate to this band */
		if i1 != start {
			balance = balance - tell
		}
		remaining_bits = total_bits - tell - int32(1)
		(*(*band_ctx)(unsafe.Pointer(bp))).Fremaining_bits = remaining_bits
		if i1 <= codedBands-int32(1) {
			if int32(3) < codedBands-i1 {
				v1 = int32(3)
			} else {
				v1 = codedBands - i1
			}
			v204 = v1
			_ = v204 > libc.Int32FromInt32(0)
			v205 = balance / v204
			goto _206
		_206:
			curr_balance = v205
			if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
				v183 = remaining_bits + int32(1)
			} else {
				v183 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
			}
			if int32(16383) < v183 {
				v6 = int32(16383)
			} else {
				if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
					v196 = remaining_bits + int32(1)
				} else {
					v196 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
				}
				v6 = v196
			}
			if 0 > v6 {
				v1 = 0
			} else {
				if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
					v203 = remaining_bits + int32(1)
				} else {
					v203 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
				}
				if int32(16383) < v203 {
					v201 = int32(16383)
				} else {
					if remaining_bits+int32(1) < *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4))+curr_balance {
						v207 = remaining_bits + int32(1)
					} else {
						v207 = *(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + curr_balance
					}
					v201 = v207
				}
				v1 = v201
			}
			b = v1
		} else {
			b = 0
		}
		if resynth != 0 && (M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))-N1 >= M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))) || i1 == start+int32(1)) && (update_lowband != 0 || lowband_offset == 0) {
			lowband_offset = i1
		}
		if i1 == start+int32(1) {
			special_hybrid_folding(tls, m, norm, norm2, start, M, dual_stereo)
		}
		tf_change = *(*int32)(unsafe.Pointer(tf_res + uintptr(i1)*4))
		(*(*band_ctx)(unsafe.Pointer(bp))).Ftf_change = tf_change
		if i1 >= (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeffEBands {
			X = norm
			if Y_ != libc.UintptrFromInt32(0) {
				Y = norm
			}
			lowband_scratch = libc.UintptrFromInt32(0)
		}
		if last != 0 && !(theta_rdo != 0) {
			lowband_scratch = libc.UintptrFromInt32(0)
		}
		/* Get a conservative estimate of the collapse_mask's for the bands we're
		   going to be folding from. */
		if lowband_offset != 0 && (spread != int32(SPREAD_AGGRESSIVE) || B > int32(1) || tf_change < 0) {
			/* This ensures we never repeat spectral content within one band */
			if 0 > M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(lowband_offset)*2)))-norm_offset-N1 {
				v1 = 0
			} else {
				v1 = M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(lowband_offset)*2))) - norm_offset - N1
			}
			effective_lowband = v1
			fold_start = lowband_offset
			for {
				fold_start = fold_start - 1
				v1 = fold_start
				if !(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(v1)*2))) > effective_lowband+norm_offset) {
					break
				}
			}
			fold_end = lowband_offset - int32(1)
			for {
				fold_end = fold_end + 1
				v1 = fold_end
				if !(v1 < i1 && M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(fold_end)*2))) < effective_lowband+norm_offset+N1) {
					break
				}
			}
			v217 = libc.Uint32FromInt32(0)
			y_cm = v217
			x_cm = v217
			fold_i = fold_start
			for {
				x_cm = x_cm | uint32(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(fold_i*C+0))))
				y_cm = y_cm | uint32(*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(fold_i*C+C-int32(1)))))
				goto _219
			_219:
				;
				fold_i = fold_i + 1
				v1 = fold_i
				if !(v1 < fold_end) {
					break
				}
			}
		} else {
			v217 = libc.Uint32FromInt32(libc.Int32FromInt32(1)<<B - libc.Int32FromInt32(1))
			y_cm = v217
			x_cm = v217
		}
		if dual_stereo != 0 && i1 == intensity {
			/* Switch off dual stereo to do intensity. */
			dual_stereo = 0
			if resynth != 0 {
				j = 0
				for {
					if !(j < M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2)))-norm_offset) {
						break
					}
					*(*OpusT_celt_norm)(unsafe.Pointer(norm + uintptr(j)*4)) = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_celt_norm)(unsafe.Pointer(norm + uintptr(j)*4)) + *(*OpusT_celt_norm)(unsafe.Pointer(norm2 + uintptr(j)*4))))
					goto _221
				_221:
					;
					j = j + 1
				}
			}
		}
		if dual_stereo != 0 {
			if effective_lowband != -int32(1) {
				v2 = norm + uintptr(effective_lowband)*4
			} else {
				v2 = libc.UintptrFromInt32(0)
			}
			if last != 0 {
				v4 = libc.UintptrFromInt32(0)
			} else {
				v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
			}
			x_cm = quant_band(tls, bp, X, N1, b/int32(2), B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(x_cm))
			if effective_lowband != -int32(1) {
				v2 = norm2 + uintptr(effective_lowband)*4
			} else {
				v2 = libc.UintptrFromInt32(0)
			}
			if last != 0 {
				v4 = libc.UintptrFromInt32(0)
			} else {
				v4 = norm2 + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
			}
			y_cm = quant_band(tls, bp, Y, N1, b/int32(2), B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(y_cm))
		} else {
			if Y != libc.UintptrFromInt32(0) {
				if theta_rdo != 0 && i1 < intensity {
					compute_channel_weights(tls, *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1)*4)), *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i1+(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)), bp+80)
					/* Make a copy. */
					cm = x_cm | y_cm
					ec_save = *(*OpusT_ec_ctx)(unsafe.Pointer(ec))
					ctx_save = *(*band_ctx)(unsafe.Pointer(bp))
					libc.Xmemcpy(tls, X_save, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X_save)-int64(X))/4)))
					libc.Xmemcpy(tls, Y_save, Y, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y_save)-int64(Y))/4)))
					/* Encode and round down. */
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = -int32(1)
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(cm))
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
						goto _228
					_228:
						;
						i = i + 1
					}
					v229 = xy
					goto _230
				_230:
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
						goto _231
					_231:
						;
						i = i + 1
					}
					v232 = xy
					goto _233
				_233:
					dist0 = OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[0]*v229) + OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[int32(1)]*v232)
					/* Save first result. */
					cm2 = x_cm
					ec_save2 = *(*OpusT_ec_ctx)(unsafe.Pointer(ec))
					ctx_save2 = *(*band_ctx)(unsafe.Pointer(bp))
					libc.Xmemcpy(tls, X_save2, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X_save2)-int64(X))/4)))
					libc.Xmemcpy(tls, Y_save2, Y, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y_save2)-int64(Y))/4)))
					if !(last != 0) {
						libc.Xmemcpy(tls, norm_save2, norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(norm_save2)-int64(norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4))/4)))
					}
					nstart_bytes = libc.Int32FromUint32(ec_save.Foffs)
					nend_bytes = libc.Int32FromUint32(ec_save.Fstorage)
					bytes_buf = ec_save.Fbuf + uintptr(nstart_bytes)
					save_bytes = nend_bytes - nstart_bytes
					libc.Xmemcpy(tls, bytes_save, bytes_buf, libc.Uint64FromInt32(save_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(bytes_save)-int64(bytes_buf))))
					/* Restore */
					*(*OpusT_ec_ctx)(unsafe.Pointer(ec)) = ec_save
					*(*band_ctx)(unsafe.Pointer(bp)) = ctx_save
					libc.Xmemcpy(tls, X, X_save, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(X_save))/4)))
					libc.Xmemcpy(tls, Y, Y_save, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(Y_save))/4)))
					if i1 == start+int32(1) {
						special_hybrid_folding(tls, m, norm, norm2, start, M, dual_stereo)
					}
					/* Encode and round up. */
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = int32(1)
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(cm))
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
						goto _236
					_236:
						;
						i = i + 1
					}
					v229 = xy
					goto _238
				_238:
					_ = arch
					xy = libc.Float32FromInt32(0)
					i = libc.Int32FromInt32(0)
					for {
						if !(i < N1) {
							break
						}
						xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y_save + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
						goto _239
					_239:
						;
						i = i + 1
					}
					v232 = xy
					goto _241
				_241:
					dist1 = OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[0]*v229) + OpusT_opus_val16((*(*[2]OpusT_opus_val16)(unsafe.Pointer(bp + 80)))[int32(1)]*v232)
					if dist0 >= dist1 {
						x_cm = cm2
						*(*OpusT_ec_ctx)(unsafe.Pointer(ec)) = ec_save2
						*(*band_ctx)(unsafe.Pointer(bp)) = ctx_save2
						libc.Xmemcpy(tls, X, X_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(X_save2))/4)))
						libc.Xmemcpy(tls, Y, Y_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(Y_save2))/4)))
						if !(last != 0) {
							libc.Xmemcpy(tls, norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4, norm_save2, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(norm+uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4-uintptr(norm_offset)*4)-int64(norm_save2))/4)))
						}
						libc.Xmemcpy(tls, bytes_buf, bytes_save, libc.Uint64FromInt32(save_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(bytes_buf)-int64(bytes_save))))
					}
				} else {
					(*(*band_ctx)(unsafe.Pointer(bp))).Ftheta_round = 0
					if effective_lowband != -int32(1) {
						v2 = norm + uintptr(effective_lowband)*4
					} else {
						v2 = libc.UintptrFromInt32(0)
					}
					if last != 0 {
						v4 = libc.UintptrFromInt32(0)
					} else {
						v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
					}
					x_cm = quant_band_stereo(tls, bp, X, Y, N1, b, B, v2, LM, v4, lowband_scratch, libc.Int32FromUint32(x_cm|y_cm))
				}
			} else {
				if effective_lowband != -int32(1) {
					v2 = norm + uintptr(effective_lowband)*4
				} else {
					v2 = libc.UintptrFromInt32(0)
				}
				if last != 0 {
					v4 = libc.UintptrFromInt32(0)
				} else {
					v4 = norm + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i1)*2))))*4 - uintptr(norm_offset)*4
				}
				x_cm = quant_band(tls, bp, X, N1, b, B, v2, LM, v4, libc.Float32FromFloat32(1), lowband_scratch, libc.Int32FromUint32(x_cm|y_cm))
			}
			y_cm = x_cm
		}
		*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i1*C+0))) = uint8(x_cm)
		*(*uint8)(unsafe.Pointer(collapse_masks + uintptr(i1*C+C-int32(1)))) = uint8(y_cm)
		balance = balance + (*(*int32)(unsafe.Pointer(pulses + uintptr(i1)*4)) + tell)
		/* Update the folding position only as long as we have 1 bit/sample depth. */
		update_lowband = libc.BoolInt32(b > N1<<int32(BITRES))
		/* We only need to avoid noise on a split for the first band. After that, we
		   have folding. */
		(*(*band_ctx)(unsafe.Pointer(bp))).Favoid_split_noise = 0
		goto _202
	_202:
		;
		i1 = i1 + 1
	}
	*(*OpusT_opus_uint32)(unsafe.Pointer(seed)) = (*(*band_ctx)(unsafe.Pointer(bp))).Fseed
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v2 = libc.Xmalloc(tls, uint64(16))
		goto _247
	_247:
		st = v2
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v4 = st
	goto _249
_249:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v4)).Fglobal_stack = _saved_stack
}

const BUFSIZ = 8192
const CELT_LPC_ORDER = 24
const CELT_SIG_SCALE7 = 32768
const COEF_ONE3 = 1
const EPSILON4 = "1e-15f"
const FILENAME_MAX = 4096
const L_tmpnam = 20
const NORM_SCALING2 = "1.f"
const Q31ONE2 = "1.0f"
const SEEK_CUR = 1
const SEEK_END = 2
const SEEK_SET = 0
const TMP_MAX = 238328
const _BITS_STDIO2_DEC_H = 1
const _BITS_STDIO2_H = 1
const _BITS_STDIO_H = 1
const _BITS_STDIO_LIM_H = 1
const _IOFBF = 0
const _IOLBF = 1
const _IONBF = 2
const _IO_EOF_SEEN = 0x0010
const _IO_ERR_SEEN = 0x0020
const _IO_USER_LOCK = 0x8000
const _STDIO_H = 1
const __FILE_defined = 1
const ____FILE_defined = 1
const _____fpos64_t_defined = 1
const _____fpos_t_defined = 1
const ____mbstate_t_defined = 1
const __struct_FILE_defined = 1

type OpusT___mbstate_t = struct {
	F__count int32
	F__value struct {
		F__wchb [0][4]int8
		F__wch  uint32
	}
}

type OpusT___fpos_t = struct {
	F__pos   OpusT___off_t
	F__state OpusT___mbstate_t
}

type _G_fpos_t = OpusT___fpos_t

type OpusT___fpos64_t = struct {
	F__pos   OpusT___off64_t
	F__state OpusT___mbstate_t
}

type _G_fpos64_t = OpusT___fpos64_t

type _IO_FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     OpusT___off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         OpusT___off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          OpusT_size_t
	F_mode           int32
	F_unused2        [20]int8
}

type OpusT___FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     OpusT___off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         OpusT___off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          OpusT_size_t
	F_mode           int32
	F_unused2        [20]int8
}

type OpusT_FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     OpusT___off_t
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         OpusT___off64_t
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          OpusT_size_t
	F_mode           int32
	F_unused2        [20]int8
}

type OpusT__IO_lock_t = struct{}

type OpusT_fpos_t = struct {
	F__pos   OpusT___off_t
	F__state OpusT___mbstate_t
}

func Opus_quant_coarse_energy(tls *libc.TLS, m uintptr, start int32, end int32, effEnd int32, eBands uintptr, oldEBands uintptr, budget OpusT_opus_uint32, error1 uintptr, enc uintptr, C int32, LM int32, nbAvailableBytes int32, force_intra int32, delayedIntra uintptr, two_pass int32, loss_rate int32, lfe int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var _saved_stack, error_intra, intra_bits, intra_buf, oldEBands_intra, st, v1, v10, v12, v14, v16, v18, v20, v22, v24, v26, v3, v5 uintptr
	var badness1, badness2, intra, v6 int32
	var intra_bias, tell_intra OpusT_opus_int32
	var max_decay, v9 OpusT_celt_glog
	var new_distortion OpusT_opus_val32
	var nintra_bytes, nstart_bytes, save_bytes, tell, v58 OpusT_opus_uint32
	var _ /* enc_intra_state at bp+56 */ OpusT_ec_enc
	var _ /* enc_start_state at bp+0 */ OpusT_ec_enc
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, badness1, badness2, error_intra, intra, intra_bias, intra_bits, intra_buf, max_decay, new_distortion, nintra_bytes, nstart_bytes, oldEBands_intra, save_bytes, st, tell, tell_intra, v1, v10, v12, v14, v16, v18, v20, v22, v24, v26, v3, v5, v58, v6, v9
	badness1 = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	intra = libc.BoolInt32(force_intra != 0 || !(two_pass != 0) && *(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) > OpusT_opus_val32(int32(2)*C*(end-start)) && nbAvailableBytes > (end-start)*C)
	intra_bias = int32(OpusT_opus_val32(OpusT_opus_val32(float32(budget)**(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)))*float32(loss_rate)) / float32(C*libc.Int32FromInt32(512)))
	new_distortion = loss_distortion(tls, eBands, oldEBands, start, effEnd, (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands, C)
	v1 = enc
	v6 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _7
_7:
	tell = libc.Uint32FromInt32(v6)
	if tell+uint32(3) > budget {
		v6 = libc.Int32FromInt32(0)
		intra = v6
		two_pass = v6
	}
	max_decay = libc.Float32FromFloat32(16)
	if end-start > int32(10) {
		if max_decay < float32(libc.Float32FromFloat32(0.125)*float32(nbAvailableBytes)) {
			v9 = max_decay
		} else {
			v9 = float32(libc.Float32FromFloat32(0.125) * float32(nbAvailableBytes))
		}
		max_decay = v9
	}
	if lfe != 0 {
		max_decay = libc.Float32FromFloat32(3)
	}
	*(*OpusT_ec_enc)(unsafe.Pointer(bp)) = *(*OpusT_ec_enc)(unsafe.Pointer(enc))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _13
_13:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _17
_17:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v12 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v12
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v14 = st
	goto _21
_21:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v16 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v16
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v18 = st
	goto _25
_25:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6054, int32(297))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v20 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v20
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v22 = st
	goto _29
_29:
	*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v24 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v24
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v26 = st
	goto _33
_33:
	oldEBands_intra = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _37
_37:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _41
_41:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v12 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v12
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v14 = st
	goto _45
_45:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v16 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v16
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v18 = st
	goto _49
_49:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6054, int32(298))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v20 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v20
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v22 = st
	goto _53
_53:
	*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v24 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v24
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v26 = st
	goto _57
_57:
	error_intra = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	libc.Xmemcpy(tls, oldEBands_intra, oldEBands, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands_intra)-int64(oldEBands))/4)))
	if two_pass != 0 || intra != 0 {
		badness1 = quant_coarse_energy_impl(tls, m, start, end, eBands, oldEBands_intra, libc.Int32FromUint32(budget), libc.Int32FromUint32(tell), uintptr(unsafe.Pointer(&e_prob_model))+uintptr(LM)*84+1*42, error_intra, enc, C, LM, int32(1), max_decay, lfe)
	}
	if !(intra != 0) {
		tell_intra = libc.Int32FromUint32(Opus_ec_tell_frac(tls, enc))
		*(*OpusT_ec_enc)(unsafe.Pointer(bp + 56)) = *(*OpusT_ec_enc)(unsafe.Pointer(enc))
		v58 = (*OpusT_ec_ctx)(unsafe.Pointer(bp)).Foffs
		goto _59
	_59:
		nstart_bytes = v58
		v58 = (*OpusT_ec_ctx)(unsafe.Pointer(bp + 56)).Foffs
		goto _61
	_61:
		nintra_bytes = v58
		v1 = (*OpusT_ec_ctx)(unsafe.Pointer(bp + 56)).Fbuf
		goto _63
	_63:
		intra_buf = v1 + uintptr(nstart_bytes)
		save_bytes = nintra_bytes - nstart_bytes
		if save_bytes == uint32(0) {
			save_bytes = uint32(ALLOC_NONE)
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _65
		_65:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _67
	_67:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _69
		_69:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _71
	_71:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(1) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fglobal_stack))) & (libc.Uint64FromInt32(1) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v12 = libc.Xmalloc(tls, uint64(16))
			goto _73
		_73:
			st = v12
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v14 = st
		goto _75
	_75:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v16 = libc.Xmalloc(tls, uint64(16))
			goto _77
		_77:
			st = v16
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v18 = st
		goto _79
	_79:
		if !(int64(libc.Int32FromUint64(uint64(save_bytes)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v14)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v18)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+6054, int32(328))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v20 = libc.Xmalloc(tls, uint64(16))
			goto _81
		_81:
			st = v20
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v22 = st
		goto _83
	_83:
		*(*uintptr)(unsafe.Pointer(v22 + 8)) += uintptr(uint64(save_bytes) * (libc.Uint64FromInt64(1) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v24 = libc.Xmalloc(tls, uint64(16))
			goto _85
		_85:
			st = v24
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v26 = st
		goto _87
	_87:
		intra_bits = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v26)).Fglobal_stack - uintptr(uint64(save_bytes)*(libc.Uint64FromInt64(1)/libc.Uint64FromInt64(1)))
		/* Copy bits from intra bit-stream */
		libc.Xmemcpy(tls, intra_bits, intra_buf, uint64(nintra_bytes-nstart_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(intra_bits)-int64(intra_buf))))
		*(*OpusT_ec_enc)(unsafe.Pointer(enc)) = *(*OpusT_ec_enc)(unsafe.Pointer(bp))
		badness2 = quant_coarse_energy_impl(tls, m, start, end, eBands, oldEBands, libc.Int32FromUint32(budget), libc.Int32FromUint32(tell), uintptr(unsafe.Pointer(&e_prob_model))+uintptr(LM)*84+uintptr(intra)*42, error1, enc, C, LM, 0, max_decay, lfe)
		if two_pass != 0 && (badness1 < badness2 || badness1 == badness2 && libc.Int32FromUint32(Opus_ec_tell_frac(tls, enc))+intra_bias > tell_intra) {
			*(*OpusT_ec_enc)(unsafe.Pointer(enc)) = *(*OpusT_ec_enc)(unsafe.Pointer(bp + 56))
			/* Copy intra bits to bit-stream */
			libc.Xmemcpy(tls, intra_buf, intra_bits, uint64(nintra_bytes-nstart_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(intra_buf)-int64(intra_bits))))
			libc.Xmemcpy(tls, oldEBands, oldEBands_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands)-int64(oldEBands_intra))/4)))
			libc.Xmemcpy(tls, error1, error_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(error1)-int64(error_intra))/4)))
			intra = int32(1)
		}
	} else {
		libc.Xmemcpy(tls, oldEBands, oldEBands_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(oldEBands)-int64(oldEBands_intra))/4)))
		libc.Xmemcpy(tls, error1, error_intra, libc.Uint64FromInt32(C*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*uint64(4)+libc.Uint64FromInt64(0*((int64(error1)-int64(error_intra))/4)))
	}
	if intra != 0 {
		*(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) = new_distortion
	} else {
		*(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra)) = OpusT_opus_val16(OpusT_opus_val16(pred_coef[LM]*pred_coef[LM])**(*OpusT_opus_val32)(unsafe.Pointer(delayedIntra))) + new_distortion
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _89
	_89:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _91
_91:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_quant_energy_finalise(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, error1 uintptr, fine_quant uintptr, fine_priority uintptr, bits_left int32, enc uintptr, C int32) {
	var c, i, prio, q2, v3, v5 int32
	var offset OpusT_celt_glog
	_, _, _, _, _, _, _ = c, i, offset, prio, q2, v3, v5
	/* Use up the remaining bits */
	prio = 0
	for {
		if !(prio < int32(2)) {
			break
		}
		i = start
		for {
			if !(i < end && bits_left >= C) {
				break
			}
			if *(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4)) >= int32(MAX_FINE_BITS) || *(*int32)(unsafe.Pointer(fine_priority + uintptr(i)*4)) != prio {
				goto _2
			}
			c = 0
			for {
				if *(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) < libc.Float32FromInt32(0) {
					v5 = 0
				} else {
					v5 = int32(1)
				}
				q2 = v5
				Opus_ec_enc_bits(tls, enc, libc.Uint32FromInt32(q2), uint32(1))
				offset = OpusT_celt_glog(float32((float32(q2)-libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4))-libc.Int32FromInt32(1)))) * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384)))
				if oldEBands != libc.UintptrFromInt32(0) {
					*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) -= offset
				bits_left = bits_left - 1
				goto _4
			_4:
				;
				c = c + 1
				v3 = c
				if !(v3 < C) {
					break
				}
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		prio = prio + 1
	}
}

func Opus_quant_fine_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, error1 uintptr, prev_quant uintptr, extra_quant uintptr, enc uintptr, C int32) {
	var c, i, q2, v3 int32
	var extra, prev OpusT_opus_int16
	var offset OpusT_celt_glog
	var v2 uintptr
	_, _, _, _, _, _, _, _ = c, extra, i, offset, prev, q2, v2, v3
	/* Encode finer resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		extra = int16(int32(1) << *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))
		if *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) <= 0 {
			goto _1
		}
		v2 = enc
		v3 = (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Frng))
		goto _4
	_4:
		if v3+C**(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) > libc.Int32FromUint32((*OpusT_ec_enc)(unsafe.Pointer(enc)).Fstorage)*int32(8) {
			goto _1
		}
		if prev_quant != libc.UintptrFromInt32(0) {
			v3 = *(*int32)(unsafe.Pointer(prev_quant + uintptr(i)*4))
		} else {
			v3 = 0
		}
		prev = int16(v3)
		c = 0
		for {
			q2 = int32(libc.Xfloor(tls, float64((OpusT_celt_glog(*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))*float32(libc.Int32FromInt32(1)<<prev))+libc.Float32FromFloat32(0.5))*float32(extra))))
			if q2 > int32(extra)-int32(1) {
				q2 = int32(extra) - int32(1)
			}
			if q2 < 0 {
				q2 = 0
			}
			Opus_ec_enc_bits(tls, enc, libc.Uint32FromInt32(q2), libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4))))
			offset = float32(float32((float32(q2)+libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384))) - libc.Float32FromFloat32(0.5)
			offset = offset * OpusT_celt_glog(float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(prev)))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384)))
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
			*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) -= offset
			/*printf ("%f ", error[i] - offset);*/
			goto _7
		_7:
			;
			c = c + 1
			v3 = c
			if !(v3 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_remove_doubling(tls *libc.TLS, x2 uintptr, maxperiod int32, minperiod int32, N2 int32, T0_ uintptr, prev_period int32, prev_gain OpusT_opus_val16, arch int32) (r OpusT_opus_val16) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var T, T0, T1, T1b, i, i1, i2, k, minperiod0, offset, v5 int32
	var _saved_stack, st, yy_lookup, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var best_xy, best_yy, xy, xy01, xy02, yy, v33 OpusT_opus_val32
	var cont, g, g0, g1, pg, thresh, v34 OpusT_opus_val16
	var xcorr [3]OpusT_opus_val32
	var v36, v37 OpusT_opus_uint32
	var v44 float32
	var _ /* xx at bp+4 */ OpusT_opus_val32
	var _ /* xy at bp+0 */ OpusT_opus_val32
	var _ /* xy2 at bp+8 */ OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = T, T0, T1, T1b, _saved_stack, best_xy, best_yy, cont, g, g0, g1, i, i1, i2, k, minperiod0, offset, pg, st, thresh, xcorr, xy, xy01, xy02, yy, yy_lookup, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v33, v34, v36, v37, v44, v5, v6, v8
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	minperiod0 = minperiod
	maxperiod = maxperiod / int32(2)
	minperiod = minperiod / int32(2)
	*(*int32)(unsafe.Pointer(T0_)) /= int32(2)
	prev_period = prev_period / int32(2)
	N2 = N2 / int32(2)
	x2 = x2 + uintptr(maxperiod)*4
	if *(*int32)(unsafe.Pointer(T0_)) >= maxperiod {
		*(*int32)(unsafe.Pointer(T0_)) = maxperiod - int32(1)
	}
	v5 = *(*int32)(unsafe.Pointer(T0_))
	T0 = v5
	T = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+5849, int32(479))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	yy_lookup = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(maxperiod+libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	_ = arch
	v1 = x2
	xy01 = libc.Float32FromInt32(0)
	xy02 = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N2) {
			break
		}
		xy01 = xy01 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(i)*4)))
		xy02 = xy02 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 - uintptr(T0)*4 + uintptr(i)*4)))
		goto _31
	_31:
		;
		i = i + 1
	}
	*(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)) = xy01
	*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = xy02
	*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup)) = *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4))
	yy = *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4))
	i2 = int32(1)
	for {
		if !(i2 <= maxperiod) {
			break
		}
		yy = yy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-i2)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-i2)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(N2-i2)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(N2-i2)*4)))
		if float32(libc.Int32FromInt32(0)) > yy {
			v33 = float32(libc.Int32FromInt32(0))
		} else {
			v33 = yy
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(i2)*4)) = v33
		goto _32
	_32:
		;
		i2 = i2 + 1
	}
	yy = *(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T0)*4))
	best_xy = *(*OpusT_opus_val32)(unsafe.Pointer(bp))
	best_yy = yy
	v34 = compute_pitch_gain(tls, *(*OpusT_opus_val32)(unsafe.Pointer(bp)), *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)), yy)
	g0 = v34
	g = v34
	/* Look for any pitch at T/k */
	k = int32(2)
	for {
		if !(k <= int32(15)) {
			break
		}
		cont = libc.Float32FromInt32(0)
		v36 = libc.Uint32FromInt32(int32(2) * k)
		_ = v36 > libc.Uint32FromInt32(0)
		v37 = libc.Uint32FromInt32(int32(2)*T0+k) / v36
		goto _38
	_38:
		T1 = libc.Int32FromUint32(v37)
		if T1 < minperiod {
			break
		}
		/* Look for another strong correlation at T1b */
		if k == int32(2) {
			if T1+T0 > maxperiod {
				T1b = T0
			} else {
				T1b = T0 + T1
			}
		} else {
			v36 = libc.Uint32FromInt32(int32(2) * k)
			_ = v36 > libc.Uint32FromInt32(0)
			v37 = libc.Uint32FromInt32(int32(2)*second_check[k]*T0+k) / v36
			goto _41
		_41:
			T1b = libc.Int32FromUint32(v37)
		}
		_ = arch
		v1 = x2
		xy01 = libc.Float32FromInt32(0)
		xy02 = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N2) {
				break
			}
			xy01 = xy01 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-T1)*4 + uintptr(i)*4)))
			xy02 = xy02 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(v1 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(-T1b)*4 + uintptr(i)*4)))
			goto _43
		_43:
			;
			i = i + 1
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = xy01
		*(*OpusT_opus_val32)(unsafe.Pointer(bp + 8)) = xy02
		*(*OpusT_opus_val32)(unsafe.Pointer(bp)) = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_val32)(unsafe.Pointer(bp)) + *(*OpusT_opus_val32)(unsafe.Pointer(bp + 8))))
		yy = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T1)*4)) + *(*OpusT_opus_val32)(unsafe.Pointer(yy_lookup + uintptr(T1b)*4))))
		g1 = compute_pitch_gain(tls, *(*OpusT_opus_val32)(unsafe.Pointer(bp)), *(*OpusT_opus_val32)(unsafe.Pointer(bp + 4)), yy)
		if libc.Xabs(tls, T1-prev_period) <= int32(1) {
			cont = prev_gain
		} else {
			if libc.Xabs(tls, T1-prev_period) <= int32(2) && int32(5)*k*k < T0 {
				cont = float32(libc.Float32FromFloat32(0.5) * prev_gain)
			} else {
				cont = libc.Float32FromInt32(0)
			}
		}
		if libc.Float32FromFloat32(0.3) > float32(libc.Float32FromFloat32(0.7)*g0)-cont {
			v44 = libc.Float32FromFloat32(0.3)
		} else {
			v44 = float32(libc.Float32FromFloat32(0.7)*g0) - cont
		}
		thresh = v44
		/* Bias against very high pitch (very short period) to avoid false-positives
		   due to short-term correlation */
		if T1 < int32(3)*minperiod {
			if libc.Float32FromFloat32(0.4) > float32(libc.Float32FromFloat32(0.85)*g0)-cont {
				v44 = libc.Float32FromFloat32(0.4)
			} else {
				v44 = float32(libc.Float32FromFloat32(0.85)*g0) - cont
			}
			thresh = v44
		} else {
			if T1 < int32(2)*minperiod {
				if libc.Float32FromFloat32(0.5) > float32(libc.Float32FromFloat32(0.9)*g0)-cont {
					v44 = libc.Float32FromFloat32(0.5)
				} else {
					v44 = float32(libc.Float32FromFloat32(0.9)*g0) - cont
				}
				thresh = v44
			}
		}
		if g1 > thresh {
			best_xy = *(*OpusT_opus_val32)(unsafe.Pointer(bp))
			best_yy = yy
			T = T1
			g = g1
		}
		goto _35
	_35:
		;
		k = k + 1
	}
	if float32(libc.Int32FromInt32(0)) > best_xy {
		v33 = float32(libc.Int32FromInt32(0))
	} else {
		v33 = best_xy
	}
	best_xy = v33
	if best_yy <= best_xy {
		pg = libc.Float32FromFloat32(1)
	} else {
		pg = best_xy / (best_yy + libc.Float32FromInt32(1))
	}
	k = 0
	for {
		if !(k < int32(3)) {
			break
		}
		_ = arch
		xy = libc.Float32FromInt32(0)
		i1 = libc.Int32FromInt32(0)
		for {
			if !(i1 < N2) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x2 + uintptr(i1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x2 - uintptr(T+k-libc.Int32FromInt32(1))*4 + uintptr(i1)*4)))
			goto _49
		_49:
			;
			i1 = i1 + 1
		}
		v33 = xy
		goto _51
	_51:
		xcorr[k] = v33
		goto _48
	_48:
		;
		k = k + 1
	}
	if xcorr[int32(2)]-xcorr[0] > float32(libc.Float32FromFloat32(0.7)*(xcorr[int32(1)]-xcorr[0])) {
		offset = int32(1)
	} else {
		if xcorr[0]-xcorr[int32(2)] > float32(libc.Float32FromFloat32(0.7)*(xcorr[int32(1)]-xcorr[int32(2)])) {
			offset = -int32(1)
		} else {
			offset = 0
		}
	}
	if pg > g {
		pg = g
	}
	*(*int32)(unsafe.Pointer(T0_)) = int32(2)*T + offset
	if *(*int32)(unsafe.Pointer(T0_)) < minperiod0 {
		*(*int32)(unsafe.Pointer(T0_)) = minperiod0
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _55
_55:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return pg
}

const Q15ONE6 = "1.0f"

var log2_x_norm_coeff18 = [8]float32{
	0: libc.Float32FromFloat32(1),
	1: libc.Float32FromFloat32(0.8888888955116272),
	2: libc.Float32FromFloat32(0.8),
	3: libc.Float32FromFloat32(0.7272727489471436),
	4: libc.Float32FromFloat32(0.6666666865348816),
	5: libc.Float32FromFloat32(0.6153846383094788),
	6: libc.Float32FromFloat32(0.5714285969734192),
	7: libc.Float32FromFloat32(0.5333333611488342),
}
var log2_y_norm_coeff18 = [8]float32{
	1: libc.Float32FromFloat32(0.1699250042438507),
	2: libc.Float32FromFloat32(0.32192808389663696),
	3: libc.Float32FromFloat32(0.45943161845207214),
	4: libc.Float32FromFloat32(0.5849624872207642),
	5: libc.Float32FromFloat32(0.7004396915435791),
	6: libc.Float32FromFloat32(0.8073549270629883),
	7: libc.Float32FromFloat32(0.9068905711174011),
}

var trim_icdf18 = [11]uint8{
	0: uint8(126),
	1: uint8(124),
	2: uint8(119),
	3: uint8(109),
	4: uint8(87),
	5: uint8(41),
	6: uint8(19),
	7: uint8(9),
	8: uint8(4),
	9: uint8(2),
}
var spread_icdf18 = [4]uint8{
	0: uint8(25),
	1: uint8(23),
	2: uint8(2),
}
var tapset_icdf18 = [3]uint8{
	0: uint8(2),
	1: uint8(1),
}

func Opus_renormalise_vector(tls *libc.TLS, X uintptr, N1 int32, gain OpusT_opus_val32, arch int32) {
	var E, t, xy, v2 OpusT_opus_val32
	var g OpusT_opus_val16
	var i, i1 int32
	var xptr uintptr
	_, _, _, _, _, _, _, _ = E, g, i, i1, t, xptr, xy, v2
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	v2 = xy
	goto _3
_3:
	E = libc.Float32FromFloat32(1e-15) + v2
	t = E
	g = float32(libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t))) * gain)
	xptr = X
	i1 = 0
	for {
		if !(i1 < N1) {
			break
		}
		*(*OpusT_celt_norm)(unsafe.Pointer(xptr)) = OpusT_opus_val32(g * *(*OpusT_celt_norm)(unsafe.Pointer(xptr)))
		xptr += 4
		goto _4
	_4:
		;
		i1 = i1 + 1
	}
	/*return celt_sqrt(E);*/
}

func Opus_resampling_factor(tls *libc.TLS, rate OpusT_opus_int32) (r int32) {
	var ret int32
	_ = ret
	switch rate {
	case int32(48000):
		ret = int32(1)
	case int32(24000):
		ret = int32(2)
	case int32(16000):
		ret = int32(3)
	case int32(12000):
		ret = int32(4)
	case int32(8000):
		ret = int32(6)
	default:
		if !(libc.Int32FromInt32(0) != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+3904, int32(87))
		}
		ret = 0
		break
	}
	return ret
}

// C documentation
//
//	/* This version should be faster on ARM */

func Opus_run_analysis(tls *libc.TLS, analysis uintptr, celt_mode uintptr, analysis_pcm uintptr, analysis_frame_size int32, frame_size int32, c1 int32, c2 int32, C int32, Fs OpusT_opus_int32, lsb_depth int32, __ccgo_fp_downmix OpusT_downmix_func, analysis_info uintptr) {
	var offset, pcm_len, v1 int32
	_, _, _ = offset, pcm_len, v1
	analysis_frame_size = analysis_frame_size - analysis_frame_size&int32(1)
	if analysis_pcm != libc.UintptrFromInt32(0) {
		/* Avoid overflow/wrap-around of the analysis buffer */
		if (libc.Int32FromInt32(DETECT_SIZE)-libc.Int32FromInt32(5))*Fs/int32(50) < analysis_frame_size {
			v1 = (libc.Int32FromInt32(DETECT_SIZE) - libc.Int32FromInt32(5)) * Fs / int32(50)
		} else {
			v1 = analysis_frame_size
		}
		analysis_frame_size = v1
		pcm_len = analysis_frame_size - (*OpusT_TonalityAnalysisState)(unsafe.Pointer(analysis)).Fanalysis_offset
		offset = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(analysis)).Fanalysis_offset
		for pcm_len > 0 {
			if Fs/int32(50) < pcm_len {
				v1 = Fs / int32(50)
			} else {
				v1 = pcm_len
			}
			tonality_analysis(tls, analysis, celt_mode, analysis_pcm, v1, offset, c1, c2, C, lsb_depth, __ccgo_fp_downmix)
			offset = offset + Fs/int32(50)
			pcm_len = pcm_len - Fs/int32(50)
		}
		(*OpusT_TonalityAnalysisState)(unsafe.Pointer(analysis)).Fanalysis_offset = analysis_frame_size
		*(*int32)(unsafe.Pointer(analysis + 7440)) -= frame_size
	}
	Opus_tonality_get_info(tls, analysis, analysis_info, frame_size)
}

const CELT_SIG_SCALE6 = "32768.f"

func Opus_spreading_decision(tls *libc.TLS, m uintptr, X uintptr, average uintptr, last_decision int32, hf_average uintptr, tapset_decision uintptr, update_hf int32, end int32, C int32, M int32, spread_weight uintptr) (r int32) {
	var N, N0, c, decision, hf_sum, i, j, nbBands, sum, tmp, v1 int32
	var eBands, x uintptr
	var tcount [3]int32
	var x2N OpusT_opus_val32
	var v5, v6 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N0, c, decision, eBands, hf_sum, i, j, nbBands, sum, tcount, tmp, x, x2N, v1, v5, v6
	sum = 0
	nbBands = 0
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	hf_sum = 0
	if !(end > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3677, __ccgo_ts+3661, int32(480))
	}
	N0 = M * (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FshortMdctSize
	if M*(int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end-int32(1))*2)))) <= int32(8) {
		return SPREAD_NONE
	}
	c = 0
	for {
		i = 0
		for {
			if !(i < end) {
				break
			}
			tmp = 0
			tcount = [3]int32{}
			x = X + uintptr(M*int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2))))*4 + uintptr(c*N0)*4
			N = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2))))
			if N <= int32(8) {
				goto _3
			}
			/* Compute rough CDF of |x[j]| */
			j = 0
			for {
				if !(j < N) {
					break
				}
				/* Q13 */
				x2N = OpusT_opus_val32(OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x + uintptr(j)*4))**(*OpusT_celt_norm)(unsafe.Pointer(x + uintptr(j)*4))) * float32(N))
				if x2N < libc.Float32FromFloat32(0.25) {
					tcount[0] = tcount[0] + 1
				}
				if x2N < libc.Float32FromFloat32(0.0625) {
					tcount[int32(1)] = tcount[int32(1)] + 1
				}
				if x2N < libc.Float32FromFloat32(0.015625) {
					tcount[int32(2)] = tcount[int32(2)] + 1
				}
				goto _4
			_4:
				;
				j = j + 1
			}
			/* Only include four last bands (8 kHz and up) */
			if i > (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands-int32(4) {
				v5 = libc.Uint32FromInt32(N)
				_ = v5 > libc.Uint32FromInt32(0)
				v6 = libc.Uint32FromInt32(int32(32)*(tcount[int32(1)]+tcount[0])) / v5
				goto _7
			_7:
				hf_sum = libc.Int32FromUint32(uint32(hf_sum) + v6)
			}
			tmp = libc.BoolInt32(int32(2)*tcount[int32(2)] >= N) + libc.BoolInt32(int32(2)*tcount[int32(1)] >= N) + libc.BoolInt32(int32(2)*tcount[0] >= N)
			sum = sum + tmp**(*int32)(unsafe.Pointer(spread_weight + uintptr(i)*4))
			nbBands = nbBands + *(*int32)(unsafe.Pointer(spread_weight + uintptr(i)*4))
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	if update_hf != 0 {
		if hf_sum != 0 {
			v5 = libc.Uint32FromInt32(C * (int32(4) - (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands + end))
			_ = v5 > libc.Uint32FromInt32(0)
			v6 = libc.Uint32FromInt32(hf_sum) / v5
			goto _10
		_10:
			hf_sum = libc.Int32FromUint32(v6)
		}
		*(*int32)(unsafe.Pointer(hf_average)) = (*(*int32)(unsafe.Pointer(hf_average)) + hf_sum) >> int32(1)
		hf_sum = *(*int32)(unsafe.Pointer(hf_average))
		if *(*int32)(unsafe.Pointer(tapset_decision)) == int32(2) {
			hf_sum = hf_sum + int32(4)
		} else {
			if *(*int32)(unsafe.Pointer(tapset_decision)) == 0 {
				hf_sum = hf_sum - int32(4)
			}
		}
		if hf_sum > int32(22) {
			*(*int32)(unsafe.Pointer(tapset_decision)) = int32(2)
		} else {
			if hf_sum > int32(18) {
				*(*int32)(unsafe.Pointer(tapset_decision)) = int32(1)
			} else {
				*(*int32)(unsafe.Pointer(tapset_decision)) = 0
			}
		}
	}
	/*printf("%d %d %d\n", hf_sum, *hf_average, *tapset_decision);*/
	if !(nbBands > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3701, __ccgo_ts+3661, int32(536))
	} /* end has to be non-zero */
	if !(sum >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3729, __ccgo_ts+3661, int32(537))
	}
	v5 = libc.Uint32FromInt32(nbBands)
	_ = v5 > libc.Uint32FromInt32(0)
	v6 = libc.Uint32FromInt32(sum<<int32(8)) / v5
	goto _13
_13:
	sum = libc.Int32FromUint32(v6)
	/* Recursive averaging */
	sum = (sum + *(*int32)(unsafe.Pointer(average))) >> int32(1)
	*(*int32)(unsafe.Pointer(average)) = sum
	/* Hysteresis */
	sum = (int32(3)*sum + ((int32(3)-last_decision)<<int32(7) + int32(64)) + int32(2)) >> int32(2)
	if sum < int32(80) {
		decision = int32(SPREAD_AGGRESSIVE)
	} else {
		if sum < int32(256) {
			decision = int32(SPREAD_NORMAL)
		} else {
			if sum < int32(384) {
				decision = int32(SPREAD_LIGHT)
			} else {
				decision = SPREAD_NONE
			}
		}
	}
	return decision
}

// C documentation
//
//	/* Indexing table for converting from natural Hadamard to ordery Hadamard
//	   This is essentially a bit-reversed Gray, on top of which we've added
//	   an inversion of the order because we want the DC at the end rather than
//	   the beginning. The lines are for N=2, 4, 8, 16 */
var ordery_table = [30]int32{
	0:  int32(1),
	2:  int32(3),
	4:  int32(2),
	5:  int32(1),
	6:  int32(7),
	8:  int32(4),
	9:  int32(3),
	10: int32(6),
	11: int32(1),
	12: int32(5),
	13: int32(2),
	14: int32(15),
	16: int32(8),
	17: int32(7),
	18: int32(12),
	19: int32(3),
	20: int32(11),
	21: int32(4),
	22: int32(14),
	23: int32(1),
	24: int32(9),
	25: int32(6),
	26: int32(13),
	27: int32(2),
	28: int32(10),
	29: int32(5),
}

func Opus_stereo_itheta(tls *libc.TLS, X uintptr, Y uintptr, stereo int32, N1 int32, arch int32) (r OpusT_opus_int32) {
	var Emid, Eside, mid, side, xy, v1 OpusT_opus_val32
	var i, i1, itheta int32
	var m, s OpusT_celt_norm
	var x_sq, v10, v11, v13, v14, v16, v17, v9 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Emid, Eside, i, i1, itheta, m, mid, s, side, x_sq, xy, v1, v10, v11, v13, v14, v16, v17, v9
	v1 = libc.Float32FromInt32(0)
	Eside = v1
	Emid = v1
	if stereo != 0 {
		i1 = 0
		for {
			if !(i1 < N1) {
				break
			}
			m = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i1)*4)) + *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(i1)*4))
			s = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i1)*4)) - *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(i1)*4))
			Emid = Emid + OpusT_opus_val32(m*m)
			Eside = Eside + OpusT_opus_val32(s*s)
			goto _2
		_2:
			;
			i1 = i1 + 1
		}
	} else {
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N1) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
			goto _3
		_3:
			;
			i = i + 1
		}
		v1 = xy
		goto _5
	_5:
		Emid = Emid + v1
		_ = arch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < N1) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
			goto _6
		_6:
			;
			i = i + 1
		}
		v1 = xy
		goto _8
	_8:
		Eside = Eside + v1
	}
	mid = float32(libc.Xsqrt(tls, float64(Emid)))
	side = float32(libc.Xsqrt(tls, float64(Eside)))
	v9 = side
	v10 = mid
	_ = v10 >= libc.Float32FromInt32(0) && v9 >= libc.Float32FromInt32(0)
	if float32(v10*v10)+float32(v9*v9) < libc.Float32FromFloat32(1e-18) {
		v11 = libc.Float32FromInt32(0)
		goto _12
	}
	if v9 < v10 {
		v13 = v9 / v10
		x_sq = float32(v13 * v13)
		v14 = float32(libc.Float32FromFloat32(0.636619772367581) * (v13 + float32(float32(v13*x_sq)*(-libc.Float32FromFloat32(0.3333165943622589)+float32(x_sq*(libc.Float32FromFloat32(0.19962704181671143)+float32(x_sq*(-libc.Float32FromFloat32(0.13976582884788513)+float32(x_sq*(libc.Float32FromFloat32(0.09794234484434128)+float32(x_sq*(-libc.Float32FromFloat32(0.057773590087890625)+float32(x_sq*(libc.Float32FromFloat32(0.023040136322379112)+float32(x_sq*-libc.Float32FromFloat32(0.0043554059229791164))))))))))))))))
		goto _15
	_15:
		v11 = v14
		goto _12
	} else {
		v16 = v10 / v9
		x_sq = float32(v16 * v16)
		v17 = float32(libc.Float32FromFloat32(0.636619772367581) * (v16 + float32(float32(v16*x_sq)*(-libc.Float32FromFloat32(0.3333165943622589)+float32(x_sq*(libc.Float32FromFloat32(0.19962704181671143)+float32(x_sq*(-libc.Float32FromFloat32(0.13976582884788513)+float32(x_sq*(libc.Float32FromFloat32(0.09794234484434128)+float32(x_sq*(-libc.Float32FromFloat32(0.057773590087890625)+float32(x_sq*(libc.Float32FromFloat32(0.023040136322379112)+float32(x_sq*-libc.Float32FromFloat32(0.0043554059229791164))))))))))))))))
		goto _18
	_18:
		v11 = libc.Float32FromFloat32(1) - v17
		goto _12
	}
_12:
	itheta = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+float32(float32(libc.Float32FromFloat32(65536)*libc.Float32FromInt32(16384))*v11))))
	return itheta
}

const MINI_MAXFACTORS = 32
const _ASSERT_H = 1
const __ASSERT_VOID_CAST = "void"
const mini_kiss_fft_scalar = "float"

/* When possible, define assert so that it does not add extra
   parentheses around EXPR.  Otherwise, those added parentheses would
   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */

/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */

type OpusT_mini_kiss_fft_cpx = struct {
	Fr float32
	Fi float32
}

type OpusT_mini_kiss_fft_cfg = uintptr

type mini_kiss_fft_state = struct {
	Fnfft     int32
	Finverse  int32
	Ffactors  [64]int32
	Ftwiddles [1]OpusT_mini_kiss_fft_cpx
}

/* e.g. an fft of length 128 has 4 factors
as far as kissfft is concerned
4*4*4*2
*/

type OpusT_mini_kiss_fft_state = struct {
	Fnfft     int32
	Finverse  int32
	Ffactors  [64]int32
	Ftwiddles [1]OpusT_mini_kiss_fft_cpx
}

/*
  Explanation of macros dealing with complex math:

   C_MUL(m,a,b)         : m = a*b
   C_FIXDIV( c , div )  : if a fixed point impl., c /= div. noop otherwise
   C_SUB( res, a,b)     : res = a - b
   C_SUBFROM( res , a)  : res -= a
   C_ADDTO( res , a)    : res += a
 * */

func Opus_surround_analysis(tls *libc.TLS, celt_mode uintptr, pcm uintptr, bandLogE uintptr, mem uintptr, preemph_mem uintptr, len1 int32, overlap int32, channels int32, rate int32, __ccgo_fp_copy_channel_in OpusT_opus_copy_channel_in_func, arch int32) {
	bp := tls.Alloc(464)
	defer tls.Free(464)
	var LM, bound, c, frame, frame_size, freq_size, i, i1, nb_frames, upsample, v84 int32
	var _saved_stack, freq, in2, mask, st, x3, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var channel_offset OpusT_opus_val16
	var integer, range_idx OpusT_opus_int32
	var sum, xy, v82 OpusT_opus_val32
	var v93 OpusT_celt_glog
	var v101 float32
	var v86 bool
	var _ /* bandE at bp+40 */ [21]OpusT_opus_val32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* in at bp+4 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* maskLogE at bp+124 */ [3][21]OpusT_celt_glog
	var _ /* pos at bp+8 */ [8]int32
	var _ /* tmpE at bp+376 */ [21]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = LM, _saved_stack, bound, c, channel_offset, frame, frame_size, freq, freq_size, i, i1, in2, integer, mask, nb_frames, range_idx, st, sum, upsample, x3, xy, v1, v10, v101, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8, v82, v84, v86, v93
	*(*[8]int32)(unsafe.Pointer(bp + 8)) = [8]int32{}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	upsample = Opus_resampling_factor(tls, rate)
	frame_size = len1 * upsample
	/* LM = log2(frame_size / 120) */
	LM = 0
	for {
		if !(LM < (*OpusT_OpusCustomMode)(unsafe.Pointer(celt_mode)).FmaxLM) {
			break
		}
		if (*OpusT_OpusCustomMode)(unsafe.Pointer(celt_mode)).FshortMdctSize<<LM == frame_size {
			break
		}
		goto _5
	_5:
		;
		LM = LM + 1
	}
	freq_size = (*OpusT_OpusCustomMode)(unsafe.Pointer(celt_mode)).FshortMdctSize << LM
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(frame_size+overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3032, int32(259))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(frame_size+overlap) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	in2 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(frame_size+overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _37
_37:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _41
_41:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _45
_45:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3032, int32(260))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _49
_49:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _53
_53:
	x3 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _57
_57:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _59
	_59:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _61
_61:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _63
	_63:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _65
_65:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _67
	_67:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _69
_69:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(freq_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3032, int32(261))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _71
	_71:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _73
_73:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(freq_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _75
	_75:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _77
_77:
	freq = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(freq_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	channel_pos(tls, channels, bp+8)
	c = 0
	for {
		if !(c < int32(3)) {
			break
		}
		i1 = 0
		for {
			if !(i1 < int32(21)) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(c)*84 + uintptr(i1)*4)) = -libc.Float32FromFloat32(28)
			goto _79
		_79:
			;
			i1 = i1 + 1
		}
		goto _78
	_78:
		;
		c = c + 1
	}
	c = 0
	for {
		if !(c < channels) {
			break
		}
		nb_frames = frame_size / freq_size
		if !(nb_frames*freq_size == frame_size) {
			Opus_celt_fatal(tls, __ccgo_ts+3066, __ccgo_ts+3032, int32(273))
		}
		libc.Xmemcpy(tls, in2, mem+uintptr(c*overlap)*4, libc.Uint64FromInt32(overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(in2)-int64(mem+uintptr(c*overlap)*4))/4)))
		(*(*func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_copy_channel_in})))(tls, x3, int32(1), pcm, channels, c, len1, libc.UintptrFromInt32(0))
		Opus_celt_preemphasis(tls, x3, in2+uintptr(overlap)*4, frame_size, int32(1), upsample, celt_mode+16, preemph_mem+uintptr(c)*4, 0)
		_ = libc.Int32FromInt32(0)
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < frame_size+overlap) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(in2 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(in2 + uintptr(i)*4)))
			goto _81
		_81:
			;
			i = i + 1
		}
		v82 = xy
		goto _83
	_83:
		sum = v82
		/* This should filter out both NaNs and ridiculous signals that could
		   cause NaNs further down. */
		if v86 = !(sum < libc.Float32FromFloat32(1e+18)); !v86 {
			*(*float32)(unsafe.Pointer(bp)) = sum
			v84 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
			goto _85
		_85:
		}
		if v86 || v84 != 0 {
			libc.Xmemset(tls, in2, 0, libc.Uint64FromInt32(frame_size+overlap)*uint64(4))
			*(*OpusT_opus_val32)(unsafe.Pointer(preemph_mem + uintptr(c)*4)) = libc.Float32FromInt32(0)
		}
		libc.Xmemset(tls, bp+40, 0, libc.Uint64FromInt32(libc.Int32FromInt32(21))*libc.Uint64FromInt64(4))
		frame = 0
		for {
			if !(frame < nb_frames) {
				break
			}
			Opus_clt_mdct_forward_c(tls, celt_mode+80, in2+uintptr(freq_size*frame)*4, freq, (*OpusT_OpusCustomMode)(unsafe.Pointer(celt_mode)).Fwindow, overlap, (*OpusT_OpusCustomMode)(unsafe.Pointer(celt_mode)).FmaxLM-LM, int32(1), arch)
			if upsample != int32(1) {
				bound = freq_size / upsample
				i1 = 0
				for {
					if !(i1 < bound) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(freq + uintptr(i1)*4)) *= float32(upsample)
					goto _88
				_88:
					;
					i1 = i1 + 1
				}
				for {
					if !(i1 < freq_size) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(freq + uintptr(i1)*4)) = libc.Float32FromInt32(0)
					goto _89
				_89:
					;
					i1 = i1 + 1
				}
			}
			Opus_compute_band_energies(tls, celt_mode, freq, bp+376, int32(21), int32(1), LM, arch)
			/* If we have multiple frames, take the max energy. */
			i1 = 0
			for {
				if !(i1 < int32(21)) {
					break
				}
				if (*(*[21]OpusT_opus_val32)(unsafe.Pointer(bp + 40)))[i1] > (*(*[21]OpusT_opus_val32)(unsafe.Pointer(bp + 376)))[i1] {
					v82 = (*(*[21]OpusT_opus_val32)(unsafe.Pointer(bp + 40)))[i1]
				} else {
					v82 = (*(*[21]OpusT_opus_val32)(unsafe.Pointer(bp + 376)))[i1]
				}
				(*(*[21]OpusT_opus_val32)(unsafe.Pointer(bp + 40)))[i1] = v82
				goto _90
			_90:
				;
				i1 = i1 + 1
			}
			goto _87
		_87:
			;
			frame = frame + 1
		}
		Opus_amp2Log2(tls, celt_mode, int32(21), int32(21), bp+40, bandLogE+uintptr(int32(21)*c)*4, int32(1))
		/* Apply spreading function with -6 dB/band going up and -12 dB/band going down. */
		i1 = int32(1)
		for {
			if !(i1 < int32(21)) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1-int32(1))*4))-libc.Float32FromFloat32(1) {
				v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4))
			} else {
				v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1-int32(1))*4)) - libc.Float32FromFloat32(1)
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) = v93
			goto _92
		_92:
			;
			i1 = i1 + 1
		}
		i1 = int32(19)
		for {
			if !(i1 >= 0) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1+int32(1))*4))-libc.Float32FromFloat32(2) {
				v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4))
			} else {
				v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1+int32(1))*4)) - libc.Float32FromFloat32(2)
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) = v93
			goto _94
		_94:
			;
			i1 = i1 - 1
		}
		if (*(*[8]int32)(unsafe.Pointer(bp + 8)))[c] == int32(1) {
			i1 = 0
			for {
				if !(i1 < int32(21)) {
					break
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4)) = logSum(tls, *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4)), *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)))
				goto _96
			_96:
				;
				i1 = i1 + 1
			}
		} else {
			if (*(*[8]int32)(unsafe.Pointer(bp + 8)))[c] == int32(3) {
				i1 = 0
				for {
					if !(i1 < int32(21)) {
						break
					}
					*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4)) = logSum(tls, *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4)), *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)))
					goto _97
				_97:
					;
					i1 = i1 + 1
				}
			} else {
				if (*(*[8]int32)(unsafe.Pointer(bp + 8)))[c] == int32(2) {
					i1 = 0
					for {
						if !(i1 < int32(21)) {
							break
						}
						*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4)) = logSum(tls, *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4)), *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4))-libc.Float32FromFloat32(0.5))
						*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4)) = logSum(tls, *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4)), *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4))-libc.Float32FromFloat32(0.5))
						goto _98
					_98:
						;
						i1 = i1 + 1
					}
				}
			}
		}
		libc.Xmemcpy(tls, mem+uintptr(c*overlap)*4, in2+uintptr(frame_size)*4, libc.Uint64FromInt32(overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(mem+uintptr(c*overlap)*4)-int64(in2+uintptr(frame_size)*4))/4)))
		goto _80
	_80:
		;
		c = c + 1
	}
	i1 = 0
	for {
		if !(i1 < int32(21)) {
			break
		}
		if *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4)) < *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4)) {
			v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(i1)*4))
		} else {
			v93 = *(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 2*84 + uintptr(i1)*4))
		}
		*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + 1*84 + uintptr(i1)*4)) = v93
		goto _99
	_99:
		;
		i1 = i1 + 1
	}
	*(*float32)(unsafe.Pointer(bp + 4)) = libc.Float32FromFloat32(2) / float32(channels-libc.Int32FromInt32(1))
	integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4))>>libc.Int32FromInt32(23)) - int32(127)
	*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
	range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4)) >> libc.Int32FromInt32(20) & uint32(0x7))
	*(*float32)(unsafe.Pointer(bp + 4)) = float32(*(*float32)(unsafe.Pointer(bp + 4))*log2_x_norm_coeff3[range_idx]) - libc.Float32FromFloat32(1.0625)
	*(*float32)(unsafe.Pointer(bp + 4)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp + 4))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp + 4))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp + 4))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp + 4))*-libc.Float32FromFloat32(0.2841544449329376))))))))
	v101 = float32(integer) + *(*float32)(unsafe.Pointer(bp + 4)) + log2_y_norm_coeff3[range_idx]
	goto _102
_102:
	channel_offset = float32(libc.Float32FromFloat32(0.5) * v101)
	c = 0
	for {
		if !(c < int32(3)) {
			break
		}
		i1 = 0
		for {
			if !(i1 < int32(21)) {
				break
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(bp + 124 + uintptr(c)*84 + uintptr(i1)*4)) += channel_offset
			goto _104
		_104:
			;
			i1 = i1 + 1
		}
		goto _103
	_103:
		;
		c = c + 1
	}
	c = 0
	for {
		if !(c < channels) {
			break
		}
		if (*(*[8]int32)(unsafe.Pointer(bp + 8)))[c] != 0 {
			mask = bp + 124 + uintptr((*(*[8]int32)(unsafe.Pointer(bp + 8)))[c]-int32(1))*84
			i1 = 0
			for {
				if !(i1 < int32(21)) {
					break
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i1)*4))
				goto _106
			_106:
				;
				i1 = i1 + 1
			}
		} else {
			i1 = 0
			for {
				if !(i1 < int32(21)) {
					break
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(int32(21)*c+i1)*4)) = libc.Float32FromInt32(0)
				goto _107
			_107:
				;
				i1 = i1 + 1
			}
		}
		goto _105
	_105:
		;
		c = c + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _109
	_109:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _111
_111:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func Opus_tonality_analysis_init(tls *libc.TLS, tonal uintptr, Fs OpusT_opus_int32) {
	var v1 int32
	_ = v1
	/* Initialize reusable fields. */
	v1 = 0
	goto _2
_2:
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Farch = v1
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs = Fs
	/* Clear remaining fields. */
	Opus_tonality_analysis_reset(tls, tonal)
}

func Opus_tonality_analysis_reset(tls *libc.TLS, tonal uintptr) {
	var start uintptr
	_ = start
	/* Clear non-reusable fields. */
	start = tonal + 12
	libc.Xmemset(tls, start, 0, (uint64(14004)-libc.Uint64FromInt64(int64(start)-int64(tonal)))*uint64(1))
}

func Opus_tonality_get_info(tls *libc.TLS, tonal uintptr, info_out uintptr, len1 int32) {
	var bandwidth_span, curr_lookahead, i, mpos, pos, pos0, tonality_count, vpos, v4 int32
	var pmax, pmin, pos_vad, prob_avg, prob_count, prob_max, prob_min, tonality_avg, tonality_max, vad_prob, v1 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bandwidth_span, curr_lookahead, i, mpos, pmax, pmin, pos, pos0, pos_vad, prob_avg, prob_count, prob_max, prob_min, tonality_avg, tonality_count, tonality_max, vad_prob, vpos, v1, v4
	pos = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_pos
	curr_lookahead = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos - (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_pos
	if curr_lookahead < 0 {
		curr_lookahead = curr_lookahead + int32(DETECT_SIZE)
	}
	*(*int32)(unsafe.Pointer(tonal + 7452)) += len1 / ((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs / int32(400))
	for (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_subframe >= int32(8) {
		*(*int32)(unsafe.Pointer(tonal + 7452)) -= int32(8)
		(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_pos = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_pos + 1
	}
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fread_pos >= int32(DETECT_SIZE) {
		*(*int32)(unsafe.Pointer(tonal + 7448)) -= int32(DETECT_SIZE)
	}
	/* On long frames, look at the second analysis window rather than the first. */
	if len1 > (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs/int32(50) && pos != (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
		pos = pos + 1
		if pos == int32(DETECT_SIZE) {
			pos = 0
		}
	}
	if pos == (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
		pos = pos - 1
	}
	if pos < 0 {
		pos = libc.Int32FromInt32(DETECT_SIZE) - libc.Int32FromInt32(1)
	}
	pos0 = pos
	libc.Xmemcpy(tls, info_out, tonal+7604+uintptr(pos)*64, libc.Uint64FromInt32(libc.Int32FromInt32(1))*libc.Uint64FromInt64(64)+libc.Uint64FromInt64(0*((int64(info_out)-OpusT___predefined_ptrdiff_t(tonal+7604+uintptr(pos)*64))/64)))
	if !((*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fvalid != 0) {
		return
	}
	v1 = (*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Ftonality
	tonality_avg = v1
	tonality_max = v1
	tonality_count = int32(1)
	/* Look at the neighbouring frames and pick largest bandwidth found (to be safe). */
	bandwidth_span = int32(6)
	/* If possible, look ahead for a tone to compensate for the delay in the tone detector. */
	i = 0
	for {
		if !(i < int32(3)) {
			break
		}
		pos = pos + 1
		if pos == int32(DETECT_SIZE) {
			pos = 0
		}
		if pos == (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
			break
		}
		if tonality_max > (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Ftonality {
			v1 = tonality_max
		} else {
			v1 = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Ftonality
		}
		tonality_max = v1
		tonality_avg = tonality_avg + (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Ftonality
		tonality_count = tonality_count + 1
		if (*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth > (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fbandwidth {
			v4 = (*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth
		} else {
			v4 = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fbandwidth
		}
		(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth = v4
		bandwidth_span = bandwidth_span - 1
		goto _2
	_2:
		;
		i = i + 1
	}
	pos = pos0
	/* Look back in time to see if any has a wider bandwidth than the current frame. */
	i = 0
	for {
		if !(i < bandwidth_span) {
			break
		}
		pos = pos - 1
		if pos < 0 {
			pos = libc.Int32FromInt32(DETECT_SIZE) - libc.Int32FromInt32(1)
		}
		if pos == (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
			break
		}
		if (*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth > (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fbandwidth {
			v4 = (*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth
		} else {
			v4 = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fbandwidth
		}
		(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fbandwidth = v4
		goto _5
	_5:
		;
		i = i + 1
	}
	if tonality_avg/float32(tonality_count) > tonality_max-libc.Float32FromFloat32(0.2) {
		v1 = tonality_avg / float32(tonality_count)
	} else {
		v1 = tonality_max - libc.Float32FromFloat32(0.2)
	}
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Ftonality = v1
	v4 = pos0
	vpos = v4
	mpos = v4
	/* If we have enough look-ahead, compensate for the ~5-frame delay in the music prob and
	   ~1 frame delay in the VAD prob. */
	if curr_lookahead > int32(15) {
		mpos = mpos + int32(5)
		if mpos >= int32(DETECT_SIZE) {
			mpos = mpos - int32(DETECT_SIZE)
		}
		vpos = vpos + int32(1)
		if vpos >= int32(DETECT_SIZE) {
			vpos = vpos - int32(DETECT_SIZE)
		}
	}
	/* The following calculations attempt to minimize a "badness function"
	   for the transition. When switching from speech to music, the badness
	   of switching at frame k is
	   b_k = S*v_k + \sum_{i=0}^{k-1} v_i*(p_i - T)
	   where
	   v_i is the activity probability (VAD) at frame i,
	   p_i is the music probability at frame i
	   T is the probability threshold for switching
	   S is the penalty for switching during active audio rather than silence
	   the current frame has index i=0
	   Rather than apply badness to directly decide when to switch, what we compute
	   instead is the threshold for which the optimal switching point is now. When
	   considering whether to switch now (frame 0) or at frame k, we have:
	   S*v_0 = S*v_k + \sum_{i=0}^{k-1} v_i*(p_i - T)
	   which gives us:
	   T = ( \sum_{i=0}^{k-1} v_i*p_i + S*(v_k-v_0) ) / ( \sum_{i=0}^{k-1} v_i )
	   We take the min threshold across all positive values of k (up to the maximum
	   amount of lookahead we have) to give us the threshold for which the current
	   frame is the optimal switch point.
	   The last step is that we need to consider whether we want to switch at all.
	   For that we use the average of the music probability over the entire window.
	   If the threshold is higher than that average we're not going to
	   switch, so we compute a min with the average as well. The result of all these
	   min operations is music_prob_min, which gives the threshold for switching to music
	   if we're currently encoding for speech.
	   We do the exact opposite to compute music_prob_max which is used for switching
	   from music to speech.
	*/
	prob_min = libc.Float32FromFloat32(1)
	prob_max = libc.Float32FromFloat32(0)
	vad_prob = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(vpos)*64))).Factivity_probability
	if libc.Float32FromFloat32(0.1) > vad_prob {
		v1 = libc.Float32FromFloat32(0.1)
	} else {
		v1 = vad_prob
	}
	prob_count = v1
	if libc.Float32FromFloat32(0.1) > vad_prob {
		v1 = libc.Float32FromFloat32(0.1)
	} else {
		v1 = vad_prob
	}
	prob_avg = float32(v1 * (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(mpos)*64))).Fmusic_prob)
	for int32(1) != 0 {
		mpos = mpos + 1
		if mpos == int32(DETECT_SIZE) {
			mpos = 0
		}
		if mpos == (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
			break
		}
		vpos = vpos + 1
		if vpos == int32(DETECT_SIZE) {
			vpos = 0
		}
		if vpos == (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos {
			break
		}
		pos_vad = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(vpos)*64))).Factivity_probability
		if (prob_avg-float32(libc.Float32FromInt32(TRANSITION_PENALTY)*(vad_prob-pos_vad)))/prob_count < prob_min {
			v1 = (prob_avg - float32(libc.Float32FromInt32(TRANSITION_PENALTY)*(vad_prob-pos_vad))) / prob_count
		} else {
			v1 = prob_min
		}
		prob_min = v1
		if (prob_avg+float32(libc.Float32FromInt32(TRANSITION_PENALTY)*(vad_prob-pos_vad)))/prob_count > prob_max {
			v1 = (prob_avg + float32(libc.Float32FromInt32(TRANSITION_PENALTY)*(vad_prob-pos_vad))) / prob_count
		} else {
			v1 = prob_max
		}
		prob_max = v1
		if libc.Float32FromFloat32(0.1) > pos_vad {
			v1 = libc.Float32FromFloat32(0.1)
		} else {
			v1 = pos_vad
		}
		prob_count = prob_count + v1
		if libc.Float32FromFloat32(0.1) > pos_vad {
			v1 = libc.Float32FromFloat32(0.1)
		} else {
			v1 = pos_vad
		}
		prob_avg = prob_avg + float32(v1*(*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(mpos)*64))).Fmusic_prob)
	}
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fmusic_prob = prob_avg / prob_count
	if prob_avg/prob_count < prob_min {
		v1 = prob_avg / prob_count
	} else {
		v1 = prob_min
	}
	prob_min = v1
	if prob_avg/prob_count > prob_max {
		v1 = prob_avg / prob_count
	} else {
		v1 = prob_max
	}
	prob_max = v1
	if prob_min > libc.Float32FromFloat32(0) {
		v1 = prob_min
	} else {
		v1 = libc.Float32FromFloat32(0)
	}
	prob_min = v1
	if prob_max < libc.Float32FromFloat32(1) {
		v1 = prob_max
	} else {
		v1 = libc.Float32FromFloat32(1)
	}
	prob_max = v1
	/* If we don't have enough look-ahead, do our best to make a decent decision. */
	if curr_lookahead < int32(10) {
		pmin = prob_min
		pmax = prob_max
		pos = pos0
		/* Look for min/max in the past. */
		i = 0
		for {
			if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount-int32(1) < int32(15) {
				v4 = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount - int32(1)
			} else {
				v4 = int32(15)
			}
			if !(i < v4) {
				break
			}
			pos = pos - 1
			if pos < 0 {
				pos = libc.Int32FromInt32(DETECT_SIZE) - libc.Int32FromInt32(1)
			}
			if pmin < (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fmusic_prob {
				v1 = pmin
			} else {
				v1 = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fmusic_prob
			}
			pmin = v1
			if pmax > (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fmusic_prob {
				v1 = pmax
			} else {
				v1 = (*(*OpusT_AnalysisInfo)(unsafe.Pointer(tonal + 7604 + uintptr(pos)*64))).Fmusic_prob
			}
			pmax = v1
			goto _19
		_19:
			;
			i = i + 1
		}
		/* Bias against switching on active audio. */
		if libc.Float32FromFloat32(0) > pmin-float32(libc.Float32FromFloat32(0.1)*vad_prob) {
			v1 = libc.Float32FromFloat32(0)
		} else {
			v1 = pmin - float32(libc.Float32FromFloat32(0.1)*vad_prob)
		}
		pmin = v1
		if libc.Float32FromFloat32(1) < pmax+float32(libc.Float32FromFloat32(0.1)*vad_prob) {
			v1 = libc.Float32FromFloat32(1)
		} else {
			v1 = pmax + float32(libc.Float32FromFloat32(0.1)*vad_prob)
		}
		pmax = v1
		prob_min = prob_min + float32((libc.Float32FromFloat32(1)-float32(libc.Float32FromFloat32(0.1)*float32(curr_lookahead)))*(pmin-prob_min))
		prob_max = prob_max + float32((libc.Float32FromFloat32(1)-float32(libc.Float32FromFloat32(0.1)*float32(curr_lookahead)))*(pmax-prob_max))
	}
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fmusic_prob_min = prob_min
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info_out)).Fmusic_prob_max = prob_max
	/* printf("%f %f %f %f %f\n", prob_min, prob_max, prob_avg/prob_count, vad_prob, info_out->music_prob); */
}

var std_feature_bias = [9]float32{
	0: libc.Float32FromFloat32(5.684947),
	1: libc.Float32FromFloat32(3.475288),
	2: libc.Float32FromFloat32(1.770634),
	3: libc.Float32FromFloat32(1.599784),
	4: libc.Float32FromFloat32(3.773215),
	5: libc.Float32FromFloat32(2.163313),
	6: libc.Float32FromFloat32(1.260756),
	7: libc.Float32FromFloat32(1.116868),
	8: libc.Float32FromFloat32(1.918795),
}

func Opus_unquant_coarse_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, intra int32, dec uintptr, C int32, LM int32) {
	var beta, coef OpusT_opus_val16
	var budget, tell OpusT_opus_int32
	var c, i, pi, qi, v2 int32
	var prev [2]OpusT_opus_val64
	var prob_model, v4 uintptr
	var q, tmp OpusT_opus_val32
	var v8 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = beta, budget, c, coef, i, pi, prev, prob_model, q, qi, tell, tmp, v2, v4, v8
	prob_model = uintptr(unsafe.Pointer(&e_prob_model)) + uintptr(LM)*84 + uintptr(intra)*42
	prev = [2]OpusT_opus_val64{}
	if intra != 0 {
		coef = libc.Float32FromInt32(0)
		beta = beta_intra
	} else {
		beta = beta_coef[LM]
		coef = pred_coef[LM]
	}
	budget = libc.Int32FromUint32((*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage * uint32(8))
	/* Decode at a fixed coarse resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		c = 0
		for {
			/* It would be better to express this invariant as a
			   test on C at function entry, but that isn't enough
			   to make the static analyzer happy. */
			_ = c < libc.Int32FromInt32(2)
			v4 = dec
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v4)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v4)).Frng))
			goto _6
		_6:
			tell = v2
			if budget-tell >= int32(15) {
				if i < int32(20) {
					v2 = i
				} else {
					v2 = int32(20)
				}
				pi = int32(2) * v2
				qi = Opus_ec_laplace_decode(tls, dec, libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi))))<<int32(7)), libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi+int32(1)))))<<int32(6))
			} else {
				if budget-tell >= int32(2) {
					qi = Opus_ec_dec_icdf(tls, dec, uintptr(unsafe.Pointer(&small_energy_icdf)), uint32(2))
					qi = qi>>int32(1) ^ -(qi & int32(1))
				} else {
					if budget-tell >= int32(1) {
						qi = -Opus_ec_dec_bit_logp(tls, dec, uint32(1))
					} else {
						qi = -int32(1)
					}
				}
			}
			q = float32(qi)
			if -libc.Float32FromFloat32(9) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v8 = -libc.Float32FromFloat32(9)
			} else {
				v8 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = v8
			tmp = OpusT_opus_val16(coef**(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))) + prev[c] + q
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = tmp
			prev[c] = prev[c] + q - OpusT_opus_val16(beta*q)
			goto _3
		_3:
			;
			c = c + 1
			v2 = c
			if !(v2 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_unquant_energy_finalise(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, fine_quant uintptr, fine_priority uintptr, bits_left int32, dec uintptr, C int32) {
	var c, i, prio, q2, v3 int32
	var offset OpusT_celt_glog
	_, _, _, _, _, _ = c, i, offset, prio, q2, v3
	/* Use up the remaining bits */
	prio = 0
	for {
		if !(prio < int32(2)) {
			break
		}
		i = start
		for {
			if !(i < end && bits_left >= C) {
				break
			}
			if *(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4)) >= int32(MAX_FINE_BITS) || *(*int32)(unsafe.Pointer(fine_priority + uintptr(i)*4)) != prio {
				goto _2
			}
			c = 0
			for {
				q2 = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, uint32(1)))
				offset = OpusT_celt_glog(float32((float32(q2)-libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-*(*int32)(unsafe.Pointer(fine_quant + uintptr(i)*4))-libc.Int32FromInt32(1)))) * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384)))
				if oldEBands != libc.UintptrFromInt32(0) {
					*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
				}
				bits_left = bits_left - 1
				goto _4
			_4:
				;
				c = c + 1
				v3 = c
				if !(v3 < C) {
					break
				}
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		prio = prio + 1
	}
}

func Opus_unquant_fine_energy(tls *libc.TLS, m uintptr, start int32, end int32, oldEBands uintptr, prev_quant uintptr, extra_quant uintptr, dec uintptr, C int32) {
	var c, i, q2, v3 int32
	var extra, prev OpusT_opus_int16
	var offset OpusT_celt_glog
	var v2 uintptr
	_, _, _, _, _, _, _, _ = c, extra, i, offset, prev, q2, v2, v3
	/* Decode finer resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		extra = int16(*(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)))
		if *(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) <= 0 {
			goto _1
		}
		v2 = dec
		v3 = (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v2)).Frng))
		goto _4
	_4:
		if v3+C**(*int32)(unsafe.Pointer(extra_quant + uintptr(i)*4)) > libc.Int32FromUint32((*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage)*int32(8) {
			goto _1
		}
		if prev_quant != libc.UintptrFromInt32(0) {
			v3 = *(*int32)(unsafe.Pointer(prev_quant + uintptr(i)*4))
		} else {
			v3 = 0
		}
		prev = int16(v3)
		c = 0
		for {
			q2 = libc.Int32FromUint32(Opus_ec_dec_bits(tls, dec, libc.Uint32FromInt16(extra)))
			offset = float32(float32((float32(q2)+libc.Float32FromFloat32(0.5))*float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(extra))))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384))) - libc.Float32FromFloat32(0.5)
			offset = offset * OpusT_celt_glog(float32(libc.Int32FromInt32(1)<<(libc.Int32FromInt32(14)-int32(prev)))*(libc.Float32FromFloat32(1)/libc.Float32FromInt32(16384)))
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) += offset
			goto _7
		_7:
			;
			c = c + 1
			v3 = c
			if !(v3 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func Opus_validate_layout(tls *libc.TLS, layout uintptr) (r int32) {
	var i, max_channel int32
	_, _ = i, max_channel
	max_channel = (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_streams + (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_coupled_streams
	if max_channel > int32(255) {
		return 0
	}
	i = 0
	for {
		if !(i < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_channels) {
			break
		}
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) >= max_channel && libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(layout + 12 + uintptr(i)))) != int32(255) {
			return 0
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	return int32(1)
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

// C documentation
//
//	/* Mean energy in each band quantized in Q4 and converted back to float */
var Opus_eMeans = [25]OpusT_opus_val16{
	0:  libc.Float32FromFloat32(6.4375),
	1:  libc.Float32FromFloat32(6.25),
	2:  libc.Float32FromFloat32(5.75),
	3:  libc.Float32FromFloat32(5.3125),
	4:  libc.Float32FromFloat32(5.0625),
	5:  libc.Float32FromFloat32(4.8125),
	6:  libc.Float32FromFloat32(4.5),
	7:  libc.Float32FromFloat32(4.375),
	8:  libc.Float32FromFloat32(4.875),
	9:  libc.Float32FromFloat32(4.6875),
	10: libc.Float32FromFloat32(4.5625),
	11: libc.Float32FromFloat32(4.4375),
	12: libc.Float32FromFloat32(4.875),
	13: libc.Float32FromFloat32(4.625),
	14: libc.Float32FromFloat32(4.3125),
	15: libc.Float32FromFloat32(4.5),
	16: libc.Float32FromFloat32(4.375),
	17: libc.Float32FromFloat32(4.625),
	18: libc.Float32FromFloat32(4.75),
	19: libc.Float32FromFloat32(4.4375),
	20: libc.Float32FromFloat32(3.75),
	21: libc.Float32FromFloat32(3.75),
	22: libc.Float32FromFloat32(3.75),
	23: libc.Float32FromFloat32(3.75),
	24: libc.Float32FromFloat32(3.75),
}

var Opus_layer0 = OpusT_AnalysisDenseLayer{
	Fbias:          uintptr(unsafe.Pointer(&layer0_bias)),
	Finput_weights: uintptr(unsafe.Pointer(&layer0_weights)),
	Fnb_inputs:     int32(25),
	Fnb_neurons:    int32(32),
}

var Opus_layer1 = OpusT_AnalysisGRULayer{
	Fbias:              uintptr(unsafe.Pointer(&layer1_bias)),
	Finput_weights:     uintptr(unsafe.Pointer(&layer1_weights)),
	Frecurrent_weights: uintptr(unsafe.Pointer(&layer1_recur_weights)),
	Fnb_inputs:         int32(32),
	Fnb_neurons:        int32(24),
}

var Opus_layer2 = OpusT_AnalysisDenseLayer{
	Fbias:          uintptr(unsafe.Pointer(&layer2_bias)),
	Finput_weights: uintptr(unsafe.Pointer(&layer2_weights)),
	Fnb_inputs:     int32(24),
	Fnb_neurons:    int32(2),
	Fsigmoid:       int32(1),
}

var Opus_mapping_matrix_fifthoa_demixing = OpusT_MappingMatrix{
	Frows: int32(38),
	Fcols: int32(38),
}

var Opus_mapping_matrix_fifthoa_demixing_data = [1444]OpusT_opus_int16{
	0:    int16(3188),
	1:    int16(3247),
	2:    int16(3268),
	3:    int16(3368),
	4:    int16(3368),
	5:    int16(3138),
	6:    int16(3268),
	7:    int16(3099),
	8:    int16(3211),
	9:    int16(3368),
	10:   int16(3099),
	11:   int16(3247),
	12:   int16(3211),
	13:   int16(3368),
	14:   int16(3368),
	15:   int16(3368),
	16:   int16(3149),
	17:   int16(3268),
	18:   int16(3247),
	19:   int16(3211),
	20:   int16(3099),
	21:   int16(3188),
	22:   int16(3138),
	23:   int16(3149),
	24:   int16(3099),
	25:   int16(3188),
	26:   int16(3368),
	27:   int16(3149),
	28:   int16(3188),
	29:   int16(3247),
	30:   int16(3268),
	31:   int16(3138),
	32:   int16(3211),
	33:   int16(3368),
	34:   int16(3138),
	35:   int16(3149),
	38:   int16(118),
	39:   int16(-int32(47)),
	40:   int16(-int32(5011)),
	41:   int16(282),
	42:   int16(333),
	43:   int16(-int32(1497)),
	44:   int16(-int32(4584)),
	45:   int16(2908),
	46:   int16(3388),
	47:   int16(-int32(3647)),
	48:   int16(-int32(2493)),
	49:   int16(1139),
	50:   int16(-int32(2882)),
	51:   int16(-int32(1719)),
	52:   int16(3604),
	53:   int16(-int32(2543)),
	54:   int16(-int32(4328)),
	55:   int16(5443),
	56:   int16(1286),
	57:   int16(-int32(5498)),
	58:   int16(-int32(4583)),
	59:   int16(2510),
	60:   int16(-int32(1743)),
	61:   int16(-int32(2556)),
	62:   int16(4168),
	63:   int16(1446),
	64:   int16(-int32(290)),
	65:   int16(1812),
	66:   int16(-int32(4074)),
	67:   int16(-int32(2377)),
	68:   int16(4152),
	69:   int16(2847),
	70:   int16(4991),
	71:   int16(3980),
	72:   int16(393),
	73:   int16(5072),
	76:   int16(5489),
	77:   int16(-int32(2235)),
	78:   int16(1507),
	79:   int16(-int32(5326)),
	80:   int16(4609),
	81:   int16(-int32(1096)),
	82:   int16(2926),
	83:   int16(-int32(3427)),
	84:   int16(-int32(3301)),
	85:   int16(-int32(3078)),
	86:   int16(4226),
	87:   int16(1730),
	88:   int16(4627),
	89:   int16(2561),
	90:   int16(2966),
	91:   int16(-int32(592)),
	92:   int16(143),
	93:   int16(-int32(677)),
	94:   int16(4617),
	95:   int16(-int32(755)),
	96:   int16(-int32(956)),
	97:   int16(-int32(433)),
	98:   int16(-int32(5138)),
	99:   int16(3037),
	100:  int16(157),
	101:  int16(-int32(1394)),
	102:  int16(-int32(4498)),
	103:  int16(-int32(4984)),
	104:  int16(-int32(3661)),
	105:  int16(-int32(4112)),
	106:  int16(-int32(3756)),
	107:  int16(4628),
	108:  int16(-int32(570)),
	109:  int16(3356),
	110:  int16(1605),
	111:  int16(1803),
	114:  int16(-int32(162)),
	115:  int16(5162),
	116:  int16(2132),
	117:  int16(2392),
	118:  int16(3556),
	119:  int16(-int32(5141)),
	120:  int16(-int32(1536)),
	121:  int16(2975),
	122:  int16(-int32(3001)),
	123:  int16(-int32(3350)),
	124:  int16(-int32(2231)),
	125:  int16(-int32(5230)),
	126:  int16(1294),
	127:  int16(-int32(4965)),
	128:  int16(3494),
	129:  int16(5230),
	130:  int16(-int32(3292)),
	131:  int16(-int32(1359)),
	132:  int16(-int32(2945)),
	133:  int16(-int32(773)),
	134:  int16(2670),
	135:  int16(4867),
	136:  int16(-int32(660)),
	137:  int16(3720),
	138:  int16(-int32(3415)),
	139:  int16(-int32(5112)),
	140:  int16(-int32(3700)),
	141:  int16(-int32(1211)),
	142:  int16(407),
	143:  int16(3013),
	144:  int16(763),
	145:  int16(591),
	146:  int16(2481),
	147:  int16(-int32(2657)),
	148:  int16(5210),
	149:  int16(784),
	152:  int16(-int32(156)),
	153:  int16(338),
	154:  int16(-int32(4246)),
	155:  int16(510),
	156:  int16(462),
	157:  int16(3296),
	158:  int16(2846),
	159:  int16(3333),
	160:  int16(-int32(4292)),
	161:  int16(4574),
	162:  int16(1940),
	163:  int16(-int32(2986)),
	164:  int16(-int32(1275)),
	165:  int16(3701),
	166:  int16(5022),
	167:  int16(-int32(5250)),
	168:  int16(5780),
	169:  int16(-int32(2676)),
	170:  int16(-int32(1180)),
	171:  int16(1516),
	172:  int16(-int32(4852)),
	173:  int16(4877),
	174:  int16(342),
	175:  int16(-int32(3923)),
	176:  int16(-int32(5703)),
	177:  int16(-int32(2920)),
	178:  int16(379),
	179:  int16(-int32(657)),
	180:  int16(-int32(361)),
	181:  int16(-int32(3346)),
	182:  int16(1044),
	183:  int16(795),
	184:  int16(5257),
	185:  int16(-int32(4004)),
	186:  int16(698),
	187:  int16(1115),
	190:  int16(47),
	191:  int16(-int32(140)),
	192:  int16(-int32(3292)),
	193:  int16(-int32(1097)),
	194:  int16(652),
	195:  int16(855),
	196:  int16(-int32(5260)),
	197:  int16(-int32(3691)),
	198:  int16(-int32(4470)),
	199:  int16(4521),
	200:  int16(-int32(3863)),
	201:  int16(1093),
	202:  int16(-int32(5552)),
	203:  int16(-int32(2016)),
	204:  int16(3831),
	205:  int16(334),
	206:  int16(-int32(456)),
	207:  int16(-int32(1532)),
	208:  int16(2068),
	209:  int16(1788),
	210:  int16(2054),
	211:  int16(-int32(295)),
	212:  int16(3668),
	213:  int16(-int32(2820)),
	214:  int16(328),
	215:  int16(-int32(994)),
	216:  int16(295),
	217:  int16(-int32(3301)),
	218:  int16(5770),
	219:  int16(4282),
	220:  int16(-int32(6353)),
	221:  int16(5632),
	222:  int16(-int32(1371)),
	223:  int16(5005),
	224:  int16(238),
	225:  int16(4041),
	228:  int16(6764),
	229:  int16(-int32(1659)),
	230:  int16(-int32(2730)),
	231:  int16(5726),
	232:  int16(3715),
	233:  int16(-int32(3216)),
	234:  int16(-int32(933)),
	235:  int16(531),
	236:  int16(-int32(52)),
	237:  int16(-int32(345)),
	238:  int16(3022),
	239:  int16(-int32(2818)),
	240:  int16(4005),
	241:  int16(-int32(1617)),
	242:  int16(-int32(1189)),
	243:  int16(-int32(3748)),
	244:  int16(-int32(3403)),
	245:  int16(-int32(3592)),
	246:  int16(4040),
	247:  int16(-int32(3553)),
	248:  int16(-int32(2806)),
	249:  int16(-int32(3444)),
	250:  int16(6023),
	251:  int16(-int32(711)),
	252:  int16(-int32(3298)),
	253:  int16(-int32(2503)),
	254:  int16(2548),
	255:  int16(5564),
	256:  int16(940),
	257:  int16(1848),
	258:  int16(1207),
	259:  int16(4010),
	260:  int16(-int32(3488)),
	261:  int16(-int32(358)),
	262:  int16(-int32(2511)),
	263:  int16(-int32(1966)),
	266:  int16(-int32(64)),
	267:  int16(-int32(5039)),
	268:  int16(1403),
	269:  int16(-int32(4455)),
	270:  int16(6240),
	271:  int16(2189),
	272:  int16(-int32(1716)),
	273:  int16(-int32(4348)),
	274:  int16(4183),
	275:  int16(3951),
	276:  int16(-int32(4042)),
	277:  int16(-int32(3606)),
	278:  int16(2399),
	279:  int16(-int32(4563)),
	280:  int16(4050),
	281:  int16(-int32(612)),
	282:  int16(-int32(395)),
	283:  int16(348),
	284:  int16(-int32(5791)),
	285:  int16(391),
	286:  int16(-int32(1440)),
	287:  int16(-int32(735)),
	288:  int16(1398),
	289:  int16(4359),
	290:  int16(-int32(518)),
	291:  int16(2969),
	292:  int16(6556),
	293:  int16(1951),
	294:  int16(-int32(518)),
	295:  int16(-int32(4993)),
	296:  int16(-int32(925)),
	297:  int16(998),
	298:  int16(-int32(569)),
	299:  int16(-int32(2934)),
	300:  int16(3460),
	301:  int16(420),
	304:  int16(16),
	305:  int16(5482),
	306:  int16(-int32(4122)),
	307:  int16(770),
	308:  int16(2082),
	309:  int16(5020),
	310:  int16(-int32(3961)),
	311:  int16(485),
	312:  int16(-int32(584)),
	313:  int16(-int32(793)),
	314:  int16(3),
	315:  int16(5222),
	316:  int16(-int32(1416)),
	317:  int16(3673),
	318:  int16(78),
	319:  int16(3549),
	320:  int16(-int32(937)),
	321:  int16(-int32(5723)),
	322:  int16(1673),
	323:  int16(-int32(6162)),
	324:  int16(-int32(2540)),
	325:  int16(3082),
	326:  int16(-int32(355)),
	327:  int16(1838),
	328:  int16(-int32(615)),
	329:  int16(4601),
	330:  int16(2832),
	331:  int16(-int32(359)),
	332:  int16(-int32(3346)),
	333:  int16(668),
	334:  int16(-int32(3393)),
	335:  int16(-int32(1583)),
	336:  int16(-int32(3774)),
	337:  int16(-int32(2206)),
	338:  int16(5754),
	339:  int16(-int32(4961)),
	342:  int16(-int32(328)),
	343:  int16(299),
	344:  int16(2470),
	345:  int16(317),
	346:  int16(525),
	347:  int16(-int32(4494)),
	348:  int16(2805),
	349:  int16(2617),
	350:  int16(2383),
	351:  int16(-int32(2363)),
	352:  int16(-int32(1037)),
	353:  int16(4085),
	354:  int16(895),
	355:  int16(-int32(4622)),
	356:  int16(3218),
	357:  int16(-int32(6607)),
	358:  int16(-int32(3381)),
	359:  int16(-int32(5933)),
	360:  int16(1397),
	361:  int16(6394),
	362:  int16(-int32(446)),
	363:  int16(5694),
	364:  int16(14),
	365:  int16(-int32(4510)),
	366:  int16(4329),
	367:  int16(3690),
	368:  int16(-int32(334)),
	370:  int16(2932),
	371:  int16(-int32(2478)),
	372:  int16(-int32(2944)),
	373:  int16(-int32(577)),
	374:  int16(-int32(599)),
	375:  int16(-int32(230)),
	376:  int16(1553),
	377:  int16(-int32(4736)),
	380:  int16(-int32(324)),
	381:  int16(142),
	382:  int16(-int32(3252)),
	383:  int16(-int32(867)),
	384:  int16(1111),
	385:  int16(-int32(1882)),
	386:  int16(3378),
	387:  int16(-int32(6055)),
	388:  int16(6502),
	389:  int16(-int32(6840)),
	390:  int16(4280),
	391:  int16(-int32(2694)),
	392:  int16(-int32(2876)),
	393:  int16(4190),
	394:  int16(6454),
	395:  int16(655),
	396:  int16(1061),
	397:  int16(626),
	398:  int16(-int32(2669)),
	399:  int16(-int32(798)),
	400:  int16(3192),
	401:  int16(-int32(985)),
	402:  int16(-int32(898)),
	403:  int16(-int32(5482)),
	404:  int16(-int32(548)),
	405:  int16(2315),
	406:  int16(-int32(558)),
	407:  int16(1302),
	408:  int16(900),
	409:  int16(5747),
	410:  int16(-int32(1325)),
	411:  int16(1599),
	412:  int16(-int32(1384)),
	413:  int16(-int32(5749)),
	414:  int16(624),
	415:  int16(1110),
	418:  int16(321),
	419:  int16(312),
	420:  int16(2188),
	421:  int16(1322),
	422:  int16(237),
	423:  int16(708),
	424:  int16(-int32(304)),
	425:  int16(2463),
	426:  int16(1500),
	427:  int16(-int32(1094)),
	428:  int16(-int32(5112)),
	429:  int16(-int32(1010)),
	430:  int16(-int32(6799)),
	431:  int16(646),
	432:  int16(992),
	433:  int16(1969),
	434:  int16(3423),
	435:  int16(-int32(3996)),
	436:  int16(2628),
	437:  int16(4451),
	438:  int16(3432),
	439:  int16(-int32(2833)),
	440:  int16(-int32(6101)),
	441:  int16(-int32(330)),
	442:  int16(-int32(3768)),
	443:  int16(-int32(3)),
	444:  int16(-int32(707)),
	445:  int16(5961),
	446:  int16(-int32(4037)),
	447:  int16(-int32(3736)),
	448:  int16(4080),
	449:  int16(7254),
	450:  int16(-int32(4113)),
	451:  int16(2151),
	452:  int16(54),
	453:  int16(-int32(2150)),
	456:  int16(7735),
	457:  int16(4064),
	458:  int16(-int32(3884)),
	459:  int16(-int32(5240)),
	460:  int16(577),
	461:  int16(2229),
	462:  int16(-int32(3947)),
	463:  int16(2914),
	464:  int16(3555),
	465:  int16(4011),
	466:  int16(774),
	467:  int16(-int32(3519)),
	468:  int16(1985),
	469:  int16(-int32(3701)),
	470:  int16(-int32(3824)),
	471:  int16(330),
	472:  int16(-int32(905)),
	473:  int16(2085),
	474:  int16(1155),
	475:  int16(2176),
	476:  int16(3006),
	477:  int16(340),
	478:  int16(-int32(5533)),
	479:  int16(-int32(3264)),
	480:  int16(-int32(902)),
	481:  int16(3114),
	482:  int16(344),
	483:  int16(-int32(5060)),
	484:  int16(1524),
	485:  int16(1805),
	486:  int16(1926),
	487:  int16(2350),
	488:  int16(1905),
	489:  int16(-int32(3203)),
	490:  int16(-int32(2762)),
	491:  int16(-int32(4162)),
	494:  int16(193),
	495:  int16(-int32(151)),
	496:  int16(-int32(1434)),
	497:  int16(6289),
	498:  int16(7354),
	499:  int16(4234),
	500:  int16(169),
	501:  int16(2868),
	502:  int16(-int32(1977)),
	503:  int16(-int32(1375)),
	504:  int16(-int32(4987)),
	505:  int16(2345),
	506:  int16(2742),
	507:  int16(599),
	508:  int16(939),
	509:  int16(-int32(4837)),
	510:  int16(2688),
	511:  int16(991),
	512:  int16(-int32(6907)),
	513:  int16(716),
	514:  int16(-int32(1542)),
	515:  int16(-int32(4346)),
	516:  int16(-int32(1833)),
	517:  int16(1493),
	518:  int16(3134),
	519:  int16(2903),
	520:  int16(-int32(7019)),
	521:  int16(-int32(2835)),
	522:  int16(93),
	523:  int16(4395),
	524:  int16(621),
	525:  int16(870),
	526:  int16(-int32(2357)),
	527:  int16(-int32(975)),
	528:  int16(-int32(2933)),
	529:  int16(-int32(127)),
	532:  int16(-int32(616)),
	533:  int16(-int32(5968)),
	534:  int16(-int32(3479)),
	535:  int16(-int32(1651)),
	536:  int16(4932),
	537:  int16(-int32(2445)),
	538:  int16(-int32(5512)),
	539:  int16(-int32(1451)),
	540:  int16(691),
	541:  int16(739),
	542:  int16(479),
	543:  int16(4227),
	544:  int16(-int32(2886)),
	545:  int16(3853),
	546:  int16(8),
	547:  int16(-int32(501)),
	548:  int16(188),
	549:  int16(1990),
	550:  int16(3842),
	551:  int16(2270),
	552:  int16(1662),
	553:  int16(-int32(174)),
	554:  int16(1290),
	555:  int16(2456),
	556:  int16(67),
	557:  int16(-int32(3267)),
	558:  int16(-int32(5535)),
	559:  int16(483),
	560:  int16(5721),
	561:  int16(-int32(1642)),
	562:  int16(6501),
	563:  int16(-int32(3432)),
	564:  int16(1184),
	565:  int16(-int32(3246)),
	566:  int16(4101),
	567:  int16(-int32(4880)),
	570:  int16(-int32(465)),
	571:  int16(5264),
	572:  int16(-int32(4812)),
	573:  int16(682),
	574:  int16(1683),
	575:  int16(-int32(4539)),
	576:  int16(2916),
	577:  int16(-int32(1985)),
	578:  int16(2899),
	579:  int16(3324),
	580:  int16(1060),
	581:  int16(-int32(4398)),
	582:  int16(-int32(745)),
	583:  int16(-int32(2137)),
	584:  int16(-int32(3827)),
	585:  int16(1044),
	586:  int16(6225),
	587:  int16(3609),
	588:  int16(-int32(532)),
	589:  int16(1980),
	590:  int16(-int32(6001)),
	591:  int16(564),
	592:  int16(-int32(209)),
	593:  int16(-int32(1299)),
	594:  int16(5336),
	595:  int16(-int32(3605)),
	596:  int16(-int32(1484)),
	597:  int16(37),
	598:  int16(19),
	599:  int16(-int32(1295)),
	600:  int16(-int32(665)),
	601:  int16(-int32(385)),
	602:  int16(-int32(6773)),
	603:  int16(3651),
	604:  int16(6153),
	605:  int16(-int32(1291)),
	608:  int16(193),
	609:  int16(-int32(415)),
	610:  int16(5166),
	611:  int16(-int32(110)),
	612:  int16(626),
	613:  int16(6743),
	614:  int16(-int32(2860)),
	615:  int16(1425),
	616:  int16(1101),
	617:  int16(-int32(1341)),
	618:  int16(80),
	619:  int16(-int32(4533)),
	620:  int16(249),
	621:  int16(4231),
	622:  int16(-int32(119)),
	623:  int16(-int32(6009)),
	624:  int16(-int32(2970)),
	625:  int16(5170),
	626:  int16(-int32(822)),
	627:  int16(-int32(2610)),
	628:  int16(4527),
	629:  int16(5948),
	630:  int16(182),
	631:  int16(-int32(2589)),
	632:  int16(837),
	633:  int16(-int32(5471)),
	634:  int16(371),
	635:  int16(-int32(43)),
	636:  int16(373),
	637:  int16(-int32(665)),
	638:  int16(-int32(1233)),
	639:  int16(-int32(626)),
	640:  int16(-int32(7353)),
	641:  int16(2606),
	642:  int16(1339),
	643:  int16(-int32(1398)),
	646:  int16(-int32(533)),
	647:  int16(147),
	648:  int16(2075),
	649:  int16(-int32(672)),
	650:  int16(1043),
	651:  int16(3503),
	652:  int16(4402),
	653:  int16(-int32(4971)),
	654:  int16(-int32(3287)),
	655:  int16(3731),
	656:  int16(-int32(2606)),
	657:  int16(3817),
	658:  int16(1972),
	659:  int16(-int32(5603)),
	660:  int16(5114),
	661:  int16(1185),
	662:  int16(-int32(1318)),
	663:  int16(1906),
	664:  int16(3018),
	665:  int16(-int32(1999)),
	666:  int16(343),
	667:  int16(-int32(1943)),
	668:  int16(207),
	669:  int16(-int32(6744)),
	670:  int16(913),
	671:  int16(-int32(4060)),
	672:  int16(645),
	673:  int16(-int32(349)),
	674:  int16(-int32(5667)),
	675:  int16(4766),
	676:  int16(5575),
	677:  int16(-int32(1733)),
	678:  int16(1116),
	679:  int16(160),
	680:  int16(1534),
	681:  int16(-int32(5690)),
	684:  int16(-int32(137)),
	685:  int16(-int32(36)),
	686:  int16(1556),
	687:  int16(1325),
	688:  int16(1553),
	689:  int16(-int32(2230)),
	690:  int16(1188),
	691:  int16(5296),
	692:  int16(-int32(5104)),
	693:  int16(4673),
	694:  int16(6295),
	695:  int16(498),
	696:  int16(-int32(4723)),
	697:  int16(933),
	698:  int16(2994),
	699:  int16(4067),
	700:  int16(-int32(4700)),
	701:  int16(1758),
	702:  int16(-int32(4116)),
	703:  int16(-int32(1252)),
	704:  int16(2444),
	705:  int16(-int32(4092)),
	706:  int16(1653),
	707:  int16(-int32(2802)),
	708:  int16(5069),
	709:  int16(1133),
	710:  int16(790),
	711:  int16(-int32(2355)),
	712:  int16(-int32(934)),
	713:  int16(-int32(6304)),
	714:  int16(1642),
	715:  int16(2045),
	716:  int16(-int32(4259)),
	717:  int16(-int32(3873)),
	718:  int16(-int32(213)),
	719:  int16(215),
	722:  int16(-int32(364)),
	723:  int16(423),
	724:  int16(4888),
	725:  int16(-int32(1316)),
	726:  int16(118),
	727:  int16(-int32(950)),
	728:  int16(4027),
	729:  int16(114),
	730:  int16(2961),
	731:  int16(-int32(3136)),
	732:  int16(-int32(3012)),
	733:  int16(-int32(883)),
	734:  int16(-int32(6192)),
	735:  int16(1340),
	736:  int16(-int32(3210)),
	737:  int16(-int32(1193)),
	738:  int16(1376),
	739:  int16(3128),
	740:  int16(1596),
	741:  int16(-int32(2994)),
	742:  int16(-int32(3194)),
	743:  int16(533),
	744:  int16(8502),
	745:  int16(2487),
	746:  int16(-int32(1485)),
	747:  int16(1032),
	748:  int16(301),
	749:  int16(-int32(8007)),
	750:  int16(-int32(577)),
	751:  int16(887),
	752:  int16(297),
	753:  int16(7778),
	754:  int16(3121),
	755:  int16(-int32(1901)),
	756:  int16(-int32(94)),
	757:  int16(-int32(6401)),
	760:  int16(9260),
	761:  int16(-int32(1845)),
	762:  int16(668),
	763:  int16(2787),
	764:  int16(-int32(2255)),
	765:  int16(2699),
	766:  int16(-int32(2512)),
	767:  int16(-int32(3737)),
	768:  int16(-int32(3675)),
	769:  int16(-int32(3601)),
	770:  int16(-int32(1803)),
	771:  int16(210),
	772:  int16(-int32(1701)),
	773:  int16(-int32(1442)),
	774:  int16(-int32(2700)),
	775:  int16(3457),
	776:  int16(2868),
	777:  int16(2079),
	778:  int16(-int32(2113)),
	779:  int16(3178),
	780:  int16(1277),
	781:  int16(3578),
	782:  int16(5240),
	783:  int16(-int32(2482)),
	784:  int16(3324),
	785:  int16(1020),
	786:  int16(-int32(4027)),
	787:  int16(3835),
	788:  int16(-int32(3758)),
	789:  int16(-int32(3633)),
	790:  int16(-int32(3170)),
	791:  int16(-int32(1310)),
	792:  int16(2509),
	793:  int16(-int32(3110)),
	794:  int16(713),
	795:  int16(174),
	798:  int16(-int32(399)),
	799:  int16(4969),
	800:  int16(-int32(2321)),
	801:  int16(-int32(7744)),
	802:  int16(6494),
	803:  int16(-int32(3776)),
	804:  int16(1478),
	805:  int16(758),
	806:  int16(-int32(1794)),
	807:  int16(-int32(2233)),
	808:  int16(-int32(4059)),
	809:  int16(4932),
	810:  int16(2770),
	811:  int16(4761),
	812:  int16(-int32(3475)),
	813:  int16(1243),
	814:  int16(829),
	815:  int16(-int32(651)),
	816:  int16(-int32(5358)),
	817:  int16(-int32(436)),
	818:  int16(2381),
	819:  int16(1360),
	820:  int16(2561),
	821:  int16(-int32(3118)),
	822:  int16(858),
	823:  int16(-int32(4366)),
	824:  int16(3933),
	825:  int16(3646),
	826:  int16(-int32(43)),
	827:  int16(-int32(1310)),
	828:  int16(-int32(16)),
	829:  int16(924),
	830:  int16(1197),
	831:  int16(1415),
	832:  int16(-int32(5036)),
	833:  int16(-int32(376)),
	836:  int16(100),
	837:  int16(1410),
	838:  int16(1290),
	839:  int16(3199),
	840:  int16(7091),
	841:  int16(-int32(3638)),
	842:  int16(-int32(2641)),
	843:  int16(1118),
	844:  int16(45),
	845:  int16(-int32(441)),
	846:  int16(794),
	847:  int16(-int32(974)),
	848:  int16(-int32(5033)),
	849:  int16(889),
	850:  int16(438),
	851:  int16(-int32(3102)),
	852:  int16(895),
	853:  int16(3555),
	854:  int16(4672),
	855:  int16(4795),
	856:  int16(1129),
	857:  int16(-int32(2408)),
	858:  int16(-int32(2153)),
	859:  int16(1742),
	860:  int16(159),
	861:  int16(-int32(2040)),
	862:  int16(7578),
	863:  int16(-int32(2006)),
	864:  int16(-int32(5737)),
	865:  int16(1986),
	866:  int16(-int32(5568)),
	867:  int16(-int32(6413)),
	868:  int16(2428),
	869:  int16(-int32(1387)),
	870:  int16(-int32(2441)),
	871:  int16(667),
	874:  int16(-int32(37)),
	875:  int16(-int32(6031)),
	876:  int16(-int32(4434)),
	877:  int16(-int32(904)),
	878:  int16(3290),
	879:  int16(1806),
	880:  int16(4736),
	881:  int16(2516),
	882:  int16(-int32(5905)),
	883:  int16(-int32(5927)),
	884:  int16(1754),
	885:  int16(-int32(4300)),
	886:  int16(-int32(2468)),
	887:  int16(-int32(2203)),
	888:  int16(-int32(4836)),
	889:  int16(-int32(672)),
	890:  int16(1444),
	891:  int16(-int32(1591)),
	892:  int16(-int32(1631)),
	893:  int16(-int32(1789)),
	894:  int16(4311),
	895:  int16(-int32(153)),
	896:  int16(-int32(688)),
	897:  int16(-int32(1222)),
	898:  int16(1058),
	899:  int16(3139),
	900:  int16(4659),
	901:  int16(-int32(353)),
	902:  int16(1543),
	903:  int16(1838),
	904:  int16(2180),
	905:  int16(-int32(1448)),
	906:  int16(2432),
	907:  int16(6277),
	908:  int16(5304),
	909:  int16(-int32(1692)),
	912:  int16(-int32(280)),
	913:  int16(4506),
	914:  int16(807),
	915:  int16(-int32(477)),
	916:  int16(823),
	917:  int16(3550),
	918:  int16(1427),
	919:  int16(-int32(1856)),
	920:  int16(-int32(3003)),
	921:  int16(-int32(3501)),
	922:  int16(-int32(1203)),
	923:  int16(2679),
	924:  int16(933),
	925:  int16(778),
	926:  int16(-int32(4954)),
	927:  int16(-int32(1977)),
	928:  int16(-int32(7458)),
	929:  int16(4687),
	930:  int16(435),
	931:  int16(7045),
	932:  int16(-int32(4053)),
	933:  int16(-int32(3130)),
	934:  int16(257),
	935:  int16(-int32(3917)),
	936:  int16(-int32(6165)),
	937:  int16(1889),
	938:  int16(927),
	939:  int16(235),
	940:  int16(1889),
	941:  int16(-int32(1097)),
	942:  int16(1985),
	943:  int16(630),
	944:  int16(-int32(2172)),
	945:  int16(-int32(2130)),
	946:  int16(7080),
	947:  int16(4810),
	950:  int16(-int32(300)),
	951:  int16(496),
	952:  int16(2808),
	953:  int16(279),
	954:  int16(667),
	955:  int16(-int32(7179)),
	956:  int16(-int32(2661)),
	957:  int16(-int32(526)),
	958:  int16(-int32(2832)),
	959:  int16(1751),
	960:  int16(2849),
	961:  int16(4829),
	962:  int16(-int32(906)),
	963:  int16(-int32(4151)),
	964:  int16(-int32(1124)),
	965:  int16(-int32(3062)),
	966:  int16(8166),
	967:  int16(5361),
	968:  int16(-int32(1656)),
	969:  int16(-int32(6017)),
	970:  int16(3265),
	971:  int16(2551),
	972:  int16(-int32(864)),
	973:  int16(-int32(432)),
	974:  int16(-int32(6966)),
	975:  int16(6295),
	976:  int16(-int32(168)),
	977:  int16(901),
	978:  int16(442),
	979:  int16(-int32(582)),
	980:  int16(269),
	981:  int16(236),
	982:  int16(-int32(3574)),
	983:  int16(799),
	984:  int16(472),
	985:  int16(565),
	988:  int16(805),
	989:  int16(-int32(2466)),
	990:  int16(6208),
	991:  int16(-int32(4592)),
	992:  int16(-int32(170)),
	993:  int16(-int32(6701)),
	994:  int16(-int32(5610)),
	995:  int16(3678),
	996:  int16(-int32(4242)),
	997:  int16(4561),
	998:  int16(-int32(724)),
	999:  int16(-int32(5534)),
	1000: int16(2415),
	1001: int16(7354),
	1002: int16(2761),
	1003: int16(2699),
	1004: int16(-int32(349)),
	1005: int16(3822),
	1006: int16(-int32(2372)),
	1007: int16(1756),
	1008: int16(-int32(5523)),
	1009: int16(-int32(3445)),
	1010: int16(-int32(588)),
	1011: int16(-int32(5749)),
	1012: int16(-int32(3986)),
	1013: int16(9804),
	1014: int16(-int32(3871)),
	1015: int16(5375),
	1016: int16(-int32(2308)),
	1017: int16(5504),
	1018: int16(-int32(2766)),
	1019: int16(-int32(1651)),
	1020: int16(1472),
	1021: int16(6832),
	1022: int16(2705),
	1023: int16(-int32(5104)),
	1026: int16(-int32(700)),
	1027: int16(-int32(1179)),
	1028: int16(4402),
	1029: int16(400),
	1030: int16(1383),
	1031: int16(939),
	1032: int16(-int32(1342)),
	1033: int16(6013),
	1034: int16(2577),
	1035: int16(-int32(3472)),
	1036: int16(472),
	1037: int16(2883),
	1038: int16(1450),
	1039: int16(-int32(3917)),
	1040: int16(2849),
	1041: int16(5084),
	1042: int16(4990),
	1043: int16(5392),
	1044: int16(342),
	1045: int16(-int32(4925)),
	1046: int16(-int32(3329)),
	1047: int16(-int32(5372)),
	1048: int16(-int32(2674)),
	1049: int16(-int32(6035)),
	1050: int16(-int32(5072)),
	1051: int16(-int32(836)),
	1052: int16(179),
	1053: int16(2506),
	1054: int16(7987),
	1055: int16(-int32(3647)),
	1056: int16(-int32(8202)),
	1057: int16(-int32(1437)),
	1058: int16(1891),
	1059: int16(2400),
	1060: int16(1607),
	1061: int16(-int32(3611)),
	1064: int16(-int32(4706)),
	1065: int16(-int32(4003)),
	1066: int16(9928),
	1067: int16(-int32(379)),
	1068: int16(5557),
	1069: int16(3738),
	1070: int16(-int32(8789)),
	1071: int16(685),
	1072: int16(1937),
	1073: int16(-int32(5157)),
	1074: int16(13388),
	1075: int16(7995),
	1076: int16(-int32(4119)),
	1077: int16(-int32(9909)),
	1078: int16(-int32(5079)),
	1079: int16(4804),
	1080: int16(5586),
	1081: int16(774),
	1082: int16(-int32(5430)),
	1083: int16(299),
	1084: int16(-int32(9943)),
	1085: int16(3264),
	1086: int16(-int32(3690)),
	1087: int16(-int32(3901)),
	1088: int16(-int32(1133)),
	1089: int16(-int32(6199)),
	1090: int16(3182),
	1091: int16(1544),
	1092: int16(5467),
	1093: int16(3686),
	1094: int16(-int32(2639)),
	1095: int16(4068),
	1096: int16(1163),
	1097: int16(-int32(185)),
	1098: int16(-int32(1299)),
	1099: int16(-int32(506)),
	1102: int16(843),
	1103: int16(1005),
	1104: int16(-int32(1059)),
	1105: int16(467),
	1106: int16(-int32(1279)),
	1107: int16(-int32(2259)),
	1108: int16(6057),
	1109: int16(-int32(1694)),
	1110: int16(-int32(5885)),
	1111: int16(5342),
	1112: int16(-int32(5160)),
	1113: int16(-int32(3748)),
	1114: int16(-int32(1382)),
	1115: int16(4420),
	1116: int16(-int32(697)),
	1117: int16(-int32(2000)),
	1118: int16(-int32(3808)),
	1119: int16(3100),
	1120: int16(2685),
	1121: int16(-int32(4073)),
	1122: int16(531),
	1123: int16(318),
	1124: int16(-int32(7822)),
	1125: int16(2414),
	1126: int16(2901),
	1127: int16(3399),
	1128: int16(-int32(1340)),
	1129: int16(8449),
	1130: int16(3685),
	1131: int16(463),
	1132: int16(-int32(3341)),
	1133: int16(2423),
	1134: int16(2304),
	1135: int16(-int32(2723)),
	1136: int16(84),
	1137: int16(-int32(2622)),
	1140: int16(12088),
	1141: int16(-int32(265)),
	1142: int16(2562),
	1143: int16(-int32(435)),
	1144: int16(-int32(4348)),
	1145: int16(-int32(2426)),
	1146: int16(3538),
	1147: int16(1552),
	1148: int16(1279),
	1149: int16(883),
	1150: int16(-int32(4166)),
	1151: int16(2634),
	1152: int16(-int32(6130)),
	1153: int16(2994),
	1154: int16(3729),
	1155: int16(-int32(1570)),
	1156: int16(-int32(601)),
	1157: int16(-int32(1753)),
	1158: int16(-int32(5124)),
	1159: int16(-int32(2788)),
	1160: int16(-int32(2096)),
	1161: int16(-int32(1920)),
	1162: int16(-int32(2649)),
	1163: int16(2793),
	1164: int16(-int32(1079)),
	1165: int16(-int32(1952)),
	1166: int16(2983),
	1167: int16(-int32(1530)),
	1168: int16(2499),
	1169: int16(1769),
	1170: int16(1492),
	1171: int16(-int32(6757)),
	1172: int16(-int32(2108)),
	1173: int16(2841),
	1174: int16(1466),
	1175: int16(2597),
	1178: int16(-int32(3830)),
	1179: int16(-int32(4093)),
	1180: int16(2448),
	1181: int16(12720),
	1182: int16(7737),
	1183: int16(-int32(665)),
	1184: int16(-int32(832)),
	1185: int16(-int32(9257)),
	1186: int16(2971),
	1187: int16(-int32(2400)),
	1188: int16(791),
	1189: int16(1873),
	1190: int16(1072),
	1191: int16(-int32(587)),
	1192: int16(-int32(7440)),
	1193: int16(8055),
	1194: int16(1531),
	1195: int16(-int32(4736)),
	1196: int16(616),
	1197: int16(-int32(1782)),
	1198: int16(-int32(2982)),
	1199: int16(9663),
	1200: int16(-int32(5057)),
	1201: int16(-int32(5926)),
	1202: int16(1610),
	1203: int16(-int32(4489)),
	1204: int16(7033),
	1205: int16(-int32(8658)),
	1206: int16(6010),
	1207: int16(-int32(5673)),
	1208: int16(5648),
	1209: int16(812),
	1210: int16(-int32(271)),
	1211: int16(-int32(1802)),
	1212: int16(-int32(4500)),
	1213: int16(4392),
	1216: int16(-int32(888)),
	1217: int16(-int32(327)),
	1218: int16(3373),
	1219: int16(-int32(1084)),
	1220: int16(7959),
	1221: int16(2430),
	1222: int16(1898),
	1223: int16(-int32(2360)),
	1224: int16(-int32(1820)),
	1225: int16(-int32(1377)),
	1226: int16(-int32(1090)),
	1227: int16(-int32(4436)),
	1228: int16(-int32(3422)),
	1229: int16(-int32(1106)),
	1230: int16(-int32(3230)),
	1231: int16(3876),
	1232: int16(-int32(41)),
	1233: int16(-int32(5128)),
	1234: int16(6375),
	1235: int16(-int32(1848)),
	1236: int16(-int32(3824)),
	1237: int16(5844),
	1238: int16(617),
	1239: int16(-int32(1957)),
	1240: int16(4232),
	1241: int16(1345),
	1242: int16(-int32(1439)),
	1243: int16(-int32(83)),
	1244: int16(3046),
	1245: int16(-int32(214)),
	1246: int16(5458),
	1247: int16(-int32(5566)),
	1248: int16(-int32(4387)),
	1249: int16(-int32(3738)),
	1250: int16(-int32(5740)),
	1251: int16(8657),
	1254: int16(6978),
	1255: int16(6239),
	1256: int16(-int32(3686)),
	1257: int16(-int32(981)),
	1258: int16(-int32(2854)),
	1259: int16(78),
	1260: int16(5859),
	1261: int16(-int32(357)),
	1262: int16(4618),
	1263: int16(7391),
	1264: int16(-int32(138)),
	1265: int16(971),
	1266: int16(-int32(5799)),
	1267: int16(2135),
	1268: int16(4478),
	1269: int16(-int32(7004)),
	1270: int16(-int32(5949)),
	1271: int16(1668),
	1272: int16(-int32(6933)),
	1273: int16(-int32(1163)),
	1274: int16(7010),
	1275: int16(-int32(5624)),
	1276: int16(2990),
	1277: int16(6192),
	1278: int16(-int32(8075)),
	1279: int16(3567),
	1280: int16(-int32(8308)),
	1281: int16(2236),
	1282: int16(-int32(5098)),
	1283: int16(-int32(2120)),
	1284: int16(-int32(4355)),
	1285: int16(-int32(4238)),
	1286: int16(4955),
	1287: int16(10230),
	1288: int16(692),
	1289: int16(-int32(5606)),
	1292: int16(-int32(1348)),
	1293: int16(-int32(7069)),
	1294: int16(-int32(12)),
	1295: int16(-int32(4927)),
	1296: int16(1211),
	1297: int16(651),
	1298: int16(1360),
	1299: int16(7744),
	1300: int16(3404),
	1301: int16(5069),
	1302: int16(-int32(2438)),
	1303: int16(-int32(105)),
	1304: int16(2332),
	1305: int16(1494),
	1306: int16(-int32(4686)),
	1307: int16(1336),
	1308: int16(-int32(3628)),
	1309: int16(-int32(881)),
	1310: int16(2474),
	1311: int16(1736),
	1312: int16(-int32(26)),
	1313: int16(-int32(257)),
	1314: int16(2135),
	1315: int16(-int32(4452)),
	1316: int16(446),
	1317: int16(-int32(641)),
	1318: int16(-int32(4704)),
	1319: int16(2605),
	1320: int16(-int32(6436)),
	1321: int16(6662),
	1322: int16(-int32(4939)),
	1323: int16(990),
	1324: int16(-int32(1100)),
	1325: int16(-int32(3782)),
	1326: int16(5028),
	1327: int16(4753),
	1330: int16(-int32(2875)),
	1331: int16(6410),
	1332: int16(3518),
	1333: int16(3950),
	1334: int16(1271),
	1335: int16(869),
	1336: int16(-int32(2842)),
	1337: int16(-int32(5837)),
	1338: int16(1532),
	1339: int16(-int32(2899)),
	1340: int16(1140),
	1341: int16(-int32(597)),
	1342: int16(1712),
	1343: int16(-int32(1988)),
	1344: int16(-int32(4819)),
	1345: int16(-int32(4783)),
	1346: int16(4773),
	1347: int16(-int32(8796)),
	1348: int16(2240),
	1349: int16(-int32(4596)),
	1350: int16(3565),
	1351: int16(-int32(4853)),
	1352: int16(-int32(556)),
	1353: int16(-int32(3974)),
	1354: int16(7366),
	1355: int16(-int32(4370)),
	1356: int16(3113),
	1357: int16(-int32(3548)),
	1358: int16(3552),
	1359: int16(-int32(5450)),
	1360: int16(3869),
	1361: int16(2514),
	1362: int16(6736),
	1363: int16(-int32(4570)),
	1364: int16(6074),
	1365: int16(3151),
	1404: int16(32767),
	1443: int16(32767),
}

var Opus_mapping_matrix_fifthoa_mixing = OpusT_MappingMatrix{
	Frows: int32(38),
	Fcols: int32(38),
}

var Opus_mapping_matrix_fifthoa_mixing_data = [1444]OpusT_opus_int16{
	0:    int16(9243),
	2:    int16(16010),
	6:    int16(20669),
	12:   int16(24456),
	20:   int16(27731),
	30:   int16(30657),
	38:   int16(9243),
	40:   int16(-int32(7023)),
	41:   int16(14387),
	44:   int16(-int32(4369)),
	45:   int16(-int32(14112)),
	46:   int16(14455),
	50:   int16(10931),
	51:   int16(-int32(510)),
	52:   int16(-int32(16777)),
	53:   int16(14031),
	58:   int16(-int32(5118)),
	59:   int16(14286),
	60:   int16(4343),
	61:   int16(-int32(18465)),
	62:   int16(13374),
	68:   int16(-int32(6494)),
	69:   int16(-int32(12221)),
	70:   int16(11761),
	71:   int16(8513),
	72:   int16(-int32(19458)),
	73:   int16(12605),
	76:   int16(9243),
	77:   int16(-int32(14128)),
	78:   int16(5093),
	79:   int16(5547),
	80:   int16(-int32(10946)),
	81:   int16(-int32(10050)),
	82:   int16(-int32(7197)),
	83:   int16(3945),
	84:   int16(-int32(11790)),
	85:   int16(7142),
	86:   int16(-int32(9213)),
	87:   int16(6529),
	88:   int16(-int32(9701)),
	89:   int16(-int32(2563)),
	90:   int16(-int32(9923)),
	91:   int16(-int32(14846)),
	92:   int16(16521),
	93:   int16(6816),
	94:   int16(2764),
	95:   int16(14103),
	96:   int16(1118),
	97:   int16(-int32(5537)),
	98:   int16(2977),
	99:   int16(-int32(14168)),
	100:  int16(1228),
	101:  int16(4866),
	102:  int16(17430),
	103:  int16(-int32(528)),
	104:  int16(10639),
	105:  int16(2641),
	106:  int16(10437),
	107:  int16(-int32(1037)),
	108:  int16(11460),
	109:  int16(1098),
	110:  int16(1296),
	111:  int16(15737),
	114:  int16(9243),
	115:  int16(1128),
	116:  int16(-int32(14775)),
	117:  int16(6062),
	118:  int16(955),
	119:  int16(-int32(2329)),
	120:  int16(16069),
	121:  int16(-int32(12511)),
	122:  int16(2477),
	123:  int16(579),
	124:  int16(-int32(2333)),
	125:  int16(3440),
	126:  int16(-int32(14197)),
	127:  int16(18478),
	128:  int16(-int32(6050)),
	129:  int16(940),
	130:  int16(303),
	131:  int16(-int32(1604)),
	132:  int16(4106),
	133:  int16(-int32(4223)),
	134:  int16(9829),
	135:  int16(-int32(22688)),
	136:  int16(10647),
	137:  int16(-int32(2604)),
	138:  int16(334),
	139:  int16(145),
	140:  int16(-int32(927)),
	141:  int16(3203),
	142:  int16(-int32(6017)),
	143:  int16(4507),
	144:  int16(-int32(3812)),
	145:  int16(24212),
	146:  int16(-int32(15600)),
	147:  int16(5198),
	148:  int16(-int32(1023)),
	149:  int16(110),
	152:  int16(9243),
	153:  int16(1158),
	154:  int16(12997),
	155:  int16(9277),
	156:  int16(1501),
	157:  int16(2103),
	158:  int16(10097),
	159:  int16(16840),
	160:  int16(5916),
	161:  int16(1402),
	162:  int16(3225),
	163:  int16(2488),
	164:  int16(2929),
	165:  int16(19916),
	166:  int16(12706),
	167:  int16(3585),
	168:  int16(1137),
	169:  int16(3415),
	170:  int16(4698),
	171:  int16(2078),
	172:  int16(-int32(5442)),
	173:  int16(16634),
	174:  int16(18511),
	175:  int16(8731),
	176:  int16(2095),
	177:  int16(850),
	178:  int16(3061),
	179:  int16(5733),
	180:  int16(5225),
	181:  int16(960),
	182:  int16(-int32(11728)),
	183:  int16(7689),
	184:  int16(20588),
	185:  int16(14659),
	186:  int16(5642),
	187:  int16(1187),
	190:  int16(9243),
	191:  int16(-int32(4663)),
	192:  int16(-int32(3081)),
	193:  int16(-int32(15003)),
	194:  int16(9771),
	195:  int16(2007),
	196:  int16(-int32(9185)),
	197:  int16(6457),
	198:  int16(14199),
	199:  int16(-int32(14357)),
	200:  int16(-int32(4976)),
	201:  int16(3554),
	202:  int16(6625),
	203:  int16(11434),
	204:  int16(-int32(7231)),
	205:  int16(-int32(11297)),
	206:  int16(17760),
	207:  int16(8291),
	208:  int16(-int32(6267)),
	209:  int16(-int32(3368)),
	210:  int16(6712),
	211:  int16(-int32(10837)),
	212:  int16(-int32(9107)),
	213:  int16(6524),
	214:  int16(6793),
	215:  int16(-int32(19531)),
	216:  int16(-int32(11338)),
	217:  int16(7934),
	218:  int16(7335),
	219:  int16(-int32(2205)),
	220:  int16(-int32(9215)),
	221:  int16(-int32(7094)),
	222:  int16(10659),
	223:  int16(6243),
	224:  int16(-int32(4337)),
	225:  int16(-int32(1250)),
	228:  int16(9243),
	229:  int16(-int32(13515)),
	230:  int16(7679),
	231:  int16(-int32(3831)),
	232:  int16(7232),
	233:  int16(-int32(14496)),
	234:  int16(-int32(3201)),
	235:  int16(-int32(4109)),
	236:  int16(-int32(11731)),
	237:  int16(8828),
	238:  int16(9178),
	239:  int16(-int32(1901)),
	240:  int16(-int32(10848)),
	241:  int16(-int32(539)),
	242:  int16(-int32(14888)),
	243:  int16(9626),
	244:  int16(-int32(10860)),
	245:  int16(12703),
	246:  int16(3824),
	247:  int16(12334),
	248:  int16(-int32(7104)),
	249:  int16(3496),
	250:  int16(-int32(6203)),
	251:  int16(13852),
	252:  int16(5461),
	253:  int16(-int32(2109)),
	254:  int16(-int32(17277)),
	255:  int16(7837),
	256:  int16(-int32(4714)),
	257:  int16(13901),
	258:  int16(4097),
	259:  int16(3940),
	260:  int16(7647),
	261:  int16(8546),
	262:  int16(8688),
	263:  int16(-int32(10986)),
	266:  int16(9243),
	267:  int16(8113),
	268:  int16(-int32(9860)),
	269:  int16(9657),
	270:  int16(10943),
	271:  int16(-int32(11174)),
	272:  int16(1426),
	273:  int16(-int32(13300)),
	274:  int16(1915),
	275:  int16(8178),
	276:  int16(-int32(17833)),
	277:  int16(6805),
	278:  int16(8309),
	279:  int16(8100),
	280:  int16(-int32(3121)),
	281:  int16(-int32(4742)),
	282:  int16(2683),
	283:  int16(-int32(15111)),
	284:  int16(15688),
	285:  int16(2358),
	286:  int16(-int32(11590)),
	287:  int16(2807),
	288:  int16(2746),
	289:  int16(8762),
	290:  int16(-int32(7430)),
	291:  int16(-int32(2251)),
	292:  int16(-int32(5481)),
	293:  int16(16370),
	294:  int16(-int32(4081)),
	295:  int16(-int32(9694)),
	296:  int16(5872),
	297:  int16(-int32(11539)),
	298:  int16(-int32(714)),
	299:  int16(-int32(9492)),
	300:  int16(15177),
	301:  int16(-int32(6126)),
	304:  int16(9243),
	305:  int16(9933),
	306:  int16(-int32(9215)),
	307:  int16(-int32(8528)),
	308:  int16(-int32(11831)),
	309:  int16(-int32(12785)),
	310:  int16(-int32(62)),
	311:  int16(10976),
	312:  int16(-int32(1811)),
	313:  int16(5593),
	314:  int16(18018),
	315:  int16(6100),
	316:  int16(9455),
	317:  int16(-int32(5237)),
	318:  int16(2758),
	319:  int16(8971),
	320:  int16(2743),
	321:  int16(-int32(9659)),
	322:  int16(-int32(13517)),
	323:  int16(5330),
	324:  int16(-int32(10737)),
	325:  int16(-int32(4576)),
	326:  int16(-int32(2069)),
	327:  int16(-int32(15491)),
	328:  int16(-int32(8749)),
	329:  int16(-int32(7226)),
	330:  int16(-int32(5237)),
	331:  int16(9191),
	332:  int16(-int32(181)),
	333:  int16(-int32(12277)),
	334:  int16(2815),
	335:  int16(10540),
	336:  int16(-int32(27)),
	337:  int16(14741),
	338:  int16(16703),
	339:  int16(3103),
	342:  int16(9243),
	343:  int16(-int32(10067)),
	344:  int16(-int32(8881)),
	345:  int16(-int32(8723)),
	346:  int16(12265),
	347:  int16(12487),
	348:  int16(-int32(793)),
	349:  int16(10821),
	350:  int16(-int32(1762)),
	351:  int16(-int32(6021)),
	352:  int16(-int32(18002)),
	353:  int16(-int32(5072)),
	354:  int16(9912),
	355:  int16(-int32(4395)),
	356:  int16(2587),
	357:  int16(9368),
	358:  int16(-int32(2767)),
	359:  int16(10021),
	360:  int16(12259),
	361:  int16(-int32(6468)),
	362:  int16(-int32(10113)),
	363:  int16(-int32(5605)),
	364:  int16(-int32(1761)),
	365:  int16(-int32(15590)),
	366:  int16(-int32(9430)),
	367:  int16(7800),
	368:  int16(5092),
	369:  int16(-int32(8835)),
	370:  int16(2293),
	371:  int16(12314),
	372:  int16(1222),
	373:  int16(10671),
	374:  int16(-int32(329)),
	375:  int16(13745),
	376:  int16(17349),
	377:  int16(3563),
	380:  int16(9243),
	381:  int16(-int32(6485)),
	382:  int16(12991),
	383:  int16(-int32(6743)),
	384:  int16(6108),
	385:  int16(-int32(11768)),
	386:  int16(10080),
	387:  int16(-int32(12236)),
	388:  int16(238),
	389:  int16(-int32(2883)),
	390:  int16(13115),
	391:  int16(-int32(13907)),
	392:  int16(2900),
	393:  int16(-int32(14460)),
	394:  int16(511),
	395:  int16(2564),
	396:  int16(186),
	397:  int16(-int32(7019)),
	398:  int16(19094),
	399:  int16(-int32(11597)),
	400:  int16(-int32(5472)),
	401:  int16(-int32(12058)),
	402:  int16(744),
	403:  int16(6243),
	404:  int16(-int32(2384)),
	405:  int16(930),
	406:  int16(501),
	407:  int16(-int32(11778)),
	408:  int16(21214),
	409:  int16(-int32(5330)),
	410:  int16(-int32(11746)),
	411:  int16(-int32(5542)),
	412:  int16(827),
	413:  int16(10475),
	414:  int16(-int32(6418)),
	415:  int16(1132),
	418:  int16(9243),
	419:  int16(3862),
	420:  int16(5238),
	421:  int16(-int32(14627)),
	422:  int16(-int32(7891)),
	423:  int16(2826),
	424:  int16(-int32(7015)),
	425:  int16(-int32(10701)),
	426:  int16(13900),
	427:  int16(11410),
	428:  int16(-int32(6831)),
	429:  int16(-int32(1679)),
	430:  int16(-int32(9861)),
	431:  int16(6359),
	432:  int16(12032),
	433:  int16(-int32(11660)),
	434:  int16(-int32(14041)),
	435:  int16(11199),
	436:  int16(1713),
	437:  int16(-int32(3895)),
	438:  int16(657),
	439:  int16(14749),
	440:  int16(-int32(3017)),
	441:  int16(-int32(11445)),
	442:  int16(8380),
	443:  int16(15575),
	444:  int16(-int32(15236)),
	445:  int16(-int32(346)),
	446:  int16(7690),
	447:  int16(-int32(923)),
	448:  int16(10317),
	449:  int16(3498),
	450:  int16(-int32(13545)),
	451:  int16(354),
	452:  int16(9093),
	453:  int16(-int32(4476)),
	456:  int16(9243),
	457:  int16(-int32(8417)),
	458:  int16(13183),
	459:  int16(3418),
	460:  int16(-int32(4018)),
	461:  int16(-int32(15498)),
	462:  int16(10685),
	463:  int16(6294),
	464:  int16(-int32(4132)),
	465:  int16(1419),
	466:  int16(-int32(8755)),
	467:  int16(-int32(18818)),
	468:  int16(3926),
	469:  int16(7642),
	470:  int16(-int32(9001)),
	471:  int16(-int32(3235)),
	472:  int16(2125),
	473:  int16(3506),
	474:  int16(-int32(13037)),
	475:  int16(-int32(16570)),
	476:  int16(-int32(4337)),
	477:  int16(6729),
	478:  int16(-int32(13404)),
	479:  int16(-int32(7991)),
	480:  int16(59),
	481:  int16(443),
	482:  int16(5804),
	483:  int16(6005),
	484:  int16(-int32(15011)),
	485:  int16(-int32(9060)),
	486:  int16(-int32(11044)),
	487:  int16(3679),
	488:  int16(-int32(15434)),
	489:  int16(-int32(13685)),
	490:  int16(161),
	491:  int16(1185),
	494:  int16(9243),
	495:  int16(-int32(5288)),
	496:  int16(6773),
	497:  int16(-int32(13508)),
	498:  int16(9977),
	499:  int16(-int32(5002)),
	500:  int16(-int32(4784)),
	501:  int16(-int32(12780)),
	502:  int16(10790),
	503:  int16(-int32(12942)),
	504:  int16(11168),
	505:  int16(519),
	506:  int16(-int32(10890)),
	507:  int16(1326),
	508:  int16(12078),
	509:  int16(-int32(6274)),
	510:  int16(13780),
	511:  int16(-int32(16427)),
	512:  int16(2186),
	513:  int16(5352),
	514:  int16(-int32(4328)),
	515:  int16(13671),
	516:  int16(2364),
	517:  int16(-int32(7963)),
	518:  int16(1080),
	519:  int16(-int32(12568)),
	520:  int16(19336),
	521:  int16(-int32(6557)),
	522:  int16(-int32(8574)),
	523:  int16(4084),
	524:  int16(7277),
	525:  int16(10433),
	526:  int16(-int32(9273)),
	527:  int16(-int32(3178)),
	528:  int16(1516),
	529:  int16(3817),
	532:  int16(9243),
	533:  int16(9660),
	534:  int16(7817),
	535:  int16(10093),
	536:  int16(13619),
	537:  int16(10548),
	538:  int16(-int32(2942)),
	539:  int16(11021),
	540:  int16(597),
	541:  int16(9663),
	542:  int16(17594),
	543:  int16(1736),
	544:  int16(-int32(10794)),
	545:  int16(1814),
	546:  int16(771),
	547:  int16(-int32(8469)),
	548:  int16(1041),
	549:  int16(14155),
	550:  int16(7891),
	551:  int16(-int32(8597)),
	552:  int16(-int32(7498)),
	553:  int16(-int32(8982)),
	554:  int16(346),
	555:  int16(-int32(12407)),
	556:  int16(-int32(11848)),
	557:  int16(-int32(6809)),
	558:  int16(1686),
	559:  int16(9181),
	560:  int16(-int32(8306)),
	561:  int16(-int32(10247)),
	562:  int16(3538),
	563:  int16(-int32(10706)),
	564:  int16(-int32(364)),
	565:  int16(-int32(8047)),
	566:  int16(-int32(19188)),
	567:  int16(-int32(8493)),
	570:  int16(9243),
	571:  int16(-int32(7163)),
	572:  int16(-int32(1020)),
	573:  int16(14282),
	574:  int16(-int32(14289)),
	575:  int16(1021),
	576:  int16(-int32(10208)),
	577:  int16(-int32(2036)),
	578:  int16(10660),
	579:  int16(-int32(18919)),
	580:  int16(2410),
	581:  int16(6564),
	582:  int16(2323),
	583:  int16(-int32(13088)),
	584:  int16(-int32(1798)),
	585:  int16(3365),
	586:  int16(-int32(19498)),
	587:  int16(3619),
	588:  int16(12022),
	589:  int16(-int32(1858)),
	590:  int16(9978),
	591:  int16(3705),
	592:  int16(-int32(8969)),
	593:  int16(-int32(643)),
	594:  int16(-int32(5794)),
	595:  int16(-int32(15523)),
	596:  int16(4123),
	597:  int16(15113),
	598:  int16(-int32(3949)),
	599:  int16(-int32(6265)),
	600:  int16(-int32(3596)),
	601:  int16(12490),
	602:  int16(2946),
	603:  int16(-int32(2688)),
	604:  int16(1225),
	605:  int16(-int32(14570)),
	608:  int16(9243),
	609:  int16(-int32(12187)),
	610:  int16(772),
	611:  int16(-int32(10354)),
	612:  int16(17623),
	613:  int16(-int32(1314)),
	614:  int16(-int32(10262)),
	615:  int16(-int32(1117)),
	616:  int16(-int32(2885)),
	617:  int16(-int32(9937)),
	618:  int16(2249),
	619:  int16(11267),
	620:  int16(-int32(1763)),
	621:  int16(9572),
	622:  int16(-int32(368)),
	623:  int16(16506),
	624:  int16(-int32(6510)),
	625:  int16(-int32(1438)),
	626:  int16(-int32(15014)),
	627:  int16(2402),
	628:  int16(10157),
	629:  int16(2041),
	630:  int16(2458),
	631:  int16(2389),
	632:  int16(-int32(19346)),
	633:  int16(19860),
	634:  int16(-int32(1041)),
	635:  int16(8067),
	636:  int16(-int32(3704)),
	637:  int16(-int32(10931)),
	638:  int16(2743),
	639:  int16(-int32(9286)),
	640:  int16(606),
	641:  int16(-int32(13399)),
	642:  int16(-int32(3095)),
	643:  int16(7924),
	646:  int16(9243),
	647:  int16(15545),
	648:  int16(-int32(2367)),
	649:  int16(-int32(3011)),
	650:  int16(-int32(6538)),
	651:  int16(-int32(5139)),
	652:  int16(-int32(9657)),
	653:  int16(995),
	654:  int16(-int32(16242)),
	655:  int16(-int32(15706)),
	656:  int16(2557),
	657:  int16(-int32(12952)),
	658:  int16(5226),
	659:  int16(2508),
	660:  int16(6353),
	661:  int16(10156),
	662:  int16(13593),
	663:  int16(6966),
	664:  int16(4795),
	665:  int16(8960),
	666:  int16(8183),
	667:  int16(-int32(1735)),
	668:  int16(11914),
	669:  int16(-int32(4504)),
	670:  int16(14149),
	671:  int16(11727),
	672:  int16(-int32(6665)),
	673:  int16(10460),
	674:  int16(-int32(3962)),
	675:  int16(10145),
	676:  int16(-int32(7648)),
	677:  int16(-int32(1965)),
	678:  int16(-int32(9845)),
	679:  int16(-int32(6764)),
	680:  int16(-int32(6938)),
	681:  int16(-int32(16633)),
	684:  int16(9243),
	685:  int16(3098),
	686:  int16(12983),
	687:  int16(-int32(8841)),
	688:  int16(-int32(3826)),
	689:  int16(5618),
	690:  int16(10053),
	691:  int16(-int32(16031)),
	692:  int16(4787),
	693:  int16(3283),
	694:  int16(-int32(8209)),
	695:  int16(6632),
	696:  int16(2856),
	697:  int16(-int32(18922)),
	698:  int16(10272),
	699:  int16(-int32(2055)),
	700:  int16(-int32(2344)),
	701:  int16(7987),
	702:  int16(-int32(11939)),
	703:  int16(5516),
	704:  int16(-int32(5520)),
	705:  int16(-int32(15739)),
	706:  int16(14940),
	707:  int16(-int32(5001)),
	708:  int16(530),
	709:  int16(1465),
	710:  int16(-int32(6306)),
	711:  int16(13388),
	712:  int16(-int32(13243)),
	713:  int16(2513),
	714:  int16(-int32(11772)),
	715:  int16(-int32(7170)),
	716:  int16(16572),
	717:  int16(-int32(8384)),
	718:  int16(1426),
	719:  int16(168),
	722:  int16(9243),
	723:  int16(-int32(15767)),
	724:  int16(-int32(2008)),
	725:  int16(-int32(1916)),
	726:  int16(4220),
	727:  int16(4422),
	728:  int16(-int32(9846)),
	729:  int16(537),
	730:  int16(-int32(17105)),
	731:  int16(17650),
	732:  int16(-int32(1400)),
	733:  int16(13589),
	734:  int16(4481),
	735:  int16(1651),
	736:  int16(5677),
	737:  int16(6701),
	738:  int16(-int32(9241)),
	739:  int16(-int32(6642)),
	740:  int16(-int32(3252)),
	741:  int16(-int32(7827)),
	742:  int16(8792),
	743:  int16(-int32(951)),
	744:  int16(13182),
	745:  int16(-int32(2522)),
	746:  int16(17586),
	747:  int16(-int32(17005)),
	748:  int16(3845),
	749:  int16(-int32(12562)),
	750:  int16(2213),
	751:  int16(-int32(11472)),
	752:  int16(-int32(6688)),
	753:  int16(-int32(1394)),
	754:  int16(-int32(8970)),
	755:  int16(-int32(4769)),
	756:  int16(-int32(7316)),
	757:  int16(-int32(11753)),
	760:  int16(9243),
	761:  int16(-int32(13344)),
	762:  int16(-int32(3829)),
	763:  int16(7975),
	764:  int16(-int32(14863)),
	765:  int16(7136),
	766:  int16(-int32(8561)),
	767:  int16(-int32(4265)),
	768:  int16(-int32(7992)),
	769:  int16(-int32(801)),
	770:  int16(9405),
	771:  int16(8912),
	772:  int16(7937),
	773:  int16(-int32(5326)),
	774:  int16(5057),
	775:  int16(-int32(17681)),
	776:  int16(15207),
	777:  int16(575),
	778:  int16(7717),
	779:  int16(-int32(11360)),
	780:  int16(4847),
	781:  int16(6789),
	782:  int16(4150),
	783:  int16(12686),
	784:  int16(-int32(10050)),
	785:  int16(16730),
	786:  int16(-int32(12063)),
	787:  int16(322),
	788:  int16(-int32(12920)),
	789:  int16(-int32(3313)),
	790:  int16(-int32(10267)),
	791:  int16(1980),
	792:  int16(-int32(6948)),
	793:  int16(7112),
	794:  int16(7972),
	795:  int16(8042),
	798:  int16(9243),
	799:  int16(7791),
	800:  int16(-int32(1021)),
	801:  int16(13949),
	802:  int16(15180),
	803:  int16(-int32(1111)),
	804:  int16(-int32(10208)),
	805:  int16(-int32(1989)),
	806:  int16(9348),
	807:  int16(19199),
	808:  int16(-int32(2561)),
	809:  int16(-int32(7140)),
	810:  int16(2323),
	811:  int16(-int32(12782)),
	812:  int16(-int32(1577)),
	813:  int16(817),
	814:  int16(18164),
	815:  int16(-int32(3673)),
	816:  int16(-int32(12771)),
	817:  int16(2022),
	818:  int16(9978),
	819:  int16(3620),
	820:  int16(-int32(7865)),
	821:  int16(-int32(156)),
	822:  int16(-int32(9155)),
	823:  int16(11924),
	824:  int16(-int32(3842)),
	825:  int16(-int32(15336)),
	826:  int16(4196),
	827:  int16(6814),
	828:  int16(-int32(3596)),
	829:  int16(12199),
	830:  int16(2583),
	831:  int16(-int32(652)),
	832:  int16(1936),
	833:  int16(-int32(17637)),
	836:  int16(9243),
	837:  int16(-int32(4810)),
	838:  int16(-int32(15144)),
	839:  int16(-int32(1958)),
	840:  int16(1315),
	841:  int16(10175),
	842:  int16(17406),
	843:  int16(4142),
	844:  int16(-int32(1348)),
	845:  int16(263),
	846:  int16(-int32(3292)),
	847:  int16(-int32(15632)),
	848:  int16(-int32(17046)),
	849:  int16(-int32(6363)),
	850:  int16(3374),
	851:  int16(605),
	852:  int16(-int32(227)),
	853:  int16(-int32(748)),
	854:  int16(5997),
	855:  int16(20334),
	856:  int16(14481),
	857:  int16(8277),
	858:  int16(-int32(6146)),
	859:  int16(-int32(1717)),
	860:  int16(5),
	861:  int16(27),
	862:  int16(712),
	863:  int16(1542),
	864:  int16(-int32(9197)),
	865:  int16(-int32(23572)),
	866:  int16(-int32(10163)),
	867:  int16(-int32(9595)),
	868:  int16(9425),
	869:  int16(3539),
	870:  int16(-int32(17)),
	871:  int16(-int32(72)),
	874:  int16(9243),
	875:  int16(-int32(7366)),
	876:  int16(8261),
	877:  int16(11568),
	878:  int16(-int32(11901)),
	879:  int16(-int32(8499)),
	880:  int16(-int32(2079)),
	881:  int16(13347),
	882:  int16(5556),
	883:  int16(-int32(12049)),
	884:  int16(-int32(16247)),
	885:  int16(-int32(2282)),
	886:  int16(-int32(10529)),
	887:  int16(3584),
	888:  int16(7585),
	889:  int16(-int32(1577)),
	890:  int16(-int32(8464)),
	891:  int16(-int32(18652)),
	892:  int16(-int32(8902)),
	893:  int16(5913),
	894:  int16(-int32(8688)),
	895:  int16(-int32(9287)),
	896:  int16(4156),
	897:  int16(-int32(2442)),
	898:  int16(-int32(7089)),
	899:  int16(-int32(2993)),
	900:  int16(-int32(14485)),
	901:  int16(-int32(13949)),
	902:  int16(5422),
	903:  int16(8459),
	904:  int16(1638),
	905:  int16(-int32(13285)),
	906:  int16(-int32(2531)),
	907:  int16(-int32(1826)),
	908:  int16(-int32(12132)),
	909:  int16(-int32(9456)),
	912:  int16(9243),
	913:  int16(11716),
	914:  int16(698),
	915:  int16(-int32(10889)),
	916:  int16(-int32(17818)),
	917:  int16(1143),
	918:  int16(-int32(10275)),
	919:  int16(-int32(1062)),
	920:  int16(-int32(1305)),
	921:  int16(12057),
	922:  int16(-int32(2057)),
	923:  int16(-int32(10855)),
	924:  int16(-int32(1595)),
	925:  int16(10088),
	926:  int16(-int32(150)),
	927:  int16(15043),
	928:  int16(2978),
	929:  int16(1578),
	930:  int16(15225),
	931:  int16(-int32(2090)),
	932:  int16(10201),
	933:  int16(1943),
	934:  int16(1115),
	935:  int16(1969),
	936:  int16(-int32(20211)),
	937:  int16(-int32(17636)),
	938:  int16(430),
	939:  int16(-int32(9826)),
	940:  int16(3391),
	941:  int16(10572),
	942:  int16(2485),
	943:  int16(-int32(9826)),
	944:  int16(248),
	945:  int16(-int32(12259)),
	946:  int16(-int32(2924)),
	947:  int16(12131),
	950:  int16(9243),
	951:  int16(4361),
	952:  int16(-int32(4594)),
	953:  int16(-int32(14703)),
	954:  int16(-int32(8956)),
	955:  int16(-int32(2798)),
	956:  int16(-int32(7781)),
	957:  int16(9434),
	958:  int16(13769),
	959:  int16(12936),
	960:  int16(6800),
	961:  int16(-int32(2400)),
	962:  int16(9082),
	963:  int16(8091),
	964:  int16(-int32(10453)),
	965:  int16(-int32(11023)),
	966:  int16(-int32(15786)),
	967:  int16(-int32(11136)),
	968:  int16(3285),
	969:  int16(4153),
	970:  int16(2658),
	971:  int16(-int32(14002)),
	972:  int16(-int32(5051)),
	973:  int16(9489),
	974:  int16(7000),
	975:  int16(17206),
	976:  int16(15024),
	977:  int16(-int32(2777)),
	978:  int16(-int32(8491)),
	979:  int16(-int32(42)),
	980:  int16(-int32(10626)),
	981:  int16(141),
	982:  int16(13053),
	983:  int16(2366),
	984:  int16(-int32(6662)),
	985:  int16(-int32(2231)),
	988:  int16(9243),
	989:  int16(-int32(752)),
	990:  int16(-int32(11933)),
	991:  int16(-int32(10646)),
	992:  int16(1119),
	993:  int16(1254),
	994:  int16(6890),
	995:  int16(17745),
	996:  int16(7875),
	997:  int16(-int32(1203)),
	998:  int16(-int32(2207)),
	999:  int16(-int32(1251)),
	1000: int16(2024),
	1001: int16(-int32(17706)),
	1002: int16(-int32(15532)),
	1003: int16(-int32(5600)),
	1004: int16(1128),
	1005: int16(2691),
	1006: int16(2800),
	1007: int16(683),
	1008: int16(-int32(9927)),
	1009: int16(9661),
	1010: int16(19706),
	1011: int16(12522),
	1012: int16(3889),
	1013: int16(-int32(978)),
	1014: int16(-int32(2789)),
	1015: int16(-int32(3992)),
	1016: int16(-int32(2440)),
	1017: int16(206),
	1018: int16(12695),
	1019: int16(2921),
	1020: int16(-int32(17173)),
	1021: int16(-int32(18575)),
	1022: int16(-int32(9616)),
	1023: int16(-int32(2657)),
	1026: int16(9243),
	1027: int16(4791),
	1028: int16(-int32(15001)),
	1029: int16(-int32(2887)),
	1030: int16(-int32(1931)),
	1031: int16(-int32(10037)),
	1032: int16(16885),
	1033: int16(6048),
	1034: int16(-int32(1020)),
	1035: int16(46),
	1036: int16(4789),
	1037: int16(15191),
	1038: int16(-int32(15922)),
	1039: int16(-int32(9154)),
	1040: int16(2530),
	1041: int16(823),
	1042: int16(252),
	1043: int16(-int32(130)),
	1044: int16(-int32(8608)),
	1045: int16(-int32(19335)),
	1046: int16(12613),
	1047: int16(11651),
	1048: int16(-int32(4549)),
	1049: int16(-int32(2314)),
	1050: int16(-int32(172)),
	1051: int16(-int32(101)),
	1052: int16(-int32(784)),
	1053: int16(265),
	1054: int16(12975),
	1055: int16(21741),
	1056: int16(-int32(7551)),
	1057: int16(-int32(13101)),
	1058: int16(6856),
	1059: int16(4710),
	1060: int16(535),
	1061: int16(-int32(46)),
	1064: int16(9243),
	1065: int16(-int32(12153)),
	1066: int16(-int32(10395)),
	1067: int16(754),
	1068: int16(-int32(1281)),
	1069: int16(17644),
	1070: int16(2735),
	1071: int16(-int32(1095)),
	1072: int16(-int32(10274)),
	1073: int16(8359),
	1074: int16(2200),
	1075: int16(-int32(12593)),
	1076: int16(7083),
	1077: int16(782),
	1078: int16(17650),
	1079: int16(-int32(1573)),
	1080: int16(1685),
	1081: int16(-int32(16282)),
	1082: int16(-int32(2164)),
	1083: int16(-int32(530)),
	1084: int16(-int32(11878)),
	1085: int16(32),
	1086: int16(-int32(17359)),
	1087: int16(3065),
	1088: int16(6651),
	1089: int16(-int32(5212)),
	1090: int16(-int32(3628)),
	1091: int16(19365),
	1092: int16(965),
	1093: int16(13180),
	1094: int16(8243),
	1095: int16(-int32(818)),
	1096: int16(7746),
	1097: int16(-int32(3645)),
	1098: int16(-int32(14323)),
	1099: int16(1670),
	1102: int16(9243),
	1103: int16(-int32(6961)),
	1104: int16(-int32(11198)),
	1105: int16(9081),
	1106: int16(-int32(8829)),
	1107: int16(10887),
	1108: int16(4833),
	1109: int16(-int32(14202)),
	1110: int16(2374),
	1111: int16(-int32(6524)),
	1112: int16(16339),
	1113: int16(-int32(9417)),
	1114: int16(4737),
	1115: int16(12284),
	1116: int16(-int32(4394)),
	1117: int16(-int32(2691)),
	1118: int16(-int32(2683)),
	1119: int16(13690),
	1120: int16(-int32(18539)),
	1121: int16(2830),
	1122: int16(-int32(11438)),
	1123: int16(-int32(3692)),
	1124: int16(4985),
	1125: int16(5648),
	1126: int16(-int32(4628)),
	1127: int16(514),
	1128: int16(6225),
	1129: int16(-int32(18409)),
	1130: int16(12672),
	1131: int16(5311),
	1132: int16(11170),
	1133: int16(-int32(6928)),
	1134: int16(-int32(3407)),
	1135: int16(-int32(7595)),
	1136: int16(10737),
	1137: int16(-int32(3977)),
	1140: int16(9243),
	1141: int16(12099),
	1142: int16(-int32(10405)),
	1143: int16(1294),
	1144: int16(2187),
	1145: int16(-int32(17582)),
	1146: int16(2760),
	1147: int16(-int32(1880)),
	1148: int16(-int32(10105)),
	1149: int16(-int32(8058)),
	1150: int16(-int32(3760)),
	1151: int16(12583),
	1152: int16(7058),
	1153: int16(1346),
	1154: int16(17376),
	1155: int16(-int32(2667)),
	1156: int16(-int32(2829)),
	1157: int16(15710),
	1158: int16(3705),
	1159: int16(468),
	1160: int16(-int32(11880)),
	1161: int16(50),
	1162: int16(-int32(17123)),
	1163: int16(5201),
	1164: int16(6230),
	1165: int16(4698),
	1166: int16(6098),
	1167: int16(-int32(18716)),
	1168: int16(-int32(1665)),
	1169: int16(-int32(13088)),
	1170: int16(8285),
	1171: int16(-int32(1400)),
	1172: int16(7696),
	1173: int16(-int32(6196)),
	1174: int16(-int32(13429)),
	1175: int16(2770),
	1178: int16(9243),
	1179: int16(8602),
	1180: int16(13392),
	1181: int16(1722),
	1182: int16(2070),
	1183: int16(16090),
	1184: int16(11359),
	1185: int16(3222),
	1186: int16(-int32(4960)),
	1187: int16(-int32(2638)),
	1188: int16(4581),
	1189: int16(20106),
	1190: int16(5099),
	1191: int16(4026),
	1192: int16(-int32(10978)),
	1193: int16(-int32(1778)),
	1194: int16(-int32(1314)),
	1195: int16(-int32(6620)),
	1196: int16(6988),
	1197: int16(18701),
	1198: int16(-int32(2965)),
	1199: int16(3745),
	1200: int16(-int32(16745)),
	1201: int16(-int32(4461)),
	1202: int16(1300),
	1203: int16(584),
	1204: int16(-int32(3646)),
	1205: int16(-int32(11588)),
	1206: int16(8350),
	1207: int16(11847),
	1208: int16(-int32(10050)),
	1209: int16(2372),
	1210: int16(-int32(20010)),
	1211: int16(-int32(7809)),
	1212: int16(3608),
	1213: int16(887),
	1216: int16(9243),
	1217: int16(14252),
	1218: int16(-int32(1958)),
	1219: int16(7026),
	1220: int16(13986),
	1221: int16(-int32(3899)),
	1222: int16(-int32(9870)),
	1223: int16(-int32(1922)),
	1224: int16(-int32(10736)),
	1225: int16(-int32(3693)),
	1226: int16(-int32(4527)),
	1227: int16(-int32(12333)),
	1228: int16(4376),
	1229: int16(-int32(6080)),
	1230: int16(3475),
	1231: int16(-int32(18537)),
	1232: int16(-int32(19222)),
	1233: int16(1355),
	1234: int16(-int32(10843)),
	1235: int16(6913),
	1236: int16(8869),
	1237: int16(3408),
	1238: int16(8323),
	1239: int16(6804),
	1240: int16(-int32(5141)),
	1241: int16(-int32(13648)),
	1242: int16(7800),
	1243: int16(2649),
	1244: int16(7171),
	1245: int16(10505),
	1246: int16(-int32(6548)),
	1247: int16(5179),
	1248: int16(-int32(5505)),
	1249: int16(13299),
	1250: int16(2086),
	1251: int16(15579),
	1254: int16(9243),
	1255: int16(11323),
	1256: int16(9021),
	1257: int16(-int32(6835)),
	1258: int16(-int32(10810)),
	1259: int16(14267),
	1260: int16(-int32(489)),
	1261: int16(-int32(8613)),
	1262: int16(-int32(5689)),
	1263: int16(639),
	1264: int16(-int32(16117)),
	1265: int16(6224),
	1266: int16(-int32(9731)),
	1267: int16(-int32(3757)),
	1268: int16(-int32(8482)),
	1269: int16(10882),
	1270: int16(7873),
	1271: int16(1080),
	1272: int16(-int32(11447)),
	1273: int16(-int32(6791)),
	1274: int16(-int32(10388)),
	1275: int16(4099),
	1276: int16(-int32(6025)),
	1277: int16(18396),
	1278: int16(-int32(5407)),
	1279: int16(-int32(7536)),
	1280: int16(14714),
	1281: int16(984),
	1282: int16(1267),
	1283: int16(-int32(13940)),
	1284: int16(-int32(1889)),
	1285: int16(8416),
	1286: int16(666),
	1287: int16(16762),
	1288: int16(-int32(10106)),
	1289: int16(-int32(3418)),
	1292: int16(9243),
	1293: int16(871),
	1294: int16(4833),
	1295: int16(15238),
	1296: int16(1855),
	1297: int16(588),
	1298: int16(-int32(7508)),
	1299: int16(10287),
	1300: int16(16162),
	1301: int16(2857),
	1302: int16(1481),
	1303: int16(-int32(443)),
	1304: int16(-int32(9392)),
	1305: int16(-int32(7758)),
	1306: int16(12910),
	1307: int16(16506),
	1308: int16(3837),
	1309: int16(2588),
	1310: int16(-int32(581)),
	1311: int16(-int32(851)),
	1312: int16(1928),
	1313: int16(-int32(14879)),
	1314: int16(-int32(5066)),
	1315: int16(14950),
	1316: int16(16498),
	1317: int16(4773),
	1318: int16(3842),
	1319: int16(-int32(425)),
	1320: int16(-int32(1785)),
	1321: int16(-int32(82)),
	1322: int16(10578),
	1323: int16(-int32(1435)),
	1324: int16(-int32(15554)),
	1325: int16(-int32(2459)),
	1326: int16(16520),
	1327: int16(16250),
	1330: int16(9243),
	1331: int16(14762),
	1332: int16(5967),
	1333: int16(1673),
	1334: int16(3450),
	1335: int16(12303),
	1336: int16(-int32(6027)),
	1337: int16(1394),
	1338: int16(-int32(15022)),
	1339: int16(-int32(14571)),
	1340: int16(3402),
	1341: int16(-int32(4217)),
	1342: int16(-int32(10507)),
	1343: int16(-int32(478)),
	1344: int16(-int32(14813)),
	1345: int16(-int32(5131)),
	1346: int16(-int32(6634)),
	1347: int16(-int32(16293)),
	1348: int16(-int32(82)),
	1349: int16(-int32(15276)),
	1350: int16(-int32(1705)),
	1351: int16(-int32(1731)),
	1352: int16(358),
	1353: int16(-int32(5738)),
	1354: int16(13681),
	1355: int16(12503),
	1356: int16(-int32(8200)),
	1357: int16(-int32(3023)),
	1358: int16(-int32(3290)),
	1359: int16(-int32(7384)),
	1360: int16(9272),
	1361: int16(-int32(837)),
	1362: int16(14328),
	1363: int16(-int32(1064)),
	1364: int16(16913),
	1365: int16(7915),
	1404: int16(32767),
	1443: int16(32767),
}

var Opus_mapping_matrix_foa_demixing = OpusT_MappingMatrix{
	Frows: int32(6),
	Fcols: int32(6),
}

var Opus_mapping_matrix_foa_demixing_data = [36]OpusT_opus_int16{
	0:  int16(16384),
	1:  int16(16384),
	2:  int16(16384),
	3:  int16(16384),
	7:  int16(23170),
	9:  int16(-int32(23170)),
	12: int16(-int32(16384)),
	13: int16(16384),
	14: int16(-int32(16384)),
	15: int16(16384),
	18: int16(23170),
	20: int16(-int32(23170)),
	28: int16(32767),
	35: int16(32767),
}

var Opus_mapping_matrix_foa_mixing = OpusT_MappingMatrix{
	Frows: int32(6),
	Fcols: int32(6),
}

var Opus_mapping_matrix_foa_mixing_data = [36]OpusT_opus_int16{
	0:  int16(16384),
	2:  int16(-int32(16384)),
	3:  int16(23170),
	6:  int16(16384),
	7:  int16(23170),
	8:  int16(16384),
	12: int16(16384),
	14: int16(-int32(16384)),
	15: int16(-int32(23170)),
	18: int16(16384),
	19: int16(-int32(23170)),
	20: int16(16384),
	28: int16(32767),
	35: int16(32767),
}

var Opus_mapping_matrix_fourthoa_demixing = OpusT_MappingMatrix{
	Frows: int32(27),
	Fcols: int32(27),
}

var Opus_mapping_matrix_fourthoa_demixing_data = [729]OpusT_opus_int16{
	0:   int16(4870),
	1:   int16(4484),
	2:   int16(4870),
	3:   int16(4347),
	4:   int16(4440),
	5:   int16(4726),
	6:   int16(4683),
	7:   int16(4821),
	8:   int16(4883),
	9:   int16(4842),
	10:  int16(4603),
	11:  int16(4484),
	12:  int16(4683),
	13:  int16(4698),
	14:  int16(4234),
	15:  int16(4368),
	16:  int16(4603),
	17:  int16(4783),
	18:  int16(4783),
	19:  int16(4820),
	20:  int16(4821),
	21:  int16(4347),
	22:  int16(4820),
	23:  int16(4440),
	24:  int16(4698),
	27:  int16(101),
	28:  int16(84),
	29:  int16(-int32(7818)),
	30:  int16(4640),
	31:  int16(-int32(7178)),
	32:  int16(-int32(5492)),
	33:  int16(4629),
	34:  int16(8384),
	35:  int16(6547),
	36:  int16(-int32(4966)),
	37:  int16(617),
	38:  int16(-int32(6345)),
	39:  int16(1061),
	40:  int16(-int32(3241)),
	41:  int16(2939),
	42:  int16(5549),
	43:  int16(6390),
	44:  int16(-int32(4434)),
	45:  int16(4994),
	46:  int16(-int32(2610)),
	47:  int16(1993),
	48:  int16(-int32(2873)),
	49:  int16(1547),
	50:  int16(-int32(4356)),
	51:  int16(-int32(164)),
	54:  int16(8797),
	55:  int16(5074),
	56:  int16(-int32(1553)),
	57:  int16(5383),
	58:  int16(1906),
	59:  int16(5297),
	60:  int16(2722),
	61:  int16(1158),
	62:  int16(-int32(5226)),
	63:  int16(1311),
	64:  int16(-int32(7760)),
	65:  int16(-int32(3327)),
	66:  int16(-int32(1940)),
	67:  int16(1586),
	68:  int16(-int32(4093)),
	69:  int16(-int32(2951)),
	70:  int16(-int32(214)),
	71:  int16(-int32(6873)),
	72:  int16(5450),
	73:  int16(-int32(4875)),
	74:  int16(-int32(7193)),
	75:  int16(-int32(4438)),
	76:  int16(558),
	77:  int16(5593),
	78:  int16(5607),
	81:  int16(-int32(26)),
	82:  int16(5761),
	83:  int16(-int32(3723)),
	84:  int16(-int32(1460)),
	85:  int16(1195),
	86:  int16(-int32(3065)),
	87:  int16(-int32(6357)),
	88:  int16(-int32(1175)),
	89:  int16(608),
	90:  int16(6965),
	91:  int16(2310),
	92:  int16(2759),
	93:  int16(-int32(8023)),
	94:  int16(-int32(7138)),
	95:  int16(5162),
	96:  int16(-int32(3624)),
	97:  int16(5006),
	98:  int16(-int32(809)),
	99:  int16(3592),
	100: int16(6209),
	101: int16(-int32(4159)),
	102: int16(-int32(4968)),
	103: int16(8150),
	104: int16(2513),
	105: int16(-int32(5702)),
	108: int16(301),
	109: int16(109),
	110: int16(7161),
	111: int16(-int32(2462)),
	112: int16(-int32(2443)),
	113: int16(5044),
	114: int16(-int32(7125)),
	115: int16(-int32(2256)),
	116: int16(1967),
	117: int16(-int32(9107)),
	118: int16(259),
	119: int16(-int32(4928)),
	120: int16(-int32(2592)),
	121: int16(6514),
	122: int16(4111),
	123: int16(-int32(7236)),
	124: int16(8695),
	125: int16(635),
	126: int16(5009),
	127: int16(-int32(4025)),
	128: int16(-int32(1937)),
	129: int16(4794),
	130: int16(3420),
	131: int16(-int32(3507)),
	132: int16(-int32(400)),
	135: int16(-int32(134)),
	136: int16(85),
	137: int16(2771),
	138: int16(7842),
	139: int16(-int32(3649)),
	140: int16(-int32(8225)),
	141: int16(2866),
	142: int16(2586),
	143: int16(-int32(9200)),
	144: int16(-int32(1945)),
	145: int16(-int32(1563)),
	146: int16(6155),
	147: int16(-int32(720)),
	148: int16(-int32(1061)),
	149: int16(-int32(3494)),
	150: int16(-int32(4513)),
	151: int16(-int32(487)),
	152: int16(8389),
	153: int16(7317),
	154: int16(3348),
	155: int16(-int32(3721)),
	156: int16(3806),
	157: int16(371),
	158: int16(-int32(6896)),
	159: int16(70),
	162: int16(10919),
	163: int16(2072),
	164: int16(-int32(4867)),
	165: int16(3472),
	166: int16(-int32(4429)),
	167: int16(1721),
	168: int16(-int32(4066)),
	169: int16(-int32(5193)),
	170: int16(1032),
	171: int16(-int32(5253)),
	172: int16(9501),
	173: int16(-int32(2017)),
	174: int16(-int32(3971)),
	175: int16(-int32(5261)),
	176: int16(-int32(306)),
	177: int16(-int32(2737)),
	178: int16(-int32(5137)),
	179: int16(5713),
	180: int16(1237),
	181: int16(-int32(8)),
	182: int16(6387),
	183: int16(364),
	184: int16(-int32(5423)),
	185: int16(3364),
	186: int16(2888),
	189: int16(-int32(48)),
	190: int16(8946),
	191: int16(1048),
	192: int16(-int32(2691)),
	193: int16(602),
	194: int16(-int32(4332)),
	195: int16(-int32(4302)),
	196: int16(-int32(514)),
	197: int16(-int32(1730)),
	198: int16(2459),
	199: int16(-int32(4328)),
	200: int16(-int32(2156)),
	201: int16(3335),
	202: int16(-int32(2748)),
	203: int16(-int32(6029)),
	204: int16(4023),
	205: int16(155),
	206: int16(897),
	207: int16(5268),
	208: int16(-int32(8380)),
	209: int16(7625),
	210: int16(7395),
	211: int16(508),
	212: int16(3945),
	213: int16(-int32(8951)),
	216: int16(39),
	217: int16(4151),
	218: int16(-int32(5965)),
	219: int16(-int32(3398)),
	220: int16(-int32(7006)),
	221: int16(-int32(3534)),
	222: int16(2697),
	223: int16(-int32(8989)),
	224: int16(-int32(5237)),
	225: int16(2913),
	226: int16(46),
	227: int16(-int32(5540)),
	228: int16(8196),
	229: int16(5766),
	230: int16(2711),
	231: int16(-int32(2520)),
	232: int16(-int32(3043)),
	233: int16(-int32(2146)),
	234: int16(-int32(948)),
	235: int16(4965),
	236: int16(1806),
	237: int16(2472),
	238: int16(8988),
	239: int16(-int32(1266)),
	240: int16(4840),
	243: int16(-int32(407)),
	244: int16(-int32(189)),
	245: int16(2179),
	246: int16(-int32(1627)),
	247: int16(6516),
	248: int16(259),
	249: int16(7196),
	250: int16(-int32(9449)),
	251: int16(-int32(4905)),
	252: int16(-int32(9766)),
	253: int16(561),
	254: int16(4021),
	255: int16(3371),
	256: int16(-int32(8650)),
	257: int16(5032),
	258: int16(3329),
	259: int16(2534),
	260: int16(641),
	261: int16(2224),
	262: int16(-int32(5747)),
	263: int16(1047),
	264: int16(-int32(4074)),
	265: int16(5252),
	266: int16(-int32(24)),
	267: int16(674),
	270: int16(664),
	271: int16(237),
	272: int16(-int32(2837)),
	273: int16(-int32(4072)),
	274: int16(-int32(1205)),
	275: int16(8252),
	276: int16(-int32(5875)),
	277: int16(-int32(1670)),
	278: int16(-int32(2743)),
	279: int16(-int32(3984)),
	280: int16(381),
	281: int16(5059),
	282: int16(1765),
	283: int16(2666),
	284: int16(-int32(8295)),
	285: int16(7403),
	286: int16(1154),
	287: int16(-int32(2086)),
	288: int16(7622),
	289: int16(7105),
	290: int16(3677),
	291: int16(-int32(6943)),
	292: int16(1050),
	293: int16(-int32(6632)),
	294: int16(-int32(694)),
	297: int16(382),
	298: int16(-int32(133)),
	299: int16(5699),
	300: int16(7650),
	301: int16(5154),
	302: int16(-int32(5713)),
	303: int16(-int32(1645)),
	304: int16(-int32(6902)),
	305: int16(6181),
	306: int16(4450),
	307: int16(1151),
	308: int16(410),
	309: int16(-int32(993)),
	310: int16(3829),
	311: int16(2444),
	312: int16(-int32(2405)),
	313: int16(-int32(6618)),
	314: int16(-int32(9514)),
	315: int16(5366),
	316: int16(-int32(1896)),
	317: int16(5844),
	318: int16(-int32(2886)),
	319: int16(-int32(1524)),
	320: int16(-int32(7321)),
	321: int16(-int32(1007)),
	324: int16(12767),
	325: int16(-int32(2530)),
	326: int16(3183),
	327: int16(-int32(1409)),
	328: int16(-int32(4015)),
	329: int16(-int32(2894)),
	330: int16(-int32(5155)),
	331: int16(-int32(1710)),
	332: int16(3841),
	333: int16(-int32(2107)),
	334: int16(-int32(10274)),
	335: int16(5119),
	336: int16(3979),
	337: int16(-int32(4010)),
	338: int16(5550),
	339: int16(4822),
	340: int16(-int32(746)),
	341: int16(-int32(2507)),
	342: int16(-int32(3080)),
	343: int16(4289),
	344: int16(-int32(3675)),
	345: int16(4333),
	346: int16(-int32(1416)),
	347: int16(-int32(1230)),
	348: int16(-int32(1122)),
	351: int16(17),
	352: int16(8048),
	353: int16(2398),
	354: int16(-int32(2167)),
	355: int16(-int32(73)),
	356: int16(-int32(3606)),
	357: int16(3125),
	358: int16(398),
	359: int16(731),
	360: int16(-int32(5973)),
	361: int16(5705),
	362: int16(-int32(1032)),
	363: int16(4679),
	364: int16(7305),
	365: int16(3134),
	366: int16(1301),
	367: int16(-int32(3858)),
	368: int16(-int32(89)),
	369: int16(2938),
	370: int16(4359),
	371: int16(-int32(9155)),
	372: int16(-int32(4805)),
	373: int16(-int32(8407)),
	374: int16(3673),
	375: int16(-int32(8645)),
	378: int16(187),
	379: int16(7355),
	380: int16(3145),
	381: int16(-int32(6719)),
	382: int16(-int32(4432)),
	383: int16(-int32(5939)),
	384: int16(2541),
	385: int16(-int32(2810)),
	386: int16(9723),
	387: int16(778),
	388: int16(-int32(1105)),
	389: int16(5687),
	390: int16(-int32(4174)),
	391: int16(2534),
	392: int16(-int32(4461)),
	393: int16(1017),
	394: int16(-int32(244)),
	395: int16(5481),
	396: int16(-int32(1655)),
	397: int16(-int32(6765)),
	398: int16(-int32(3350)),
	399: int16(-int32(4894)),
	400: int16(1592),
	401: int16(-int32(2318)),
	402: int16(8827),
	405: int16(196),
	406: int16(3588),
	407: int16(9631),
	408: int16(3063),
	409: int16(-int32(4564)),
	410: int16(6043),
	411: int16(2683),
	412: int16(2595),
	413: int16(-int32(2488)),
	414: int16(-int32(2186)),
	415: int16(173),
	416: int16(-int32(6059)),
	417: int16(-int32(8270)),
	418: int16(-int32(2386)),
	419: int16(409),
	420: int16(7441),
	421: int16(-int32(8608)),
	422: int16(376),
	423: int16(-int32(4364)),
	424: int16(2321),
	425: int16(-int32(280)),
	426: int16(97),
	427: int16(8331),
	428: int16(-int32(3022)),
	429: int16(-int32(4721)),
	432: int16(117),
	433: int16(-int32(748)),
	434: int16(-int32(10833)),
	435: int16(1533),
	436: int16(4200),
	437: int16(-int32(2875)),
	438: int16(-int32(997)),
	439: int16(-int32(109)),
	440: int16(-int32(3661)),
	441: int16(-int32(6119)),
	442: int16(4454),
	443: int16(8808),
	444: int16(-int32(9189)),
	445: int16(8294),
	446: int16(1521),
	447: int16(7265),
	448: int16(-int32(2348)),
	449: int16(-int32(5094)),
	450: int16(-int32(948)),
	451: int16(-int32(5400)),
	452: int16(-int32(3193)),
	453: int16(8914),
	454: int16(5763),
	455: int16(1716),
	456: int16(-int32(1070)),
	459: int16(2497),
	460: int16(399),
	461: int16(-int32(5201)),
	462: int16(-int32(2038)),
	463: int16(7843),
	464: int16(-int32(376)),
	465: int16(7567),
	466: int16(-int32(5073)),
	467: int16(7616),
	468: int16(-int32(5537)),
	469: int16(2086),
	470: int16(-int32(3453)),
	471: int16(-int32(5544)),
	472: int16(-int32(56)),
	473: int16(-int32(11648)),
	474: int16(-int32(1314)),
	475: int16(3546),
	476: int16(-int32(3432)),
	477: int16(-int32(117)),
	478: int16(8694),
	479: int16(-int32(4245)),
	480: int16(9621),
	481: int16(3098),
	482: int16(-int32(2582)),
	483: int16(-int32(2351)),
	486: int16(4386),
	487: int16(-int32(3104)),
	488: int16(-int32(3132)),
	489: int16(-int32(10512)),
	490: int16(566),
	491: int16(5217),
	492: int16(5128),
	493: int16(4967),
	494: int16(1348),
	495: int16(7035),
	496: int16(-int32(1470)),
	497: int16(91),
	498: int16(-int32(125)),
	499: int16(-int32(3548)),
	500: int16(8244),
	501: int16(-int32(3029)),
	502: int16(-int32(10033)),
	503: int16(2186),
	504: int16(9745),
	505: int16(-int32(6440)),
	506: int16(-int32(2074)),
	507: int16(3638),
	508: int16(-int32(1477)),
	509: int16(-int32(7045)),
	510: int16(-int32(562)),
	513: int16(2154),
	514: int16(8116),
	515: int16(-int32(6102)),
	516: int16(6570),
	517: int16(12998),
	518: int16(-int32(712)),
	519: int16(-int32(4126)),
	520: int16(-int32(4996)),
	521: int16(30),
	522: int16(1571),
	523: int16(-int32(6393)),
	524: int16(-int32(12794)),
	525: int16(425),
	526: int16(5036),
	527: int16(1190),
	528: int16(5763),
	529: int16(5653),
	530: int16(12933),
	531: int16(-int32(6671)),
	532: int16(5197),
	533: int16(-int32(2964)),
	534: int16(-int32(3316)),
	535: int16(-int32(6354)),
	536: int16(-int32(10554)),
	537: int16(-int32(2652)),
	540: int16(12618),
	541: int16(-int32(3737)),
	542: int16(93),
	543: int16(-int32(5901)),
	544: int16(4262),
	545: int16(-int32(3364)),
	546: int16(4444),
	547: int16(3103),
	548: int16(-int32(2767)),
	549: int16(3403),
	550: int16(4925),
	551: int16(-int32(2584)),
	552: int16(-int32(989)),
	553: int16(4977),
	554: int16(-int32(3714)),
	555: int16(-int32(1965)),
	556: int16(3076),
	557: int16(326),
	558: int16(-int32(2946)),
	559: int16(-int32(2568)),
	560: int16(1026),
	561: int16(-int32(2980)),
	562: int16(3362),
	563: int16(-int32(6132)),
	564: int16(-int32(5966)),
	567: int16(6001),
	568: int16(48),
	569: int16(-int32(1979)),
	570: int16(-int32(7275)),
	571: int16(3476),
	572: int16(-int32(2096)),
	573: int16(10591),
	574: int16(3793),
	575: int16(2629),
	576: int16(-int32(447)),
	577: int16(-int32(14747)),
	578: int16(-int32(3689)),
	579: int16(-int32(5525)),
	580: int16(8358),
	581: int16(6883),
	582: int16(-int32(9703)),
	583: int16(-int32(4556)),
	584: int16(7471),
	585: int16(2965),
	586: int16(4056),
	587: int16(13221),
	588: int16(-int32(7327)),
	589: int16(-int32(3073)),
	590: int16(-int32(2353)),
	591: int16(-int32(6720)),
	594: int16(621),
	595: int16(11034),
	596: int16(-int32(44)),
	597: int16(-int32(2828)),
	598: int16(5978),
	599: int16(-int32(1850)),
	600: int16(-int32(1772)),
	601: int16(3894),
	602: int16(-int32(7471)),
	603: int16(-int32(1397)),
	604: int16(945),
	605: int16(-int32(2028)),
	606: int16(-int32(2928)),
	607: int16(-int32(2240)),
	608: int16(3172),
	609: int16(2222),
	610: int16(4544),
	611: int16(-int32(4243)),
	612: int16(-int32(5645)),
	613: int16(3745),
	614: int16(2573),
	615: int16(3511),
	616: int16(-int32(8206)),
	617: int16(-int32(7286)),
	618: int16(5700),
	621: int16(321),
	622: int16(10818),
	623: int16(-int32(4982)),
	624: int16(7813),
	625: int16(-int32(749)),
	626: int16(9907),
	627: int16(1360),
	628: int16(-int32(1443)),
	629: int16(568),
	630: int16(-int32(1103)),
	631: int16(2305),
	632: int16(6045),
	633: int16(2270),
	634: int16(-int32(1063)),
	635: int16(-int32(1920)),
	636: int16(-int32(3073)),
	637: int16(5893),
	638: int16(-int32(3476)),
	639: int16(-int32(11346)),
	640: int16(-int32(1657)),
	641: int16(-int32(588)),
	642: int16(2957),
	643: int16(-int32(2287)),
	644: int16(-int32(8527)),
	645: int16(-int32(8041)),
	648: int16(119),
	649: int16(-int32(268)),
	650: int16(2372),
	651: int16(-int32(3040)),
	652: int16(4979),
	653: int16(-int32(3789)),
	654: int16(-int32(5630)),
	655: int16(10619),
	656: int16(5900),
	657: int16(-int32(5109)),
	658: int16(-int32(4585)),
	659: int16(-int32(3862)),
	660: int16(10467),
	661: int16(-int32(3527)),
	662: int16(-int32(385)),
	663: int16(-int32(10034)),
	664: int16(-int32(9991)),
	665: int16(4860),
	666: int16(984),
	667: int16(2362),
	668: int16(2311),
	669: int16(-int32(6804)),
	670: int16(6324),
	671: int16(433),
	672: int16(5291),
	700: int16(32767),
	728: int16(32767),
}

var Opus_mapping_matrix_fourthoa_mixing = OpusT_MappingMatrix{
	Frows: int32(27),
	Fcols: int32(27),
}

var Opus_mapping_matrix_fourthoa_mixing_data = [729]OpusT_opus_int16{
	0:   int16(9243),
	2:   int16(16010),
	6:   int16(20669),
	12:  int16(24456),
	20:  int16(27731),
	27:  int16(9243),
	29:  int16(10884),
	30:  int16(11741),
	33:  int16(3995),
	34:  int16(17849),
	35:  int16(9626),
	39:  int16(-int32(5727)),
	40:  int16(14399),
	41:  int16(17315),
	42:  int16(7625),
	47:  int16(-int32(11747)),
	48:  int16(2574),
	49:  int16(18637),
	50:  int16(15552),
	51:  int16(5930),
	54:  int16(9243),
	55:  int16(-int32(14302)),
	56:  int16(-int32(2682)),
	57:  int16(-int32(6677)),
	58:  int16(13337),
	59:  int16(5357),
	60:  int16(-int32(9464)),
	61:  int16(2501),
	62:  int16(-int32(11170)),
	63:  int16(4770),
	64:  int16(-int32(5911)),
	65:  int16(11501),
	66:  int16(5858),
	67:  int16(5369),
	68:  int16(4951),
	69:  int16(17901),
	70:  int16(-int32(19071)),
	71:  int16(-int32(2397)),
	72:  int16(-int32(9281)),
	73:  int16(-int32(9198)),
	74:  int16(7576),
	75:  int16(-int32(4294)),
	76:  int16(7773),
	77:  int16(-int32(8997)),
	78:  int16(-int32(3399)),
	81:  int16(9243),
	82:  int16(9940),
	83:  int16(11991),
	84:  int16(-int32(3705)),
	85:  int16(-int32(5144)),
	86:  int16(16647),
	87:  int16(7057),
	88:  int16(-int32(6206)),
	89:  int16(-int32(5941)),
	90:  int16(-int32(2698)),
	91:  int16(-int32(10194)),
	92:  int16(16781),
	93:  int16(-int32(1788)),
	94:  int16(-int32(6256)),
	95:  int16(-int32(11772)),
	96:  int16(4935),
	97:  int16(3912),
	98:  int16(-int32(6062)),
	99:  int16(-int32(13039)),
	100: int16(9446),
	101: int16(-int32(9758)),
	102: int16(-int32(3521)),
	103: int16(-int32(15058)),
	104: int16(11089),
	105: int16(565),
	108: int16(9243),
	109: int16(-int32(15376)),
	110: int16(3720),
	111: int16(2461),
	112: int16(-int32(5285)),
	113: int16(-int32(7989)),
	114: int16(-int32(8660)),
	115: int16(1278),
	116: int16(-int32(16087)),
	117: int16(15811),
	118: int16(-int32(3249)),
	119: int16(10500),
	120: int16(-int32(7757)),
	121: int16(-int32(1680)),
	122: int16(-int32(9890)),
	123: int16(-int32(8153)),
	124: int16(10884),
	125: int16(11022),
	126: int16(2847),
	127: int16(12828),
	128: int16(5137),
	129: int16(-int32(2053)),
	130: int16(8666),
	131: int16(-int32(5684)),
	132: int16(14776),
	135: int16(9243),
	136: int16(-int32(10577)),
	137: int16(10304),
	138: int16(-int32(6186)),
	139: int16(9139),
	140: int16(-int32(15222)),
	141: int16(2507),
	142: int16(-int32(8902)),
	143: int16(-int32(5140)),
	144: int16(-int32(145)),
	145: int16(15562),
	146: int16(-int32(10596)),
	147: int16(-int32(7311)),
	148: int16(-int32(6197)),
	149: int16(-int32(8753)),
	150: int16(8667),
	151: int16(-int32(6014)),
	152: int16(-int32(281)),
	153: int16(15033),
	154: int16(938),
	155: int16(-int32(11859)),
	156: int16(548),
	157: int16(-int32(8456)),
	158: int16(16735),
	159: int16(-int32(3654)),
	162: int16(9243),
	163: int16(8974),
	164: int16(4839),
	165: int16(-int32(12343)),
	166: int16(-int32(15472)),
	167: int16(6066),
	168: int16(-int32(7501)),
	169: int16(-int32(8343)),
	170: int16(5015),
	171: int16(15920),
	172: int16(-int32(12374)),
	173: int16(-int32(4559)),
	174: int16(-int32(9400)),
	175: int16(6271),
	176: int16(4011),
	177: int16(5191),
	178: int16(-int32(9932)),
	179: int16(14438),
	180: int16(4828),
	181: int16(-int32(8768)),
	182: int16(1909),
	183: int16(12059),
	184: int16(-int32(1565)),
	185: int16(4707),
	186: int16(-int32(13711)),
	189: int16(9243),
	190: int16(15799),
	191: int16(2085),
	192: int16(-int32(1534)),
	193: int16(-int32(3386)),
	194: int16(4602),
	195: int16(-int32(9808)),
	196: int16(-int32(447)),
	197: int16(-int32(17267)),
	198: int16(-int32(18054)),
	199: int16(-int32(1167)),
	200: int16(-int32(13525)),
	201: int16(-int32(4644)),
	202: int16(1313),
	203: int16(-int32(5951)),
	204: int16(5397),
	205: int16(7485),
	206: int16(-int32(7056)),
	207: int16(2584),
	208: int16(-int32(8120)),
	209: int16(8669),
	210: int16(788),
	211: int16(13177),
	212: int16(2109),
	213: int16(18349),
	216: int16(9243),
	217: int16(12371),
	218: int16(-int32(10036)),
	219: int16(1597),
	220: int16(2760),
	221: int16(-int32(17341)),
	222: int16(1848),
	223: int16(-int32(2239)),
	224: int16(-int32(10509)),
	225: int16(-int32(8474)),
	226: int16(-int32(4577)),
	227: int16(11164),
	228: int16(7935),
	229: int16(1441),
	230: int16(17430),
	231: int16(-int32(3436)),
	232: int16(-int32(3713)),
	233: int16(15936),
	234: int16(4184),
	235: int16(2647),
	236: int16(-int32(11730)),
	237: int16(341),
	238: int16(-int32(15934)),
	239: int16(6462),
	240: int16(6581),
	243: int16(9243),
	244: int16(-int32(8963)),
	245: int16(2184),
	246: int16(13084),
	247: int16(-int32(16381)),
	248: int16(-int32(2734)),
	249: int16(-int32(9757)),
	250: int16(3991),
	251: int16(6345),
	252: int16(-int32(18297)),
	253: int16(-int32(5912)),
	254: int16(7604),
	255: int16(-int32(4849)),
	256: int16(-int32(11100)),
	257: int16(2290),
	258: int16(-int32(4304)),
	259: int16(-int32(13305)),
	260: int16(-int32(7488)),
	261: int16(12338),
	262: int16(4805),
	263: int16(8505),
	264: int16(-int32(7014)),
	265: int16(-int32(4779)),
	266: int16(-int32(1761)),
	267: int16(-int32(14597)),
	270: int16(9243),
	271: int16(1301),
	272: int16(-int32(15498)),
	273: int16(3799),
	274: int16(690),
	275: int16(-int32(2816)),
	276: int16(18718),
	277: int16(-int32(8223)),
	278: int16(889),
	279: int16(255),
	280: int16(-int32(1768)),
	281: int16(4485),
	282: int16(-int32(19951)),
	283: int16(13097),
	284: int16(-int32(2278)),
	285: int16(167),
	286: int16(78),
	287: int16(-int32(740)),
	288: int16(3324),
	289: int16(-int32(6139)),
	290: int16(19488),
	291: int16(-int32(17925)),
	292: int16(4283),
	293: int16(-int32(486)),
	294: int16(20),
	297: int16(9243),
	298: int16(-int32(13470)),
	299: int16(-int32(6719)),
	300: int16(5452),
	301: int16(-int32(10257)),
	302: int16(12641),
	303: int16(-int32(4873)),
	304: int16(-int32(5116)),
	305: int16(-int32(10595)),
	306: int16(5856),
	307: int16(11389),
	308: int16(1502),
	309: int16(10876),
	310: int16(-int32(608)),
	311: int16(11765),
	312: int16(-int32(13218)),
	313: int16(13911),
	314: int16(-int32(7373)),
	315: int16(-int32(2070)),
	316: int16(-int32(13679)),
	317: int16(-int32(4154)),
	318: int16(5536),
	319: int16(-int32(2138)),
	320: int16(16643),
	321: int16(451),
	324: int16(9243),
	325: int16(2455),
	326: int16(-int32(3679)),
	327: int16(-int32(15387)),
	328: int16(-int32(5277)),
	329: int16(-int32(1261)),
	330: int16(-int32(8697)),
	331: int16(7906),
	332: int16(16112),
	333: int16(8147),
	334: int16(3208),
	335: int16(-int32(1690)),
	336: int16(7687),
	337: int16(10593),
	338: int16(-int32(9796)),
	339: int16(-int32(15852)),
	340: int16(-int32(10884)),
	341: int16(-int32(5616)),
	342: int16(2881),
	343: int16(2032),
	344: int16(5246),
	345: int16(-int32(12735)),
	346: int16(-int32(8796)),
	347: int16(10928),
	348: int16(14833),
	351: int16(9243),
	352: int16(-int32(6849)),
	353: int16(2775),
	354: int16(-int32(14202)),
	355: int16(13586),
	356: int16(-int32(2655)),
	357: int16(-int32(9402)),
	358: int16(-int32(5505)),
	359: int16(10809),
	360: int16(-int32(18013)),
	361: int16(6231),
	362: int16(5444),
	363: int16(-int32(6041)),
	364: int16(11288),
	365: int16(4958),
	366: int16(-int32(4078)),
	367: int16(18799),
	368: int16(-int32(9368)),
	369: int16(-int32(9291)),
	370: int16(4535),
	371: int16(7383),
	372: int16(9405),
	373: int16(-int32(7391)),
	374: int16(-int32(2121)),
	375: int16(-int32(4336)),
	378: int16(9243),
	379: int16(6423),
	380: int16(-int32(9040)),
	381: int16(11548),
	382: int16(10359),
	383: int16(-int32(8109)),
	384: int16(-int32(450)),
	385: int16(-int32(14580)),
	386: int16(6431),
	387: int16(10857),
	388: int16(-int32(15475)),
	389: int16(3569),
	390: int16(9707),
	391: int16(6416),
	392: int16(-int32(9607)),
	393: int16(521),
	394: int16(8528),
	395: int16(-int32(18391)),
	396: int16(11049),
	397: int16(3815),
	398: int16(-int32(10423)),
	399: int16(6860),
	400: int16(6860),
	401: int16(-int32(883)),
	402: int16(-int32(4221)),
	405: int16(9243),
	406: int16(11932),
	407: int16(-int32(5968)),
	408: int16(-int32(8850)),
	409: int16(-int32(14749)),
	410: int16(-int32(9946)),
	411: int16(-int32(6026)),
	412: int16(7377),
	413: int16(-int32(4472)),
	414: int16(5206),
	415: int16(14547),
	416: int16(-int32(3406)),
	417: int16(10508),
	418: int16(2526),
	419: int16(4411),
	420: int16(14543),
	421: int16(8444),
	422: int16(-int32(5822)),
	423: int16(347),
	424: int16(12347),
	425: int16(-int32(1709)),
	426: int16(-int32(9158)),
	427: int16(105),
	428: int16(-int32(16265)),
	429: int16(-int32(12642)),
	432: int16(9243),
	433: int16(13044),
	434: int16(-int32(150)),
	435: int16(9282),
	436: int16(16910),
	437: int16(-int32(274)),
	438: int16(-int32(10332)),
	439: int16(-int32(194)),
	440: int16(-int32(5864)),
	441: int16(5428),
	442: int16(-int32(420)),
	443: int16(-int32(12196)),
	444: int16(344),
	445: int16(-int32(8679)),
	446: int16(145),
	447: int16(-int32(18554)),
	448: int16(-int32(12695)),
	449: int16(-int32(152)),
	450: int16(-int32(14635)),
	451: int16(503),
	452: int16(10389),
	453: int16(358),
	454: int16(5076),
	455: int16(522),
	456: int16(-int32(16100)),
	459: int16(9243),
	460: int16(-int32(8374)),
	461: int16(-int32(13590)),
	462: int16(-int32(1221)),
	463: int16(1428),
	464: int16(15896),
	465: int16(12005),
	466: int16(2318),
	467: int16(-int32(4793)),
	468: int16(2590),
	469: int16(-int32(3209)),
	470: int16(-int32(20390)),
	471: int16(-int32(6256)),
	472: int16(-int32(2974)),
	473: int16(10766),
	474: int16(1202),
	475: int16(-int32(876)),
	476: int16(-int32(6597)),
	477: int16(5004),
	478: int16(19896),
	479: int16(-int32(1541)),
	480: int16(2902),
	481: int16(-int32(16788)),
	482: int16(-int32(3062)),
	483: int16(1340),
	486: int16(9243),
	487: int16(9879),
	488: int16(10267),
	489: int16(7300),
	490: int16(10073),
	491: int16(14167),
	492: int16(2416),
	493: int16(10469),
	494: int16(-int32(3094)),
	495: int16(2899),
	496: int16(17092),
	497: int16(9762),
	498: int16(-int32(7400)),
	499: int16(7214),
	500: int16(-int32(5250)),
	501: int16(-int32(8238)),
	502: int16(-int32(3989)),
	503: int16(5578),
	504: int16(16392),
	505: int16(-int32(1050)),
	506: int16(-int32(11848)),
	507: int16(-int32(776)),
	508: int16(-int32(5034)),
	509: int16(-int32(15850)),
	510: int16(-int32(5882)),
	513: int16(9243),
	514: int16(-int32(4974)),
	515: int16(-int32(9068)),
	516: int16(12221),
	517: int16(-int32(8490)),
	518: int16(6299),
	519: int16(-int32(388)),
	520: int16(-int32(15478)),
	521: int16(8702),
	522: int16(-int32(9920)),
	523: int16(12723),
	524: int16(-int32(2810)),
	525: int16(9668),
	526: int16(6905),
	527: int16(-int32(13040)),
	528: int16(4325),
	529: int16(-int32(9456)),
	530: int16(16856),
	531: int16(-int32(9159)),
	532: int16(-int32(2909)),
	533: int16(-int32(10476)),
	534: int16(7149),
	535: int16(9387),
	536: int16(-int32(7350)),
	537: int16(233),
	540: int16(9243),
	541: int16(3627),
	542: int16(-int32(13823)),
	543: int16(-int32(7218)),
	544: int16(-int32(3656)),
	545: int16(-int32(7002)),
	546: int16(12776),
	547: int16(13935),
	548: int16(2719),
	549: int16(2446),
	550: int16(8352),
	551: int16(9252),
	552: int16(-int32(7676)),
	553: int16(-int32(18413)),
	554: int16(-int32(6212)),
	555: int16(-int32(429)),
	556: int16(-int32(1272)),
	557: int16(-int32(6335)),
	558: int16(-int32(13356)),
	559: int16(-int32(9510)),
	560: int16(295),
	561: int16(18926),
	562: int16(9934),
	563: int16(1112),
	564: int16(-int32(382)),
	567: int16(9243),
	568: int16(-int32(6383)),
	569: int16(-int32(9343)),
	570: int16(-int32(11326)),
	571: int16(10097),
	572: int16(8329),
	573: int16(223),
	574: int16(14780),
	575: int16(6114),
	576: int16(-int32(10348)),
	577: int16(-int32(15590)),
	578: int16(-int32(4195)),
	579: int16(9257),
	580: int16(-int32(7445)),
	581: int16(-int32(9439)),
	582: int16(-int32(323)),
	583: int16(7902),
	584: int16(18117),
	585: int16(12101),
	586: int16(-int32(3142)),
	587: int16(-int32(10944)),
	588: int16(-int32(5577)),
	589: int16(7327),
	590: int16(566),
	591: int16(-int32(4133)),
	594: int16(9243),
	595: int16(2626),
	596: int16(865),
	597: int16(15769),
	598: int16(5783),
	599: int16(317),
	600: int16(-int32(10244)),
	601: int16(1905),
	602: int16(16884),
	603: int16(9144),
	604: int16(826),
	605: int16(-int32(2420)),
	606: int16(-int32(1972)),
	607: int16(-int32(14536)),
	608: int16(2413),
	609: int16(16939),
	610: int16(12500),
	611: int16(1482),
	612: int16(-int32(4906)),
	613: int16(-int32(578)),
	614: int16(10096),
	615: int16(-int32(3476)),
	616: int16(-int32(14323)),
	617: int16(2745),
	618: int16(16105),
	621: int16(9243),
	622: int16(-int32(8975)),
	623: int16(12086),
	624: int16(5450),
	625: int16(-int32(6832)),
	626: int16(-int32(15149)),
	627: int16(7333),
	628: int16(9200),
	629: int16(-int32(3550)),
	630: int16(-int32(362)),
	631: int16(-int32(13645)),
	632: int16(-int32(15525)),
	633: int16(-int32(1391)),
	634: int16(9428),
	635: int16(-int32(7091)),
	636: int16(-int32(5442)),
	637: int16(3105),
	638: int16(-int32(820)),
	639: int16(-int32(17685)),
	640: int16(-int32(9175)),
	641: int16(-int32(9462)),
	642: int16(5572),
	643: int16(-int32(9191)),
	644: int16(-int32(12325)),
	645: int16(-int32(2180)),
	648: int16(9243),
	649: int16(-int32(114)),
	650: int16(11576),
	651: int16(-int32(11058)),
	652: int16(177),
	653: int16(-int32(185)),
	654: int16(5875),
	655: int16(-int32(17880)),
	656: int16(8539),
	657: int16(-int32(198)),
	658: int16(339),
	659: int16(-int32(173)),
	660: int16(-int32(3411)),
	661: int16(-int32(16698)),
	662: int16(16336),
	663: int16(-int32(6369)),
	664: int16(193),
	665: int16(-int32(430)),
	666: int16(408),
	667: int16(-int32(75)),
	668: int16(-int32(10806)),
	669: int16(-int32(7225)),
	670: int16(19670),
	671: int16(-int32(13817)),
	672: int16(4665),
	700: int16(32767),
	728: int16(32767),
}

var Opus_mapping_matrix_soa_demixing = OpusT_MappingMatrix{
	Frows: int32(11),
	Fcols: int32(11),
	Fgain: int32(3050),
}

var Opus_mapping_matrix_soa_demixing_data = [121]OpusT_opus_int16{
	0:   int16(2771),
	1:   int16(2771),
	2:   int16(2771),
	3:   int16(2771),
	4:   int16(2771),
	5:   int16(2771),
	6:   int16(2771),
	7:   int16(2771),
	8:   int16(2771),
	11:  int16(10033),
	12:  int16(10033),
	13:  int16(-int32(20066)),
	14:  int16(10033),
	15:  int16(14189),
	16:  int16(14189),
	17:  int16(-int32(28378)),
	18:  int16(10033),
	19:  int16(-int32(20066)),
	22:  int16(3393),
	23:  int16(3393),
	24:  int16(3393),
	25:  int16(-int32(3393)),
	29:  int16(-int32(3393)),
	30:  int16(-int32(3393)),
	33:  int16(-int32(17378)),
	34:  int16(17378),
	36:  int16(-int32(17378)),
	37:  int16(-int32(24576)),
	38:  int16(24576),
	40:  int16(17378),
	44:  int16(-int32(14189)),
	45:  int16(14189),
	47:  int16(-int32(14189)),
	48:  int16(-int32(28378)),
	49:  int16(28378),
	51:  int16(14189),
	55:  int16(2399),
	56:  int16(2399),
	57:  int16(-int32(4799)),
	58:  int16(-int32(2399)),
	62:  int16(-int32(2399)),
	63:  int16(4799),
	66:  int16(1959),
	67:  int16(1959),
	68:  int16(1959),
	69:  int16(1959),
	70:  int16(-int32(3918)),
	71:  int16(-int32(3918)),
	72:  int16(-int32(3918)),
	73:  int16(1959),
	74:  int16(1959),
	77:  int16(-int32(4156)),
	78:  int16(4156),
	80:  int16(4156),
	84:  int16(-int32(4156)),
	88:  int16(8192),
	89:  int16(8192),
	90:  int16(-int32(16384)),
	91:  int16(8192),
	92:  int16(16384),
	93:  int16(16384),
	94:  int16(-int32(32768)),
	95:  int16(8192),
	96:  int16(-int32(16384)),
	108: int16(8312),
	120: int16(8312),
}

var Opus_mapping_matrix_soa_mixing = OpusT_MappingMatrix{
	Frows: int32(11),
	Fcols: int32(11),
}

var Opus_mapping_matrix_soa_mixing_data = [121]OpusT_opus_int16{
	0:   int16(10923),
	1:   int16(7723),
	2:   int16(13377),
	3:   int16(-int32(13377)),
	4:   int16(11585),
	5:   int16(9459),
	6:   int16(7723),
	7:   int16(-int32(16384)),
	8:   int16(-int32(6689)),
	11:  int16(10923),
	12:  int16(7723),
	13:  int16(13377),
	14:  int16(13377),
	15:  int16(-int32(11585)),
	16:  int16(9459),
	17:  int16(7723),
	18:  int16(16384),
	19:  int16(-int32(6689)),
	22:  int16(10923),
	23:  int16(-int32(15447)),
	24:  int16(13377),
	27:  int16(-int32(18919)),
	28:  int16(7723),
	30:  int16(13377),
	33:  int16(10923),
	34:  int16(7723),
	35:  int16(-int32(13377)),
	36:  int16(-int32(13377)),
	37:  int16(11585),
	38:  int16(-int32(9459)),
	39:  int16(7723),
	40:  int16(16384),
	41:  int16(-int32(6689)),
	44:  int16(10923),
	45:  int16(-int32(7723)),
	47:  int16(13377),
	48:  int16(-int32(16384)),
	50:  int16(-int32(15447)),
	52:  int16(9459),
	55:  int16(10923),
	56:  int16(-int32(7723)),
	58:  int16(-int32(13377)),
	59:  int16(16384),
	61:  int16(-int32(15447)),
	63:  int16(9459),
	66:  int16(10923),
	67:  int16(15447),
	72:  int16(-int32(15447)),
	74:  int16(-int32(18919)),
	77:  int16(10923),
	78:  int16(7723),
	79:  int16(-int32(13377)),
	80:  int16(13377),
	81:  int16(-int32(11585)),
	82:  int16(-int32(9459)),
	83:  int16(7723),
	84:  int16(-int32(16384)),
	85:  int16(-int32(6689)),
	88:  int16(10923),
	89:  int16(-int32(15447)),
	90:  int16(-int32(13377)),
	93:  int16(18919),
	94:  int16(7723),
	96:  int16(13377),
	108: int16(32767),
	120: int16(32767),
}

var Opus_mapping_matrix_toa_demixing = OpusT_MappingMatrix{
	Frows: int32(18),
	Fcols: int32(18),
}

var Opus_mapping_matrix_toa_demixing_data = [324]OpusT_opus_int16{
	0:   int16(8192),
	1:   int16(8192),
	2:   int16(8192),
	3:   int16(8192),
	4:   int16(8192),
	5:   int16(8192),
	6:   int16(8192),
	7:   int16(8192),
	8:   int16(8192),
	9:   int16(8192),
	10:  int16(8192),
	11:  int16(8192),
	12:  int16(8192),
	13:  int16(8192),
	14:  int16(8192),
	15:  int16(8192),
	19:  int16(-int32(9779)),
	20:  int16(9779),
	21:  int16(6263),
	22:  int16(8857),
	24:  int16(6263),
	25:  int16(13829),
	26:  int16(9779),
	27:  int16(-int32(13829)),
	29:  int16(-int32(6263)),
	31:  int16(-int32(8857)),
	32:  int16(-int32(6263)),
	33:  int16(-int32(9779)),
	36:  int16(-int32(3413)),
	37:  int16(3413),
	38:  int16(3413),
	39:  int16(-int32(11359)),
	40:  int16(11359),
	41:  int16(11359),
	42:  int16(-int32(11359)),
	43:  int16(-int32(3413)),
	44:  int16(3413),
	45:  int16(-int32(3413)),
	46:  int16(-int32(3413)),
	47:  int16(-int32(11359)),
	48:  int16(11359),
	49:  int16(11359),
	50:  int16(-int32(11359)),
	51:  int16(3413),
	54:  int16(13829),
	55:  int16(9779),
	56:  int16(-int32(9779)),
	57:  int16(6263),
	59:  int16(8857),
	60:  int16(-int32(6263)),
	62:  int16(9779),
	64:  int16(-int32(13829)),
	65:  int16(6263),
	66:  int16(-int32(8857)),
	68:  int16(-int32(6263)),
	69:  int16(-int32(9779)),
	73:  int16(-int32(15617)),
	74:  int16(-int32(15617)),
	75:  int16(6406),
	78:  int16(-int32(6406)),
	80:  int16(15617),
	83:  int16(-int32(6406)),
	86:  int16(6406),
	87:  int16(15617),
	91:  int16(-int32(5003)),
	92:  int16(5003),
	93:  int16(-int32(10664)),
	94:  int16(15081),
	96:  int16(-int32(10664)),
	97:  int16(-int32(7075)),
	98:  int16(5003),
	99:  int16(7075),
	101: int16(10664),
	103: int16(-int32(15081)),
	104: int16(10664),
	105: int16(-int32(5003)),
	108: int16(-int32(8176)),
	109: int16(-int32(8176)),
	110: int16(-int32(8176)),
	111: int16(8208),
	112: int16(8208),
	113: int16(8208),
	114: int16(8208),
	115: int16(-int32(8176)),
	116: int16(-int32(8176)),
	117: int16(-int32(8176)),
	118: int16(-int32(8176)),
	119: int16(8208),
	120: int16(8208),
	121: int16(8208),
	122: int16(8208),
	123: int16(-int32(8176)),
	126: int16(-int32(7075)),
	127: int16(5003),
	128: int16(-int32(5003)),
	129: int16(-int32(10664)),
	131: int16(15081),
	132: int16(10664),
	134: int16(5003),
	136: int16(7075),
	137: int16(-int32(10664)),
	138: int16(-int32(15081)),
	140: int16(10664),
	141: int16(-int32(5003)),
	144: int16(15617),
	148: int16(-int32(6406)),
	149: int16(6406),
	151: int16(-int32(15617)),
	153: int16(-int32(15617)),
	154: int16(15617),
	156: int16(6406),
	157: int16(-int32(6406)),
	163: int16(-int32(11393)),
	164: int16(11393),
	165: int16(2993),
	166: int16(-int32(4233)),
	168: int16(2993),
	169: int16(-int32(16112)),
	170: int16(11393),
	171: int16(16112),
	173: int16(-int32(2993)),
	175: int16(4233),
	176: int16(-int32(2993)),
	177: int16(-int32(11393)),
	181: int16(-int32(9974)),
	182: int16(-int32(9974)),
	183: int16(-int32(13617)),
	186: int16(13617),
	188: int16(9974),
	191: int16(13617),
	194: int16(-int32(13617)),
	195: int16(9974),
	199: int16(5579),
	200: int16(-int32(5579)),
	201: int16(10185),
	202: int16(14403),
	204: int16(10185),
	205: int16(-int32(7890)),
	206: int16(-int32(5579)),
	207: int16(7890),
	209: int16(-int32(10185)),
	211: int16(-int32(14403)),
	212: int16(-int32(10185)),
	213: int16(5579),
	216: int16(11826),
	217: int16(-int32(11826)),
	218: int16(-int32(11826)),
	219: int16(-int32(901)),
	220: int16(901),
	221: int16(901),
	222: int16(-int32(901)),
	223: int16(11826),
	224: int16(-int32(11826)),
	225: int16(11826),
	226: int16(11826),
	227: int16(-int32(901)),
	228: int16(901),
	229: int16(901),
	230: int16(-int32(901)),
	231: int16(-int32(11826)),
	234: int16(-int32(7890)),
	235: int16(-int32(5579)),
	236: int16(5579),
	237: int16(10185),
	239: int16(14403),
	240: int16(-int32(10185)),
	242: int16(-int32(5579)),
	244: int16(7890),
	245: int16(10185),
	246: int16(-int32(14403)),
	248: int16(-int32(10185)),
	249: int16(5579),
	252: int16(-int32(9974)),
	256: int16(-int32(13617)),
	257: int16(13617),
	259: int16(9974),
	261: int16(9974),
	262: int16(-int32(9974)),
	264: int16(13617),
	265: int16(-int32(13617)),
	270: int16(16112),
	271: int16(-int32(11393)),
	272: int16(11393),
	273: int16(-int32(2993)),
	275: int16(4233),
	276: int16(2993),
	278: int16(-int32(11393)),
	280: int16(-int32(16112)),
	281: int16(-int32(2993)),
	282: int16(-int32(4233)),
	284: int16(2993),
	285: int16(11393),
	304: int16(32767),
	323: int16(32767),
}

var Opus_mapping_matrix_toa_mixing = OpusT_MappingMatrix{
	Frows: int32(18),
	Fcols: int32(18),
}

var Opus_mapping_matrix_toa_mixing_data = [324]OpusT_opus_int16{
	0:   int16(8208),
	2:   int16(-int32(881)),
	3:   int16(14369),
	6:   int16(-int32(8192)),
	7:   int16(-int32(4163)),
	8:   int16(13218),
	12:  int16(11095),
	13:  int16(-int32(8836)),
	14:  int16(-int32(6218)),
	15:  int16(14833),
	18:  int16(8208),
	19:  int16(-int32(10161)),
	20:  int16(881),
	21:  int16(10161),
	22:  int16(-int32(13218)),
	23:  int16(-int32(2944)),
	24:  int16(-int32(8192)),
	25:  int16(2944),
	27:  int16(-int32(10488)),
	28:  int16(-int32(6218)),
	29:  int16(6248),
	30:  int16(-int32(11095)),
	31:  int16(-int32(6248)),
	33:  int16(-int32(10488)),
	36:  int16(8208),
	37:  int16(10161),
	38:  int16(881),
	39:  int16(-int32(10161)),
	40:  int16(-int32(13218)),
	41:  int16(2944),
	42:  int16(-int32(8192)),
	43:  int16(-int32(2944)),
	45:  int16(10488),
	46:  int16(-int32(6218)),
	47:  int16(-int32(6248)),
	48:  int16(-int32(11095)),
	49:  int16(6248),
	51:  int16(10488),
	54:  int16(8176),
	55:  int16(5566),
	56:  int16(-int32(11552)),
	57:  int16(5566),
	58:  int16(9681),
	59:  int16(-int32(11205)),
	60:  int16(8192),
	61:  int16(-int32(11205)),
	63:  int16(4920),
	64:  int16(-int32(15158)),
	65:  int16(9756),
	66:  int16(-int32(3334)),
	67:  int16(9756),
	69:  int16(-int32(4920)),
	72:  int16(8176),
	73:  int16(7871),
	74:  int16(11552),
	77:  int16(15846),
	78:  int16(8192),
	80:  int16(-int32(9681)),
	81:  int16(-int32(6958)),
	83:  int16(13797),
	84:  int16(3334),
	86:  int16(-int32(15158)),
	90:  int16(8176),
	92:  int16(11552),
	93:  int16(7871),
	96:  int16(8192),
	97:  int16(15846),
	98:  int16(9681),
	102: int16(3334),
	103: int16(13797),
	104: int16(15158),
	105: int16(6958),
	108: int16(8176),
	109: int16(5566),
	110: int16(-int32(11552)),
	111: int16(-int32(5566)),
	112: int16(-int32(9681)),
	113: int16(-int32(11205)),
	114: int16(8192),
	115: int16(11205),
	117: int16(4920),
	118: int16(15158),
	119: int16(9756),
	120: int16(-int32(3334)),
	121: int16(-int32(9756)),
	123: int16(4920),
	126: int16(8208),
	127: int16(14369),
	128: int16(-int32(881)),
	131: int16(-int32(4163)),
	132: int16(-int32(8192)),
	134: int16(-int32(13218)),
	135: int16(-int32(14833)),
	137: int16(-int32(8836)),
	138: int16(11095),
	140: int16(6218),
	144: int16(8208),
	145: int16(10161),
	146: int16(881),
	147: int16(10161),
	148: int16(13218),
	149: int16(2944),
	150: int16(-int32(8192)),
	151: int16(2944),
	153: int16(10488),
	154: int16(6218),
	155: int16(-int32(6248)),
	156: int16(-int32(11095)),
	157: int16(-int32(6248)),
	159: int16(-int32(10488)),
	162: int16(8208),
	163: int16(-int32(14369)),
	164: int16(-int32(881)),
	167: int16(4163),
	168: int16(-int32(8192)),
	170: int16(-int32(13218)),
	171: int16(14833),
	173: int16(8836),
	174: int16(11095),
	176: int16(6218),
	180: int16(8208),
	182: int16(-int32(881)),
	183: int16(-int32(14369)),
	186: int16(-int32(8192)),
	187: int16(4163),
	188: int16(13218),
	192: int16(11095),
	193: int16(8836),
	194: int16(-int32(6218)),
	195: int16(-int32(14833)),
	198: int16(8176),
	199: int16(-int32(5566)),
	200: int16(-int32(11552)),
	201: int16(5566),
	202: int16(-int32(9681)),
	203: int16(11205),
	204: int16(8192),
	205: int16(-int32(11205)),
	207: int16(-int32(4920)),
	208: int16(15158),
	209: int16(-int32(9756)),
	210: int16(-int32(3334)),
	211: int16(9756),
	213: int16(-int32(4920)),
	216: int16(8176),
	218: int16(11552),
	219: int16(-int32(7871)),
	222: int16(8192),
	223: int16(-int32(15846)),
	224: int16(9681),
	228: int16(3334),
	229: int16(-int32(13797)),
	230: int16(15158),
	231: int16(-int32(6958)),
	234: int16(8176),
	235: int16(-int32(7871)),
	236: int16(11552),
	239: int16(-int32(15846)),
	240: int16(8192),
	242: int16(-int32(9681)),
	243: int16(6958),
	245: int16(-int32(13797)),
	246: int16(3334),
	248: int16(-int32(15158)),
	252: int16(8176),
	253: int16(-int32(5566)),
	254: int16(-int32(11552)),
	255: int16(-int32(5566)),
	256: int16(9681),
	257: int16(11205),
	258: int16(8192),
	259: int16(11205),
	261: int16(-int32(4920)),
	262: int16(-int32(15158)),
	263: int16(-int32(9756)),
	264: int16(-int32(3334)),
	265: int16(-int32(9756)),
	267: int16(4920),
	270: int16(8208),
	271: int16(-int32(10161)),
	272: int16(881),
	273: int16(-int32(10161)),
	274: int16(13218),
	275: int16(-int32(2944)),
	276: int16(-int32(8192)),
	277: int16(-int32(2944)),
	279: int16(-int32(10488)),
	280: int16(6218),
	281: int16(6248),
	282: int16(-int32(11095)),
	283: int16(6248),
	285: int16(10488),
	304: int16(32767),
	323: int16(32767),
}

var Opus_silk_CB_lags_stage2 = [4][11]OpusT_opus_int8{
	0: {
		1:  int8(2),
		2:  int8(-int32(1)),
		3:  int8(-int32(1)),
		4:  int8(-int32(1)),
		7:  int8(1),
		8:  int8(1),
		10: int8(1),
	},
	1: {
		1: int8(1),
		7: int8(1),
	},
	2: {
		2: int8(1),
		6: int8(1),
	},
	3: {
		1:  int8(-int32(1)),
		2:  int8(2),
		3:  int8(1),
		5:  int8(1),
		6:  int8(1),
		9:  int8(-int32(1)),
		10: int8(-int32(1)),
	},
}

var Opus_silk_CB_lags_stage2_10_ms = [2][3]OpusT_opus_int8{
	0: {
		1: int8(1),
	},
	1: {
		2: int8(1),
	},
}

var Opus_silk_CB_lags_stage3 = [4][34]OpusT_opus_int8{
	0: {
		2:  int8(1),
		3:  int8(-int32(1)),
		5:  int8(1),
		6:  int8(-int32(1)),
		8:  int8(-int32(1)),
		9:  int8(1),
		10: int8(-int32(2)),
		11: int8(2),
		12: int8(-int32(2)),
		13: int8(-int32(2)),
		14: int8(2),
		15: int8(-int32(3)),
		16: int8(2),
		17: int8(3),
		18: int8(-int32(3)),
		19: int8(-int32(4)),
		20: int8(3),
		21: int8(-int32(4)),
		22: int8(4),
		23: int8(4),
		24: int8(-int32(5)),
		25: int8(5),
		26: int8(-int32(6)),
		27: int8(-int32(5)),
		28: int8(6),
		29: int8(-int32(7)),
		30: int8(6),
		31: int8(5),
		32: int8(8),
		33: int8(-int32(9)),
	},
	1: {
		2:  int8(1),
		10: int8(-int32(1)),
		11: int8(1),
		14: int8(1),
		15: int8(-int32(1)),
		17: int8(1),
		18: int8(-int32(1)),
		19: int8(-int32(1)),
		20: int8(1),
		21: int8(-int32(1)),
		22: int8(2),
		23: int8(1),
		24: int8(-int32(1)),
		25: int8(2),
		26: int8(-int32(2)),
		27: int8(-int32(2)),
		28: int8(2),
		29: int8(-int32(2)),
		30: int8(2),
		31: int8(2),
		32: int8(3),
		33: int8(-int32(3)),
	},
	2: {
		1:  int8(1),
		8:  int8(1),
		10: int8(1),
		13: int8(1),
		14: int8(-int32(1)),
		15: int8(1),
		18: int8(2),
		19: int8(1),
		20: int8(-int32(1)),
		21: int8(2),
		22: int8(-int32(1)),
		23: int8(-int32(1)),
		24: int8(2),
		25: int8(-int32(1)),
		26: int8(2),
		27: int8(2),
		28: int8(-int32(1)),
		29: int8(3),
		30: int8(-int32(2)),
		31: int8(-int32(2)),
		32: int8(-int32(2)),
		33: int8(3),
	},
	3: {
		1:  int8(1),
		4:  int8(1),
		6:  int8(1),
		7:  int8(-int32(1)),
		8:  int8(2),
		9:  int8(-int32(1)),
		10: int8(2),
		11: int8(-int32(1)),
		12: int8(2),
		13: int8(3),
		14: int8(-int32(2)),
		15: int8(3),
		16: int8(-int32(2)),
		17: int8(-int32(2)),
		18: int8(4),
		19: int8(4),
		20: int8(-int32(3)),
		21: int8(5),
		22: int8(-int32(3)),
		23: int8(-int32(4)),
		24: int8(6),
		25: int8(-int32(4)),
		26: int8(6),
		27: int8(5),
		28: int8(-int32(5)),
		29: int8(8),
		30: int8(-int32(6)),
		31: int8(-int32(5)),
		32: int8(-int32(7)),
		33: int8(9),
	},
}

var Opus_silk_CB_lags_stage3_10_ms = [2][12]OpusT_opus_int8{
	0: {
		2:  int8(1),
		3:  int8(-int32(1)),
		4:  int8(1),
		5:  int8(-int32(1)),
		6:  int8(2),
		7:  int8(-int32(2)),
		8:  int8(2),
		9:  int8(-int32(2)),
		10: int8(3),
		11: int8(-int32(3)),
	},
	1: {
		1:  int8(1),
		3:  int8(1),
		4:  int8(-int32(1)),
		5:  int8(2),
		6:  int8(-int32(1)),
		7:  int8(2),
		8:  int8(-int32(2)),
		9:  int8(3),
		10: int8(-int32(2)),
		11: int8(3),
	},
}

var Opus_silk_LBRR_flags_iCDF_ptr = [2]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LBRR_flags_2_iCDF)),
	1: uintptr(unsafe.Pointer(&silk_LBRR_flags_3_iCDF)),
}

// C documentation
//
//	/* Cosine approximation table for LSF conversion */
//	/* Q12 values (even) */
var Opus_silk_LSFCosTab_FIX_Q12 = [129]OpusT_opus_int16{
	0:   int16(8192),
	1:   int16(8190),
	2:   int16(8182),
	3:   int16(8170),
	4:   int16(8152),
	5:   int16(8130),
	6:   int16(8104),
	7:   int16(8072),
	8:   int16(8034),
	9:   int16(7994),
	10:  int16(7946),
	11:  int16(7896),
	12:  int16(7840),
	13:  int16(7778),
	14:  int16(7714),
	15:  int16(7644),
	16:  int16(7568),
	17:  int16(7490),
	18:  int16(7406),
	19:  int16(7318),
	20:  int16(7226),
	21:  int16(7128),
	22:  int16(7026),
	23:  int16(6922),
	24:  int16(6812),
	25:  int16(6698),
	26:  int16(6580),
	27:  int16(6458),
	28:  int16(6332),
	29:  int16(6204),
	30:  int16(6070),
	31:  int16(5934),
	32:  int16(5792),
	33:  int16(5648),
	34:  int16(5502),
	35:  int16(5352),
	36:  int16(5198),
	37:  int16(5040),
	38:  int16(4880),
	39:  int16(4718),
	40:  int16(4552),
	41:  int16(4382),
	42:  int16(4212),
	43:  int16(4038),
	44:  int16(3862),
	45:  int16(3684),
	46:  int16(3502),
	47:  int16(3320),
	48:  int16(3136),
	49:  int16(2948),
	50:  int16(2760),
	51:  int16(2570),
	52:  int16(2378),
	53:  int16(2186),
	54:  int16(1990),
	55:  int16(1794),
	56:  int16(1598),
	57:  int16(1400),
	58:  int16(1202),
	59:  int16(1002),
	60:  int16(802),
	61:  int16(602),
	62:  int16(402),
	63:  int16(202),
	65:  int16(-int32(202)),
	66:  int16(-int32(402)),
	67:  int16(-int32(602)),
	68:  int16(-int32(802)),
	69:  int16(-int32(1002)),
	70:  int16(-int32(1202)),
	71:  int16(-int32(1400)),
	72:  int16(-int32(1598)),
	73:  int16(-int32(1794)),
	74:  int16(-int32(1990)),
	75:  int16(-int32(2186)),
	76:  int16(-int32(2378)),
	77:  int16(-int32(2570)),
	78:  int16(-int32(2760)),
	79:  int16(-int32(2948)),
	80:  int16(-int32(3136)),
	81:  int16(-int32(3320)),
	82:  int16(-int32(3502)),
	83:  int16(-int32(3684)),
	84:  int16(-int32(3862)),
	85:  int16(-int32(4038)),
	86:  int16(-int32(4212)),
	87:  int16(-int32(4382)),
	88:  int16(-int32(4552)),
	89:  int16(-int32(4718)),
	90:  int16(-int32(4880)),
	91:  int16(-int32(5040)),
	92:  int16(-int32(5198)),
	93:  int16(-int32(5352)),
	94:  int16(-int32(5502)),
	95:  int16(-int32(5648)),
	96:  int16(-int32(5792)),
	97:  int16(-int32(5934)),
	98:  int16(-int32(6070)),
	99:  int16(-int32(6204)),
	100: int16(-int32(6332)),
	101: int16(-int32(6458)),
	102: int16(-int32(6580)),
	103: int16(-int32(6698)),
	104: int16(-int32(6812)),
	105: int16(-int32(6922)),
	106: int16(-int32(7026)),
	107: int16(-int32(7128)),
	108: int16(-int32(7226)),
	109: int16(-int32(7318)),
	110: int16(-int32(7406)),
	111: int16(-int32(7490)),
	112: int16(-int32(7568)),
	113: int16(-int32(7644)),
	114: int16(-int32(7714)),
	115: int16(-int32(7778)),
	116: int16(-int32(7840)),
	117: int16(-int32(7896)),
	118: int16(-int32(7946)),
	119: int16(-int32(7994)),
	120: int16(-int32(8034)),
	121: int16(-int32(8072)),
	122: int16(-int32(8104)),
	123: int16(-int32(8130)),
	124: int16(-int32(8152)),
	125: int16(-int32(8170)),
	126: int16(-int32(8182)),
	127: int16(-int32(8190)),
	128: int16(-int32(8192)),
}

// C documentation
//
//	/* Table for LTPScale */
var Opus_silk_LTPScales_table_Q14 = [3]OpusT_opus_int16{
	0: int16(15565),
	1: int16(12288),
	2: int16(8192),
}

var Opus_silk_LTP_gain_BITS_Q5_ptrs = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_BITS_Q5_2)),
}

var Opus_silk_LTP_gain_iCDF_ptrs = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_iCDF_2)),
}

var Opus_silk_LTP_per_index_iCDF = [3]OpusT_opus_uint8{
	0: uint8(179),
	1: uint8(99),
}

var Opus_silk_LTP_vq_gain_ptrs_Q7 = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_0_gain)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_1_gain)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_2_gain)),
}

var Opus_silk_LTP_vq_ptrs_Q7 = [3]uintptr{
	0: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_0)),
	1: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_1)),
	2: uintptr(unsafe.Pointer(&silk_LTP_gain_vq_2)),
}

var Opus_silk_LTP_vq_sizes = [3]OpusT_opus_int8{
	0: int8(8),
	1: int8(16),
	2: int8(32),
}

// C documentation
//
//	/* Tables for LTPScale */
var Opus_silk_LTPscale_iCDF = [3]OpusT_opus_uint8{
	0: uint8(128),
	1: uint8(64),
}

var Opus_silk_Lag_range_stage3 = [3][4][2]OpusT_opus_int8{
	0: {
		0: {
			0: int8(-int32(5)),
			1: int8(8),
		},
		1: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		2: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		3: {
			0: int8(-int32(4)),
			1: int8(10),
		},
	},
	1: {
		0: {
			0: int8(-int32(6)),
			1: int8(10),
		},
		1: {
			0: int8(-int32(2)),
			1: int8(6),
		},
		2: {
			0: int8(-int32(1)),
			1: int8(6),
		},
		3: {
			0: int8(-int32(5)),
			1: int8(10),
		},
	},
	2: {
		0: {
			0: int8(-int32(9)),
			1: int8(12),
		},
		1: {
			0: int8(-int32(3)),
			1: int8(7),
		},
		2: {
			0: int8(-int32(2)),
			1: int8(7),
		},
		3: {
			0: int8(-int32(7)),
			1: int8(13),
		},
	},
}

var Opus_silk_Lag_range_stage3_10_ms = [2][2]OpusT_opus_int8{
	0: {
		0: int8(-int32(3)),
		1: int8(7),
	},
	1: {
		0: int8(-int32(2)),
		1: int8(7),
	},
}

var Opus_silk_NLSF_CB_NB_MB = OpusT_silk_NLSF_CB_struct{
	FnVectors:            int16(32),
	Forder:               int16(10),
	FquantStepSize_Q16:   int16(int32(float64(libc.Float64FromFloat64(0.18)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))),
	FinvQuantStepSize_Q6: int16(int32(float64(libc.Float64FromFloat64(1)/libc.Float64FromFloat64(0.18)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(6))) + libc.Float64FromFloat64(0.5))),
	FCB1_NLSF_Q8:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_NB_MB_Q8)),
	FCB1_Wght_Q9:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_Wght_Q9)),
	FCB1_iCDF:            uintptr(unsafe.Pointer(&silk_NLSF_CB1_iCDF_NB_MB)),
	Fpred_Q8:             uintptr(unsafe.Pointer(&silk_NLSF_PRED_NB_MB_Q8)),
	Fec_sel:              uintptr(unsafe.Pointer(&silk_NLSF_CB2_SELECT_NB_MB)),
	Fec_iCDF:             uintptr(unsafe.Pointer(&silk_NLSF_CB2_iCDF_NB_MB)),
	Fec_Rates_Q5:         uintptr(unsafe.Pointer(&silk_NLSF_CB2_BITS_NB_MB_Q5)),
	FdeltaMin_Q15:        uintptr(unsafe.Pointer(&silk_NLSF_DELTA_MIN_NB_MB_Q15)),
}

var Opus_silk_NLSF_CB_WB = OpusT_silk_NLSF_CB_struct{
	FnVectors:            int16(32),
	Forder:               int16(16),
	FquantStepSize_Q16:   int16(int32(float64(libc.Float64FromFloat64(0.15)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16))) + libc.Float64FromFloat64(0.5))),
	FinvQuantStepSize_Q6: int16(int32(float64(libc.Float64FromFloat64(1)/libc.Float64FromFloat64(0.15)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(6))) + libc.Float64FromFloat64(0.5))),
	FCB1_NLSF_Q8:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_WB_Q8)),
	FCB1_Wght_Q9:         uintptr(unsafe.Pointer(&silk_NLSF_CB1_WB_Wght_Q9)),
	FCB1_iCDF:            uintptr(unsafe.Pointer(&silk_NLSF_CB1_iCDF_WB)),
	Fpred_Q8:             uintptr(unsafe.Pointer(&silk_NLSF_PRED_WB_Q8)),
	Fec_sel:              uintptr(unsafe.Pointer(&silk_NLSF_CB2_SELECT_WB)),
	Fec_iCDF:             uintptr(unsafe.Pointer(&silk_NLSF_CB2_iCDF_WB)),
	Fec_Rates_Q5:         uintptr(unsafe.Pointer(&silk_NLSF_CB2_BITS_WB_Q5)),
	FdeltaMin_Q15:        uintptr(unsafe.Pointer(&silk_NLSF_DELTA_MIN_WB_Q15)),
}

var Opus_silk_NLSF_EXT_iCDF = [7]OpusT_opus_uint8{
	0: uint8(100),
	1: uint8(40),
	2: uint8(16),
	3: uint8(7),
	4: uint8(3),
	5: uint8(1),
}

// C documentation
//
//	/* Tables for NLSF interpolation factor */
var Opus_silk_NLSF_interpolation_factor_iCDF = [5]OpusT_opus_uint8{
	0: uint8(243),
	1: uint8(221),
	2: uint8(192),
	3: uint8(181),
}

// C documentation
//
//	/* Quantization offsets */
var Opus_silk_Quantization_Offsets_Q10 = [2][2]OpusT_opus_int16{
	0: {
		0: int16(OFFSET_UVL_Q10),
		1: int16(OFFSET_UVH_Q10),
	},
	1: {
		0: int16(OFFSET_VL_Q10),
		1: int16(OFFSET_VH_Q10),
	},
}

var Opus_silk_Resampler_1_2_COEFS = [14]OpusT_opus_int16{
	0:  int16(616),
	1:  int16(-int32(14323)),
	2:  int16(-int32(10)),
	3:  int16(39),
	4:  int16(58),
	5:  int16(-int32(46)),
	6:  int16(-int32(84)),
	7:  int16(120),
	8:  int16(184),
	9:  int16(-int32(315)),
	10: int16(-int32(541)),
	11: int16(1284),
	12: int16(5380),
	13: int16(9024),
}

var Opus_silk_Resampler_1_3_COEFS = [20]OpusT_opus_int16{
	0:  int16(16102),
	1:  int16(-int32(15162)),
	2:  int16(-int32(13)),
	4:  int16(20),
	5:  int16(26),
	6:  int16(5),
	7:  int16(-int32(31)),
	8:  int16(-int32(43)),
	9:  int16(-int32(4)),
	10: int16(65),
	11: int16(90),
	12: int16(7),
	13: int16(-int32(157)),
	14: int16(-int32(248)),
	15: int16(-int32(44)),
	16: int16(593),
	17: int16(1583),
	18: int16(2612),
	19: int16(3271),
}

var Opus_silk_Resampler_1_4_COEFS = [20]OpusT_opus_int16{
	0:  int16(22500),
	1:  int16(-int32(15099)),
	2:  int16(3),
	3:  int16(-int32(14)),
	4:  int16(-int32(20)),
	5:  int16(-int32(15)),
	6:  int16(2),
	7:  int16(25),
	8:  int16(37),
	9:  int16(25),
	10: int16(-int32(16)),
	11: int16(-int32(71)),
	12: int16(-int32(107)),
	13: int16(-int32(79)),
	14: int16(50),
	15: int16(292),
	16: int16(623),
	17: int16(982),
	18: int16(1288),
	19: int16(1464),
}

var Opus_silk_Resampler_1_6_COEFS = [20]OpusT_opus_int16{
	0:  int16(27540),
	1:  int16(-int32(15257)),
	2:  int16(17),
	3:  int16(12),
	4:  int16(8),
	5:  int16(1),
	6:  int16(-int32(10)),
	7:  int16(-int32(22)),
	8:  int16(-int32(30)),
	9:  int16(-int32(32)),
	10: int16(-int32(22)),
	11: int16(3),
	12: int16(44),
	13: int16(100),
	14: int16(168),
	15: int16(243),
	16: int16(317),
	17: int16(381),
	18: int16(429),
	19: int16(455),
}

var Opus_silk_Resampler_2_3_COEFS = [20]OpusT_opus_int16{
	0:  int16(-int32(14457)),
	1:  int16(-int32(14019)),
	2:  int16(64),
	3:  int16(128),
	4:  int16(-int32(122)),
	5:  int16(36),
	6:  int16(310),
	7:  int16(-int32(768)),
	8:  int16(584),
	9:  int16(9267),
	10: int16(17733),
	11: int16(12),
	12: int16(128),
	13: int16(18),
	14: int16(-int32(142)),
	15: int16(288),
	16: int16(-int32(117)),
	17: int16(-int32(865)),
	18: int16(4123),
	19: int16(14459),
}

var Opus_silk_Resampler_2_3_COEFS_LQ = [6]OpusT_opus_int16{
	0: int16(-int32(2797)),
	1: int16(-int32(6507)),
	2: int16(4697),
	3: int16(10739),
	4: int16(1567),
	5: int16(8276),
}

/* Matlab code for the notch filter coefficients: */
/* B = [1, 0.147, 1];  A = [1, 0.107, 0.89]; G = 0.93; freqz(G * B, A, 2^14, 16e3); axis([0, 8000, -10, 1]) */
/* fprintf('\t%6d, %6d, %6d, %6d\n', round(B(2)*2^16), round(-A(2)*2^16), round((1-A(3))*2^16), round(G*2^15)) */
/* const opus_int16 silk_resampler_up2_hq_notch[ 4 ] = { 9634,  -7012,   7209,  30474 }; */

// C documentation
//
//	/* Tables with IIR and FIR coefficients for fractional downsamplers (123 Words) */
var Opus_silk_Resampler_3_4_COEFS = [29]OpusT_opus_int16{
	0:  int16(-int32(20694)),
	1:  int16(-int32(13867)),
	2:  int16(-int32(49)),
	3:  int16(64),
	4:  int16(17),
	5:  int16(-int32(157)),
	6:  int16(353),
	7:  int16(-int32(496)),
	8:  int16(163),
	9:  int16(11047),
	10: int16(22205),
	11: int16(-int32(39)),
	12: int16(6),
	13: int16(91),
	14: int16(-int32(170)),
	15: int16(186),
	16: int16(23),
	17: int16(-int32(896)),
	18: int16(6336),
	19: int16(19928),
	20: int16(-int32(19)),
	21: int16(-int32(36)),
	22: int16(102),
	23: int16(-int32(89)),
	24: int16(-int32(24)),
	25: int16(328),
	26: int16(-int32(951)),
	27: int16(2568),
	28: int16(15909),
}

// C documentation
//
//	/* Interpolation points for filter coefficients used in the bandwidth transition smoother */
var Opus_silk_Transition_LP_A_Q28 = [5][2]OpusT_opus_int32{
	0: {
		0: int32(506393414),
		1: int32(239854379),
	},
	1: {
		0: int32(411067935),
		1: int32(169683996),
	},
	2: {
		0: int32(306733530),
		1: int32(116694253),
	},
	3: {
		0: int32(185807084),
		1: int32(77959395),
	},
	4: {
		0: int32(35497197),
		1: int32(57401098),
	},
}

/*  Elliptic/Cauer filters designed with 0.1 dB passband ripple,
    80 dB minimum stopband attenuation, and
    [0.95 : 0.15 : 0.35] normalized cut off frequencies. */

// C documentation
//
//	/* Interpolation points for filter coefficients used in the bandwidth transition smoother */
var Opus_silk_Transition_LP_B_Q28 = [5][3]OpusT_opus_int32{
	0: {
		0: int32(250767114),
		1: int32(501534038),
		2: int32(250767114),
	},
	1: {
		0: int32(209867381),
		1: int32(419732057),
		2: int32(209867381),
	},
	2: {
		0: int32(170987846),
		1: int32(341967853),
		2: int32(170987846),
	},
	3: {
		0: int32(131531482),
		1: int32(263046905),
		2: int32(131531482),
	},
	4: {
		0: int32(89306658),
		1: int32(178584282),
		2: int32(89306658),
	},
}

var Opus_silk_delta_gain_iCDF = [41]OpusT_opus_uint8{
	0:  uint8(250),
	1:  uint8(245),
	2:  uint8(234),
	3:  uint8(203),
	4:  uint8(71),
	5:  uint8(50),
	6:  uint8(42),
	7:  uint8(38),
	8:  uint8(35),
	9:  uint8(33),
	10: uint8(31),
	11: uint8(29),
	12: uint8(28),
	13: uint8(27),
	14: uint8(26),
	15: uint8(25),
	16: uint8(24),
	17: uint8(23),
	18: uint8(22),
	19: uint8(21),
	20: uint8(20),
	21: uint8(19),
	22: uint8(18),
	23: uint8(17),
	24: uint8(16),
	25: uint8(15),
	26: uint8(14),
	27: uint8(13),
	28: uint8(12),
	29: uint8(11),
	30: uint8(10),
	31: uint8(9),
	32: uint8(8),
	33: uint8(7),
	34: uint8(6),
	35: uint8(5),
	36: uint8(4),
	37: uint8(3),
	38: uint8(2),
	39: uint8(1),
}

var Opus_silk_gain_iCDF = [3][8]OpusT_opus_uint8{
	0: {
		0: uint8(224),
		1: uint8(112),
		2: uint8(44),
		3: uint8(15),
		4: uint8(3),
		5: uint8(2),
		6: uint8(1),
	},
	1: {
		0: uint8(254),
		1: uint8(237),
		2: uint8(192),
		3: uint8(132),
		4: uint8(70),
		5: uint8(23),
		6: uint8(4),
	},
	2: {
		0: uint8(255),
		1: uint8(252),
		2: uint8(226),
		3: uint8(155),
		4: uint8(61),
		5: uint8(11),
		6: uint8(2),
	},
}

// C documentation
//
//	/* Table for LSB coding */
var Opus_silk_lsb_iCDF = [2]OpusT_opus_uint8{
	0: uint8(120),
}

var Opus_silk_max_pulses_table = [4]OpusT_opus_uint8{
	0: uint8(8),
	1: uint8(10),
	2: uint8(12),
	3: uint8(16),
}

var Opus_silk_nb_cbk_searchs_stage3 = [3]OpusT_opus_int8{
	0: int8(PE_NB_CBKS_STAGE3_MIN),
	1: int8(PE_NB_CBKS_STAGE3_MID),
	2: int8(PE_NB_CBKS_STAGE3_MAX),
}

var Opus_silk_pitch_contour_10_ms_NB_iCDF = [3]OpusT_opus_uint8{
	0: uint8(113),
	1: uint8(63),
}

var Opus_silk_pitch_contour_10_ms_iCDF = [12]OpusT_opus_uint8{
	0:  uint8(165),
	1:  uint8(119),
	2:  uint8(80),
	3:  uint8(61),
	4:  uint8(47),
	5:  uint8(35),
	6:  uint8(27),
	7:  uint8(20),
	8:  uint8(14),
	9:  uint8(9),
	10: uint8(4),
}

var Opus_silk_pitch_contour_NB_iCDF = [11]OpusT_opus_uint8{
	0: uint8(188),
	1: uint8(176),
	2: uint8(155),
	3: uint8(138),
	4: uint8(119),
	5: uint8(97),
	6: uint8(67),
	7: uint8(43),
	8: uint8(26),
	9: uint8(10),
}

var Opus_silk_pitch_contour_iCDF = [34]OpusT_opus_uint8{
	0:  uint8(223),
	1:  uint8(201),
	2:  uint8(183),
	3:  uint8(167),
	4:  uint8(152),
	5:  uint8(138),
	6:  uint8(124),
	7:  uint8(111),
	8:  uint8(98),
	9:  uint8(88),
	10: uint8(79),
	11: uint8(70),
	12: uint8(62),
	13: uint8(56),
	14: uint8(50),
	15: uint8(44),
	16: uint8(39),
	17: uint8(35),
	18: uint8(31),
	19: uint8(27),
	20: uint8(24),
	21: uint8(21),
	22: uint8(18),
	23: uint8(16),
	24: uint8(14),
	25: uint8(12),
	26: uint8(10),
	27: uint8(8),
	28: uint8(6),
	29: uint8(4),
	30: uint8(3),
	31: uint8(2),
	32: uint8(1),
}

var Opus_silk_pitch_delta_iCDF = [21]OpusT_opus_uint8{
	0:  uint8(210),
	1:  uint8(208),
	2:  uint8(206),
	3:  uint8(203),
	4:  uint8(199),
	5:  uint8(193),
	6:  uint8(183),
	7:  uint8(168),
	8:  uint8(142),
	9:  uint8(104),
	10: uint8(74),
	11: uint8(52),
	12: uint8(37),
	13: uint8(27),
	14: uint8(20),
	15: uint8(14),
	16: uint8(10),
	17: uint8(6),
	18: uint8(4),
	19: uint8(2),
}

var Opus_silk_pitch_lag_iCDF = [32]OpusT_opus_uint8{
	0:  uint8(253),
	1:  uint8(250),
	2:  uint8(244),
	3:  uint8(233),
	4:  uint8(212),
	5:  uint8(182),
	6:  uint8(150),
	7:  uint8(131),
	8:  uint8(120),
	9:  uint8(110),
	10: uint8(98),
	11: uint8(85),
	12: uint8(72),
	13: uint8(60),
	14: uint8(49),
	15: uint8(40),
	16: uint8(32),
	17: uint8(25),
	18: uint8(19),
	19: uint8(15),
	20: uint8(13),
	21: uint8(11),
	22: uint8(9),
	23: uint8(8),
	24: uint8(7),
	25: uint8(6),
	26: uint8(5),
	27: uint8(4),
	28: uint8(3),
	29: uint8(2),
	30: uint8(1),
}

var Opus_silk_pulses_per_block_BITS_Q5 = [9][18]OpusT_opus_uint8{
	0: {
		0:  uint8(31),
		1:  uint8(57),
		2:  uint8(107),
		3:  uint8(160),
		4:  uint8(205),
		5:  uint8(205),
		6:  uint8(255),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	1: {
		0:  uint8(69),
		1:  uint8(47),
		2:  uint8(67),
		3:  uint8(111),
		4:  uint8(166),
		5:  uint8(205),
		6:  uint8(255),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	2: {
		0:  uint8(82),
		1:  uint8(74),
		2:  uint8(79),
		3:  uint8(95),
		4:  uint8(109),
		5:  uint8(128),
		6:  uint8(145),
		7:  uint8(160),
		8:  uint8(173),
		9:  uint8(205),
		10: uint8(205),
		11: uint8(205),
		12: uint8(224),
		13: uint8(255),
		14: uint8(255),
		15: uint8(224),
		16: uint8(255),
		17: uint8(224),
	},
	3: {
		0:  uint8(125),
		1:  uint8(74),
		2:  uint8(59),
		3:  uint8(69),
		4:  uint8(97),
		5:  uint8(141),
		6:  uint8(182),
		7:  uint8(255),
		8:  uint8(255),
		9:  uint8(255),
		10: uint8(255),
		11: uint8(255),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	4: {
		0:  uint8(173),
		1:  uint8(115),
		2:  uint8(85),
		3:  uint8(73),
		4:  uint8(76),
		5:  uint8(92),
		6:  uint8(115),
		7:  uint8(145),
		8:  uint8(173),
		9:  uint8(205),
		10: uint8(224),
		11: uint8(224),
		12: uint8(255),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	5: {
		0:  uint8(166),
		1:  uint8(134),
		2:  uint8(113),
		3:  uint8(102),
		4:  uint8(101),
		5:  uint8(102),
		6:  uint8(107),
		7:  uint8(118),
		8:  uint8(125),
		9:  uint8(138),
		10: uint8(145),
		11: uint8(155),
		12: uint8(166),
		13: uint8(182),
		14: uint8(192),
		15: uint8(192),
		16: uint8(205),
		17: uint8(150),
	},
	6: {
		0:  uint8(224),
		1:  uint8(182),
		2:  uint8(134),
		3:  uint8(101),
		4:  uint8(83),
		5:  uint8(79),
		6:  uint8(85),
		7:  uint8(97),
		8:  uint8(120),
		9:  uint8(145),
		10: uint8(173),
		11: uint8(205),
		12: uint8(224),
		13: uint8(255),
		14: uint8(255),
		15: uint8(255),
		16: uint8(255),
		17: uint8(255),
	},
	7: {
		0:  uint8(255),
		1:  uint8(224),
		2:  uint8(192),
		3:  uint8(150),
		4:  uint8(120),
		5:  uint8(101),
		6:  uint8(92),
		7:  uint8(89),
		8:  uint8(93),
		9:  uint8(102),
		10: uint8(118),
		11: uint8(134),
		12: uint8(160),
		13: uint8(182),
		14: uint8(192),
		15: uint8(224),
		16: uint8(224),
		17: uint8(224),
	},
	8: {
		0:  uint8(255),
		1:  uint8(224),
		2:  uint8(224),
		3:  uint8(182),
		4:  uint8(155),
		5:  uint8(134),
		6:  uint8(118),
		7:  uint8(109),
		8:  uint8(104),
		9:  uint8(102),
		10: uint8(106),
		11: uint8(111),
		12: uint8(118),
		13: uint8(131),
		14: uint8(145),
		15: uint8(160),
		16: uint8(173),
		17: uint8(131),
	},
}

var Opus_silk_pulses_per_block_iCDF = [10][18]OpusT_opus_uint8{
	0: {
		0:  uint8(125),
		1:  uint8(51),
		2:  uint8(26),
		3:  uint8(18),
		4:  uint8(15),
		5:  uint8(12),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	1: {
		0:  uint8(198),
		1:  uint8(105),
		2:  uint8(45),
		3:  uint8(22),
		4:  uint8(15),
		5:  uint8(12),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	2: {
		0:  uint8(213),
		1:  uint8(162),
		2:  uint8(116),
		3:  uint8(83),
		4:  uint8(59),
		5:  uint8(43),
		6:  uint8(32),
		7:  uint8(24),
		8:  uint8(18),
		9:  uint8(15),
		10: uint8(12),
		11: uint8(9),
		12: uint8(7),
		13: uint8(6),
		14: uint8(5),
		15: uint8(3),
		16: uint8(2),
	},
	3: {
		0:  uint8(239),
		1:  uint8(187),
		2:  uint8(116),
		3:  uint8(59),
		4:  uint8(28),
		5:  uint8(16),
		6:  uint8(11),
		7:  uint8(10),
		8:  uint8(9),
		9:  uint8(8),
		10: uint8(7),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	4: {
		0:  uint8(250),
		1:  uint8(229),
		2:  uint8(188),
		3:  uint8(135),
		4:  uint8(86),
		5:  uint8(51),
		6:  uint8(30),
		7:  uint8(19),
		8:  uint8(13),
		9:  uint8(10),
		10: uint8(8),
		11: uint8(6),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	5: {
		0:  uint8(249),
		1:  uint8(235),
		2:  uint8(213),
		3:  uint8(185),
		4:  uint8(156),
		5:  uint8(128),
		6:  uint8(103),
		7:  uint8(83),
		8:  uint8(66),
		9:  uint8(53),
		10: uint8(42),
		11: uint8(33),
		12: uint8(26),
		13: uint8(21),
		14: uint8(17),
		15: uint8(13),
		16: uint8(10),
	},
	6: {
		0:  uint8(254),
		1:  uint8(249),
		2:  uint8(235),
		3:  uint8(206),
		4:  uint8(164),
		5:  uint8(118),
		6:  uint8(77),
		7:  uint8(46),
		8:  uint8(27),
		9:  uint8(16),
		10: uint8(10),
		11: uint8(7),
		12: uint8(5),
		13: uint8(4),
		14: uint8(3),
		15: uint8(2),
		16: uint8(1),
	},
	7: {
		0:  uint8(255),
		1:  uint8(253),
		2:  uint8(249),
		3:  uint8(239),
		4:  uint8(220),
		5:  uint8(191),
		6:  uint8(156),
		7:  uint8(119),
		8:  uint8(85),
		9:  uint8(57),
		10: uint8(37),
		11: uint8(23),
		12: uint8(15),
		13: uint8(10),
		14: uint8(6),
		15: uint8(4),
		16: uint8(2),
	},
	8: {
		0:  uint8(255),
		1:  uint8(253),
		2:  uint8(251),
		3:  uint8(246),
		4:  uint8(237),
		5:  uint8(223),
		6:  uint8(203),
		7:  uint8(179),
		8:  uint8(152),
		9:  uint8(124),
		10: uint8(98),
		11: uint8(75),
		12: uint8(55),
		13: uint8(40),
		14: uint8(29),
		15: uint8(21),
		16: uint8(15),
	},
	9: {
		0:  uint8(255),
		1:  uint8(254),
		2:  uint8(253),
		3:  uint8(247),
		4:  uint8(220),
		5:  uint8(162),
		6:  uint8(106),
		7:  uint8(67),
		8:  uint8(42),
		9:  uint8(28),
		10: uint8(18),
		11: uint8(12),
		12: uint8(9),
		13: uint8(6),
		14: uint8(4),
		15: uint8(3),
		16: uint8(2),
	},
}

var Opus_silk_rate_levels_BITS_Q5 = [2][9]OpusT_opus_uint8{
	0: {
		0: uint8(131),
		1: uint8(74),
		2: uint8(141),
		3: uint8(79),
		4: uint8(80),
		5: uint8(138),
		6: uint8(95),
		7: uint8(104),
		8: uint8(134),
	},
	1: {
		0: uint8(95),
		1: uint8(99),
		2: uint8(91),
		3: uint8(125),
		4: uint8(93),
		5: uint8(76),
		6: uint8(123),
		7: uint8(115),
		8: uint8(123),
	},
}

var Opus_silk_rate_levels_iCDF = [2][9]OpusT_opus_uint8{
	0: {
		0: uint8(241),
		1: uint8(190),
		2: uint8(178),
		3: uint8(132),
		4: uint8(87),
		5: uint8(74),
		6: uint8(41),
		7: uint8(14),
	},
	1: {
		0: uint8(223),
		1: uint8(193),
		2: uint8(157),
		3: uint8(140),
		4: uint8(106),
		5: uint8(57),
		6: uint8(39),
		7: uint8(18),
	},
}

// C documentation
//
//	/* Table with interplation fractions of 1/24, 3/24, 5/24, ... , 23/24 : 23/24 (46 Words) */
var Opus_silk_resampler_frac_FIR_12 = [12][4]OpusT_opus_int16{
	0: {
		0: int16(189),
		1: int16(-int32(600)),
		2: int16(617),
		3: int16(30567),
	},
	1: {
		0: int16(117),
		1: int16(-int32(159)),
		2: int16(-int32(1070)),
		3: int16(29704),
	},
	2: {
		0: int16(52),
		1: int16(221),
		2: int16(-int32(2392)),
		3: int16(28276),
	},
	3: {
		0: int16(-int32(4)),
		1: int16(529),
		2: int16(-int32(3350)),
		3: int16(26341),
	},
	4: {
		0: int16(-int32(48)),
		1: int16(758),
		2: int16(-int32(3956)),
		3: int16(23973),
	},
	5: {
		0: int16(-int32(80)),
		1: int16(905),
		2: int16(-int32(4235)),
		3: int16(21254),
	},
	6: {
		0: int16(-int32(99)),
		1: int16(972),
		2: int16(-int32(4222)),
		3: int16(18278),
	},
	7: {
		0: int16(-int32(107)),
		1: int16(967),
		2: int16(-int32(3957)),
		3: int16(15143),
	},
	8: {
		0: int16(-int32(103)),
		1: int16(896),
		2: int16(-int32(3487)),
		3: int16(11950),
	},
	9: {
		0: int16(-int32(91)),
		1: int16(773),
		2: int16(-int32(2865)),
		3: int16(8798),
	},
	10: {
		0: int16(-int32(71)),
		1: int16(611),
		2: int16(-int32(2143)),
		3: int16(5784),
	},
	11: {
		0: int16(-int32(46)),
		1: int16(425),
		2: int16(-int32(1375)),
		3: int16(2996),
	},
}

var Opus_silk_shell_code_table0 = [152]OpusT_opus_uint8{
	0:   uint8(128),
	2:   uint8(214),
	3:   uint8(42),
	5:   uint8(235),
	6:   uint8(128),
	7:   uint8(21),
	9:   uint8(244),
	10:  uint8(184),
	11:  uint8(72),
	12:  uint8(11),
	14:  uint8(248),
	15:  uint8(214),
	16:  uint8(128),
	17:  uint8(42),
	18:  uint8(7),
	20:  uint8(248),
	21:  uint8(225),
	22:  uint8(170),
	23:  uint8(80),
	24:  uint8(25),
	25:  uint8(5),
	27:  uint8(251),
	28:  uint8(236),
	29:  uint8(198),
	30:  uint8(126),
	31:  uint8(54),
	32:  uint8(18),
	33:  uint8(3),
	35:  uint8(250),
	36:  uint8(238),
	37:  uint8(211),
	38:  uint8(159),
	39:  uint8(82),
	40:  uint8(35),
	41:  uint8(15),
	42:  uint8(5),
	44:  uint8(250),
	45:  uint8(231),
	46:  uint8(203),
	47:  uint8(168),
	48:  uint8(128),
	49:  uint8(88),
	50:  uint8(53),
	51:  uint8(25),
	52:  uint8(6),
	54:  uint8(252),
	55:  uint8(238),
	56:  uint8(216),
	57:  uint8(185),
	58:  uint8(148),
	59:  uint8(108),
	60:  uint8(71),
	61:  uint8(40),
	62:  uint8(18),
	63:  uint8(4),
	65:  uint8(253),
	66:  uint8(243),
	67:  uint8(225),
	68:  uint8(199),
	69:  uint8(166),
	70:  uint8(128),
	71:  uint8(90),
	72:  uint8(57),
	73:  uint8(31),
	74:  uint8(13),
	75:  uint8(3),
	77:  uint8(254),
	78:  uint8(246),
	79:  uint8(233),
	80:  uint8(212),
	81:  uint8(183),
	82:  uint8(147),
	83:  uint8(109),
	84:  uint8(73),
	85:  uint8(44),
	86:  uint8(23),
	87:  uint8(10),
	88:  uint8(2),
	90:  uint8(255),
	91:  uint8(250),
	92:  uint8(240),
	93:  uint8(223),
	94:  uint8(198),
	95:  uint8(166),
	96:  uint8(128),
	97:  uint8(90),
	98:  uint8(58),
	99:  uint8(33),
	100: uint8(16),
	101: uint8(6),
	102: uint8(1),
	104: uint8(255),
	105: uint8(251),
	106: uint8(244),
	107: uint8(231),
	108: uint8(210),
	109: uint8(181),
	110: uint8(146),
	111: uint8(110),
	112: uint8(75),
	113: uint8(46),
	114: uint8(25),
	115: uint8(12),
	116: uint8(5),
	117: uint8(1),
	119: uint8(255),
	120: uint8(253),
	121: uint8(248),
	122: uint8(238),
	123: uint8(221),
	124: uint8(196),
	125: uint8(164),
	126: uint8(128),
	127: uint8(92),
	128: uint8(60),
	129: uint8(35),
	130: uint8(18),
	131: uint8(8),
	132: uint8(3),
	133: uint8(1),
	135: uint8(255),
	136: uint8(253),
	137: uint8(249),
	138: uint8(242),
	139: uint8(229),
	140: uint8(208),
	141: uint8(180),
	142: uint8(146),
	143: uint8(110),
	144: uint8(76),
	145: uint8(48),
	146: uint8(27),
	147: uint8(14),
	148: uint8(7),
	149: uint8(3),
	150: uint8(1),
}

var Opus_silk_shell_code_table1 = [152]OpusT_opus_uint8{
	0:   uint8(129),
	2:   uint8(207),
	3:   uint8(50),
	5:   uint8(236),
	6:   uint8(129),
	7:   uint8(20),
	9:   uint8(245),
	10:  uint8(185),
	11:  uint8(72),
	12:  uint8(10),
	14:  uint8(249),
	15:  uint8(213),
	16:  uint8(129),
	17:  uint8(42),
	18:  uint8(6),
	20:  uint8(250),
	21:  uint8(226),
	22:  uint8(169),
	23:  uint8(87),
	24:  uint8(27),
	25:  uint8(4),
	27:  uint8(251),
	28:  uint8(233),
	29:  uint8(194),
	30:  uint8(130),
	31:  uint8(62),
	32:  uint8(20),
	33:  uint8(4),
	35:  uint8(250),
	36:  uint8(236),
	37:  uint8(207),
	38:  uint8(160),
	39:  uint8(99),
	40:  uint8(47),
	41:  uint8(17),
	42:  uint8(3),
	44:  uint8(255),
	45:  uint8(240),
	46:  uint8(217),
	47:  uint8(182),
	48:  uint8(131),
	49:  uint8(81),
	50:  uint8(41),
	51:  uint8(11),
	52:  uint8(1),
	54:  uint8(255),
	55:  uint8(254),
	56:  uint8(233),
	57:  uint8(201),
	58:  uint8(159),
	59:  uint8(107),
	60:  uint8(61),
	61:  uint8(20),
	62:  uint8(2),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(249),
	67:  uint8(233),
	68:  uint8(206),
	69:  uint8(170),
	70:  uint8(128),
	71:  uint8(86),
	72:  uint8(50),
	73:  uint8(23),
	74:  uint8(7),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(250),
	79:  uint8(238),
	80:  uint8(217),
	81:  uint8(186),
	82:  uint8(148),
	83:  uint8(108),
	84:  uint8(70),
	85:  uint8(39),
	86:  uint8(18),
	87:  uint8(6),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(252),
	92:  uint8(243),
	93:  uint8(226),
	94:  uint8(200),
	95:  uint8(166),
	96:  uint8(128),
	97:  uint8(90),
	98:  uint8(56),
	99:  uint8(30),
	100: uint8(13),
	101: uint8(4),
	102: uint8(1),
	104: uint8(255),
	105: uint8(252),
	106: uint8(245),
	107: uint8(231),
	108: uint8(209),
	109: uint8(180),
	110: uint8(146),
	111: uint8(110),
	112: uint8(76),
	113: uint8(47),
	114: uint8(25),
	115: uint8(11),
	116: uint8(4),
	117: uint8(1),
	119: uint8(255),
	120: uint8(253),
	121: uint8(248),
	122: uint8(237),
	123: uint8(219),
	124: uint8(194),
	125: uint8(163),
	126: uint8(128),
	127: uint8(93),
	128: uint8(62),
	129: uint8(37),
	130: uint8(19),
	131: uint8(8),
	132: uint8(3),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(250),
	138: uint8(241),
	139: uint8(226),
	140: uint8(205),
	141: uint8(177),
	142: uint8(145),
	143: uint8(111),
	144: uint8(79),
	145: uint8(51),
	146: uint8(30),
	147: uint8(15),
	148: uint8(6),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table2 = [152]OpusT_opus_uint8{
	0:   uint8(129),
	2:   uint8(203),
	3:   uint8(54),
	5:   uint8(234),
	6:   uint8(129),
	7:   uint8(23),
	9:   uint8(245),
	10:  uint8(184),
	11:  uint8(73),
	12:  uint8(10),
	14:  uint8(250),
	15:  uint8(215),
	16:  uint8(129),
	17:  uint8(41),
	18:  uint8(5),
	20:  uint8(252),
	21:  uint8(232),
	22:  uint8(173),
	23:  uint8(86),
	24:  uint8(24),
	25:  uint8(3),
	27:  uint8(253),
	28:  uint8(240),
	29:  uint8(200),
	30:  uint8(129),
	31:  uint8(56),
	32:  uint8(15),
	33:  uint8(2),
	35:  uint8(253),
	36:  uint8(244),
	37:  uint8(217),
	38:  uint8(164),
	39:  uint8(94),
	40:  uint8(38),
	41:  uint8(10),
	42:  uint8(1),
	44:  uint8(253),
	45:  uint8(245),
	46:  uint8(226),
	47:  uint8(189),
	48:  uint8(132),
	49:  uint8(71),
	50:  uint8(27),
	51:  uint8(7),
	52:  uint8(1),
	54:  uint8(253),
	55:  uint8(246),
	56:  uint8(231),
	57:  uint8(203),
	58:  uint8(159),
	59:  uint8(105),
	60:  uint8(56),
	61:  uint8(23),
	62:  uint8(6),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(248),
	67:  uint8(235),
	68:  uint8(213),
	69:  uint8(179),
	70:  uint8(133),
	71:  uint8(85),
	72:  uint8(47),
	73:  uint8(19),
	74:  uint8(5),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(254),
	79:  uint8(243),
	80:  uint8(221),
	81:  uint8(194),
	82:  uint8(159),
	83:  uint8(117),
	84:  uint8(70),
	85:  uint8(37),
	86:  uint8(12),
	87:  uint8(2),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(254),
	92:  uint8(248),
	93:  uint8(234),
	94:  uint8(208),
	95:  uint8(171),
	96:  uint8(128),
	97:  uint8(85),
	98:  uint8(48),
	99:  uint8(22),
	100: uint8(8),
	101: uint8(2),
	102: uint8(1),
	104: uint8(255),
	105: uint8(254),
	106: uint8(250),
	107: uint8(240),
	108: uint8(220),
	109: uint8(189),
	110: uint8(149),
	111: uint8(107),
	112: uint8(67),
	113: uint8(36),
	114: uint8(16),
	115: uint8(6),
	116: uint8(2),
	117: uint8(1),
	119: uint8(255),
	120: uint8(254),
	121: uint8(251),
	122: uint8(243),
	123: uint8(227),
	124: uint8(201),
	125: uint8(166),
	126: uint8(128),
	127: uint8(90),
	128: uint8(55),
	129: uint8(29),
	130: uint8(13),
	131: uint8(5),
	132: uint8(2),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(252),
	138: uint8(246),
	139: uint8(234),
	140: uint8(213),
	141: uint8(183),
	142: uint8(147),
	143: uint8(109),
	144: uint8(73),
	145: uint8(43),
	146: uint8(22),
	147: uint8(10),
	148: uint8(4),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table3 = [152]OpusT_opus_uint8{
	0:   uint8(130),
	2:   uint8(200),
	3:   uint8(58),
	5:   uint8(231),
	6:   uint8(130),
	7:   uint8(26),
	9:   uint8(244),
	10:  uint8(184),
	11:  uint8(76),
	12:  uint8(12),
	14:  uint8(249),
	15:  uint8(214),
	16:  uint8(130),
	17:  uint8(43),
	18:  uint8(6),
	20:  uint8(252),
	21:  uint8(232),
	22:  uint8(173),
	23:  uint8(87),
	24:  uint8(24),
	25:  uint8(3),
	27:  uint8(253),
	28:  uint8(241),
	29:  uint8(203),
	30:  uint8(131),
	31:  uint8(56),
	32:  uint8(14),
	33:  uint8(2),
	35:  uint8(254),
	36:  uint8(246),
	37:  uint8(221),
	38:  uint8(167),
	39:  uint8(94),
	40:  uint8(35),
	41:  uint8(8),
	42:  uint8(1),
	44:  uint8(254),
	45:  uint8(249),
	46:  uint8(232),
	47:  uint8(193),
	48:  uint8(130),
	49:  uint8(65),
	50:  uint8(23),
	51:  uint8(5),
	52:  uint8(1),
	54:  uint8(255),
	55:  uint8(251),
	56:  uint8(239),
	57:  uint8(211),
	58:  uint8(162),
	59:  uint8(99),
	60:  uint8(45),
	61:  uint8(15),
	62:  uint8(4),
	63:  uint8(1),
	65:  uint8(255),
	66:  uint8(251),
	67:  uint8(243),
	68:  uint8(223),
	69:  uint8(186),
	70:  uint8(131),
	71:  uint8(74),
	72:  uint8(33),
	73:  uint8(11),
	74:  uint8(3),
	75:  uint8(1),
	77:  uint8(255),
	78:  uint8(252),
	79:  uint8(245),
	80:  uint8(230),
	81:  uint8(202),
	82:  uint8(158),
	83:  uint8(105),
	84:  uint8(57),
	85:  uint8(24),
	86:  uint8(8),
	87:  uint8(2),
	88:  uint8(1),
	90:  uint8(255),
	91:  uint8(253),
	92:  uint8(247),
	93:  uint8(235),
	94:  uint8(214),
	95:  uint8(179),
	96:  uint8(132),
	97:  uint8(84),
	98:  uint8(44),
	99:  uint8(19),
	100: uint8(7),
	101: uint8(2),
	102: uint8(1),
	104: uint8(255),
	105: uint8(254),
	106: uint8(250),
	107: uint8(240),
	108: uint8(223),
	109: uint8(196),
	110: uint8(159),
	111: uint8(112),
	112: uint8(69),
	113: uint8(36),
	114: uint8(15),
	115: uint8(6),
	116: uint8(2),
	117: uint8(1),
	119: uint8(255),
	120: uint8(254),
	121: uint8(253),
	122: uint8(245),
	123: uint8(231),
	124: uint8(209),
	125: uint8(176),
	126: uint8(136),
	127: uint8(93),
	128: uint8(55),
	129: uint8(27),
	130: uint8(11),
	131: uint8(3),
	132: uint8(2),
	133: uint8(1),
	135: uint8(255),
	136: uint8(254),
	137: uint8(253),
	138: uint8(252),
	139: uint8(239),
	140: uint8(221),
	141: uint8(194),
	142: uint8(158),
	143: uint8(117),
	144: uint8(76),
	145: uint8(42),
	146: uint8(18),
	147: uint8(4),
	148: uint8(3),
	149: uint8(2),
	150: uint8(1),
}

var Opus_silk_shell_code_table_offsets = [17]OpusT_opus_uint8{
	2:  uint8(2),
	3:  uint8(5),
	4:  uint8(9),
	5:  uint8(14),
	6:  uint8(20),
	7:  uint8(27),
	8:  uint8(35),
	9:  uint8(44),
	10: uint8(54),
	11: uint8(65),
	12: uint8(77),
	13: uint8(90),
	14: uint8(104),
	15: uint8(119),
	16: uint8(135),
}

var Opus_silk_sign_iCDF = [42]OpusT_opus_uint8{
	0:  uint8(254),
	1:  uint8(49),
	2:  uint8(67),
	3:  uint8(77),
	4:  uint8(82),
	5:  uint8(93),
	6:  uint8(99),
	7:  uint8(198),
	8:  uint8(11),
	9:  uint8(18),
	10: uint8(24),
	11: uint8(31),
	12: uint8(36),
	13: uint8(45),
	14: uint8(255),
	15: uint8(46),
	16: uint8(66),
	17: uint8(78),
	18: uint8(87),
	19: uint8(94),
	20: uint8(104),
	21: uint8(208),
	22: uint8(14),
	23: uint8(21),
	24: uint8(32),
	25: uint8(42),
	26: uint8(51),
	27: uint8(66),
	28: uint8(255),
	29: uint8(94),
	30: uint8(104),
	31: uint8(109),
	32: uint8(112),
	33: uint8(115),
	34: uint8(118),
	35: uint8(248),
	36: uint8(53),
	37: uint8(69),
	38: uint8(80),
	39: uint8(88),
	40: uint8(95),
	41: uint8(102),
}

var Opus_silk_stereo_only_code_mid_iCDF = [2]OpusT_opus_uint8{
	0: uint8(64),
}

var Opus_silk_stereo_pred_joint_iCDF = [25]OpusT_opus_uint8{
	0:  uint8(249),
	1:  uint8(247),
	2:  uint8(246),
	3:  uint8(245),
	4:  uint8(244),
	5:  uint8(234),
	6:  uint8(210),
	7:  uint8(202),
	8:  uint8(201),
	9:  uint8(200),
	10: uint8(197),
	11: uint8(174),
	12: uint8(82),
	13: uint8(59),
	14: uint8(56),
	15: uint8(55),
	16: uint8(54),
	17: uint8(46),
	18: uint8(22),
	19: uint8(12),
	20: uint8(11),
	21: uint8(10),
	22: uint8(9),
	23: uint8(7),
}

// C documentation
//
//	/* Tables for stereo predictor coding */
var Opus_silk_stereo_pred_quant_Q13 = [16]OpusT_opus_int16{
	0:  int16(-int32(13732)),
	1:  int16(-int32(10050)),
	2:  int16(-int32(8266)),
	3:  int16(-int32(7526)),
	4:  int16(-int32(6500)),
	5:  int16(-int32(5000)),
	6:  int16(-int32(2950)),
	7:  int16(-int32(820)),
	8:  int16(820),
	9:  int16(2950),
	10: int16(5000),
	11: int16(6500),
	12: int16(7526),
	13: int16(8266),
	14: int16(10050),
	15: int16(13732),
}

// C documentation
//
//	/* Tables for signal type and offset coding */
var Opus_silk_type_offset_VAD_iCDF = [4]OpusT_opus_uint8{
	0: uint8(232),
	1: uint8(158),
	2: uint8(10),
}

var Opus_silk_type_offset_no_VAD_iCDF = [2]OpusT_opus_uint8{
	0: uint8(230),
}

// C documentation
//
//	/* Uniform entropy tables */
var Opus_silk_uniform3_iCDF = [3]OpusT_opus_uint8{
	0: uint8(171),
	1: uint8(85),
}

var Opus_silk_uniform4_iCDF = [4]OpusT_opus_uint8{
	0: uint8(192),
	1: uint8(128),
	2: uint8(64),
}

var Opus_silk_uniform5_iCDF = [5]OpusT_opus_uint8{
	0: uint8(205),
	1: uint8(154),
	2: uint8(102),
	3: uint8(51),
}

var Opus_silk_uniform6_iCDF = [6]OpusT_opus_uint8{
	0: uint8(213),
	1: uint8(171),
	2: uint8(128),
	3: uint8(85),
	4: uint8(43),
}

var Opus_silk_uniform8_iCDF = [8]OpusT_opus_uint8{
	0: uint8(224),
	1: uint8(192),
	2: uint8(160),
	3: uint8(128),
	4: uint8(96),
	5: uint8(64),
	6: uint8(32),
}

// C documentation
//
//	/* TF change table. Positive values mean better frequency resolution (longer
//	   effective window), whereas negative values mean better time resolution
//	   (shorter effective window). The second index is computed as:
//	   4*isTransient + 2*tf_select + per_band_flag */
var Opus_tf_select_table = [4][8]int8{
	0: {
		1: int8(-int32(1)),
		3: int8(-int32(1)),
		5: int8(-int32(1)),
		7: int8(-int32(1)),
	},
	1: {
		1: int8(-int32(1)),
		3: int8(-int32(2)),
		4: int8(1),
		6: int8(1),
		7: int8(-int32(1)),
	},
	2: {
		1: int8(-int32(2)),
		3: int8(-int32(3)),
		4: int8(2),
		6: int8(1),
		7: int8(-int32(1)),
	},
	3: {
		1: int8(-int32(2)),
		3: int8(-int32(3)),
		4: int8(3),
		6: int8(1),
		7: int8(-int32(1)),
	},
}

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = "assertion failed: st->channels == 1 || st->channels == 2\x00../src/opus_decoder.c\x00assertion failed: st->Fs == 48000 || st->Fs == 24000 || st->Fs == 16000 || st->Fs == 12000 || st->Fs == 8000\x00assertion failed: st->DecControl.API_sampleRate == st->Fs\x00assertion failed: st->DecControl.internalSampleRate == 0 || st->DecControl.internalSampleRate == 16000 || st->DecControl.internalSampleRate == 12000 || st->DecControl.internalSampleRate == 8000\x00assertion failed: st->DecControl.nChannelsAPI == st->channels\x00assertion failed: st->DecControl.nChannelsInternal == 0 || st->DecControl.nChannelsInternal == 1 || st->DecControl.nChannelsInternal == 2\x00assertion failed: st->DecControl.payloadSize_ms == 0 || st->DecControl.payloadSize_ms == 10 || st->DecControl.payloadSize_ms == 20 || st->DecControl.payloadSize_ms == 40 || st->DecControl.payloadSize_ms == 60\x00assertion failed: st->arch >= 0\x00assertion failed: st->arch <= OPUS_ARCHMASK\x00assertion failed: st->stream_channels == 1 || st->stream_channels == 2\x00pseudostack overflow\x00assertion failed: 0\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10012, (((void)((endband) == (opus_int32)0)), (opus_int32)(endband)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10008, (((void)((st->stream_channels) == (opus_int32)0)), (opus_int32)(st->stream_channels)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10010, (((void)((0) == (opus_int32)0)), (opus_int32)(0)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 4031, ((&redundant_rng) + ((&redundant_rng) - (opus_uint32*)(&redundant_rng))))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10010, (((void)((start_band) == (opus_int32)0)), (opus_int32)(start_band)))) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 4028)) == OPUS_OK\x00assertion failed: (opus_custom_decoder_ctl(celt_dec, 10015, ((&celt_mode) + ((&celt_mode) - (const OpusCustomMode**)(&celt_mode))))) == OPUS_OK\x00assertion failed: pcm_count == frame_size\x00assertion failed: ret==frame_size-packet_frame_size\x00assertion failed: ret==packet_frame_size\x00assertion failed: st->application != OPUS_APPLICATION_RESTRICTED_SILK\x00../src/opus_encoder.c\x00assertion failed: cbr_bytes>=0\x00assertion failed: st->mode == MODE_HYBRID || curr_bandwidth == OPUS_BANDWIDTH_WIDEBAND\x00assertion failed: st->silk_mode.internalSampleRate == 16000\x00assertion failed: celt_enc != NULL\x00assertion failed: len >= 0\x00../src/extensions.c\x00assertion failed: data != NULL || len == 0\x00assertion failed: nb_frames >= 0 && nb_frames <= 48\x00assertion failed: iter->repeat_frame > 0\x00assertion failed: iter->src_len >= 0\x00assertion failed: iter->curr_data - iter->data == iter->len - iter->curr_len\x00assertion failed: nb_extensions != NULL\x00assertion failed: extensions != NULL || *nb_extensions == 0\x00assertion failed: nb_frames <= 48\x00assertion failed: idx < nb_frames_cum[ext.frame + 1]\x00assertion failed: ext->id >= 3 && ext->id <= 127\x00assertion failed: extensions[frame_repeat_idx[g]].frame == g\x00assertion failed: written == nb_extensions\x00../src/opus_multistream_encoder.c\x00assertion failed: nb_frames*freq_size == frame_size\x00assertion failed: (opus_multistream_decoder_ctl(st, 4029, ((&Fs) + ((&Fs) - (opus_int32*)(&Fs))))) == OPUS_OK\x00../src/opus_multistream_decoder.c\x00../src/repacketizer.c\x00assertion failed: ret == ext_len\x00assertion failed: ret > 0 && ret <= len\x00../src/opus_projection_decoder.c\x00assertion failed: align(data_size) == align(rows * cols * sizeof(opus_int16))\x00../src/mapping_matrix.c\x00assertion failed: input_rows <= matrix->cols && output_rows <= matrix->rows\x00../src/analysis.c\x00assertion failed: NB_TBANDS+1 <= LEAK_BANDS\x00assertion failed: start <= end\x00../celt/bands.c\x00assertion failed: end>0\x00assertion failed: nbBands>0\x00assertion failed: sum>=0\x00assertion failed: stride>0\x00assertion failed: qn <= 256\x00assertion failed: itheta>=0\x00assertion failed: N > 0\x00Fatal (internal) error in %s, line %d: %s\n\x00../celt/celt.c\x00success\x00invalid argument\x00buffer too small\x00internal error\x00corrupted stream\x00request not implemented\x00invalid state\x00memory allocation failed\x00unknown error\x00libopus 1.6.1\x00../celt/celt_encoder.c\x00assertion failed: !celt_isnan(tmp[0])\x00assertion failed: !celt_isnan(norm)\x00assertion failed: len > 2*delay\x00assertion failed: st->signalling==0\x00assertion failed: !celt_isnan(freq[0]) && (C==1 || !celt_isnan(freq[N]))\x00assertion failed: count>0\x00assertion failed: st->mode == opus_custom_mode_create(48000, 960, NULL)\x00../celt/celt_decoder.c\x00assertion failed: st->overlap == 120\x00assertion failed: st->end <= 21\x00assertion failed: st->downsample > 0\x00assertion failed: st->start == 0 || st->start == 17\x00assertion failed: st->start < st->end\x00assertion failed: st->last_pitch_index <= PLC_PITCH_LAG_MAX\x00assertion failed: st->last_pitch_index >= PLC_PITCH_LAG_MIN || st->last_pitch_index == 0\x00assertion failed: st->postfilter_period < MAX_PERIOD\x00assertion failed: st->postfilter_period >= COMBFILTER_MINPERIOD || st->postfilter_period == 0\x00assertion failed: st->postfilter_period_old < MAX_PERIOD\x00assertion failed: st->postfilter_period_old >= COMBFILTER_MINPERIOD || st->postfilter_period_old == 0\x00assertion failed: st->postfilter_tapset <= 2\x00assertion failed: st->postfilter_tapset >= 0\x00assertion failed: st->postfilter_tapset_old <= 2\x00assertion failed: st->postfilter_tapset_old >= 0\x00assertion failed: _n>=2\x00../celt/cwrs.c\x00assertion failed: _k>0\x00assertion failed: _n>1\x00assertion failed: _ft>1\x00../celt/entdec.c\x00../celt/entenc.c\x00assertion failed: _bits>0\x00assertion failed: _nbits<=EC_SYM_BITS\x00assertion failed: _this->offs+_this->end_offs<=_size\x00assertion failed: m==4\x00../celt/kiss_fft.c\x00assertion failed: fin != fout\nIn-place FFT not supported\x00assertion failed: fl+fs<=32768\x00../celt/laplace.c\x00assertion failed: fs>0\x00assertion failed: fl<32768\x00assertion failed: fl<=fm\x00assertion failed: fm<IMIN(fl+fs,32768)\x00../celt/mdct.c\x00assertion failed: max_pitch>0\x00../celt/pitch.c\x00assertion failed: len>=3\x00../celt/pitch.h\x00assertion failed: len>0\x00assertion failed: x != y\x00../celt/celt_lpc.c\x00assertion failed: (ord&3)==0\x00assertion failed: n>0\x00assertion failed: overlap>=0\x00../celt/quant_bands.c\x00assertion failed: codedBands > start\x00../celt/rate.c\x00assertion failed: bits[j] >= 0\x00assertion failed: ebits[j] >= 0\x00assertion failed: C*ebits[j]<<BITRES == bits[j]\x00../celt/vq.c\x00assertion failed: K>0\nalg_quant() needs at least one pulse\x00assertion failed: N>1\nalg_quant() needs at least two dimensions\x00assertion failed: K>0\nalg_unquant() needs at least one pulse\x00assertion failed: N>1\nalg_unquant() needs at least two dimensions\x000\x00../celt/mini_kfft.c\x00fin != fout\x00(nfft & 1) == 0\x00!st->substate->inverse\x00../silk/CNG.c\x00assertion failed: psDec->LPC_order == 10 || psDec->LPC_order == 16\x00../silk/decode_core.c\x00assertion failed: start_idx > 0\x00../silk/decode_frame.c\x00assertion failed: L > 0 && L <= MAX_FRAME_LENGTH\x00assertion failed: psDec->ltp_mem_length >= psDec->frame_length\x00assertion failed: psDec->prevSignalType >= 0 && psDec->prevSignalType <= 2\x00assertion failed: psDec->psNLSF_CB->order == psDec->LPC_order\x00../silk/decode_indices.c\x00assertion failed: frame_length == 12 * 10\x00../silk/decode_pulses.c\x00assertion failed: fs_kHz == 8 || fs_kHz == 12 || fs_kHz == 16\x00../silk/decoder_set_fs.c\x00assertion failed: psDec->nb_subfr == MAX_NB_SUBFR || psDec->nb_subfr == MAX_NB_SUBFR/2\x00assertion failed: psDec->frame_length > 0 && psDec->frame_length <= MAX_FRAME_LENGTH\x00assertion failed: decControl->nChannelsInternal == 1 || decControl->nChannelsInternal == 2\x00../silk/dec_API.c\x00../silk/enc_API.c\x00assertion failed: encControl->nChannelsAPI >= encControl->nChannelsInternal && encControl->nChannelsAPI >= psEnc->nChannelsInternal\x00assertion failed: !ret\x00assertion failed: encControl->nChannelsInternal == 1 || psEnc->state_Fxx[ 0 ].sCmn.fs_kHz == psEnc->state_Fxx[ 1 ].sCmn.fs_kHz\x00assertion failed: encControl->nChannelsAPI == 1 && encControl->nChannelsInternal == 1\x00assertion failed: psEnc->state_Fxx[ 0 ].sCmn.inputBufIx == psEnc->state_Fxx[ 0 ].sCmn.frame_length\x00assertion failed: encControl->nChannelsInternal == 1 || psEnc->state_Fxx[ 1 ].sCmn.inputBufIx == psEnc->state_Fxx[ 1 ].sCmn.frame_length\x00assertion failed: typeOffset >= 0 && typeOffset < 6\x00../silk/encode_indices.c\x00assertion failed: encode_LBRR == 0 || typeOffset >= 2\x00assertion failed: psEncC->psNLSF_CB->order == psEncC->predictLPCOrder\x00../silk/encode_pulses.c\x00assertion failed: ifact_Q2 >= 0\x00../silk/interpolate.c\x00assertion failed: ifact_Q2 <= 4\x00../silk/NSQ.c\x00assertion failed: ( shapingLPCOrder & 1 ) == 0\x00assertion failed: lag > 0 || signalType != TYPE_VOICED\x00../silk/NSQ_del_dec.c\x00assertion failed: nStatesDelayedDecision > 0\x00../silk/PLC.c\x00assertion failed: idx > 0\x00assertion failed: psDec->LPC_order >= 10\x00assertion failed: MAX_FRAME_LENGTH >= psEncC->frame_length\x00../silk/VAD.c\x00assertion failed: psEncC->frame_length <= 512\x00assertion failed: psEncC->frame_length == 8 * silk_RSHIFT( psEncC->frame_length, 3 )\x00assertion failed: signalType >= 0 && signalType <= 2\x00../silk/NLSF_encode.c\x00assertion failed: ( LPC_order & 1 ) == 0\x00../silk/NLSF_VQ.c\x00assertion failed: psEncC->useInterpolatedNLSFs == 1 || psEncC->indices.NLSFInterpCoef_Q2 == ( 1 << 2 )\x00../silk/process_NLSFs.c\x00assertion failed: NLSF_mu_Q20 > 0\x00assertion failed: psEncC->predictLPCOrder <= MAX_LPC_ORDER\x00../silk/stereo_LR_to_MS.c\x00assertion failed: encControl != NULL\x00../silk/check_control_input.c\x00../silk/control_codec.c\x00assertion failed: psEnc->sCmn.nb_subfr == 2 || psEnc->sCmn.nb_subfr == 4\x00assertion failed: ( psEnc->sCmn.subfr_length * psEnc->sCmn.nb_subfr ) == psEnc->sCmn.frame_length\x00assertion failed: Complexity >= 0 && Complexity <= 10\x00assertion failed: psEncC->pitchEstimationLPCOrder <= MAX_FIND_PITCH_LPC_ORDER\x00assertion failed: psEncC->shapingLPCOrder <= MAX_SHAPE_LPC_ORDER\x00assertion failed: psEncC->nStatesDelayedDecision <= MAX_DEL_DEC_STATES\x00assertion failed: psEncC->warping_Q16 <= 32767\x00assertion failed: psEncC->la_shape <= LA_SHAPE_MAX\x00assertion failed: psEncC->shapeWinLength <= SHAPE_LPC_WIN_MAX\x00assertion failed: nb_subfr == PE_MAX_NB_SUBFR >> 1\x00../silk/decode_pitch.c\x00assertion failed: d >= 6\x00../silk/LPC_analysis_filter.c\x00assertion failed: (d & 1) == 0\x00assertion failed: d <= len\x00assertion failed: d==10 || d==16\x00../silk/NLSF2A.c\x00assertion failed: D > 0\x00../silk/NLSF_VQ_weights_laroia.c\x00assertion failed: ( D & 1 ) == 0\x00../silk/resampler.c\x00assertion failed: inLen >= S->Fs_in_kHz\x00assertion failed: S->inputDelay <= S->Fs_in_kHz\x00../silk/resampler_down2_3.c\x00assertion failed: silk_resampler_down2_0 > 0\x00../silk/resampler_down2.c\x00assertion failed: silk_resampler_down2_1 < 0\x00../silk/resampler_private_down_FIR.c\x00../silk/resampler_private_IIR_FIR.c\x00assertion failed: K > 0\x00../silk/sort.c\x00assertion failed: L > 0\x00assertion failed: L >= K\x00assertion failed: n < 25\x00../silk/stereo_encode_pred.c\x00assertion failed: ix[ n ][ 0 ] < 3\x00assertion failed: ix[ n ][ 1 ] < STEREO_QUANT_SUB_STEPS\x00assertion failed: win_type == 1 || win_type == 2\x00../silk/float/apply_sine_window_FLP.c\x00assertion failed: ( length & 3 ) == 0\x00../silk/float/encode_frame_FLP.c\x00assertion failed: sRangeEnc_copy2.offs <= 1275\x00assertion failed: psRangeEnc->offs <= 1275\x00assertion failed: psEncC->indices.NLSFInterpCoef_Q2 == 4 || ( psEncC->useInterpolatedNLSFs && !psEncC->first_frame_after_reset && psEncC->nb_subfr == MAX_NB_SUBFR )\x00../silk/float/find_LPC_FLP.c\x00assertion failed: buf_len >= psEnc->sCmn.pitch_LPC_win_length\x00../silk/float/find_pitch_lags_FLP.c\x00assertion failed: psEnc->sCmn.ltp_mem_length - psEnc->sCmn.predictLPCOrder >= psEncCtrl->pitchL[ 0 ] + LTP_ORDER / 2\x00../silk/float/find_pred_coefs_FLP.c\x00assertion failed: Order <= length\x00../silk/float/LPC_analysis_filter_FLP.c\x00assertion failed: D >= 0\x00../silk/float/residual_energy_FLP.c\x00assertion failed: ( order & 1 ) == 0\x00../silk/float/warped_autocorrelation_FLP.c\x00assertion failed: subfr_length * nb_subfr <= MAX_FRAME_SIZE\x00../silk/float/burg_modified_FLP.c\x00assertion failed: Fs_kHz == 8 || Fs_kHz == 12 || Fs_kHz == 16\x00../silk/float/pitch_analysis_core_FLP.c\x00assertion failed: complexity >= SILK_PE_MIN_COMPLEX\x00assertion failed: complexity <= SILK_PE_MAX_COMPLEX\x00assertion failed: Fs_kHz == 8\x00assertion failed: target_ptr >= frame_4kHz\x00assertion failed: target_ptr + sf_length_8kHz <= frame_4kHz + frame_length_4kHz\x00assertion failed: basis_ptr >= frame_4kHz\x00assertion failed: basis_ptr + sf_length_8kHz <= frame_4kHz + frame_length_4kHz\x00assertion failed: 3 * length_d_srch <= PE_D_SRCH_LENGTH\x00assertion failed: length_d_srch > 0\x00assertion failed: *lagIndex >= 0\x00assertion failed: order >= 0 && order <= SILK_MAX_ORDER_LPC\x00../silk/float/schur_FLP.c\x00../silk/float/sort_FLP.c\x00"

func alloc_trim_analysis(tls *libc.TLS, m uintptr, X uintptr, bandLogE uintptr, end int32, LM int32, C int32, N0 int32, analysis uintptr, stereo_saving uintptr, tf_estimate OpusT_opus_val16, intensity int32, surround_trim OpusT_celt_glog, equiv_rate OpusT_opus_int32, arch int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, i, i1, trim_index, v21, v30, v31 int32
	var diff, partial, partial1, xy, v3 OpusT_opus_val32
	var frac, integer, range_idx OpusT_opus_int32
	var logXC, logXC2, minXC, sum, trim, v10 OpusT_opus_val16
	var v11, v12, v5 float32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, diff, frac, i, i1, integer, logXC, logXC2, minXC, partial, partial1, range_idx, sum, trim, trim_index, xy, v10, v11, v12, v21, v3, v30, v31, v5
	diff = libc.Float32FromInt32(0)
	trim = libc.Float32FromFloat32(5)
	/* At low bitrate, reducing the trim seems to help. At higher bitrates, it's less
	   clear what's best, so we're keeping it as it was before, at least for now. */
	if equiv_rate < int32(64000) {
		trim = libc.Float32FromFloat32(4)
	} else {
		if equiv_rate < int32(80000) {
			frac = (equiv_rate - int32(64000)) >> int32(10)
			trim = libc.Float32FromFloat32(4) + float32(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(16)*float32(frac))
		}
	}
	if C == int32(2) {
		sum = libc.Float32FromInt32(0) /* Q10 */
		/* Compute inter-channel correlation for low frequencies */
		i1 = 0
		for {
			if !(i1 < int32(8)) {
				break
			}
			_ = arch
			xy = libc.Float32FromInt32(0)
			i = libc.Int32FromInt32(0)
			for {
				if !(i < (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2))))<<LM) {
					break
				}
				xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(N0+int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4)))
				goto _2
			_2:
				;
				i = i + 1
			}
			v3 = xy
			goto _4
		_4:
			partial = v3
			sum = sum + partial
			goto _1
		_1:
			;
			i1 = i1 + 1
		}
		sum = float32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(8) * sum)
		if libc.Float32FromFloat32(1) < float32(libc.Xfabs(tls, float64(sum))) {
			v5 = libc.Float32FromFloat32(1)
		} else {
			v5 = float32(libc.Xfabs(tls, float64(sum)))
		}
		sum = v5
		minXC = sum
		i1 = int32(8)
		for {
			if !(i1 < intensity) {
				break
			}
			_ = arch
			xy = libc.Float32FromInt32(0)
			i = libc.Int32FromInt32(0)
			for {
				if !(i < (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2))))<<LM) {
					break
				}
				xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(N0+int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i1)*2)))<<LM)*4 + uintptr(i)*4)))
				goto _7
			_7:
				;
				i = i + 1
			}
			v3 = xy
			goto _9
		_9:
			partial1 = v3
			if minXC < float32(libc.Xfabs(tls, float64(partial1))) {
				v10 = minXC
			} else {
				v10 = float32(libc.Xfabs(tls, float64(partial1)))
			}
			minXC = v10
			goto _6
		_6:
			;
			i1 = i1 + 1
		}
		if libc.Float32FromFloat32(1) < float32(libc.Xfabs(tls, float64(minXC))) {
			v5 = libc.Float32FromFloat32(1)
		} else {
			v5 = float32(libc.Xfabs(tls, float64(minXC)))
		}
		minXC = v5
		/*printf ("%f\n", sum);*/
		/* mid-side savings estimations based on the LF average*/
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(1.001) - OpusT_opus_val32(sum*sum)
		integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)) - int32(127)
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
		range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(20) & uint32(0x7))
		*(*float32)(unsafe.Pointer(bp)) = float32(*(*float32)(unsafe.Pointer(bp))*log2_x_norm_coeff9[range_idx]) - libc.Float32FromFloat32(1.0625)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp))*-libc.Float32FromFloat32(0.2841544449329376))))))))
		v5 = float32(integer) + *(*float32)(unsafe.Pointer(bp)) + log2_y_norm_coeff9[range_idx]
		goto _13
	_13:
		logXC = v5
		/* mid-side savings estimations based on min correlation */
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(1.001) - OpusT_opus_val32(minXC*minXC)
		integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)) - int32(127)
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
		range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(20) & uint32(0x7))
		*(*float32)(unsafe.Pointer(bp)) = float32(*(*float32)(unsafe.Pointer(bp))*log2_x_norm_coeff9[range_idx]) - libc.Float32FromFloat32(1.0625)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp))*-libc.Float32FromFloat32(0.2841544449329376))))))))
		v11 = float32(integer) + *(*float32)(unsafe.Pointer(bp)) + log2_y_norm_coeff9[range_idx]
		goto _16
	_16:
		if float32(libc.Float32FromFloat32(0.5)*logXC) > v11 {
			v5 = float32(libc.Float32FromFloat32(0.5) * logXC)
		} else {
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(1.001) - OpusT_opus_val32(minXC*minXC)
			integer = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)) - int32(127)
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))) - libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23)))
			range_idx = libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) >> libc.Int32FromInt32(20) & uint32(0x7))
			*(*float32)(unsafe.Pointer(bp)) = float32(*(*float32)(unsafe.Pointer(bp))*log2_x_norm_coeff9[range_idx]) - libc.Float32FromFloat32(1.0625)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.08746284246444702) + float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(1.3578295707702637)+float32(*(*float32)(unsafe.Pointer(bp))*(-libc.Float32FromFloat32(0.63897705078125)+float32(*(*float32)(unsafe.Pointer(bp))*(libc.Float32FromFloat32(0.4019712507724762)+float32(*(*float32)(unsafe.Pointer(bp))*-libc.Float32FromFloat32(0.2841544449329376))))))))
			v12 = float32(integer) + *(*float32)(unsafe.Pointer(bp)) + log2_y_norm_coeff9[range_idx]
			goto _18
		_18:
			v5 = v12
		}
		logXC2 = v5
		if -libc.Float32FromFloat32(4) > float32(libc.Float32FromFloat32(0.75)*logXC) {
			v5 = -libc.Float32FromFloat32(4)
		} else {
			v5 = float32(libc.Float32FromFloat32(0.75) * logXC)
		}
		trim = trim + v5
		if *(*OpusT_opus_val16)(unsafe.Pointer(stereo_saving))+libc.Float32FromFloat32(0.25) < -float32(libc.Float32FromFloat32(0.5)*logXC2) {
			v10 = *(*OpusT_opus_val16)(unsafe.Pointer(stereo_saving)) + libc.Float32FromFloat32(0.25)
		} else {
			v10 = -float32(libc.Float32FromFloat32(0.5) * logXC2)
		}
		*(*OpusT_opus_val16)(unsafe.Pointer(stereo_saving)) = v10
	}
	/* Estimate spectral tilt */
	c = 0
	for {
		i1 = 0
		for {
			if !(i1 < end-int32(1)) {
				break
			}
			diff = diff + OpusT_opus_val32(*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i1+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))*float32(libc.Int32FromInt32(2)+libc.Int32FromInt32(2)*i1-end))
			goto _23
		_23:
			;
			i1 = i1 + 1
		}
		goto _22
	_22:
		;
		c = c + 1
		v21 = c
		if !(v21 < C) {
			break
		}
	}
	diff = diff / OpusT_opus_val32(C*(end-int32(1)))
	/*printf("%f\n", diff);*/
	if libc.Float32FromFloat32(2) < (diff+libc.Float32FromFloat32(1))/libc.Float32FromInt32(6) {
		v11 = libc.Float32FromFloat32(2)
	} else {
		v11 = (diff + libc.Float32FromFloat32(1)) / libc.Float32FromInt32(6)
	}
	if -libc.Float32FromFloat32(2) > v11 {
		v5 = -libc.Float32FromFloat32(2)
	} else {
		if libc.Float32FromFloat32(2) < (diff+libc.Float32FromFloat32(1))/libc.Float32FromInt32(6) {
			v12 = libc.Float32FromFloat32(2)
		} else {
			v12 = (diff + libc.Float32FromFloat32(1)) / libc.Float32FromInt32(6)
		}
		v5 = v12
	}
	trim = trim - v5
	trim = trim - surround_trim
	trim = trim - OpusT_opus_val16(libc.Float32FromInt32(2)*tf_estimate)
	if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fvalid != 0 {
		if libc.Float32FromFloat32(2) < float32(libc.Float32FromFloat32(2)*((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality_slope+libc.Float32FromFloat32(0.05))) {
			v11 = libc.Float32FromFloat32(2)
		} else {
			v11 = float32(libc.Float32FromFloat32(2) * ((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality_slope + libc.Float32FromFloat32(0.05)))
		}
		if -libc.Float32FromFloat32(2) > v11 {
			v5 = -libc.Float32FromFloat32(2)
		} else {
			if libc.Float32FromFloat32(2) < float32(libc.Float32FromFloat32(2)*((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality_slope+libc.Float32FromFloat32(0.05))) {
				v12 = libc.Float32FromFloat32(2)
			} else {
				v12 = float32(libc.Float32FromFloat32(2) * ((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality_slope + libc.Float32FromFloat32(0.05)))
			}
			v5 = v12
		}
		trim = trim - v5
	}
	trim_index = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+trim)))
	if int32(10) < trim_index {
		v30 = int32(10)
	} else {
		v30 = trim_index
	}
	if 0 > v30 {
		v21 = 0
	} else {
		if int32(10) < trim_index {
			v31 = int32(10)
		} else {
			v31 = trim_index
		}
		v21 = v31
	}
	trim_index = v21
	/*printf("%d\n", trim_index);*/
	return trim_index
}

func ambisonics_rate_allocation(tls *libc.TLS, st uintptr, rate uintptr, frame_size int32, Fs OpusT_opus_int32) {
	var i, nb_channels int32
	var per_stream_rate, total_rate OpusT_opus_int32
	_, _, _, _ = i, nb_channels, per_stream_rate, total_rate
	nb_channels = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams + (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps == -int32(1000) {
		total_rate = ((*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams+(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams)*(Fs+int32(60)*Fs/frame_size) + (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams*libc.Int32FromInt32(15000)
	} else {
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps == -int32(1) {
			total_rate = nb_channels * int32(750000)
		} else {
			total_rate = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps
		}
	}
	/* Allocate equal number of bits to Ambisonic (uncoupled) and non-diegetic
	 * (coupled) streams */
	per_stream_rate = total_rate / (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams
	i = 0
	for {
		if !(i < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i)*4)) = per_stream_rate
		goto _1
	_1:
		;
		i = i + 1
	}
}

func channel_pos(tls *libc.TLS, channels int32, pos uintptr) {
	/* Position in the mix: 0 don't mix, 1: left, 2: center, 3:right */
	if channels == int32(4) {
		*(*int32)(unsafe.Pointer(pos)) = int32(1)
		*(*int32)(unsafe.Pointer(pos + 1*4)) = int32(3)
		*(*int32)(unsafe.Pointer(pos + 2*4)) = int32(1)
		*(*int32)(unsafe.Pointer(pos + 3*4)) = int32(3)
	} else {
		if channels == int32(3) || channels == int32(5) || channels == int32(6) {
			*(*int32)(unsafe.Pointer(pos)) = int32(1)
			*(*int32)(unsafe.Pointer(pos + 1*4)) = int32(2)
			*(*int32)(unsafe.Pointer(pos + 2*4)) = int32(3)
			*(*int32)(unsafe.Pointer(pos + 3*4)) = int32(1)
			*(*int32)(unsafe.Pointer(pos + 4*4)) = int32(3)
			*(*int32)(unsafe.Pointer(pos + 5*4)) = 0
		} else {
			if channels == int32(7) {
				*(*int32)(unsafe.Pointer(pos)) = int32(1)
				*(*int32)(unsafe.Pointer(pos + 1*4)) = int32(2)
				*(*int32)(unsafe.Pointer(pos + 2*4)) = int32(3)
				*(*int32)(unsafe.Pointer(pos + 3*4)) = int32(1)
				*(*int32)(unsafe.Pointer(pos + 4*4)) = int32(3)
				*(*int32)(unsafe.Pointer(pos + 5*4)) = int32(2)
				*(*int32)(unsafe.Pointer(pos + 6*4)) = 0
			} else {
				if channels == int32(8) {
					*(*int32)(unsafe.Pointer(pos)) = int32(1)
					*(*int32)(unsafe.Pointer(pos + 1*4)) = int32(2)
					*(*int32)(unsafe.Pointer(pos + 2*4)) = int32(3)
					*(*int32)(unsafe.Pointer(pos + 3*4)) = int32(1)
					*(*int32)(unsafe.Pointer(pos + 4*4)) = int32(3)
					*(*int32)(unsafe.Pointer(pos + 5*4)) = int32(1)
					*(*int32)(unsafe.Pointer(pos + 6*4)) = int32(3)
					*(*int32)(unsafe.Pointer(pos + 7*4)) = 0
				}
			}
		}
	}
}

// C documentation
//
//	/* Computes a rough approximation of log2(2^a + 2^b) */

func comb_filter_const_c(tls *libc.TLS, y uintptr, x uintptr, T int32, N int32, g10 OpusT_celt_coef, g11 OpusT_celt_coef, g12 OpusT_celt_coef) {
	var i int32
	var x0, x1, x2, x3, x4 OpusT_opus_val32
	_, _, _, _, _, _ = i, x0, x1, x2, x3, x4
	x4 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T-int32(2))*4))
	x3 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T-int32(1))*4))
	x2 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T)*4))
	x1 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(-T+int32(1))*4))
	i = 0
	for {
		if !(i < N) {
			break
		}
		x0 = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i-T+int32(2))*4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(x + uintptr(i)*4)) + OpusT_celt_coef(g10*x2) + OpusT_celt_coef(g11*(x1+x3)) + OpusT_celt_coef(g12*(x0+x4))
		*(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(y + uintptr(i)*4))
		x4 = x3
		x3 = x2
		x2 = x1
		x1 = x0
		goto _1
	_1:
		;
		i = i + 1
	}
}

func combine_and_check(tls *libc.TLS, pulses_comb uintptr, pulses_in uintptr, max_pulses int32, len1 int32) (r int32) {
	var k, sum int32
	_, _ = k, sum
	k = 0
	for {
		if !(k < len1) {
			break
		}
		sum = *(*int32)(unsafe.Pointer(pulses_in + uintptr(int32(2)*k)*4)) + *(*int32)(unsafe.Pointer(pulses_in + uintptr(int32(2)*k+int32(1))*4))
		if sum > max_pulses {
			return int32(1)
		}
		*(*int32)(unsafe.Pointer(pulses_comb + uintptr(k)*4)) = sum
		goto _1
	_1:
		;
		k = k + 1
	}
	return 0
}

// C documentation
//
//	/* Encode quantization indices of excitation */

func combine_pulses(tls *libc.TLS, out uintptr, in uintptr, len1 int32) {
	var k int32
	_ = k
	k = 0
	for {
		if !(k < len1) {
			break
		}
		*(*int32)(unsafe.Pointer(out + uintptr(k)*4)) = *(*int32)(unsafe.Pointer(in + uintptr(int32(2)*k)*4)) + *(*int32)(unsafe.Pointer(in + uintptr(int32(2)*k+int32(1))*4))
		goto _1
	_1:
		;
		k = k + 1
	}
}

func compute_channel_weights(tls *libc.TLS, Ex OpusT_celt_ener, Ey OpusT_celt_ener, w uintptr) {
	var minE, v1 OpusT_celt_ener
	_, _ = minE, v1
	if Ex < Ey {
		v1 = Ex
	} else {
		v1 = Ey
	}
	minE = v1
	/* Adjustment to make the weights a bit more conservative. */
	Ex = Ex + minE/libc.Float32FromInt32(3)
	Ey = Ey + minE/libc.Float32FromInt32(3)
	*(*OpusT_opus_val16)(unsafe.Pointer(w)) = Ex
	*(*OpusT_opus_val16)(unsafe.Pointer(w + 1*4)) = Ey
}

func compute_equiv_rate(tls *libc.TLS, bitrate OpusT_opus_int32, channels int32, frame_rate int32, vbr int32, mode int32, complexity int32, loss int32) (r OpusT_opus_int32) {
	var equiv OpusT_opus_int32
	_ = equiv
	equiv = bitrate
	/* Take into account overhead from smaller frames. */
	if frame_rate > int32(50) {
		equiv = equiv - (int32(40)*channels+int32(20))*(frame_rate-int32(50))
	}
	/* CBR is about a 8% penalty for both SILK and CELT. */
	if !(vbr != 0) {
		equiv = equiv - equiv/int32(12)
	}
	/* Complexity makes about 10% difference (from 0 to 10) in general. */
	equiv = equiv * (int32(90) + complexity) / int32(100)
	if mode == int32(MODE_SILK_ONLY) || mode == int32(MODE_HYBRID) {
		/* SILK complexity 0-1 uses the non-delayed-decision NSQ, which
		   costs about 20%. */
		if complexity < int32(2) {
			equiv = equiv * int32(4) / int32(5)
		}
		equiv = equiv - equiv*loss/(int32(6)*loss+int32(10))
	} else {
		if mode == int32(MODE_CELT_ONLY) {
			/* CELT complexity 0-4 doesn't have the pitch filter, which costs
			   about 10%. */
			if complexity < int32(5) {
				equiv = equiv * int32(9) / int32(10)
			}
		} else {
			/* Mode not known yet */
			/* Half the SILK loss*/
			equiv = equiv - equiv*loss/(int32(12)*loss+int32(20))
		}
	}
	return equiv
}

func compute_frame_energy(tls *libc.TLS, pcm uintptr, frame_size int32, channels int32, arch int32) (r OpusT_opus_val32) {
	var i, len1 int32
	var xy, v2 OpusT_opus_val32
	_, _, _, _ = i, len1, xy, v2
	len1 = frame_size * channels
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < len1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(pcm + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(pcm + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	v2 = xy
	goto _3
_3:
	return v2 / float32(len1)
}

// C documentation
//
//	/* Decides if DTX should be turned on (=1) or off (=0) */

func compute_mdcts(tls *libc.TLS, mode uintptr, shortBlocks int32, in uintptr, out uintptr, C int32, CC int32, LM int32, upsample int32, arch int32) {
	var B, N, b, bound, c, i, overlap, shift, v1 int32
	_, _, _, _, _, _, _, _, _ = B, N, b, bound, c, i, overlap, shift, v1
	overlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	if shortBlocks != 0 {
		B = shortBlocks
		N = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize
		shift = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM
	} else {
		B = int32(1)
		N = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize << LM
		shift = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FmaxLM - LM
	}
	c = 0
	for {
		b = 0
		for {
			if !(b < B) {
				break
			}
			/* Interleaving the sub-frames while doing the MDCTs */
			Opus_clt_mdct_forward_c(tls, mode+80, in+uintptr(c*(B*N+overlap))*4+uintptr(b*N)*4, out+uintptr(b+c*N*B)*4, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, shift, B, arch)
			goto _3
		_3:
			;
			b = b + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < CC) {
			break
		}
	}
	if CC == int32(2) && C == int32(1) {
		i = 0
		for {
			if !(i < B*N) {
				break
			}
			*(*OpusT_celt_sig)(unsafe.Pointer(out + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(out + uintptr(i)*4))) + float32(libc.Float32FromFloat32(0.5)**(*OpusT_celt_sig)(unsafe.Pointer(out + uintptr(B*N+i)*4)))
			goto _4
		_4:
			;
			i = i + 1
		}
	}
	if upsample != int32(1) {
		c = 0
		for {
			bound = B * N / upsample
			i = 0
			for {
				if !(i < bound) {
					break
				}
				*(*OpusT_celt_sig)(unsafe.Pointer(out + uintptr(c*B*N+i)*4)) *= float32(upsample)
				goto _7
			_7:
				;
				i = i + 1
			}
			libc.Xmemset(tls, out+uintptr(c*B*N+bound)*4, 0, libc.Uint64FromInt32(B*N-bound)*uint64(4))
			goto _6
		_6:
			;
			c = c + 1
			v1 = c
			if !(v1 < C) {
				break
			}
		}
	}
}

func compute_pitch_gain(tls *libc.TLS, xy OpusT_opus_val32, xx OpusT_opus_val32, yy OpusT_opus_val32) (r OpusT_opus_val16) {
	return xy / float32(libc.Xsqrt(tls, float64(libc.Float32FromInt32(1)+OpusT_opus_val32(xx*yy))))
}

var second_check = [16]int32{
	2:  int32(3),
	3:  int32(2),
	4:  int32(3),
	5:  int32(2),
	6:  int32(5),
	7:  int32(2),
	8:  int32(3),
	9:  int32(2),
	10: int32(3),
	11: int32(2),
	12: int32(5),
	13: int32(2),
	14: int32(3),
	15: int32(2),
}

func compute_qn(tls *libc.TLS, N int32, b int32, offset int32, pulse_cap int32, stereo int32) (r int32) {
	var N2, qb, qn, v4 int32
	var v1, v2 OpusT_opus_int32
	_, _, _, _, _, _ = N2, qb, qn, v1, v2, v4
	N2 = int32(2)*N - int32(1)
	if stereo != 0 && N == int32(2) {
		N2 = N2 - 1
	}
	/* The upper limit ensures that in a stereo split with itheta==16384, we'll
	   always have enough bits left over to code at least one pulse in the
	   side; otherwise it would collapse, since it doesn't get folded. */
	v1 = N2
	_ = v1 > libc.Int32FromInt32(0)
	v2 = (b + N2*offset) / v1
	goto _3
_3:
	qb = v2
	if b-pulse_cap-libc.Int32FromInt32(4)<<libc.Int32FromInt32(BITRES) < qb {
		v4 = b - pulse_cap - libc.Int32FromInt32(4)<<libc.Int32FromInt32(BITRES)
	} else {
		v4 = qb
	}
	qb = v4
	if libc.Int32FromInt32(8)<<libc.Int32FromInt32(BITRES) < qb {
		v4 = libc.Int32FromInt32(8) << libc.Int32FromInt32(BITRES)
	} else {
		v4 = qb
	}
	qb = v4
	if qb < libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)>>libc.Int32FromInt32(1) {
		qn = int32(1)
	} else {
		qn = int32(exp2_table8[qb&int32(0x7)]) >> (int32(14) - qb>>int32(BITRES))
		qn = (qn + int32(1)) >> int32(1) << int32(1)
	}
	if !(qn <= libc.Int32FromInt32(256)) {
		Opus_celt_fatal(tls, __ccgo_ts+3781, __ccgo_ts+3661, int32(660))
	}
	return qn
}

var exp2_table8 = [8]OpusT_opus_int16{
	0: int16(16384),
	1: int16(17866),
	2: int16(19483),
	3: int16(21247),
	4: int16(23170),
	5: int16(25267),
	6: int16(27554),
	7: int16(30048),
}

type band_ctx = struct {
	Fencode            int32
	Fresynth           int32
	Fm                 uintptr
	Fi                 int32
	Fintensity         int32
	Fspread            int32
	Ftf_change         int32
	Fec                uintptr
	Fremaining_bits    OpusT_opus_int32
	FbandE             uintptr
	Fseed              OpusT_opus_uint32
	Farch              int32
	Ftheta_round       int32
	Fdisable_inv       int32
	Favoid_split_noise int32
}

type split_ctx = struct {
	Finv    int32
	Fimid   int32
	Fiside  int32
	Fdelta  int32
	Fitheta int32
	Fqalloc int32
}

func compute_redundancy_bytes(tls *libc.TLS, max_data_bytes OpusT_opus_int32, bitrate_bps OpusT_opus_int32, frame_rate int32, channels int32) (r int32) {
	var available_bits, redundancy_rate OpusT_opus_int32
	var base_bits, redundancy_bytes, redundancy_bytes_cap, v1 int32
	_, _, _, _, _, _ = available_bits, base_bits, redundancy_bytes, redundancy_bytes_cap, redundancy_rate, v1
	base_bits = int32(40)*channels + int32(20)
	/* Equivalent rate for 5 ms frames. */
	redundancy_rate = bitrate_bps + base_bits*(int32(200)-frame_rate)
	/* For VBR, further increase the bitrate if we can afford it. It's pretty short
	   and we'll avoid artefacts. */
	redundancy_rate = int32(3) * redundancy_rate / int32(2)
	redundancy_bytes = redundancy_rate / int32(1600)
	/* Compute the max rate we can use given CBR or VBR with cap. */
	available_bits = max_data_bytes*int32(8) - int32(2)*base_bits
	redundancy_bytes_cap = (available_bits*int32(240)/(int32(240)+int32(48000)/frame_rate) + base_bits) / int32(8)
	if redundancy_bytes < redundancy_bytes_cap {
		v1 = redundancy_bytes
	} else {
		v1 = redundancy_bytes_cap
	}
	redundancy_bytes = v1
	/* It we can't get enough bits for redundancy to be worth it, rely on the decoder PLC. */
	if redundancy_bytes > int32(4)+int32(8)*channels {
		if int32(257) < redundancy_bytes {
			v1 = int32(257)
		} else {
			v1 = redundancy_bytes
		}
		redundancy_bytes = v1
	} else {
		redundancy_bytes = 0
	}
	return redundancy_bytes
}

type OpusT___ccgo_fp__Xopus_encode_native_11 = func(*libc.TLS, uintptr, uintptr, int32, int32, int32, int32, int32)

func compute_theta(tls *libc.TLS, ctx uintptr, sctx uintptr, X uintptr, Y uintptr, N int32, b uintptr, B int32, B0 int32, LM int32, stereo int32, fill uintptr) {
	var bandE, ec, m uintptr
	var bias, delta, down, encode, fl, fl1, fm, fs, fs1, ft, ft1, i, imid, intensity, inv, iside, itheta, itheta_q30, j, offset, p0, pulse_cap, qalloc, qn, unquantized, x, x0, v1, v5, v6, v7 int32
	var tell OpusT_opus_int32
	var v2, v3 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bandE, bias, delta, down, ec, encode, fl, fl1, fm, fs, fs1, ft, ft1, i, imid, intensity, inv, iside, itheta, itheta_q30, j, m, offset, p0, pulse_cap, qalloc, qn, tell, unquantized, x, x0, v1, v2, v3, v5, v6, v7
	itheta = 0
	itheta_q30 = 0
	inv = 0
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	m = (*band_ctx)(unsafe.Pointer(ctx)).Fm
	i = (*band_ctx)(unsafe.Pointer(ctx)).Fi
	intensity = (*band_ctx)(unsafe.Pointer(ctx)).Fintensity
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	bandE = (*band_ctx)(unsafe.Pointer(ctx)).FbandE
	/* Decide on the resolution to give to the split parameter theta */
	pulse_cap = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FlogN + uintptr(i)*2))) + LM*(libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES))
	if stereo != 0 && N == int32(2) {
		v1 = int32(QTHETA_OFFSET_TWOPHASE)
	} else {
		v1 = int32(QTHETA_OFFSET)
	}
	offset = pulse_cap>>int32(1) - v1
	qn = compute_qn(tls, N, *(*int32)(unsafe.Pointer(b)), offset, pulse_cap, stereo)
	if stereo != 0 && i >= intensity {
		qn = int32(1)
	}
	if encode != 0 {
		/* theta is the atan() of the ratio between the (normalized)
		   side and mid. With just that parameter, we can re-scale both
		   mid and side because we know that 1) they have unit norm and
		   2) they are orthogonal. */
		itheta_q30 = Opus_stereo_itheta(tls, X, Y, stereo, N, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
		itheta = itheta_q30 >> int32(16)
	}
	tell = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec))
	if qn != int32(1) {
		if encode != 0 {
			if !(stereo != 0) || (*band_ctx)(unsafe.Pointer(ctx)).Ftheta_round == 0 {
				itheta = (itheta*qn + int32(8192)) >> int32(14)
				if !(stereo != 0) && (*band_ctx)(unsafe.Pointer(ctx)).Favoid_split_noise != 0 && itheta > 0 && itheta < qn {
					v2 = libc.Uint32FromInt32(qn)
					_ = v2 > libc.Uint32FromInt32(0)
					v3 = libc.Uint32FromInt32(itheta*int32(16384)) / v2
					goto _4
				_4:
					/* Check if the selected value of theta will cause the bit allocation
					   to inject noise on one side. If so, make sure the energy of that side
					   is zero. */
					unquantized = libc.Int32FromUint32(v3)
					imid = int32(Opus_bitexact_cos(tls, int16(unquantized)))
					iside = int32(Opus_bitexact_cos(tls, int16(libc.Int32FromInt32(16384)-unquantized)))
					delta = (int32(16384) + int32(int16((N-libc.Int32FromInt32(1))<<libc.Int32FromInt32(7)))*int32(int16(Opus_bitexact_log2tan(tls, iside, imid)))) >> int32(15)
					if delta > *(*int32)(unsafe.Pointer(b)) {
						itheta = qn
					} else {
						if delta < -*(*int32)(unsafe.Pointer(b)) {
							itheta = 0
						}
					}
				}
			} else {
				if itheta > int32(8192) {
					v1 = int32(32767) / qn
				} else {
					v1 = -int32(32767) / qn
				}
				/* Bias quantization towards itheta=0 and itheta=16384. */
				bias = v1
				if 0 > (itheta*qn+bias)>>int32(14) {
					v6 = 0
				} else {
					v6 = (itheta*qn + bias) >> int32(14)
				}
				if qn-int32(1) < v6 {
					v5 = qn - int32(1)
				} else {
					if 0 > (itheta*qn+bias)>>int32(14) {
						v7 = 0
					} else {
						v7 = (itheta*qn + bias) >> int32(14)
					}
					v5 = v7
				}
				down = v5
				if (*band_ctx)(unsafe.Pointer(ctx)).Ftheta_round < 0 {
					itheta = down
				} else {
					itheta = down + int32(1)
				}
			}
		}
		/* Entropy coding of the angle. We use a uniform pdf for the
		   time split, a step for stereo, and a triangular one for the rest. */
		if stereo != 0 && N > int32(2) {
			p0 = int32(3)
			x = itheta
			x0 = qn / int32(2)
			ft = p0*(x0+int32(1)) + x0
			/* Use a probability of p0 up to itheta=8192 and then use 1 after */
			if encode != 0 {
				if x <= x0 {
					v1 = p0 * x
				} else {
					v1 = x - int32(1) - x0 + (x0+int32(1))*p0
				}
				if x <= x0 {
					v5 = p0 * (x + int32(1))
				} else {
					v5 = x - x0 + (x0+int32(1))*p0
				}
				Opus_ec_encode(tls, ec, libc.Uint32FromInt32(v1), libc.Uint32FromInt32(v5), libc.Uint32FromInt32(ft))
			} else {
				fs = libc.Int32FromUint32(Opus_ec_decode(tls, ec, libc.Uint32FromInt32(ft)))
				if fs < (x0+int32(1))*p0 {
					x = fs / p0
				} else {
					x = x0 + int32(1) + (fs - (x0+int32(1))*p0)
				}
				if x <= x0 {
					v1 = p0 * x
				} else {
					v1 = x - int32(1) - x0 + (x0+int32(1))*p0
				}
				if x <= x0 {
					v5 = p0 * (x + int32(1))
				} else {
					v5 = x - x0 + (x0+int32(1))*p0
				}
				Opus_ec_dec_update(tls, ec, libc.Uint32FromInt32(v1), libc.Uint32FromInt32(v5), libc.Uint32FromInt32(ft))
				itheta = x
			}
		} else {
			if B0 > int32(1) || stereo != 0 {
				/* Uniform pdf */
				if encode != 0 {
					Opus_ec_enc_uint(tls, ec, libc.Uint32FromInt32(itheta), libc.Uint32FromInt32(qn+int32(1)))
				} else {
					itheta = libc.Int32FromUint32(Opus_ec_dec_uint(tls, ec, libc.Uint32FromInt32(qn+int32(1))))
				}
			} else {
				fs1 = int32(1)
				ft1 = (qn>>int32(1) + int32(1)) * (qn>>int32(1) + int32(1))
				if encode != 0 {
					if itheta <= qn>>int32(1) {
						v1 = itheta + int32(1)
					} else {
						v1 = qn + int32(1) - itheta
					}
					fs1 = v1
					if itheta <= qn>>int32(1) {
						v1 = itheta * (itheta + int32(1)) >> int32(1)
					} else {
						v1 = ft1 - (qn+int32(1)-itheta)*(qn+int32(2)-itheta)>>int32(1)
					}
					fl = v1
					Opus_ec_encode(tls, ec, libc.Uint32FromInt32(fl), libc.Uint32FromInt32(fl+fs1), libc.Uint32FromInt32(ft1))
				} else {
					/* Triangular pdf */
					fl1 = 0
					fm = libc.Int32FromUint32(Opus_ec_decode(tls, ec, libc.Uint32FromInt32(ft1)))
					if fm < qn>>int32(1)*(qn>>int32(1)+int32(1))>>int32(1) {
						itheta = libc.Int32FromUint32((Opus_isqrt32(tls, uint32(8)*libc.Uint32FromInt32(fm)+uint32(1)) - uint32(1)) >> int32(1))
						fs1 = itheta + int32(1)
						fl1 = itheta * (itheta + int32(1)) >> int32(1)
					} else {
						itheta = libc.Int32FromUint32((libc.Uint32FromInt32(int32(2)*(qn+int32(1))) - Opus_isqrt32(tls, uint32(8)*libc.Uint32FromInt32(ft1-fm-libc.Int32FromInt32(1))+uint32(1))) >> int32(1))
						fs1 = qn + int32(1) - itheta
						fl1 = ft1 - (qn+int32(1)-itheta)*(qn+int32(2)-itheta)>>int32(1)
					}
					Opus_ec_dec_update(tls, ec, libc.Uint32FromInt32(fl1), libc.Uint32FromInt32(fl1+fs1), libc.Uint32FromInt32(ft1))
				}
			}
		}
		if !(itheta >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+3809, __ccgo_ts+3661, int32(840))
		}
		v2 = libc.Uint32FromInt32(qn)
		_ = v2 > libc.Uint32FromInt32(0)
		v3 = libc.Uint32FromInt32(itheta*int32(16384)) / v2
		goto _17
	_17:
		itheta = libc.Int32FromUint32(v3)
		if encode != 0 && stereo != 0 {
			if itheta == 0 {
				intensity_stereo(tls, m, X, Y, bandE, i, N)
			} else {
				stereo_split(tls, X, Y, N)
			}
		}
		/* NOTE: Renormalising X and Y *may* help fixed-point a bit at very high rate.
		   Let's do that at higher complexity */
	} else {
		if stereo != 0 {
			if encode != 0 {
				inv = libc.BoolInt32(itheta > int32(8192) && !((*band_ctx)(unsafe.Pointer(ctx)).Fdisable_inv != 0))
				if inv != 0 {
					j = 0
					for {
						if !(j < N) {
							break
						}
						*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = -*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
						goto _18
					_18:
						;
						j = j + 1
					}
				}
				intensity_stereo(tls, m, X, Y, bandE, i, N)
			}
			if *(*int32)(unsafe.Pointer(b)) > libc.Int32FromInt32(2)<<libc.Int32FromInt32(BITRES) && (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits > libc.Int32FromInt32(2)<<libc.Int32FromInt32(BITRES) {
				if encode != 0 {
					Opus_ec_enc_bit_logp(tls, ec, inv, uint32(2))
				} else {
					inv = Opus_ec_dec_bit_logp(tls, ec, uint32(2))
				}
			} else {
				inv = 0
			}
			/* inv flag override to avoid problems with downmixing. */
			if (*band_ctx)(unsafe.Pointer(ctx)).Fdisable_inv != 0 {
				inv = 0
			}
			itheta = 0
			itheta_q30 = 0
		}
	}
	qalloc = libc.Int32FromUint32(Opus_ec_tell_frac(tls, ec) - libc.Uint32FromInt32(tell))
	*(*int32)(unsafe.Pointer(b)) -= qalloc
	if itheta == 0 {
		imid = int32(32767)
		iside = 0
		*(*int32)(unsafe.Pointer(fill)) &= int32(1)<<B - int32(1)
		delta = -int32(16384)
	} else {
		if itheta == int32(16384) {
			imid = 0
			iside = int32(32767)
			*(*int32)(unsafe.Pointer(fill)) &= (int32(1)<<B - int32(1)) << B
			delta = int32(16384)
		} else {
			imid = int32(Opus_bitexact_cos(tls, int16(itheta)))
			iside = int32(Opus_bitexact_cos(tls, int16(libc.Int32FromInt32(16384)-itheta)))
			/* This is the mid vs side allocation that minimizes squared error
			   in that band. */
			delta = (int32(16384) + int32(int16((N-libc.Int32FromInt32(1))<<libc.Int32FromInt32(7)))*int32(int16(Opus_bitexact_log2tan(tls, iside, imid)))) >> int32(15)
		}
	}
	(*split_ctx)(unsafe.Pointer(sctx)).Finv = inv
	(*split_ctx)(unsafe.Pointer(sctx)).Fimid = imid
	(*split_ctx)(unsafe.Pointer(sctx)).Fiside = iside
	(*split_ctx)(unsafe.Pointer(sctx)).Fdelta = delta
	(*split_ctx)(unsafe.Pointer(sctx)).Fitheta = itheta
	(*split_ctx)(unsafe.Pointer(sctx)).Fqalloc = qalloc
}

func compute_vbr(tls *libc.TLS, mode uintptr, analysis uintptr, base_target OpusT_opus_int32, LM int32, bitrate OpusT_opus_int32, lastCodedBands int32, C int32, intensity int32, constrained_vbr int32, stereo_saving OpusT_opus_val16, tot_boost int32, tf_estimate OpusT_opus_val16, pitch_change int32, maxDepth OpusT_celt_glog, lfe int32, has_surround_mask int32, surround_masking OpusT_celt_glog, temporal_vbr OpusT_celt_glog) (r int32) {
	var amount, max_frac, tf_calibration, tvbr_factor, v4 OpusT_opus_val16
	var bins, coded_bands, coded_bins, coded_stereo_bands, coded_stereo_dof, nbEBands, v1, v2, v3 int32
	var eBands uintptr
	var floor_depth, surround_target, target, tonal_target OpusT_opus_int32
	var tonal, v6 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = amount, bins, coded_bands, coded_bins, coded_stereo_bands, coded_stereo_dof, eBands, floor_depth, max_frac, nbEBands, surround_target, target, tf_calibration, tonal, tonal_target, tvbr_factor, v1, v2, v3, v4, v6
	nbEBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FeBands
	if lastCodedBands != 0 {
		v1 = lastCodedBands
	} else {
		v1 = nbEBands
	}
	coded_bands = v1
	coded_bins = int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(coded_bands)*2))) << LM
	if C == int32(2) {
		if intensity < coded_bands {
			v1 = intensity
		} else {
			v1 = coded_bands
		}
		coded_bins = coded_bins + int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(v1)*2)))<<LM
	}
	target = base_target
	/*printf("%f %f %f %f %d %d ", st->analysis.activity, st->analysis.tonality, tf_estimate, st->stereo_saving, tot_boost, coded_bands);*/
	if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fvalid != 0 && float64((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Factivity) < float64(0.4) {
		target = target - int32(float32(float32(coded_bins<<libc.Int32FromInt32(BITRES))*(libc.Float32FromFloat32(0.4)-(*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Factivity)))
	}
	/* Stereo savings */
	if C == int32(2) {
		if intensity < coded_bands {
			v1 = intensity
		} else {
			v1 = coded_bands
		}
		coded_stereo_bands = v1
		coded_stereo_dof = int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(coded_stereo_bands)*2)))<<LM - coded_stereo_bands
		/* Maximum fraction of the bits we can save if the signal is mono. */
		max_frac = OpusT_opus_val32(libc.Float32FromFloat32(0.8)*float32(coded_stereo_dof)) / float32(coded_bins)
		if stereo_saving < libc.Float32FromFloat32(1) {
			v4 = stereo_saving
		} else {
			v4 = libc.Float32FromFloat32(1)
		}
		stereo_saving = v4
		/*printf("%d %d %d ", coded_stereo_dof, coded_bins, tot_boost);*/
		if OpusT_opus_val16(max_frac*float32(target)) < OpusT_opus_val32((stereo_saving-libc.Float32FromFloat32(0.1))*float32(coded_stereo_dof<<libc.Int32FromInt32(BITRES))) {
			v4 = OpusT_opus_val16(max_frac * float32(target))
		} else {
			v4 = OpusT_opus_val32((stereo_saving - libc.Float32FromFloat32(0.1)) * float32(coded_stereo_dof<<libc.Int32FromInt32(BITRES)))
		}
		target = target - int32(v4)
	}
	/* Boost the rate according to dynalloc (minus the dynalloc average for calibration). */
	target = target + (tot_boost - int32(19)<<LM)
	/* Apply transient boost, compensating for average boost. */
	tf_calibration = libc.Float32FromFloat32(0.044)
	target = target + int32(OpusT_opus_val16((tf_estimate-tf_calibration)*float32(target)))
	/* Apply tonality boost */
	if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fvalid != 0 && !(lfe != 0) {
		/* Tonality boost (compensating for the average). */
		if libc.Float32FromFloat32(0) > (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality-libc.Float32FromFloat32(0.15) {
			v6 = libc.Float32FromFloat32(0)
		} else {
			v6 = (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Ftonality - libc.Float32FromFloat32(0.15)
		}
		tonal = v6 - libc.Float32FromFloat32(0.12)
		tonal_target = target + int32(float32(float32(float32(coded_bins<<libc.Int32FromInt32(BITRES))*libc.Float32FromFloat32(1.2))*tonal))
		if pitch_change != 0 {
			tonal_target = tonal_target + int32(float32(float32(coded_bins<<libc.Int32FromInt32(BITRES))*libc.Float32FromFloat32(0.8)))
		}
		/*printf("%f %f ", analysis->tonality, tonal);*/
		target = tonal_target
	}
	if has_surround_mask != 0 && !(lfe != 0) {
		surround_target = target + int32(OpusT_opus_val32(surround_masking*float32(coded_bins<<libc.Int32FromInt32(BITRES))))
		/*printf("%f %d %d %d %d %d %d ", surround_masking, coded_bins, st->end, st->intensity, surround_target, target, st->bitrate);*/
		if target/int32(4) > surround_target {
			v1 = target / int32(4)
		} else {
			v1 = surround_target
		}
		target = v1
	}
	bins = int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(nbEBands-int32(2))*2))) << LM
	/*floor_depth = SHR32(MULT16_16((C*bins<<BITRES),celt_log2(SHL32(MAX16(1,sample_max),13))), DB_SHIFT);*/
	floor_depth = int32(OpusT_celt_glog(float32(C*bins<<libc.Int32FromInt32(BITRES)) * maxDepth))
	if floor_depth > target>>libc.Int32FromInt32(2) {
		v1 = floor_depth
	} else {
		v1 = target >> libc.Int32FromInt32(2)
	}
	floor_depth = v1
	if target < floor_depth {
		v1 = target
	} else {
		v1 = floor_depth
	}
	target = v1
	/*printf("%f %d\n", maxDepth, floor_depth);*/
	/* Make VBR less aggressive for constrained VBR because we can't keep a higher bitrate
	   for long. Needs tuning. */
	if (!(has_surround_mask != 0) || lfe != 0) && constrained_vbr != 0 {
		target = base_target + int32(float32(libc.Float32FromFloat32(0.67)*float32(target-base_target)))
	}
	if !(has_surround_mask != 0) && tf_estimate < libc.Float32FromFloat32(0.2) {
		if int32(32000) < int32(96000)-bitrate {
			v2 = int32(32000)
		} else {
			v2 = int32(96000) - bitrate
		}
		if 0 > v2 {
			v1 = 0
		} else {
			if int32(32000) < int32(96000)-bitrate {
				v3 = int32(32000)
			} else {
				v3 = int32(96000) - bitrate
			}
			v1 = v3
		}
		amount = float32(libc.Float32FromFloat32(3.1e-06) * float32(v1))
		tvbr_factor = OpusT_opus_val32(temporal_vbr * amount)
		target = target + int32(OpusT_opus_val16(tvbr_factor*float32(target)))
	}
	/* Don't allow more than doubling the rate */
	if int32(2)*base_target < target {
		v1 = int32(2) * base_target
	} else {
		v1 = target
	}
	target = v1
	return target
}

func cwrsi(tls *libc.TLS, _n int32, _k int32, _i OpusT_opus_uint32, _y uintptr) (r OpusT_opus_val32) {
	var k0, s, v1 int32
	var p, q OpusT_opus_uint32
	var row, v3 uintptr
	var val OpusT_opus_int16
	var yy OpusT_opus_val32
	_, _, _, _, _, _, _, _, _ = k0, p, q, row, s, val, yy, v1, v3
	yy = libc.Float32FromInt32(0)
	if !(_k > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+5321, __ccgo_ts+5306, int32(473))
	}
	if !(_n > libc.Int32FromInt32(1)) {
		Opus_celt_fatal(tls, __ccgo_ts+5344, __ccgo_ts+5306, int32(474))
	}
	for _n > int32(2) {
		/*Lots of pulses case:*/
		if _k >= _n {
			row = CELT_PVQ_U_ROW[_n]
			/*Are the pulses in this dimension negative?*/
			p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k+int32(1))*4))
			s = -libc.BoolInt32(_i >= p)
			_i = _i - p&libc.Uint32FromInt32(s)
			/*Count how many pulses were placed in this dimension.*/
			k0 = _k
			q = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_n)*4))
			if q > _i {
				_ = p > q
				_k = _n
				for cond := true; cond; cond = p > _i {
					_k = _k - 1
					v1 = _k
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(_n)*4))
				}
			} else {
				p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k)*4))
				for {
					if !(p > _i) {
						break
					}
					_k = _k - 1
					goto _2
				_2:
					;
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(row + uintptr(_k)*4))
				}
			}
			_i = _i - p
			val = int16(k0 - _k + s ^ s)
			v3 = _y
			_y += 4
			*(*int32)(unsafe.Pointer(v3)) = int32(val)
			yy = yy + OpusT_opus_val32(float32(val)*float32(val))
		} else {
			/*Are there any pulses in this dimension at all?*/
			p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[_k] + uintptr(_n)*4))
			q = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[_k+int32(1)] + uintptr(_n)*4))
			if p <= _i && _i < q {
				_i = _i - p
				v3 = _y
				_y += 4
				*(*int32)(unsafe.Pointer(v3)) = 0
			} else {
				/*Are the pulses in this dimension negative?*/
				s = -libc.BoolInt32(_i >= q)
				_i = _i - q&libc.Uint32FromInt32(s)
				/*Count how many pulses were placed in this dimension.*/
				k0 = _k
				for cond := true; cond; cond = p > _i {
					_k = _k - 1
					v1 = _k
					p = *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(_n)*4))
				}
				_i = _i - p
				val = int16(k0 - _k + s ^ s)
				v3 = _y
				_y += 4
				*(*int32)(unsafe.Pointer(v3)) = int32(val)
				yy = yy + OpusT_opus_val32(float32(val)*float32(val))
			}
		}
		_n = _n - 1
	}
	/*_n==2*/
	p = libc.Uint32FromInt32(int32(2)*_k + int32(1))
	s = -libc.BoolInt32(_i >= p)
	_i = _i - p&libc.Uint32FromInt32(s)
	k0 = _k
	_k = libc.Int32FromUint32((_i + uint32(1)) >> int32(1))
	if _k != 0 {
		_i = _i - libc.Uint32FromInt32(int32(2)*_k-int32(1))
	}
	val = int16(k0 - _k + s ^ s)
	v3 = _y
	_y += 4
	*(*int32)(unsafe.Pointer(v3)) = int32(val)
	yy = yy + OpusT_opus_val32(float32(val)*float32(val))
	/*_n==1*/
	s = -libc.Int32FromUint32(_i)
	val = int16(_k + s ^ s)
	*(*int32)(unsafe.Pointer(_y)) = int32(val)
	yy = yy + OpusT_opus_val32(float32(val)*float32(val))
	return yy
}

func dc_reject(tls *libc.TLS, in uintptr, cutoff_Hz OpusT_opus_int32, out uintptr, hp_mem uintptr, len1 int32, channels int32, Fs OpusT_opus_int32) {
	var coef, coef2, m0, m01, m2 float32
	var i int32
	var out0, out1, x, x0, x1, y OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _ = coef, coef2, i, m0, m01, m2, out0, out1, x, x0, x1, y
	coef = float32(libc.Float32FromFloat32(6.3)*float32(cutoff_Hz)) / float32(Fs)
	coef2 = libc.Float32FromInt32(1) - coef
	if channels == int32(2) {
		m0 = *(*OpusT_opus_val32)(unsafe.Pointer(hp_mem))
		m2 = *(*OpusT_opus_val32)(unsafe.Pointer(hp_mem + 2*4))
		i = 0
		for {
			if !(i < len1) {
				break
			}
			x0 = *(*OpusT_opus_val16)(unsafe.Pointer(in + uintptr(int32(2)*i+0)*4))
			x1 = *(*OpusT_opus_val16)(unsafe.Pointer(in + uintptr(int32(2)*i+int32(1))*4))
			out0 = x0 - m0
			out1 = x1 - m2
			m0 = float32(coef*x0) + libc.Float32FromFloat32(1e-30) + float32(coef2*m0)
			m2 = float32(coef*x1) + libc.Float32FromFloat32(1e-30) + float32(coef2*m2)
			*(*OpusT_opus_val16)(unsafe.Pointer(out + uintptr(int32(2)*i+0)*4)) = out0
			*(*OpusT_opus_val16)(unsafe.Pointer(out + uintptr(int32(2)*i+int32(1))*4)) = out1
			goto _1
		_1:
			;
			i = i + 1
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(hp_mem)) = m0
		*(*OpusT_opus_val32)(unsafe.Pointer(hp_mem + 2*4)) = m2
	} else {
		m01 = *(*OpusT_opus_val32)(unsafe.Pointer(hp_mem))
		i = 0
		for {
			if !(i < len1) {
				break
			}
			x = *(*OpusT_opus_val16)(unsafe.Pointer(in + uintptr(i)*4))
			y = x - m01
			m01 = float32(coef*x) + libc.Float32FromFloat32(1e-30) + float32(coef2*m01)
			*(*OpusT_opus_val16)(unsafe.Pointer(out + uintptr(i)*4)) = y
			goto _2
		_2:
			;
			i = i + 1
		}
		*(*OpusT_opus_val32)(unsafe.Pointer(hp_mem)) = m01
	}
}

func decide_dtx_mode(tls *libc.TLS, activity int32, nb_no_activity_ms_Q1 uintptr, frame_size_ms_Q1 int32) (r int32) {
	if !(activity != 0) {
		/* The number of consecutive DTX frames should be within the allowed bounds.
		   Note that the allowed bound is defined in the SILK headers and assumes 20 ms
		   frames. As this function can be called with any frame length, a conversion to
		   milliseconds is done before the comparisons. */
		*(*int32)(unsafe.Pointer(nb_no_activity_ms_Q1)) += frame_size_ms_Q1
		if *(*int32)(unsafe.Pointer(nb_no_activity_ms_Q1)) > libc.Int32FromInt32(NB_SPEECH_FRAMES_BEFORE_DTX)*libc.Int32FromInt32(20)*libc.Int32FromInt32(2) {
			if *(*int32)(unsafe.Pointer(nb_no_activity_ms_Q1)) <= (libc.Int32FromInt32(NB_SPEECH_FRAMES_BEFORE_DTX)+libc.Int32FromInt32(MAX_CONSECUTIVE_DTX))*libc.Int32FromInt32(20)*libc.Int32FromInt32(2) {
				/* Valid frame for DTX! */
				return int32(1)
			} else {
				*(*int32)(unsafe.Pointer(nb_no_activity_ms_Q1)) = libc.Int32FromInt32(NB_SPEECH_FRAMES_BEFORE_DTX) * libc.Int32FromInt32(20) * libc.Int32FromInt32(2)
			}
		}
	} else {
		*(*int32)(unsafe.Pointer(nb_no_activity_ms_Q1)) = 0
	}
	return 0
}

func decide_fec(tls *libc.TLS, useInBandFEC int32, PacketLoss_perc int32, last_fec int32, mode int32, bandwidth uintptr, rate OpusT_opus_int32) (r int32) {
	var LBRR_rate_thres_bps, hysteresis OpusT_opus_int32
	var orig_bandwidth, v2 int32
	_, _, _, _ = LBRR_rate_thres_bps, hysteresis, orig_bandwidth, v2
	if !(useInBandFEC != 0) || PacketLoss_perc == 0 || mode == int32(MODE_CELT_ONLY) {
		return 0
	}
	orig_bandwidth = *(*int32)(unsafe.Pointer(bandwidth))
	for {
		/* Compute threshold for using FEC at the current bandwidth setting */
		LBRR_rate_thres_bps = fec_thresholds[int32(2)*(*(*int32)(unsafe.Pointer(bandwidth))-int32(OPUS_BANDWIDTH_NARROWBAND))]
		hysteresis = fec_thresholds[int32(2)*(*(*int32)(unsafe.Pointer(bandwidth))-int32(OPUS_BANDWIDTH_NARROWBAND))+int32(1)]
		if last_fec == int32(1) {
			LBRR_rate_thres_bps = LBRR_rate_thres_bps - hysteresis
		}
		if last_fec == 0 {
			LBRR_rate_thres_bps = LBRR_rate_thres_bps + hysteresis
		}
		if PacketLoss_perc < int32(25) {
			v2 = PacketLoss_perc
		} else {
			v2 = int32(25)
		}
		LBRR_rate_thres_bps = int32(int64(LBRR_rate_thres_bps*(libc.Int32FromInt32(125)-v2)) * int64(int16(int32(float64(libc.Float64FromFloat64(0.01)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5)))) >> libc.Int32FromInt32(16))
		/* If loss <= 5%, we look at whether we have enough rate to enable FEC.
		   If loss > 5%, we decrease the bandwidth until we can enable FEC. */
		if rate > LBRR_rate_thres_bps {
			return int32(1)
		} else {
			if PacketLoss_perc <= int32(5) {
				return 0
			} else {
				if *(*int32)(unsafe.Pointer(bandwidth)) > int32(OPUS_BANDWIDTH_NARROWBAND) {
					*(*int32)(unsafe.Pointer(bandwidth)) = *(*int32)(unsafe.Pointer(bandwidth)) - 1
				} else {
					break
				}
			}
		}
		goto _1
	_1:
	}
	/* Couldn't find any bandwidth to enable FEC, keep original bandwidth. */
	*(*int32)(unsafe.Pointer(bandwidth)) = orig_bandwidth
	return 0
}

func decode_split(tls *libc.TLS, p_child1 uintptr, p_child2 uintptr, psRangeDec uintptr, p int32, shell_table uintptr) {
	if p > 0 {
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child1)) = int16(Opus_ec_dec_icdf(tls, psRangeDec, shell_table+uintptr(Opus_silk_shell_code_table_offsets[p]), uint32(8)))
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child2)) = int16(p - int32(*(*OpusT_opus_int16)(unsafe.Pointer(p_child1))))
	} else {
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child1)) = 0
		*(*OpusT_opus_int16)(unsafe.Pointer(p_child2)) = 0
	}
}

// C documentation
//
//	/* Shell encoder, operates on one shell code frame of 16 pulses */

func deemphasis(tls *libc.TLS, in uintptr, pcm uintptr, N int32, C int32, downsample int32, coef uintptr, mem uintptr, accum int32) {
	var Nd, apply_downsampling, c, j, v29 int32
	var _saved_stack, scratch, st, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var coef0 OpusT_opus_val16
	var m, tmp, tmp1, tmp2 OpusT_celt_sig
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = Nd, _saved_stack, apply_downsampling, c, coef0, j, m, scratch, st, tmp, tmp1, tmp2, x, y, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	apply_downsampling = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	/* Short version for common case. */
	if downsample == int32(1) && C == int32(2) && !(accum != 0) {
		deemphasis_stereo_simple(tls, in, pcm, N, *(*OpusT_opus_val16)(unsafe.Pointer(coef)), mem)
		return
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4420, int32(335))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	scratch = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	coef0 = *(*OpusT_opus_val16)(unsafe.Pointer(coef))
	Nd = N / downsample
	c = 0
	for {
		m = *(*OpusT_celt_sig)(unsafe.Pointer(mem + uintptr(c)*4))
		x = *(*uintptr)(unsafe.Pointer(in + uintptr(c)*8))
		y = pcm + uintptr(c)*4
		if downsample > int32(1) {
			/* Shortcut for the standard (non-custom modes) case */
			j = 0
			for {
				if !(j < N) {
					break
				}
				tmp = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m
				m = OpusT_opus_val16(coef0 * tmp)
				*(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j)*4)) = tmp
				goto _31
			_31:
				;
				j = j + 1
			}
			apply_downsampling = int32(1)
		} else {
			/* Shortcut for the standard (non-custom modes) case */
			if accum != 0 {
				j = 0
				for {
					if !(j < N) {
						break
					}
					tmp1 = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + m + libc.Float32FromFloat32(1e-30)
					m = OpusT_opus_val16(coef0 * tmp1)
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) + float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)*tmp1)
					goto _32
				_32:
					;
					j = j + 1
				}
			} else {
				j = 0
				for {
					if !(j < N) {
						break
					}
					tmp2 = *(*OpusT_celt_sig)(unsafe.Pointer(x + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m
					m = OpusT_opus_val16(coef0 * tmp2)
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp2)
					goto _33
				_33:
					;
					j = j + 1
				}
			}
		}
		*(*OpusT_celt_sig)(unsafe.Pointer(mem + uintptr(c)*4)) = m
		if apply_downsampling != 0 {
			/* Perform down-sampling */
			if accum != 0 {
				j = 0
				for {
					if !(j < Nd) {
						break
					}
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) + float32(libc.Float32FromInt32(1)/libc.Float32FromFloat32(32768)**(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j*downsample)*4)))
					goto _34
				_34:
					;
					j = j + 1
				}
			} else {
				j = 0
				for {
					if !(j < Nd) {
						break
					}
					*(*OpusT_opus_res)(unsafe.Pointer(y + uintptr(j*C)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * *(*OpusT_celt_sig)(unsafe.Pointer(scratch + uintptr(j*downsample)*4)))
					goto _35
				_35:
					;
					j = j + 1
				}
			}
		}
		goto _30
	_30:
		;
		c = c + 1
		v29 = c
		if !(v29 < C) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _37
	_37:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _39
_39:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func deemphasis_stereo_simple(tls *libc.TLS, in uintptr, pcm uintptr, N int32, coef0 OpusT_opus_val16, mem uintptr) {
	var j int32
	var m0, m1, tmp0, tmp1 OpusT_celt_sig
	var x0, x1 uintptr
	_, _, _, _, _, _, _ = j, m0, m1, tmp0, tmp1, x0, x1
	x0 = *(*uintptr)(unsafe.Pointer(in))
	x1 = *(*uintptr)(unsafe.Pointer(in + 1*8))
	m0 = *(*OpusT_celt_sig)(unsafe.Pointer(mem))
	m1 = *(*OpusT_celt_sig)(unsafe.Pointer(mem + 1*4))
	j = 0
	for {
		if !(j < N) {
			break
		}
		/* Add VERY_SMALL to x[] first to reduce dependency chain. */
		tmp0 = *(*OpusT_celt_sig)(unsafe.Pointer(x0 + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m0
		tmp1 = *(*OpusT_celt_sig)(unsafe.Pointer(x1 + uintptr(j)*4)) + libc.Float32FromFloat32(1e-30) + m1
		m0 = OpusT_opus_val16(coef0 * tmp0)
		m1 = OpusT_opus_val16(coef0 * tmp1)
		*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*j)*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp0)
		*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(int32(2)*j+int32(1))*4)) = float32(libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768) * tmp1)
		goto _1
	_1:
		;
		j = j + 1
	}
	*(*OpusT_celt_sig)(unsafe.Pointer(mem)) = m0
	*(*OpusT_celt_sig)(unsafe.Pointer(mem + 1*4)) = m1
}

func deinterleave_hadamard(tls *libc.TLS, X uintptr, N0 int32, stride int32, hadamard int32) {
	var N, i, j int32
	var _saved_stack, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, _saved_stack, i, j, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	N = N0 * stride
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(581))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if !(stride > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+3754, __ccgo_ts+3661, int32(582))
	}
	if hadamard != 0 {
		ordery = uintptr(unsafe.Pointer(&ordery_table)) + uintptr(stride)*4 - uintptr(2)*4
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(*(*int32)(unsafe.Pointer(ordery + uintptr(i)*4))*N0+j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j*stride+i)*4))
				goto _30
			_30:
				;
				j = j + 1
			}
			goto _29
		_29:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(i*N0+j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j*stride+i)*4))
				goto _32
			_32:
				;
				j = j + 1
			}
			goto _31
		_31:
			;
			i = i + 1
		}
	}
	libc.Xmemcpy(tls, X, tmp, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(tmp))/4)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func downmix_and_resample(tls *libc.TLS, __ccgo_fp_downmix OpusT_downmix_func, _x uintptr, y uintptr, S uintptr, subframe int32, offset int32, c1 int32, c2 int32, C int32, Fs int32) (r OpusT_opus_val32) {
	var _saved_stack, st, tmp, tmp3x, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var j int32
	var ret OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, j, ret, st, tmp, tmp3x, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	ret = libc.Float32FromInt32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if subframe == 0 {
		return libc.Float32FromInt32(0)
	}
	if Fs == int32(48000) {
		subframe = subframe * int32(2)
		offset = offset * int32(2)
	} else {
		if Fs == int32(16000) {
			subframe = subframe * int32(2) / int32(3)
			offset = offset * int32(2) / int32(3)
		} else {
			if Fs != int32(24000) {
				if !(libc.Int32FromInt32(0) != 0) {
					Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+3568, int32(181))
				}
			}
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(subframe)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(182))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(subframe) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(subframe)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	(*(*func(*libc.TLS, uintptr, uintptr, int32, int32, int32, int32, int32))(unsafe.Pointer(&struct{ uintptr }{__ccgo_fp_downmix})))(tls, _x, tmp, subframe, offset, c1, c2, C)
	if c2 == -int32(2) && C == int32(2) || c2 > -int32(1) {
		j = 0
		for {
			if !(j < subframe) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(tmp + uintptr(j)*4)) = float32(libc.Float32FromFloat32(0.5) * *(*OpusT_opus_val32)(unsafe.Pointer(tmp + uintptr(j)*4)))
			goto _29
		_29:
			;
			j = j + 1
		}
	}
	if Fs == int32(48000) {
		ret = silk_resampler_down2_hp(tls, S, y, tmp, subframe)
	} else {
		if Fs == int32(24000) {
			libc.Xmemcpy(tls, y, tmp, libc.Uint64FromInt32(subframe)*uint64(4)+libc.Uint64FromInt64(0*((int64(y)-int64(tmp))/4)))
		} else {
			if Fs == int32(16000) {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _31
				_31:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _33
			_33:
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v5 = libc.Xmalloc(tls, uint64(16))
					goto _35
				_35:
					st = v5
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v7 = st
				goto _37
			_37:
				*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v9 = libc.Xmalloc(tls, uint64(16))
					goto _39
				_39:
					st = v9
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v11 = st
				goto _41
			_41:
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v13 = libc.Xmalloc(tls, uint64(16))
					goto _43
				_43:
					st = v13
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v15 = st
				goto _45
			_45:
				if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(3)*subframe)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
					Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(197))
				}
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v17 = libc.Xmalloc(tls, uint64(16))
					goto _47
				_47:
					st = v17
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v19 = st
				goto _49
			_49:
				*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(3)*subframe) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v21 = libc.Xmalloc(tls, uint64(16))
					goto _51
				_51:
					st = v21
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v23 = st
				goto _53
			_53:
				tmp3x = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(3)*subframe)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
				/* Don't do this at home! This resampler is horrible and it's only (barely)
				   usable for the purpose of the analysis because we don't care about all
				   the aliasing between 8 kHz and 12 kHz. */
				j = 0
				for {
					if !(j < subframe) {
						break
					}
					*(*OpusT_opus_val32)(unsafe.Pointer(tmp3x + uintptr(int32(3)*j)*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(tmp + uintptr(j)*4))
					*(*OpusT_opus_val32)(unsafe.Pointer(tmp3x + uintptr(int32(3)*j+int32(1))*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(tmp + uintptr(j)*4))
					*(*OpusT_opus_val32)(unsafe.Pointer(tmp3x + uintptr(int32(3)*j+int32(2))*4)) = *(*OpusT_opus_val32)(unsafe.Pointer(tmp + uintptr(j)*4))
					goto _54
				_54:
					;
					j = j + 1
				}
				silk_resampler_down2_hp(tls, S, y, tmp3x, int32(3)*subframe)
			}
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _56
	_56:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _58
_58:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	ret = ret * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) / libc.Float32FromInt32(32768))
	return ret
}

func dynalloc_analysis(tls *libc.TLS, bandLogE uintptr, bandLogE2 uintptr, oldBandE uintptr, nbEBands int32, start int32, end int32, C int32, offsets uintptr, lsb_depth int32, logN uintptr, isTransient int32, vbr int32, constrained_vbr int32, eBands uintptr, LM int32, effectiveBytes int32, tot_boost_ uintptr, lfe int32, surround_dynalloc uintptr, analysis uintptr, importance uintptr, spread_weight uintptr, tone_freq OpusT_opus_val16, toneishness OpusT_opus_val32) (r OpusT_celt_glog) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, bandLogE3, f, follower, mask, noise_floor, sig, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var boost, boost_bits, c, freq_bin, i, last, shift, width, v141, v142, v78 int32
	var cap1, integer, tot_boost OpusT_opus_int32
	var frac, v174, v175 float32
	var maxDepth, offset, smr, tmp, v132, v134, v81 OpusT_celt_glog
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, bandLogE3, boost, boost_bits, c, cap1, f, follower, frac, freq_bin, i, integer, last, mask, maxDepth, noise_floor, offset, shift, sig, smr, st, tmp, tot_boost, width, v1, v11, v13, v132, v134, v141, v142, v15, v17, v174, v175, v19, v21, v23, v3, v5, v7, v78, v81, v9
	tot_boost = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1063))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(C*nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	follower = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _30
	_30:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _32
_32:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _36
_36:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _40
_40:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _42
	_42:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _44
_44:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1064))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _46
	_46:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _48
_48:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(C*nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _50
	_50:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _52
_52:
	noise_floor = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(C*nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _54
	_54:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _56
_56:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _58
	_58:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _60
_60:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _62
	_62:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _64
_64:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _66
	_66:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _68
_68:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1065))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _72
_72:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _74
	_74:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _76
_76:
	bandLogE3 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	libc.Xmemset(tls, offsets, 0, libc.Uint64FromInt32(nbEBands)*uint64(4))
	/* Dynamic allocation code */
	maxDepth = -libc.Float32FromFloat32(31.9)
	i = 0
	for {
		if !(i < end) {
			break
		}
		/* Noise floor must take into account eMeans, the depth, the width of the bands
		   and the preemphasis filter (approx. square of bark band ID) */
		*(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.0625)*float32(*(*OpusT_opus_int16)(unsafe.Pointer(logN + uintptr(i)*2)))) + libc.Float32FromFloat32(0.5) + float32(libc.Int32FromInt32(9)-lsb_depth) - Opus_eMeans[i] + float32(float32(libc.Float32FromFloat32(0.0062)*float32(i+libc.Int32FromInt32(5)))*float32(i+libc.Int32FromInt32(5)))
		goto _77
	_77:
		;
		i = i + 1
	}
	c = 0
	for {
		i = 0
		for {
			if !(i < end) {
				break
			}
			if maxDepth > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(c*nbEBands+i)*4))-*(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4)) {
				v81 = maxDepth
			} else {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(c*nbEBands+i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4))
			}
			maxDepth = v81
			goto _80
		_80:
			;
			i = i + 1
		}
		goto _79
	_79:
		;
		c = c + 1
		v78 = c
		if !(v78 < C) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _83
	_83:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _85
_85:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _87
	_87:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _89
_89:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _91
	_91:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _93
_93:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _95
	_95:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _97
_97:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1087))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _99
	_99:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _101
_101:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _103
	_103:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _105
_105:
	mask = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _107
	_107:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _109
_109:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _111
	_111:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _113
_113:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _115
	_115:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _117
_117:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _119
	_119:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _121
_121:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1088))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _123
	_123:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _125
_125:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(nbEBands) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _127
	_127:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _129
_129:
	sig = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(nbEBands)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < end) {
			break
		}
		*(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4))
		goto _130
	_130:
		;
		i = i + 1
	}
	if C == int32(2) {
		i = 0
		for {
			if !(i < end) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(nbEBands+i)*4))-*(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4)) {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4))
			} else {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(nbEBands+i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) = v81
			goto _131
		_131:
			;
			i = i + 1
		}
	}
	libc.Xmemcpy(tls, sig, mask, libc.Uint64FromInt32(end)*uint64(4)+libc.Uint64FromInt64(0*((int64(sig)-int64(mask))/4)))
	i = int32(1)
	for {
		if !(i < end) {
			break
		}
		if *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i-int32(1))*4))-libc.Float32FromFloat32(2) {
			v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4))
		} else {
			v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i-int32(1))*4)) - libc.Float32FromFloat32(2)
		}
		*(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) = v81
		goto _133
	_133:
		;
		i = i + 1
	}
	i = end - int32(2)
	for {
		if !(i >= 0) {
			break
		}
		if *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i+int32(1))*4))-libc.Float32FromFloat32(3) {
			v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4))
		} else {
			v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i+int32(1))*4)) - libc.Float32FromFloat32(3)
		}
		*(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) = v81
		goto _135
	_135:
		;
		i = i - 1
	}
	i = 0
	for {
		if !(i < end) {
			break
		}
		if float32(libc.Int32FromInt32(0)) > maxDepth-libc.Float32FromFloat32(12) {
			v132 = float32(libc.Int32FromInt32(0))
		} else {
			v132 = maxDepth - libc.Float32FromFloat32(12)
		}
		if v132 > *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4)) {
			if float32(libc.Int32FromInt32(0)) > maxDepth-libc.Float32FromFloat32(12) {
				v134 = float32(libc.Int32FromInt32(0))
			} else {
				v134 = maxDepth - libc.Float32FromFloat32(12)
			}
			v81 = v134
		} else {
			v81 = *(*OpusT_celt_glog)(unsafe.Pointer(mask + uintptr(i)*4))
		}
		/* Compute SMR: Mask is never more than 72 dB below the peak and never below the noise floor.*/
		smr = *(*OpusT_celt_glog)(unsafe.Pointer(sig + uintptr(i)*4)) - v81
		if 0 > -int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+smr))) {
			v141 = 0
		} else {
			v141 = -int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+smr)))
		}
		if int32(5) < v141 {
			v78 = int32(5)
		} else {
			if 0 > -int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+smr))) {
				v142 = 0
			} else {
				v142 = -int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+smr)))
			}
			v78 = v142
		}
		/* Clamp SMR to make sure we're not shifting by something negative or too large. */
		shift = v78
		*(*int32)(unsafe.Pointer(spread_weight + uintptr(i)*4)) = int32(32) >> shift
		goto _137
	_137:
		;
		i = i + 1
	}
	/*for (i=0;i<end;i++)
	   printf("%d ", spread_weight[i]);
	printf("\n");*/
	/* Make sure that dynamic allocation can't make us bust the budget.
	   We enable the feature starting at 24 kb/s for 20-ms frames
	   and 96 kb/s for 2.5 ms frames.  */
	if effectiveBytes >= int32(30)+int32(5)*LM && !(lfe != 0) {
		last = 0
		c = 0
		for {
			libc.Xmemcpy(tls, bandLogE3, bandLogE2+uintptr(c*nbEBands)*4, libc.Uint64FromInt32(end)*uint64(4)+libc.Uint64FromInt64(0*((int64(bandLogE3)-OpusT___predefined_ptrdiff_t(bandLogE2+uintptr(c*nbEBands)*4))/4)))
			if LM == 0 {
				/* For 2.5 ms frames, the first 8 bands have just one bin, so the
				   energy is highly unreliable (high variance). For that reason,
				   we take the max with the previous energy so that at least 2 bins
				   are getting used. */
				i = 0
				for {
					if int32(8) < end {
						v78 = int32(8)
					} else {
						v78 = end
					}
					if !(i < v78) {
						break
					}
					if *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE2 + uintptr(c*nbEBands+i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4)) {
						v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE2 + uintptr(c*nbEBands+i)*4))
					} else {
						v81 = *(*OpusT_celt_glog)(unsafe.Pointer(oldBandE + uintptr(c*nbEBands+i)*4))
					}
					*(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4)) = v81
					goto _146
				_146:
					;
					i = i + 1
				}
			}
			f = follower + uintptr(c*nbEBands)*4
			*(*OpusT_celt_glog)(unsafe.Pointer(f)) = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3))
			i = int32(1)
			for {
				if !(i < end) {
					break
				}
				/* The last band to be at least 3 dB higher than the previous one
				   is the last we'll consider. Otherwise, we run into problems on
				   bandlimited signals. */
				if *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i-int32(1))*4))+libc.Float32FromFloat32(0.5) {
					last = i
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i-int32(1))*4))+libc.Float32FromFloat32(1.5) < *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4)) {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i-int32(1))*4)) + libc.Float32FromFloat32(1.5)
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4))
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) = v81
				goto _149
			_149:
				;
				i = i + 1
			}
			i = last - int32(1)
			for {
				if !(i >= 0) {
					break
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i+int32(1))*4))+libc.Float32FromFloat32(2) < *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4)) {
					v132 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i+int32(1))*4)) + libc.Float32FromFloat32(2)
				} else {
					v132 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4))
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) < v132 {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4))
				} else {
					if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i+int32(1))*4))+libc.Float32FromFloat32(2) < *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4)) {
						v134 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i+int32(1))*4)) + libc.Float32FromFloat32(2)
					} else {
						v134 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE3 + uintptr(i)*4))
					}
					v81 = v134
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) = v81
				goto _151
			_151:
				;
				i = i - 1
			}
			/* Combine with a median filter to avoid dynalloc triggering unnecessarily.
			   The "offset" value controls how conservative we are -- a higher offset
			   reduces the impact of the median filter and makes dynalloc use more bits. */
			offset = libc.Float32FromFloat32(1)
			i = int32(2)
			for {
				if !(i < end-int32(2)) {
					break
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) > median_of_5(tls, bandLogE3+uintptr(i-int32(2))*4)-offset {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4))
				} else {
					v81 = median_of_5(tls, bandLogE3+uintptr(i-int32(2))*4) - offset
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) = v81
				goto _155
			_155:
				;
				i = i + 1
			}
			tmp = median_of_3(tls, bandLogE3) - offset
			if *(*OpusT_celt_glog)(unsafe.Pointer(f)) > tmp {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f))
			} else {
				v81 = tmp
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(f)) = v81
			if *(*OpusT_celt_glog)(unsafe.Pointer(f + 1*4)) > tmp {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + 1*4))
			} else {
				v81 = tmp
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(f + 1*4)) = v81
			tmp = median_of_3(tls, bandLogE3+uintptr(end-int32(3))*4) - offset
			if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(2))*4)) > tmp {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(2))*4))
			} else {
				v81 = tmp
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(2))*4)) = v81
			if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(1))*4)) > tmp {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(1))*4))
			} else {
				v81 = tmp
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(end-int32(1))*4)) = v81
			i = 0
			for {
				if !(i < end) {
					break
				}
				if *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4)) {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4))
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(noise_floor + uintptr(i)*4))
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(f + uintptr(i)*4)) = v81
				goto _161
			_161:
				;
				i = i + 1
			}
			goto _145
		_145:
			;
			c = c + 1
			v78 = c
			if !(v78 < C) {
				break
			}
		}
		if C == int32(2) {
			i = start
			for {
				if !(i < end) {
					break
				}
				/* Consider 24 dB "cross-talk" */
				if *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))-libc.Float32FromFloat32(4) {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4))
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) - libc.Float32FromFloat32(4)
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4)) = v81
				if *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4))-libc.Float32FromFloat32(4) {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4)) - libc.Float32FromFloat32(4)
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = v81
				if float32(libc.Int32FromInt32(0)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4))-*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) {
					v81 = float32(libc.Int32FromInt32(0))
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
				}
				if float32(libc.Int32FromInt32(0)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(nbEBands+i)*4))-*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4)) {
					v132 = float32(libc.Int32FromInt32(0))
				} else {
					v132 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(nbEBands+i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(nbEBands+i)*4))
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.5) * (v81 + v132))
				goto _163
			_163:
				;
				i = i + 1
			}
		} else {
			i = start
			for {
				if !(i < end) {
					break
				}
				if float32(libc.Int32FromInt32(0)) > *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4))-*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) {
					v81 = float32(libc.Int32FromInt32(0))
				} else {
					v81 = *(*OpusT_celt_glog)(unsafe.Pointer(bandLogE + uintptr(i)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = v81
				goto _168
			_168:
				;
				i = i + 1
			}
		}
		i = start
		for {
			if !(i < end) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(surround_dynalloc + uintptr(i)*4)) {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
			} else {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(surround_dynalloc + uintptr(i)*4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = v81
			goto _170
		_170:
			;
			i = i + 1
		}
		i = start
		for {
			if !(i < end) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) < libc.Float32FromFloat32(4) {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
			} else {
				v81 = libc.Float32FromFloat32(4)
			}
			v174 = v81
			integer = int32(libc.Xfloor(tls, float64(v174)))
			if integer < -libc.Int32FromInt32(50) {
				v175 = libc.Float32FromInt32(0)
				goto _176
			}
			frac = v174 - float32(integer)
			*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
			*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
			v175 = *(*float32)(unsafe.Pointer(bp))
			goto _176
		_176:
			*(*int32)(unsafe.Pointer(importance + uintptr(i)*4)) = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+float32(libc.Float32FromInt32(13)*v175))))
			goto _172
		_172:
			;
			i = i + 1
		}
		/* For non-transient CBR/CVBR frames, halve the dynalloc contribution */
		if (!(vbr != 0) || constrained_vbr != 0) && !(isTransient != 0) {
			i = start
			for {
				if !(i < end) {
					break
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.5) * *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)))
				goto _177
			_177:
				;
				i = i + 1
			}
		}
		i = start
		for {
			if !(i < end) {
				break
			}
			if i < int32(8) {
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) *= libc.Float32FromInt32(2)
			}
			if i >= int32(12) {
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.5) * *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)))
			}
			goto _178
		_178:
			;
			i = i + 1
		}
		/* Compensate for Opus' under-allocation on tones. */
		if toneishness > libc.Float32FromFloat32(0.98) {
			freq_bin = int32(libc.Xfloor(tls, float64(0.5)+float64(tone_freq*libc.Float32FromInt32(120))/float64(M_PI)))
			i = start
			for {
				if !(i < end) {
					break
				}
				if freq_bin >= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2))) && freq_bin <= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) {
					*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) += libc.Float32FromFloat32(2)
				}
				if freq_bin >= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))-int32(1) && freq_bin <= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))+int32(1) {
					*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) += libc.Float32FromFloat32(1)
				}
				if freq_bin >= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))-int32(2) && freq_bin <= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))+int32(2) {
					*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) += libc.Float32FromFloat32(1)
				}
				if freq_bin >= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))-int32(3) && freq_bin <= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2)))+int32(3) {
					*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) += libc.Float32FromFloat32(0.5)
				}
				goto _179
			_179:
				;
				i = i + 1
			}
			if freq_bin >= int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(end)*2))) {
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(end-int32(1))*4)) += libc.Float32FromFloat32(2)
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(end-int32(2))*4)) += libc.Float32FromFloat32(1)
			}
		}
		if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fvalid != 0 {
			i = start
			for {
				if int32(LEAK_BANDS) < end {
					v78 = int32(LEAK_BANDS)
				} else {
					v78 = end
				}
				if !(i < v78) {
					break
				}
				*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) + OpusT_celt_glog(libc.Float32FromFloat32(1)/libc.Float32FromFloat32(64)*float32(*(*uint8)(unsafe.Pointer(analysis + 44 + uintptr(i)))))
				goto _180
			_180:
				;
				i = i + 1
			}
		}
		i = start
		for {
			if !(i < end) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) < float32(libc.Int32FromInt32(4)) {
				v81 = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
			} else {
				v81 = float32(libc.Int32FromInt32(4))
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = v81
			*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) = *(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))
			width = C * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(i)*2)))) << LM
			if width < int32(6) {
				boost = int32(*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)))
				boost_bits = boost * width << int32(BITRES)
			} else {
				if width > int32(48) {
					boost = int32(OpusT_celt_glog(*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4)) * libc.Float32FromInt32(8)))
					boost_bits = boost * width << int32(BITRES) / int32(8)
				} else {
					boost = int32(OpusT_celt_glog(*(*OpusT_celt_glog)(unsafe.Pointer(follower + uintptr(i)*4))*float32(width)) / libc.Float32FromInt32(6))
					boost_bits = boost * int32(6) << int32(BITRES)
				}
			}
			/* For CBR and non-transient CVBR frames, limit dynalloc to 2/3 of the bits */
			if (!(vbr != 0) || constrained_vbr != 0 && !(isTransient != 0)) && (tot_boost+boost_bits)>>int32(BITRES)>>int32(3) > int32(2)*effectiveBytes/int32(3) {
				cap1 = libc.Int32FromInt32(2) * effectiveBytes / libc.Int32FromInt32(3) << libc.Int32FromInt32(BITRES) << libc.Int32FromInt32(3)
				*(*int32)(unsafe.Pointer(offsets + uintptr(i)*4)) = cap1 - tot_boost
				tot_boost = cap1
				break
			} else {
				*(*int32)(unsafe.Pointer(offsets + uintptr(i)*4)) = boost
				tot_boost = tot_boost + boost_bits
			}
			goto _182
		_182:
			;
			i = i + 1
		}
	} else {
		i = start
		for {
			if !(i < end) {
				break
			}
			*(*int32)(unsafe.Pointer(importance + uintptr(i)*4)) = int32(13)
			goto _184
		_184:
			;
			i = i + 1
		}
	}
	*(*OpusT_opus_int32)(unsafe.Pointer(tot_boost_)) = tot_boost
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _186
	_186:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _188
_188:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return maxDepth
}

// C documentation
//
//	/* Compute the LPC coefficients using a least-squares fit for both forward and backward prediction. */

func ec_dec_normalize(tls *libc.TLS, _this uintptr) {
	var sym int32
	_ = sym
	/*If the range is too small, rescale it and input some bits.*/
	for (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>libc.Int32FromInt32(EC_SYM_BITS) {
		*(*int32)(unsafe.Pointer(_this + 24)) += int32(EC_SYM_BITS)
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) <<= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		/*Use up the remaining bits from our last symbol.*/
		sym = (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem
		/*Read the next value from the input.*/
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem = ec_read_byte(tls, _this)
		/*Take the rest of the bits we need from this new symbol.*/
		sym = (sym<<int32(EC_SYM_BITS) | (*OpusT_ec_dec)(unsafe.Pointer(_this)).Frem) >> (libc.Int32FromInt32(EC_SYM_BITS) - ((libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(2))%libc.Int32FromInt32(EC_SYM_BITS) + libc.Int32FromInt32(1)))
		/*And subtract them from val, capped to be less than EC_CODE_TOP.*/
		(*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval = ((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fval<<libc.Int32FromInt32(EC_SYM_BITS) + (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1))&libc.Uint32FromInt32(^sym)) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
	}
}

func ec_enc_carry_out(tls *libc.TLS, _this uintptr, _c int32) {
	var carry int32
	var sym uint32
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _, _, _ = carry, sym, v1, v2
	if libc.Uint32FromInt32(_c) != libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS)-libc.Uint32FromInt32(1) {
		carry = _c >> int32(EC_SYM_BITS)
		/*Don't output a byte on the first write.
		  This compare should be taken care of by branch-prediction thereafter.*/
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem >= 0 {
			*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte(tls, _this, libc.Uint32FromInt32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem+carry))
		}
		if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext > uint32(0) {
			sym = (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1) + libc.Uint32FromInt32(carry)) & (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1))
			for {
				*(*int32)(unsafe.Pointer(_this + 48)) |= ec_write_byte(tls, _this, sym)
				goto _3
			_3:
				;
				v2 = _this + 40
				*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) - 1
				v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
				if !(v1 > uint32(0)) {
					break
				}
			}
		}
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Frem = libc.Int32FromUint32(libc.Uint32FromInt32(_c) & (libc.Uint32FromUint32(1)<<libc.Int32FromInt32(EC_SYM_BITS) - libc.Uint32FromInt32(1)))
	} else {
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fext + 1
	}
}

func ec_enc_normalize(tls *libc.TLS, _this uintptr) {
	/*If the range is too small, output some bits and rescale it.*/
	for (*OpusT_ec_enc)(unsafe.Pointer(_this)).Frng <= libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1))>>libc.Int32FromInt32(EC_SYM_BITS) {
		ec_enc_carry_out(tls, _this, libc.Int32FromUint32((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval>>(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(EC_SYM_BITS)-libc.Int32FromInt32(1))))
		/*Move the next-to-high-order symbol into the high-order position.*/
		(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval = (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fval << libc.Int32FromInt32(EC_SYM_BITS) & (libc.Uint32FromUint32(1)<<(libc.Int32FromInt32(EC_CODE_BITS)-libc.Int32FromInt32(1)) - libc.Uint32FromInt32(1))
		*(*OpusT_opus_uint32)(unsafe.Pointer(_this + 32)) <<= libc.Uint32FromInt32(libc.Int32FromInt32(EC_SYM_BITS))
		*(*int32)(unsafe.Pointer(_this + 24)) += int32(EC_SYM_BITS)
	}
}

func ec_laplace_get_freq1(tls *libc.TLS, fs0 uint32, decay int32) (r uint32) {
	var ft uint32
	_ = ft
	ft = libc.Uint32FromInt32(libc.Int32FromInt32(32768)-libc.Int32FromInt32(1)<<libc.Int32FromInt32(LAPLACE_LOG_MINP)*(libc.Int32FromInt32(2)*libc.Int32FromInt32(LAPLACE_NMIN))) - fs0
	return ft * libc.Uint32FromInt32(libc.Int32FromInt32(16384)-decay) >> int32(15)
}

func ec_read_byte(tls *libc.TLS, _this uintptr) (r int32) {
	var v1 int32
	var v2 OpusT_opus_uint32
	var v3 uintptr
	_, _, _ = v1, v2, v3
	if (*OpusT_ec_dec)(unsafe.Pointer(_this)).Foffs < (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage {
		v3 = _this + 28
		v2 = *(*OpusT_opus_uint32)(unsafe.Pointer(v3))
		*(*OpusT_opus_uint32)(unsafe.Pointer(v3)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v3)) + 1
		v1 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf + uintptr(v2))))
	} else {
		v1 = 0
	}
	return v1
}

func ec_read_byte_from_end(tls *libc.TLS, _this uintptr) (r int32) {
	var v1 int32
	var v2 OpusT_opus_uint32
	var v3 uintptr
	_, _, _ = v1, v2, v3
	if (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fend_offs < (*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage {
		v3 = _this + 12
		*(*OpusT_opus_uint32)(unsafe.Pointer(v3)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v3)) + 1
		v2 = *(*OpusT_opus_uint32)(unsafe.Pointer(v3))
		v1 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_dec)(unsafe.Pointer(_this)).Fstorage-v2))))
	} else {
		v1 = 0
	}
	return v1
}

// C documentation
//
//	/*Normalizes the contents of val and rng so that rng lies entirely in the
//	   high-order symbol.*/

func ec_write_byte(tls *libc.TLS, _this uintptr, _value uint32) (r int32) {
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _ = v1, v2
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
		return -int32(1)
	}
	v2 = _this + 28
	v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
	*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) + 1
	*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr(v1))) = uint8(_value)
	return 0
}

func ec_write_byte_at_end(tls *libc.TLS, _this uintptr, _value uint32) (r int32) {
	var v1 OpusT_opus_uint32
	var v2 uintptr
	_, _ = v1, v2
	if (*OpusT_ec_enc)(unsafe.Pointer(_this)).Foffs+(*OpusT_ec_enc)(unsafe.Pointer(_this)).Fend_offs >= (*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage {
		return -int32(1)
	}
	v2 = _this + 12
	*(*OpusT_opus_uint32)(unsafe.Pointer(v2)) = *(*OpusT_opus_uint32)(unsafe.Pointer(v2)) + 1
	v1 = *(*OpusT_opus_uint32)(unsafe.Pointer(v2))
	*(*uint8)(unsafe.Pointer((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fbuf + uintptr((*OpusT_ec_enc)(unsafe.Pointer(_this)).Fstorage-v1))) = uint8(_value)
	return 0
}

// C documentation
//
//	/*Outputs a symbol, with a carry bit.
//	  If there is a potential to propagate a carry over several symbols, they are
//	   buffered until it can be determined whether or not an actual carry will
//	   occur.
//	  If the counter for the buffered symbols overflows, then the stream becomes
//	   undecodable.
//	  This gives a theoretical limit of a few billion symbols in a single packet on
//	   32-bit systems.
//	  The alternative is to truncate the range in order to force a carry, but
//	   requires similar carry tracking in the decoder, needlessly slowing it down.*/

func encode_split(tls *libc.TLS, psRangeEnc uintptr, p_child1 int32, p int32, shell_table uintptr) {
	if p > 0 {
		Opus_ec_enc_icdf(tls, psRangeEnc, p_child1, shell_table+uintptr(Opus_silk_shell_code_table_offsets[p]), uint32(8))
	}
}

func exp_rotation1(tls *libc.TLS, X uintptr, len1 int32, stride int32, c OpusT_opus_val16, s OpusT_opus_val16) {
	var Xptr, v2 uintptr
	var i int32
	var ms OpusT_opus_val16
	var x1, x11, x2, x21 OpusT_celt_norm
	_, _, _, _, _, _, _, _ = Xptr, i, ms, x1, x11, x2, x21, v2
	Xptr = X
	ms = -s
	i = 0
	for {
		if !(i < len1-stride) {
			break
		}
		x1 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr))
		x2 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4)) = OpusT_opus_val32(c*x2) + OpusT_opus_val32(s*x1)
		v2 = Xptr
		Xptr += 4
		*(*OpusT_celt_norm)(unsafe.Pointer(v2)) = OpusT_opus_val32(c*x1) + OpusT_opus_val32(ms*x2)
		goto _1
	_1:
		;
		i = i + 1
	}
	Xptr = X + uintptr(len1-int32(2)*stride-int32(1))*4
	i = len1 - int32(2)*stride - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		x11 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr))
		x21 = *(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(Xptr + uintptr(stride)*4)) = OpusT_opus_val32(c*x21) + OpusT_opus_val32(s*x11)
		v2 = Xptr
		Xptr -= 4
		*(*OpusT_celt_norm)(unsafe.Pointer(v2)) = OpusT_opus_val32(c*x11) + OpusT_opus_val32(ms*x21)
		goto _3
	_3:
		;
		i = i - 1
	}
}

func extract_collapse_mask(tls *libc.TLS, iy uintptr, N int32, B int32) (r uint32) {
	var N0, i, j, v4 int32
	var collapse_mask, tmp uint32
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _ = N0, collapse_mask, i, j, tmp, v1, v2, v4
	if B <= int32(1) {
		return uint32(1)
	}
	/*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
	  exp_rotation().*/
	v1 = libc.Uint32FromInt32(B)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(N) / v1
	goto _3
_3:
	N0 = libc.Int32FromUint32(v2)
	collapse_mask = uint32(0)
	i = 0
	for {
		tmp = uint32(0)
		j = 0
		for {
			tmp = tmp | libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(iy + uintptr(i*N0+j)*4)))
			goto _7
		_7:
			;
			j = j + 1
			v4 = j
			if !(v4 < N0) {
				break
			}
		}
		collapse_mask = collapse_mask | libc.Uint32FromInt32(libc.BoolInt32(tmp != uint32(0))<<i)
		goto _5
	_5:
		;
		i = i + 1
		v4 = i
		if !(v4 < B) {
			break
		}
	}
	return collapse_mask
}

func find_best_pitch(tls *libc.TLS, xcorr uintptr, y uintptr, len1 int32, max_pitch int32, best_pitch uintptr) {
	var Syy, xcorr16, v3 OpusT_opus_val32
	var best_den [2]OpusT_opus_val32
	var best_num [2]OpusT_opus_val16
	var i, j int32
	var num OpusT_opus_val16
	_, _, _, _, _, _, _, _ = Syy, best_den, best_num, i, j, num, xcorr16, v3
	Syy = libc.Float32FromInt32(1)
	best_num[0] = float32(-libc.Int32FromInt32(1))
	best_num[int32(1)] = float32(-libc.Int32FromInt32(1))
	best_den[0] = libc.Float32FromInt32(0)
	best_den[int32(1)] = libc.Float32FromInt32(0)
	*(*int32)(unsafe.Pointer(best_pitch)) = 0
	*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = int32(1)
	j = 0
	for {
		if !(j < len1) {
			break
		}
		Syy = Syy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(j)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(j)*4)))
		goto _1
	_1:
		;
		j = j + 1
	}
	i = 0
	for {
		if !(i < max_pitch) {
			break
		}
		if *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i)*4)) > libc.Float32FromInt32(0) {
			xcorr16 = *(*OpusT_opus_val32)(unsafe.Pointer(xcorr + uintptr(i)*4))
			/* Considering the range of xcorr16, this should avoid both underflows
			   and overflows (inf) when squaring xcorr16 */
			xcorr16 = xcorr16 * libc.Float32FromFloat32(1e-12)
			num = OpusT_opus_val32(xcorr16 * xcorr16)
			if OpusT_opus_val16(num*best_den[int32(1)]) > OpusT_opus_val16(best_num[int32(1)]*Syy) {
				if OpusT_opus_val16(num*best_den[0]) > OpusT_opus_val16(best_num[0]*Syy) {
					best_num[int32(1)] = best_num[0]
					best_den[int32(1)] = best_den[0]
					*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = *(*int32)(unsafe.Pointer(best_pitch))
					best_num[0] = num
					best_den[0] = Syy
					*(*int32)(unsafe.Pointer(best_pitch)) = i
				} else {
					best_num[int32(1)] = num
					best_den[int32(1)] = Syy
					*(*int32)(unsafe.Pointer(best_pitch + 1*4)) = i
				}
			}
		}
		Syy = Syy + (OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i+len1)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i+len1)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(y + uintptr(i)*4))))
		if float32(libc.Int32FromInt32(1)) > Syy {
			v3 = float32(libc.Int32FromInt32(1))
		} else {
			v3 = Syy
		}
		Syy = v3
		goto _2
	_2:
		;
		i = i + 1
	}
}

func gain_fade(tls *libc.TLS, in uintptr, out uintptr, g11 OpusT_opus_val16, g2 OpusT_opus_val16, overlap48 int32, frame_size int32, channels int32, window uintptr, Fs OpusT_opus_int32) {
	var c, i, inc, overlap, v1 int32
	var g, g1, w, w1 OpusT_opus_val16
	_, _, _, _, _, _, _, _, _ = c, g, g1, i, inc, overlap, w, w1, v1
	if int32(1) > int32(48000)/Fs {
		v1 = int32(1)
	} else {
		v1 = int32(48000) / Fs
	}
	inc = v1
	overlap = overlap48 / inc
	if channels == int32(1) {
		i = 0
		for {
			if !(i < overlap) {
				break
			}
			w = *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4))
			w = OpusT_opus_val16(w * w)
			g = OpusT_opus_val32(w*g2) + OpusT_opus_val32((libc.Float32FromFloat32(1)-w)*g11)
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i)*4)) = OpusT_opus_val16(g * *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < overlap) {
				break
			}
			w1 = *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4))
			w1 = OpusT_opus_val16(w1 * w1)
			g1 = OpusT_opus_val32(w1*g2) + OpusT_opus_val32((libc.Float32FromFloat32(1)-w1)*g11)
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*int32(2))*4)) = OpusT_opus_val16(g1 * *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*int32(2))*4)))
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*int32(2)+int32(1))*4)) = OpusT_opus_val16(g1 * *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*int32(2)+int32(1))*4)))
			goto _3
		_3:
			;
			i = i + 1
		}
	}
	c = 0
	for {
		i = overlap
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+c)*4)) = OpusT_opus_val16(g2 * *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*channels+c)*4)))
			goto _6
		_6:
			;
			i = i + 1
		}
		goto _5
	_5:
		;
		c = c + 1
		v1 = c
		if !(v1 < channels) {
			break
		}
	}
}

func gemm_accum(tls *libc.TLS, out uintptr, weights uintptr, rows int32, cols int32, col_stride int32, x uintptr) {
	var i, j int32
	_, _ = i, j
	i = 0
	for {
		if !(i < rows) {
			break
		}
		j = 0
		for {
			if !(j < cols) {
				break
			}
			*(*float32)(unsafe.Pointer(out + uintptr(i)*4)) += float32(float32(*(*OpusT_opus_int8)(unsafe.Pointer(weights + uintptr(j*col_stride+i)))) * *(*float32)(unsafe.Pointer(x + uintptr(j)*4)))
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func gen_toc(tls *libc.TLS, mode int32, framerate int32, bandwidth int32, channels int32) (r uint8) {
	var period, tmp int32
	var toc uint8
	_, _, _ = period, tmp, toc
	period = 0
	for framerate < int32(400) {
		framerate = framerate << int32(1)
		period = period + 1
	}
	if mode == int32(MODE_SILK_ONLY) {
		toc = libc.Uint8FromInt32((bandwidth - int32(OPUS_BANDWIDTH_NARROWBAND)) << int32(5))
		toc = libc.Uint8FromInt32(int32(toc) | (period-libc.Int32FromInt32(2))<<libc.Int32FromInt32(3))
	} else {
		if mode == int32(MODE_CELT_ONLY) {
			tmp = bandwidth - int32(OPUS_BANDWIDTH_MEDIUMBAND)
			if tmp < 0 {
				tmp = 0
			}
			toc = uint8(0x80)
			toc = libc.Uint8FromInt32(int32(toc) | tmp<<libc.Int32FromInt32(5))
			toc = libc.Uint8FromInt32(int32(toc) | period<<libc.Int32FromInt32(3))
		} else { /* Hybrid */
			toc = uint8(0x60)
			toc = libc.Uint8FromInt32(int32(toc) | (bandwidth-libc.Int32FromInt32(OPUS_BANDWIDTH_SUPERWIDEBAND))<<libc.Int32FromInt32(4))
			toc = libc.Uint8FromInt32(int32(toc) | (period-libc.Int32FromInt32(2))<<libc.Int32FromInt32(3))
		}
	}
	toc = libc.Uint8FromInt32(int32(toc) | libc.BoolInt32(channels == libc.Int32FromInt32(2))<<libc.Int32FromInt32(2))
	return toc
}

func get_dec_demixing_matrix(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(4)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_enc_demixing_matrix(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(uint64(8)+libc.Uint64FromInt32((*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fmixing_matrix_size_in_bytes))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_mixing_matrix(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(8)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_multistream_decoder(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(uint64(4)+libc.Uint64FromInt32((*OpusT_OpusProjectionDecoder)(unsafe.Pointer(st)).Fdemixing_matrix_size_in_bytes))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_multistream_encoder(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var v1 int32
	_, _ = alignment, v1
	/* void* cast avoids clang -Wcast-align warning */
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(libc.Int32FromUint64(uint64(8)+libc.Uint64FromInt32((*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fmixing_matrix_size_in_bytes)+libc.Uint64FromInt32((*OpusT_OpusProjectionEncoder)(unsafe.Pointer(st)).Fdemixing_matrix_size_in_bytes))) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	return st + uintptr(v1)
}

func get_order_plus_one_from_channels(tls *libc.TLS, channels int32, order_plus_one uintptr) (r int32) {
	var acn_channels, nondiegetic_channels, order_plus_one_ int32
	_, _, _ = acn_channels, nondiegetic_channels, order_plus_one_
	/* Allowed numbers of channels:
	 * (1 + n)^2 + 2j, for n = 0...14 and j = 0 or 1.
	 */
	if channels < int32(1) || channels > int32(227) {
		return -int32(1)
	}
	order_plus_one_ = libc.Int32FromUint32(Opus_isqrt32(tls, libc.Uint32FromInt32(channels)))
	acn_channels = order_plus_one_ * order_plus_one_
	nondiegetic_channels = channels - acn_channels
	if nondiegetic_channels != 0 && nondiegetic_channels != int32(2) {
		return -int32(1)
	}
	if order_plus_one != 0 {
		*(*int32)(unsafe.Pointer(order_plus_one)) = order_plus_one_
	}
	return OPUS_OK
}

func get_streams_from_channels(tls *libc.TLS, channels int32, mapping_family int32, streams uintptr, coupled_streams uintptr, order_plus_one uintptr) (r int32) {
	if mapping_family == int32(3) {
		if get_order_plus_one_from_channels(tls, channels, order_plus_one) != OPUS_OK {
			return -int32(1)
		}
		if streams != 0 {
			*(*int32)(unsafe.Pointer(streams)) = (channels + int32(1)) / int32(2)
		}
		if coupled_streams != 0 {
			*(*int32)(unsafe.Pointer(coupled_streams)) = channels / int32(2)
		}
		return OPUS_OK
	}
	return -int32(1)
}

func hp_cutoff(tls *libc.TLS, in uintptr, cutoff_Hz OpusT_opus_int32, out uintptr, hp_mem uintptr, len1 int32, channels int32, Fs OpusT_opus_int32, arch int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var Fc_Q19, r_Q22, r_Q28 OpusT_opus_int32
	var _ /* A_Q28 at bp+16 */ [2]OpusT_opus_int32
	var _ /* B_Q28 at bp+0 */ [3]OpusT_opus_int32
	_, _, _ = Fc_Q19, r_Q22, r_Q28
	_ = arch
	_ = cutoff_Hz <= libc.Int32FromInt32(silk_int32_MAX)/int32(float64(float64(libc.Float64FromFloat64(1.5)*libc.Float64FromFloat64(3.14159))/libc.Float64FromInt32(1000)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(19)))+libc.Float64FromFloat64(0.5))
	Fc_Q19 = int32(int16(int32(float64(float64(libc.Float64FromFloat64(1.5)*libc.Float64FromFloat64(3.14159))/libc.Float64FromInt32(1000)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(19)))+libc.Float64FromFloat64(0.5)))) * int32(int16(cutoff_Hz)) / (Fs / libc.Int32FromInt32(1000))
	_ = Fc_Q19 > 0 && Fc_Q19 < int32(32768)
	r_Q28 = int32(float64(libc.Float64FromFloat64(1)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(28)))+libc.Float64FromFloat64(0.5)) - int32(float64(libc.Float64FromFloat64(0.92)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(9)))+libc.Float64FromFloat64(0.5))*Fc_Q19
	/* b = r * [ 1; -2; 1 ]; */
	/* a = [ 1; -2 * r * ( 1 - 0.5 * Fc^2 ); r^2 ]; */
	(*(*[3]OpusT_opus_int32)(unsafe.Pointer(bp)))[0] = r_Q28
	(*(*[3]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(1)] = libc.Int32FromUint32(libc.Uint32FromInt32(-r_Q28) << libc.Int32FromInt32(1))
	(*(*[3]OpusT_opus_int32)(unsafe.Pointer(bp)))[int32(2)] = r_Q28
	/* -r * ( 2 - Fc * Fc ); */
	r_Q22 = r_Q28 >> int32(6)
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 16)))[0] = int32(int64(r_Q22) * int64(int32(int64(Fc_Q19)*int64(Fc_Q19)>>libc.Int32FromInt32(16))-int32(float64(libc.Float64FromFloat64(2)*float64(libc.Int64FromInt32(1)<<libc.Int32FromInt32(22)))+libc.Float64FromFloat64(0.5))) >> libc.Int32FromInt32(16))
	(*(*[2]OpusT_opus_int32)(unsafe.Pointer(bp + 16)))[int32(1)] = int32(int64(r_Q22) * int64(r_Q22) >> libc.Int32FromInt32(16))
	silk_biquad_res(tls, in, bp, bp+16, hp_mem, out, len1, channels)
	if channels == int32(2) {
		silk_biquad_res(tls, in+uintptr(1)*4, bp, bp+16, hp_mem+uintptr(2)*4, out+uintptr(1)*4, len1, channels)
	}
}

func icwrs(tls *libc.TLS, _n int32, _y uintptr) (r OpusT_opus_uint32) {
	var i OpusT_opus_uint32
	var j, k, v1, v2 int32
	_, _, _, _, _ = i, j, k, v1, v2
	if !(_n >= libc.Int32FromInt32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+5282, __ccgo_ts+5306, int32(448))
	}
	j = _n - int32(1)
	i = libc.BoolUint32(*(*int32)(unsafe.Pointer(_y + uintptr(j)*4)) < 0)
	k = libc.Xabs(tls, *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)))
	for cond := true; cond; cond = j > 0 {
		j = j - 1
		if _n-j < k {
			v1 = _n - j
		} else {
			v1 = k
		}
		if _n-j > k {
			v2 = _n - j
		} else {
			v2 = k
		}
		i = i + *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))
		k = k + libc.Xabs(tls, *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)))
		if *(*int32)(unsafe.Pointer(_y + uintptr(j)*4)) < 0 {
			if _n-j < k+int32(1) {
				v1 = _n - j
			} else {
				v1 = k + int32(1)
			}
			if _n-j > k+int32(1) {
				v2 = _n - j
			} else {
				v2 = k + int32(1)
			}
			i = i + *(*OpusT_opus_uint32)(unsafe.Pointer(CELT_PVQ_U_ROW[v1] + uintptr(v2)*4))
		}
	}
	return i
}

func intensity_stereo(tls *libc.TLS, m uintptr, X uintptr, Y uintptr, bandE uintptr, bandID int32, N int32) {
	var a1, a2, left, norm, right OpusT_opus_val16
	var i, j int32
	_, _, _, _, _, _, _ = a1, a2, i, j, left, norm, right
	i = bandID
	left = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i)*4))
	right = *(*OpusT_celt_ener)(unsafe.Pointer(bandE + uintptr(i+(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
	norm = libc.Float32FromFloat32(1e-15) + float32(libc.Xsqrt(tls, float64(libc.Float32FromFloat32(1e-15)+OpusT_opus_val32(left*left)+OpusT_opus_val32(right*right))))
	a1 = left / norm
	a2 = right / norm
	j = 0
	for {
		if !(j < N) {
			break
		}
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = OpusT_opus_val16(a1**(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))) + OpusT_opus_val16(a2**(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)))
		/* Side is not encoded, no need to calculate */
		goto _1
	_1:
		;
		j = j + 1
	}
}

func interleave_hadamard(tls *libc.TLS, X uintptr, N0 int32, stride int32, hadamard int32) {
	var N, i, j int32
	var _saved_stack, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, _saved_stack, i, j, ordery, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	N = N0 * stride
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3661, int32(607))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if hadamard != 0 {
		ordery = uintptr(unsafe.Pointer(&ordery_table)) + uintptr(stride)*4 - uintptr(2)*4
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(j*stride+i)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(*(*int32)(unsafe.Pointer(ordery + uintptr(i)*4))*N0+j)*4))
				goto _30
			_30:
				;
				j = j + 1
			}
			goto _29
		_29:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < stride) {
				break
			}
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(j*stride+i)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i*N0+j)*4))
				goto _32
			_32:
				;
				j = j + 1
			}
			goto _31
		_31:
			;
			i = i + 1
		}
	}
	libc.Xmemcpy(tls, X, tmp, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(tmp))/4)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _34
	_34:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _36
_36:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func interp_bits2pulses(tls *libc.TLS, m uintptr, start int32, end int32, skip_start int32, bits1 uintptr, bits2 uintptr, thresh uintptr, cap1 uintptr, total OpusT_opus_int32, _balance uintptr, skip_rsv int32, intensity uintptr, intensity_rsv int32, dual_stereo uintptr, dual_stereo_rsv int32, bits uintptr, ebits uintptr, fine_priority uintptr, C int32, LM int32, ec uintptr, encode int32, prev int32, signalBandwidth int32) (r int32) {
	var N, N0, NClogN, alloc_floor, band_bits, band_width, codedBands, den, depth_threshold, done, extra_bits, extra_fine, hi, i, j, lo, logM, mid, offset, rem, stereo, tmp, tmp1, tmp2, v7, v8 int32
	var _saved_stack, st, v1, v3 uintptr
	var balance, bit, excess, left, percoeff, psum OpusT_opus_int32
	var v13, v14 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = N, N0, NClogN, _saved_stack, alloc_floor, balance, band_bits, band_width, bit, codedBands, den, depth_threshold, done, excess, extra_bits, extra_fine, hi, i, j, left, lo, logM, mid, offset, percoeff, psum, rem, st, stereo, tmp, tmp1, tmp2, v1, v13, v14, v3, v7, v8
	codedBands = -int32(1)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	alloc_floor = C << int32(BITRES)
	stereo = libc.BoolInt32(C > int32(1))
	logM = LM << int32(BITRES)
	lo = 0
	hi = libc.Int32FromInt32(1) << libc.Int32FromInt32(ALLOC_STEPS)
	i = 0
	for {
		if !(i < int32(ALLOC_STEPS)) {
			break
		}
		mid = (lo + hi) >> int32(1)
		psum = 0
		done = 0
		j = end
		for {
			v7 = j
			j = j - 1
			if !(v7 > start) {
				break
			}
			tmp = *(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) + mid**(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4))>>int32(ALLOC_STEPS)
			if tmp >= *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) || done != 0 {
				done = int32(1)
				/* Don't allocate more than we can actually use */
				if tmp < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
					v7 = tmp
				} else {
					v7 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
				}
				psum = psum + v7
			} else {
				if tmp >= alloc_floor {
					psum = psum + alloc_floor
				}
			}
			goto _6
		_6:
		}
		if psum > total {
			hi = mid
		} else {
			lo = mid
		}
		goto _5
	_5:
		;
		i = i + 1
	}
	psum = 0
	/*printf ("interp bisection gave %d\n", lo);*/
	done = 0
	j = end
	for {
		v7 = j
		j = j - 1
		if !(v7 > start) {
			break
		}
		tmp1 = *(*int32)(unsafe.Pointer(bits1 + uintptr(j)*4)) + lo**(*int32)(unsafe.Pointer(bits2 + uintptr(j)*4))>>int32(ALLOC_STEPS)
		if tmp1 < *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) && !(done != 0) {
			if tmp1 >= alloc_floor {
				tmp1 = alloc_floor
			} else {
				tmp1 = 0
			}
		} else {
			done = int32(1)
		}
		/* Don't allocate more than we can actually use */
		if tmp1 < *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) {
			v7 = tmp1
		} else {
			v7 = *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
		}
		tmp1 = v7
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = tmp1
		psum = psum + tmp1
		goto _9
	_9:
	}
	/* Decide which bands to skip, working backwards from the end. */
	codedBands = end
	for {
		j = codedBands - int32(1)
		/* Never skip the first band, nor a band that has been boosted by
		    dynalloc.
		   In the first case, we'd be coding a bit to signal we're going to waste
		    all the other bits.
		   In the second case, we'd be coding a bit to redistribute all the bits
		    we just signaled should be concentrated in this band. */
		if j <= skip_start {
			/* Give the bit we reserved to end skipping back. */
			total = total + skip_rsv
			break
		}
		/*Figure out how many left-over bits we would be adding to this band.
		  This can include bits we've stolen back from higher, skipped bands.*/
		left = total - psum
		v13 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
		_ = v13 > libc.Uint32FromInt32(0)
		v14 = libc.Uint32FromInt32(left) / v13
		goto _15
	_15:
		percoeff = libc.Int32FromUint32(v14)
		left = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))*percoeff
		if left-(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2)))) > 0 {
			v7 = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
		} else {
			v7 = 0
		}
		rem = v7
		band_width = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		band_bits = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + percoeff*band_width + rem
		/*Only code a skip decision if we're above the threshold for this band.
		  Otherwise it is force-skipped.
		  This ensures that we have enough bits to code the skip flag.*/
		if *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4)) > alloc_floor+libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
			v7 = *(*int32)(unsafe.Pointer(thresh + uintptr(j)*4))
		} else {
			v7 = alloc_floor + libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
		}
		if band_bits >= v7 {
			if encode != 0 {
				/*We choose a threshold with some hysteresis to keep bands from
				  fluctuating in and out, but we try not to fold below a certain point. */
				if codedBands > int32(17) {
					if j < prev {
						v8 = int32(7)
					} else {
						v8 = int32(9)
					}
					depth_threshold = v8
				} else {
					depth_threshold = 0
				}
				if codedBands <= start+int32(2) || band_bits > depth_threshold*band_width<<LM<<int32(BITRES)>>int32(4) && j <= signalBandwidth {
					Opus_ec_enc_bit_logp(tls, ec, int32(1), uint32(1))
					break
				}
				Opus_ec_enc_bit_logp(tls, ec, 0, uint32(1))
			} else {
				if Opus_ec_dec_bit_logp(tls, ec, uint32(1)) != 0 {
					break
				}
			}
			/*We used a bit to skip this band.*/
			psum = psum + libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
			band_bits = band_bits - libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES)
		}
		/*Reclaim the bits originally allocated to this band.*/
		psum = psum - (*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + intensity_rsv)
		if intensity_rsv > 0 {
			intensity_rsv = libc.Int32FromUint8(LOG2_FRAC_TABLE[j-start])
		}
		psum = psum + intensity_rsv
		if band_bits >= alloc_floor {
			/*If we have enough for a fine energy bit per channel, use it.*/
			psum = psum + alloc_floor
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = alloc_floor
		} else {
			/*Otherwise this band gets nothing at all.*/
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = 0
		}
		goto _12
	_12:
		;
		codedBands = codedBands - 1
	}
	if !(codedBands > start) {
		Opus_celt_fatal(tls, __ccgo_ts+6076, __ccgo_ts+6113, int32(394))
	}
	/* Code the intensity and dual stereo parameters. */
	if intensity_rsv > 0 {
		if encode != 0 {
			if *(*int32)(unsafe.Pointer(intensity)) < codedBands {
				v7 = *(*int32)(unsafe.Pointer(intensity))
			} else {
				v7 = codedBands
			}
			*(*int32)(unsafe.Pointer(intensity)) = v7
			Opus_ec_enc_uint(tls, ec, libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(intensity))-start), libc.Uint32FromInt32(codedBands+int32(1)-start))
		} else {
			*(*int32)(unsafe.Pointer(intensity)) = libc.Int32FromUint32(libc.Uint32FromInt32(start) + Opus_ec_dec_uint(tls, ec, libc.Uint32FromInt32(codedBands+int32(1)-start)))
		}
	} else {
		*(*int32)(unsafe.Pointer(intensity)) = 0
	}
	if *(*int32)(unsafe.Pointer(intensity)) <= start {
		total = total + dual_stereo_rsv
		dual_stereo_rsv = 0
	}
	if dual_stereo_rsv > 0 {
		if encode != 0 {
			Opus_ec_enc_bit_logp(tls, ec, *(*int32)(unsafe.Pointer(dual_stereo)), uint32(1))
		} else {
			*(*int32)(unsafe.Pointer(dual_stereo)) = Opus_ec_dec_bit_logp(tls, ec, uint32(1))
		}
	} else {
		*(*int32)(unsafe.Pointer(dual_stereo)) = 0
	}
	/* Allocate the remaining bits */
	left = total - psum
	v13 = libc.Uint32FromInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))
	_ = v13 > libc.Uint32FromInt32(0)
	v14 = libc.Uint32FromInt32(left) / v13
	goto _22
_22:
	percoeff = libc.Int32FromUint32(v14)
	left = left - (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(codedBands)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(start)*2))))*percoeff
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) += percoeff * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))))
		goto _23
	_23:
		;
		j = j + 1
	}
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		if left < int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2))) {
			v7 = left
		} else {
			v7 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		}
		tmp2 = v7
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) += tmp2
		left = left - tmp2
		goto _24
	_24:
		;
		j = j + 1
	}
	/*for (j=0;j<end;j++)printf("%d ", bits[j]);printf("\n");*/
	balance = 0
	j = start
	for {
		if !(j < codedBands) {
			break
		}
		if !(*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+6128, __ccgo_ts+6113, int32(445))
		}
		N0 = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(j)*2)))
		N = N0 << LM
		bit = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + balance
		if N > int32(1) {
			if bit-*(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4)) > 0 {
				v7 = bit - *(*int32)(unsafe.Pointer(cap1 + uintptr(j)*4))
			} else {
				v7 = 0
			}
			excess = v7
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = bit - excess
			/* Compensate for the extra DoF in stereo */
			if C == int32(2) && N > int32(2) && !(*(*int32)(unsafe.Pointer(dual_stereo)) != 0) && j < *(*int32)(unsafe.Pointer(intensity)) {
				v7 = int32(1)
			} else {
				v7 = 0
			}
			den = C*N + v7
			NClogN = den * (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FlogN + uintptr(j)*2))) + logM)
			/* Offset for the number of fine bits by log2(N)/2 + FINE_OFFSET
			   compared to their "fair share" of total/N */
			offset = NClogN>>int32(1) - den*int32(FINE_OFFSET)
			/* N=2 is the only point that doesn't match the curve */
			if N == int32(2) {
				offset = offset + den<<int32(BITRES)>>int32(2)
			}
			/* Changing the offset for allocating the second and third
			   fine energy bit */
			if *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset < den*int32(2)<<int32(BITRES) {
				offset = offset + NClogN>>int32(2)
			} else {
				if *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset < den*int32(3)<<int32(BITRES) {
					offset = offset + NClogN>>int32(3)
				}
			}
			/* Divide with rounding */
			if 0 > *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset+den<<(libc.Int32FromInt32(BITRES)-libc.Int32FromInt32(1)) {
				v7 = 0
			} else {
				v7 = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) + offset + den<<(libc.Int32FromInt32(BITRES)-libc.Int32FromInt32(1))
			}
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = v7
			v13 = libc.Uint32FromInt32(den)
			_ = v13 > libc.Uint32FromInt32(0)
			v14 = libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))) / v13
			goto _32
		_32:
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = libc.Int32FromUint32(v14 >> int32(BITRES))
			/* Make sure not to bust */
			if C**(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) > *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))>>int32(BITRES) {
				*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >> stereo >> int32(BITRES)
			}
			/* More than that is useless because that's about as far as PVQ can go */
			if *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) < int32(MAX_FINE_BITS) {
				v7 = *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))
			} else {
				v7 = int32(MAX_FINE_BITS)
			}
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = v7
			/* If we rounded down or capped this band, make it a candidate for the
			   final fine energy pass */
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))*(den<<int32(BITRES)) >= *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))+offset)
			/* Remove the allocated fine bits; the rest are assigned to PVQ */
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) -= C * *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) << int32(BITRES)
		} else {
			/* For N=1, all bits go to fine energy except for a single sign bit */
			if 0 > bit-C<<int32(BITRES) {
				v7 = 0
			} else {
				v7 = bit - C<<int32(BITRES)
			}
			excess = v7
			*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = bit - excess
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = 0
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = int32(1)
		}
		/* Fine energy can't take advantage of the re-balancing in
		   quant_all_bands().
		  Instead, do the re-balancing here.*/
		if excess > 0 {
			if excess>>(stereo+libc.Int32FromInt32(BITRES)) < int32(MAX_FINE_BITS)-*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) {
				v7 = excess >> (stereo + libc.Int32FromInt32(BITRES))
			} else {
				v7 = int32(MAX_FINE_BITS) - *(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))
			}
			extra_fine = v7
			*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) += extra_fine
			extra_bits = extra_fine * C << int32(BITRES)
			*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(extra_bits >= excess-balance)
			excess = excess - extra_bits
		}
		balance = excess
		if !(*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+6128, __ccgo_ts+6113, int32(516))
		}
		if !(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) >= libc.Int32FromInt32(0)) {
			Opus_celt_fatal(tls, __ccgo_ts+6159, __ccgo_ts+6113, int32(517))
		}
		goto _26
	_26:
		;
		j = j + 1
	}
	/* Save any remaining bits over the cap for the rebalancing in
	   quant_all_bands(). */
	*(*OpusT_opus_int32)(unsafe.Pointer(_balance)) = balance
	/* The skipped bands use all their bits for fine energy. */
	for {
		if !(j < end) {
			break
		}
		*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) >> stereo >> int32(BITRES)
		if !(C**(*int32)(unsafe.Pointer(ebits + uintptr(j)*4))<<libc.Int32FromInt32(BITRES) == *(*int32)(unsafe.Pointer(bits + uintptr(j)*4))) {
			Opus_celt_fatal(tls, __ccgo_ts+6191, __ccgo_ts+6113, int32(527))
		}
		*(*int32)(unsafe.Pointer(bits + uintptr(j)*4)) = 0
		*(*int32)(unsafe.Pointer(fine_priority + uintptr(j)*4)) = libc.BoolInt32(*(*int32)(unsafe.Pointer(ebits + uintptr(j)*4)) < int32(1))
		goto _36
	_36:
		;
		j = j + 1
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _38
	_38:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _40
_40:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return codedBands
}

func kf_bfly2(tls *libc.TLS, Fout uintptr, m int32, N int32) {
	var Fout2 uintptr
	var i int32
	var t OpusT_kiss_fft_cpx
	var tw OpusT_celt_coef
	_, _, _, _ = Fout2, i, t, tw
	_ = m
	tw = libc.Float32FromFloat32(0.7071067812)
	/* We know that m==4 here because the radix-2 is just after a radix-4 */
	if !(m == libc.Int32FromInt32(4)) {
		Opus_celt_fatal(tls, __ccgo_ts+5542, __ccgo_ts+5565, int32(80))
	}
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout2 = Fout + uintptr(4)*8
		t = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout))).Fi += t.Fi
		t.Fr = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi) * tw)
		t.Fi = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr) * tw)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 1*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi += t.Fi
		t.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fi
		t.Fi = -(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 2*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi += t.Fi
		t.Fr = float32(((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr) * tw)
		t.Fi = float32(-((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr) * tw)
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr - t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2 + 3*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi - t.Fi
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr += t.Fr
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi += t.Fi
		Fout = Fout + uintptr(8)*8
		goto _1
	_1:
		;
		i = i + 1
	}
}

func kf_bfly21(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m int32) {
	var Fout2, tw1 uintptr
	var t OpusT_mini_kiss_fft_cpx
	var v1 int32
	_, _, _, _ = Fout2, t, tw1, v1
	tw1 = st + 264
	Fout2 = Fout + uintptr(m)*8
	for {
		t.Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		t.Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		tw1 = tw1 + uintptr(fstride)*8
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - t.Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - t.Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += t.Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += t.Fi
		Fout2 += 8
		Fout += 8
		goto _2
	_2:
		;
		m = m - 1
		v1 = m
		if !(v1 != 0) {
			break
		}
	}
}

func kf_bfly3(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout_beg, tw1, tw2, v2 uintptr
	var epi3 OpusT_kiss_twiddle_cpx
	var i int32
	var k, m2, v3 OpusT_size_t
	var scratch [5]OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _ = Fout_beg, epi3, i, k, m2, scratch, tw1, tw2, v2, v3
	m2 = libc.Uint64FromInt32(int32(2) * m)
	Fout_beg = Fout
	epi3 = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout = Fout_beg + uintptr(i*mm)*8
		v2 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
		tw2 = v2
		tw1 = v2
		/* For non-custom modes, m is guaranteed to be a multiple of 4. */
		k = libc.Uint64FromInt32(m)
		for {
			scratch[int32(1)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi)
			scratch[int32(1)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr)
			scratch[int32(2)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi)
			scratch[int32(2)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr)
			scratch[int32(3)].Fr = scratch[int32(1)].Fr + scratch[int32(2)].Fr
			scratch[int32(3)].Fi = scratch[int32(1)].Fi + scratch[int32(2)].Fi
			scratch[0].Fr = scratch[int32(1)].Fr - scratch[int32(2)].Fr
			scratch[0].Fi = scratch[int32(1)].Fi - scratch[int32(2)].Fi
			tw1 = tw1 + uintptr(fstride)*8
			tw2 = tw2 + uintptr(fstride*uint64(2))*8
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - float32(scratch[int32(3)].Fr*libc.Float32FromFloat32(0.5))
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - float32(scratch[int32(3)].Fi*libc.Float32FromFloat32(0.5))
			scratch[0].Fr *= epi3.Fi
			scratch[0].Fi *= epi3.Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr + scratch[0].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi - scratch[0].Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr - scratch[0].Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi + scratch[0].Fr
			Fout += 8
			goto _4
		_4:
			;
			k = k - 1
			v3 = k
			if !(v3 != 0) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func kf_bfly31(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m OpusT_size_t) {
	var epi3 OpusT_mini_kiss_fft_cpx
	var k, m2, v2 OpusT_size_t
	var scratch [5]OpusT_mini_kiss_fft_cpx
	var tw1, tw2, v1 uintptr
	_, _, _, _, _, _, _, _ = epi3, k, m2, scratch, tw1, tw2, v1, v2
	k = m
	m2 = uint64(2) * m
	epi3 = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(st + 264 + uintptr(fstride*m)*8))
	v1 = st + 264
	tw2 = v1
	tw1 = v1
	for {
		scratch[int32(1)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		scratch[int32(1)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		scratch[int32(2)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi)
		scratch[int32(2)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr)
		scratch[int32(3)].Fr = scratch[int32(1)].Fr + scratch[int32(2)].Fr
		scratch[int32(3)].Fi = scratch[int32(1)].Fi + scratch[int32(2)].Fi
		scratch[0].Fr = scratch[int32(1)].Fr - scratch[int32(2)].Fr
		scratch[0].Fi = scratch[int32(1)].Fi - scratch[int32(2)].Fi
		tw1 = tw1 + uintptr(fstride)*8
		tw2 = tw2 + uintptr(fstride*uint64(2))*8
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - float32(scratch[int32(3)].Fr*libc.Float32FromFloat64(0.5))
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - float32(scratch[int32(3)].Fi*libc.Float32FromFloat64(0.5))
		scratch[0].Fr *= epi3.Fi
		scratch[0].Fi *= epi3.Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr + scratch[0].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi - scratch[0].Fr
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr -= scratch[0].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi += scratch[0].Fr
		Fout += 8
		goto _3
	_3:
		;
		k = k - 1
		v2 = k
		if !(v2 != 0) {
			break
		}
	}
}

func kf_bfly4(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout_beg, tw1, tw2, tw3, v3, v4 uintptr
	var i, j, m2, m3 int32
	var scratch [6]OpusT_kiss_fft_cpx
	var scratch0, scratch1 OpusT_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _, _, _ = Fout_beg, i, j, m2, m3, scratch, scratch0, scratch1, tw1, tw2, tw3, v3, v4
	if m == int32(1) {
		/* Degenerate case where all the twiddles are 1. */
		i = 0
		for {
			if !(i < N) {
				break
			}
			scratch0.Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr
			scratch0.Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi
			scratch1.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr
			scratch1.Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch1.Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 2*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch1.Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch1.Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch1.Fi
			scratch1.Fr = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr
			scratch1.Fi = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fr = scratch0.Fr + scratch1.Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 1*8))).Fi = scratch0.Fi - scratch1.Fr
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fr = scratch0.Fr - scratch1.Fi
			(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + 3*8))).Fi = scratch0.Fi + scratch1.Fr
			Fout = Fout + uintptr(4)*8
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		m2 = int32(2) * m
		m3 = int32(3) * m
		Fout_beg = Fout
		i = 0
		for {
			if !(i < N) {
				break
			}
			Fout = Fout_beg + uintptr(i*mm)*8
			v4 = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
			tw1 = v4
			v3 = v4
			tw2 = v3
			tw3 = v3
			/* m is guaranteed to be a multiple of 4. */
			j = 0
			for {
				if !(j < m) {
					break
				}
				scratch[0].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi)
				scratch[0].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw1)).Fr)
				scratch[int32(1)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi)
				scratch[int32(1)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw2)).Fr)
				scratch[int32(2)].Fr = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fr) - float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fi)
				scratch[int32(2)].Fi = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw3)).Fr)
				scratch[int32(5)].Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(1)].Fr
				scratch[int32(5)].Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(1)].Fi
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(1)].Fr
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(1)].Fi
				scratch[int32(3)].Fr = scratch[0].Fr + scratch[int32(2)].Fr
				scratch[int32(3)].Fi = scratch[0].Fi + scratch[int32(2)].Fi
				scratch[int32(4)].Fr = scratch[0].Fr - scratch[int32(2)].Fr
				scratch[int32(4)].Fi = scratch[0].Fi - scratch[int32(2)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(3)].Fr
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(3)].Fi
				tw1 = tw1 + uintptr(fstride)*8
				tw2 = tw2 + uintptr(fstride*uint64(2))*8
				tw3 = tw3 + uintptr(fstride*uint64(3))*8
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
				(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
				(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
				Fout += 8
				goto _5
			_5:
				;
				j = j + 1
			}
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func kf_bfly41(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m OpusT_size_t) {
	var k, m2, m3, v3 OpusT_size_t
	var scratch [6]OpusT_mini_kiss_fft_cpx
	var tw1, tw2, tw3, v1, v2 uintptr
	_, _, _, _, _, _, _, _, _, _ = k, m2, m3, scratch, tw1, tw2, tw3, v1, v2, v3
	k = m
	m2 = uint64(2) * m
	m3 = uint64(3) * m
	v2 = st + 264
	tw1 = v2
	v1 = v2
	tw2 = v1
	tw3 = v1
	for {
		scratch[0].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi)
		scratch[0].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw1)).Fr)
		scratch[int32(1)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi)
		scratch[int32(1)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw2)).Fr)
		scratch[int32(2)].Fr = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fr) - float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fi)
		scratch[int32(2)].Fi = float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fi) + float32((*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw3)).Fr)
		scratch[int32(5)].Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(1)].Fr
		scratch[int32(5)].Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(1)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(1)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(1)].Fi
		scratch[int32(3)].Fr = scratch[0].Fr + scratch[int32(2)].Fr
		scratch[int32(3)].Fi = scratch[0].Fi + scratch[int32(2)].Fi
		scratch[int32(4)].Fr = scratch[0].Fr - scratch[int32(2)].Fr
		scratch[int32(4)].Fi = scratch[0].Fi - scratch[int32(2)].Fi
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fr = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr - scratch[int32(3)].Fr
		(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m2)*8))).Fi = (*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi - scratch[int32(3)].Fi
		tw1 = tw1 + uintptr(fstride)*8
		tw2 = tw2 + uintptr(fstride*uint64(2))*8
		tw3 = tw3 + uintptr(fstride*uint64(3))*8
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fr += scratch[int32(3)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)).Fi += scratch[int32(3)].Fi
		if (*mini_kiss_fft_state)(unsafe.Pointer(st)).Finverse != 0 {
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
		} else {
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fr = scratch[int32(5)].Fr + scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m)*8))).Fi = scratch[int32(5)].Fi - scratch[int32(4)].Fr
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fr = scratch[int32(5)].Fr - scratch[int32(4)].Fi
			(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout + uintptr(m3)*8))).Fi = scratch[int32(5)].Fi + scratch[int32(4)].Fr
		}
		Fout += 8
		goto _4
	_4:
		;
		k = k - 1
		v3 = k
		if !(v3 != 0) {
			break
		}
	}
}

func kf_bfly5(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st uintptr, m int32, N int32, mm int32) {
	var Fout0, Fout1, Fout2, Fout3, Fout4, Fout_beg, tw uintptr
	var i, u int32
	var scratch [13]OpusT_kiss_fft_cpx
	var ya, yb OpusT_kiss_twiddle_cpx
	_, _, _, _, _, _, _, _, _, _, _, _ = Fout0, Fout1, Fout2, Fout3, Fout4, Fout_beg, i, scratch, tw, u, ya, yb
	Fout_beg = Fout
	ya = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	yb = *(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer((*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles + uintptr(fstride*uint64(2)*libc.Uint64FromInt32(m))*8))
	tw = (*OpusT_kiss_fft_state)(unsafe.Pointer(st)).Ftwiddles
	i = 0
	for {
		if !(i < N) {
			break
		}
		Fout = Fout_beg + uintptr(i*mm)*8
		Fout0 = Fout
		Fout1 = Fout0 + uintptr(m)*8
		Fout2 = Fout0 + uintptr(int32(2)*m)*8
		Fout3 = Fout0 + uintptr(int32(3)*m)*8
		Fout4 = Fout0 + uintptr(int32(4)*m)*8
		/* For non-custom modes, m is guaranteed to be a multiple of 4. */
		u = 0
		for {
			if !(u < m) {
				break
			}
			scratch[0] = *(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0))
			scratch[int32(1)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi)
			scratch[int32(1)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr)
			scratch[int32(2)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi)
			scratch[int32(2)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr)
			scratch[int32(3)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi)
			scratch[int32(3)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr)
			scratch[int32(4)].Fr = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr) - float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi)
			scratch[int32(4)].Fi = float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi) + float32((*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_kiss_twiddle_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr)
			scratch[int32(7)].Fr = scratch[int32(1)].Fr + scratch[int32(4)].Fr
			scratch[int32(7)].Fi = scratch[int32(1)].Fi + scratch[int32(4)].Fi
			scratch[int32(10)].Fr = scratch[int32(1)].Fr - scratch[int32(4)].Fr
			scratch[int32(10)].Fi = scratch[int32(1)].Fi - scratch[int32(4)].Fi
			scratch[int32(8)].Fr = scratch[int32(2)].Fr + scratch[int32(3)].Fr
			scratch[int32(8)].Fi = scratch[int32(2)].Fi + scratch[int32(3)].Fi
			scratch[int32(9)].Fr = scratch[int32(2)].Fr - scratch[int32(3)].Fr
			scratch[int32(9)].Fi = scratch[int32(2)].Fi - scratch[int32(3)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fr = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fr + (scratch[int32(7)].Fr + scratch[int32(8)].Fr)
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fi = (*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout0)).Fi + (scratch[int32(7)].Fi + scratch[int32(8)].Fi)
			scratch[int32(5)].Fr = scratch[0].Fr + (float32(scratch[int32(7)].Fr*ya.Fr) + float32(scratch[int32(8)].Fr*yb.Fr))
			scratch[int32(5)].Fi = scratch[0].Fi + (float32(scratch[int32(7)].Fi*ya.Fr) + float32(scratch[int32(8)].Fi*yb.Fr))
			scratch[int32(6)].Fr = float32(scratch[int32(10)].Fi*ya.Fi) + float32(scratch[int32(9)].Fi*yb.Fi)
			scratch[int32(6)].Fi = -(float32(scratch[int32(10)].Fr*ya.Fi) + float32(scratch[int32(9)].Fr*yb.Fi))
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr = scratch[int32(5)].Fr - scratch[int32(6)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi = scratch[int32(5)].Fi - scratch[int32(6)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr = scratch[int32(5)].Fr + scratch[int32(6)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi = scratch[int32(5)].Fi + scratch[int32(6)].Fi
			scratch[int32(11)].Fr = scratch[0].Fr + (float32(scratch[int32(7)].Fr*yb.Fr) + float32(scratch[int32(8)].Fr*ya.Fr))
			scratch[int32(11)].Fi = scratch[0].Fi + (float32(scratch[int32(7)].Fi*yb.Fr) + float32(scratch[int32(8)].Fi*ya.Fr))
			scratch[int32(12)].Fr = float32(scratch[int32(9)].Fi*ya.Fi) - float32(scratch[int32(10)].Fi*yb.Fi)
			scratch[int32(12)].Fi = float32(scratch[int32(10)].Fr*yb.Fi) - float32(scratch[int32(9)].Fr*ya.Fi)
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = scratch[int32(11)].Fr + scratch[int32(12)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = scratch[int32(11)].Fi + scratch[int32(12)].Fi
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr = scratch[int32(11)].Fr - scratch[int32(12)].Fr
			(*OpusT_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi = scratch[int32(11)].Fi - scratch[int32(12)].Fi
			Fout0 += 8
			Fout1 += 8
			Fout2 += 8
			Fout3 += 8
			Fout4 += 8
			goto _2
		_2:
			;
			u = u + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
}

func kf_bfly51(tls *libc.TLS, Fout uintptr, fstride OpusT_size_t, st OpusT_mini_kiss_fft_cfg, m int32) {
	var Fout0, Fout1, Fout2, Fout3, Fout4, tw, twiddles uintptr
	var scratch [13]OpusT_mini_kiss_fft_cpx
	var u int32
	var ya, yb OpusT_mini_kiss_fft_cpx
	_, _, _, _, _, _, _, _, _, _, _ = Fout0, Fout1, Fout2, Fout3, Fout4, scratch, tw, twiddles, u, ya, yb
	twiddles = st + 264
	ya = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(twiddles + uintptr(fstride*libc.Uint64FromInt32(m))*8))
	yb = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(twiddles + uintptr(fstride*uint64(2)*libc.Uint64FromInt32(m))*8))
	Fout0 = Fout
	Fout1 = Fout0 + uintptr(m)*8
	Fout2 = Fout0 + uintptr(int32(2)*m)*8
	Fout3 = Fout0 + uintptr(int32(3)*m)*8
	Fout4 = Fout0 + uintptr(int32(4)*m)*8
	tw = st + 264
	u = 0
	for {
		if !(u < m) {
			break
		}
		scratch[0] = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout0))
		scratch[int32(1)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi)
		scratch[int32(1)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(u)*fstride)*8))).Fr)
		scratch[int32(2)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi)
		scratch[int32(2)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(2)*u)*fstride)*8))).Fr)
		scratch[int32(3)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi)
		scratch[int32(3)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(3)*u)*fstride)*8))).Fr)
		scratch[int32(4)].Fr = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr) - float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi)
		scratch[int32(4)].Fi = float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fi) + float32((*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi*(*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(tw + uintptr(libc.Uint64FromInt32(int32(4)*u)*fstride)*8))).Fr)
		scratch[int32(7)].Fr = scratch[int32(1)].Fr + scratch[int32(4)].Fr
		scratch[int32(7)].Fi = scratch[int32(1)].Fi + scratch[int32(4)].Fi
		scratch[int32(10)].Fr = scratch[int32(1)].Fr - scratch[int32(4)].Fr
		scratch[int32(10)].Fi = scratch[int32(1)].Fi - scratch[int32(4)].Fi
		scratch[int32(8)].Fr = scratch[int32(2)].Fr + scratch[int32(3)].Fr
		scratch[int32(8)].Fi = scratch[int32(2)].Fi + scratch[int32(3)].Fi
		scratch[int32(9)].Fr = scratch[int32(2)].Fr - scratch[int32(3)].Fr
		scratch[int32(9)].Fi = scratch[int32(2)].Fi - scratch[int32(3)].Fi
		*(*float32)(unsafe.Pointer(Fout0)) += scratch[int32(7)].Fr + scratch[int32(8)].Fr
		*(*float32)(unsafe.Pointer(Fout0 + 4)) += scratch[int32(7)].Fi + scratch[int32(8)].Fi
		scratch[int32(5)].Fr = scratch[0].Fr + float32(scratch[int32(7)].Fr*ya.Fr) + float32(scratch[int32(8)].Fr*yb.Fr)
		scratch[int32(5)].Fi = scratch[0].Fi + float32(scratch[int32(7)].Fi*ya.Fr) + float32(scratch[int32(8)].Fi*yb.Fr)
		scratch[int32(6)].Fr = float32(scratch[int32(10)].Fi*ya.Fi) + float32(scratch[int32(9)].Fi*yb.Fi)
		scratch[int32(6)].Fi = -float32(scratch[int32(10)].Fr*ya.Fi) - float32(scratch[int32(9)].Fr*yb.Fi)
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fr = scratch[int32(5)].Fr - scratch[int32(6)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout1)).Fi = scratch[int32(5)].Fi - scratch[int32(6)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fr = scratch[int32(5)].Fr + scratch[int32(6)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout4)).Fi = scratch[int32(5)].Fi + scratch[int32(6)].Fi
		scratch[int32(11)].Fr = scratch[0].Fr + float32(scratch[int32(7)].Fr*yb.Fr) + float32(scratch[int32(8)].Fr*ya.Fr)
		scratch[int32(11)].Fi = scratch[0].Fi + float32(scratch[int32(7)].Fi*yb.Fr) + float32(scratch[int32(8)].Fi*ya.Fr)
		scratch[int32(12)].Fr = -float32(scratch[int32(10)].Fi*yb.Fi) + float32(scratch[int32(9)].Fi*ya.Fi)
		scratch[int32(12)].Fi = float32(scratch[int32(10)].Fr*yb.Fi) - float32(scratch[int32(9)].Fr*ya.Fi)
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fr = scratch[int32(11)].Fr + scratch[int32(12)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout2)).Fi = scratch[int32(11)].Fi + scratch[int32(12)].Fi
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fr = scratch[int32(11)].Fr - scratch[int32(12)].Fr
		(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout3)).Fi = scratch[int32(11)].Fi - scratch[int32(12)].Fi
		Fout0 += 8
		Fout1 += 8
		Fout2 += 8
		Fout3 += 8
		Fout4 += 8
		goto _1
	_1:
		;
		u = u + 1
	}
}

func kf_factor(tls *libc.TLS, n int32, facbuf uintptr) {
	var floor_sqrt float64
	var p int32
	var v1 uintptr
	_, _, _ = floor_sqrt, p, v1
	p = int32(4)
	floor_sqrt = libc.Xfloor(tls, libc.Xsqrt(tls, float64(n)))
	/*factor out powers of 4, powers of 2, then any remaining primes */
	for cond := true; cond; cond = n > int32(1) {
		for n%p != 0 {
			switch p {
			case int32(4):
				p = int32(2)
			case int32(2):
				p = int32(3)
			default:
				p = p + int32(2)
				break
			}
			if float64(p) > floor_sqrt {
				p = n
			} /* no more factors, skip to end */
		}
		n = n / p
		v1 = facbuf
		facbuf += 4
		*(*int32)(unsafe.Pointer(v1)) = p
		v1 = facbuf
		facbuf += 4
		*(*int32)(unsafe.Pointer(v1)) = n
	}
}

// C documentation
//
//	/*
//	 *
//	 * User-callable function to allocate all necessary storage space for the fft.
//	 *
//	 * The return value is a contiguous block of memory, allocated with malloc.  As such,
//	 * It can be freed with free(), rather than a kiss_fft-specific function.
//	 * */

func kf_work(tls *libc.TLS, Fout uintptr, f uintptr, fstride OpusT_size_t, in_stride int32, factors uintptr, st OpusT_mini_kiss_fft_cfg) {
	var Fout_beg, Fout_end, v1, v2, v3 uintptr
	var m, p int32
	_, _, _, _, _, _, _ = Fout_beg, Fout_end, m, p, v1, v2, v3
	Fout_beg = Fout
	v1 = factors
	factors += 4
	p = *(*int32)(unsafe.Pointer(v1))
	v2 = factors
	factors += 4                      /* the radix  */
	m = *(*int32)(unsafe.Pointer(v2)) /* stage's fft length/p */
	Fout_end = Fout + uintptr(p*m)*8
	if m == int32(1) {
		for {
			*(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(Fout)) = *(*OpusT_mini_kiss_fft_cpx)(unsafe.Pointer(f))
			f = f + uintptr(fstride*libc.Uint64FromInt32(in_stride))*8
			goto _4
		_4:
			;
			Fout += 8
			v3 = Fout
			if !(v3 != Fout_end) {
				break
			}
		}
	} else {
		for {
			/* recursive call:
			   DFT of size m*p performed by doing
			   p instances of smaller DFTs of size m,
			   each one takes a decimated version of the input */
			kf_work(tls, Fout, f, fstride*libc.Uint64FromInt32(p), in_stride, factors, st)
			f = f + uintptr(fstride*libc.Uint64FromInt32(in_stride))*8
			goto _5
		_5:
			;
			Fout = Fout + uintptr(m)*8
			if !(Fout != Fout_end) {
				break
			}
		}
	}
	Fout = Fout_beg
	/* recombine the p smaller DFTs*/
	switch p {
	case int32(2):
		kf_bfly21(tls, Fout, fstride, st, m)
	case int32(3):
		kf_bfly31(tls, Fout, fstride, st, libc.Uint64FromInt32(m))
	case int32(4):
		kf_bfly41(tls, Fout, fstride, st, libc.Uint64FromInt32(m))
	case int32(5):
		kf_bfly51(tls, Fout, fstride, st, m)
	default:
		libc.X__assert_fail(tls, __ccgo_ts+6502, __ccgo_ts+6504, int32(317), uintptr(unsafe.Pointer(&__func__)))
	}
}

var __func__ = [8]int8{'k', 'f', '_', 'w', 'o', 'r', 'k'}

// C documentation
//
//	/*  facbuf is populated by p1,m1,p2,m2, ...
//	    where
//	    p[i] * m[i] = m[i-1]
//	    m0 = n                  */

func l1_metric(tls *libc.TLS, tmp uintptr, N int32, LM int32, bias OpusT_opus_val16) (r OpusT_opus_val32) {
	var L1 OpusT_opus_val32
	var i int32
	_, _ = L1, i
	L1 = libc.Float32FromInt32(0)
	i = 0
	for {
		if !(i < N) {
			break
		}
		L1 = L1 + float32(libc.Xfabs(tls, float64(*(*OpusT_celt_norm)(unsafe.Pointer(tmp + uintptr(i)*4)))))
		goto _1
	_1:
		;
		i = i + 1
	}
	/* When in doubt, prefer good freq resolution */
	L1 = L1 + OpusT_opus_val32(OpusT_opus_val16(float32(LM)*bias)*L1)
	return L1
}

func limit_coefs(tls *libc.TLS, coefs uintptr, limit float32, order int32) {
	var chirp, maxabs, tmp float32
	var i, ind, iter int32
	_, _, _, _, _, _ = chirp, i, ind, iter, maxabs, tmp
	ind = 0
	iter = 0
	for {
		if !(iter < int32(10)) {
			break
		}
		/* Find maximum absolute value */
		maxabs = -libc.Float32FromFloat32(1)
		i = 0
		for {
			if !(i < order) {
				break
			}
			tmp = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)))))
			if tmp > maxabs {
				maxabs = tmp
				ind = i
			}
			goto _2
		_2:
			;
			i = i + 1
		}
		if maxabs <= limit {
			/* Coefficients are within range - done */
			return
		}
		/* Apply bandwidth expansion */
		chirp = libc.Float32FromFloat32(0.99) - float32((libc.Float32FromFloat32(0.8)+float32(libc.Float32FromFloat32(0.1)*float32(iter)))*(maxabs-limit))/float32(maxabs*float32(ind+libc.Int32FromInt32(1)))
		Opus_silk_bwexpander_FLP(tls, coefs, order, chirp)
		goto _1
	_1:
		;
		iter = iter + 1
	}
	_ = libc.Int32FromInt32(0)
}

// C documentation
//
//	/* Compute noise shaping coefficients and initial gain values */

func logSum(tls *libc.TLS, a OpusT_celt_glog, b OpusT_celt_glog) (r OpusT_opus_val16) {
	var diff, frac, max OpusT_celt_glog
	var low int32
	_, _, _, _ = diff, frac, low, max
	if a > b {
		max = a
		diff = a - b
	} else {
		max = b
		diff = b - a
	}
	if !(diff < libc.Float32FromFloat32(8)) { /* inverted to catch NaNs */
		return max
	}
	low = int32(libc.Xfloor(tls, float64(libc.Float32FromInt32(2)*diff)))
	frac = OpusT_celt_glog(libc.Float32FromInt32(2)*diff) - float32(low)
	return max + diff_table[low] + OpusT_celt_glog(frac*(diff_table[low+int32(1)]-diff_table[low]))
}

var diff_table = [17]OpusT_celt_glog{
	0: libc.Float32FromFloat32(0.5),
	1: libc.Float32FromFloat32(0.2924813),
	2: libc.Float32FromFloat32(0.160964),
	3: libc.Float32FromFloat32(0.0849625),
	4: libc.Float32FromFloat32(0.0437314),
	5: libc.Float32FromFloat32(0.0221971),
	6: libc.Float32FromFloat32(0.0111839),
	7: libc.Float32FromFloat32(0.0056136),
	8: libc.Float32FromFloat32(0.0028123),
}

type OpusT___ccgo_fp__Xsurround_analysis_9 = func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr)

func loss_distortion(tls *libc.TLS, eBands uintptr, oldEBands uintptr, start int32, end int32, len1 int32, C int32) (r OpusT_opus_val32) {
	var c, i, v1 int32
	var d OpusT_celt_glog
	var dist, v4 OpusT_opus_val32
	_, _, _, _, _, _ = c, d, dist, i, v1, v4
	dist = libc.Float32FromInt32(0)
	c = 0
	for {
		i = start
		for {
			if !(i < end) {
				break
			}
			d = *(*OpusT_celt_glog)(unsafe.Pointer(eBands + uintptr(i+c*len1)*4)) - *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*len1)*4))
			dist = dist + OpusT_opus_val32(d*d)
			goto _3
		_3:
			;
			i = i + 1
		}
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < C) {
			break
		}
	}
	if float32(libc.Int32FromInt32(200)) < dist {
		v4 = float32(libc.Int32FromInt32(200))
	} else {
		v4 = dist
	}
	return v4
}

func lrint_ties_to_even_double(tls *libc.TLS, x float64) (r int64) {
	var frac float64
	var i int64
	_, _ = frac, i
	i = int64(x) /* truncates toward 0 */
	frac = x - float64(i)
	if x >= libc.Float64FromInt32(0) {
		if frac > float64(0.5) {
			return i + int64(1)
		}
		if frac < float64(0.5) {
			return i
		}
		return i + i&int64(1)
	} else {
		if frac < -libc.Float64FromFloat64(0.5) {
			return i - int64(1)
		}
		if frac > -libc.Float64FromFloat64(0.5) {
			return i
		}
		return i - i&int64(1)
	}
	return r
}

func lrintf_ties_to_even_float(tls *libc.TLS, x float32) (r int64) {
	var frac float32
	var i int64
	_, _ = frac, i
	i = int64(x) /* truncates toward 0 */
	frac = x - float32(i)
	if x >= libc.Float32FromInt32(0) {
		if frac > libc.Float32FromFloat32(0.5) {
			return i + int64(1)
		}
		if frac < libc.Float32FromFloat32(0.5) {
			return i
		}
		/* frac == 0.5 */
		return i + i&int64(1)
	} else {
		if frac < -libc.Float32FromFloat32(0.5) {
			return i - int64(1)
		}
		if frac > -libc.Float32FromFloat32(0.5) {
			return i
		}
		/* frac == -0.5 */
		return i - i&int64(1)
	}
	return r
}

func median_of_3(tls *libc.TLS, x uintptr) (r OpusT_celt_glog) {
	var t0, t1, t2 OpusT_celt_glog
	_, _, _ = t0, t1, t2
	if *(*OpusT_celt_glog)(unsafe.Pointer(x)) > *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4)) {
		t0 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4))
		t1 = *(*OpusT_celt_glog)(unsafe.Pointer(x))
	} else {
		t0 = *(*OpusT_celt_glog)(unsafe.Pointer(x))
		t1 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4))
	}
	t2 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 2*4))
	if t1 < t2 {
		return t1
	} else {
		if t0 < t2 {
			return t2
		} else {
			return t0
		}
	}
	return r
}

func median_of_5(tls *libc.TLS, x uintptr) (r OpusT_celt_glog) {
	var t0, t1, t2, t3, t4, tmp, tmp1, v1 OpusT_celt_glog
	_, _, _, _, _, _, _, _ = t0, t1, t2, t3, t4, tmp, tmp1, v1
	t2 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 2*4))
	if *(*OpusT_celt_glog)(unsafe.Pointer(x)) > *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4)) {
		t0 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4))
		t1 = *(*OpusT_celt_glog)(unsafe.Pointer(x))
	} else {
		t0 = *(*OpusT_celt_glog)(unsafe.Pointer(x))
		t1 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 1*4))
	}
	if *(*OpusT_celt_glog)(unsafe.Pointer(x + 3*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(x + 4*4)) {
		t3 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 4*4))
		t4 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 3*4))
	} else {
		t3 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 3*4))
		t4 = *(*OpusT_celt_glog)(unsafe.Pointer(x + 4*4))
	}
	if t0 > t3 {
		tmp = t0
		t0 = t3
		t3 = tmp
		tmp1 = t1
		t1 = t4
		t4 = tmp1
	}
	if t2 > t1 {
		if t1 < t3 {
			if t2 < t3 {
				v1 = t2
			} else {
				v1 = t3
			}
			return v1
		} else {
			if t4 < t1 {
				v1 = t4
			} else {
				v1 = t1
			}
			return v1
		}
	} else {
		if t2 < t3 {
			if t1 < t3 {
				v1 = t1
			} else {
				v1 = t3
			}
			return v1
		} else {
			if t2 < t4 {
				v1 = t2
			} else {
				v1 = t4
			}
			return v1
		}
	}
	return r
}

func ms_get_preemph_mem(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var coupled_size, mono_size, s, v1 int32
	var ptr uintptr
	_, _, _, _, _, _ = alignment, coupled_size, mono_size, ptr, s, v1
	coupled_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(2), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	mono_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(1), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	s = 0
	for {
		if !(s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _5
		_5:
			ptr = ptr + uintptr(v1)
		} else {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _7
		_7:
			ptr = ptr + uintptr(v1)
		}
		goto _3
	_3:
		;
		s = s + 1
	}
	/* void* cast avoids clang -Wcast-align warning */
	return ptr + uintptr(libc.Uint64FromInt32((*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels*libc.Int32FromInt32(MAX_OVERLAP))*libc.Uint64FromInt64(4))
}

func ms_get_window_mem(tls *libc.TLS, st uintptr) (r uintptr) {
	var alignment uint32
	var coupled_size, mono_size, s, v1 int32
	var ptr uintptr
	_, _, _, _, _, _ = alignment, coupled_size, mono_size, ptr, s, v1
	coupled_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(2), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	mono_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs, int32(1), (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication)
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	s = 0
	for {
		if !(s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		if s < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
			goto _5
		_5:
			ptr = ptr + uintptr(v1)
		} else {
			alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
			v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
			goto _7
		_7:
			ptr = ptr + uintptr(v1)
		}
		goto _3
	_3:
		;
		s = s + 1
	}
	/* void* cast avoids clang -Wcast-align warning */
	return ptr
}

func normalise_residual(tls *libc.TLS, iy uintptr, X uintptr, N int32, Ryy OpusT_opus_val32, gain OpusT_opus_val32, shift int32) {
	var g, t OpusT_opus_val32
	var i, v1 int32
	_, _, _, _ = g, i, t, v1
	t = Ryy
	g = float32(libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t))) * gain)
	i = 0
	_ = shift
	for {
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(i)*4)) = OpusT_opus_val32(float32(*(*int32)(unsafe.Pointer(iy + uintptr(i)*4))) * g)
		goto _2
	_2:
		;
		i = i + 1
		v1 = i
		if !(v1 < N) {
			break
		}
	}
}

func opus_copy_channel_in_float(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	var float_src uintptr
	var i OpusT_opus_int32
	_, _ = float_src, i
	_ = user_data
	float_src = src
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		*(*OpusT_opus_res)(unsafe.Pointer(dst + uintptr(i*dst_stride)*4)) = *(*float32)(unsafe.Pointer(float_src + uintptr(i*src_stride+src_channel)*4))
		goto _1
	_1:
		;
		i = i + 1
	}
}

func opus_copy_channel_in_int24(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_src uintptr
	_, _ = i, short_src
	_ = user_data
	short_src = src
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		*(*OpusT_opus_res)(unsafe.Pointer(dst + uintptr(i*dst_stride)*4)) = float32(libc.Float32FromFloat32(1) / libc.Float32FromFloat32(32768) / libc.Float32FromFloat32(256) * float32(*(*OpusT_opus_int32)(unsafe.Pointer(short_src + uintptr(i*src_stride+src_channel)*4))))
		goto _1
	_1:
		;
		i = i + 1
	}
}

func opus_copy_channel_in_short(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_src uintptr
	_, _ = i, short_src
	_ = user_data
	short_src = src
	i = 0
	for {
		if !(i < frame_size) {
			break
		}
		*(*OpusT_opus_res)(unsafe.Pointer(dst + uintptr(i*dst_stride)*4)) = float32(float32(*(*OpusT_opus_int16)(unsafe.Pointer(short_src + uintptr(i*src_stride+src_channel)*2))) * (libc.Float32FromInt32(1) / libc.Float32FromFloat32(32768)))
		goto _1
	_1:
		;
		i = i + 1
	}
}

func opus_copy_channel_out_float(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var float_dst uintptr
	var i OpusT_opus_int32
	_, _ = float_dst, i
	_ = user_data
	float_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*float32)(unsafe.Pointer(float_dst + uintptr(i*dst_stride+dst_channel)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4))
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*float32)(unsafe.Pointer(float_dst + uintptr(i*dst_stride+dst_channel)*4)) = libc.Float32FromInt32(0)
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func opus_copy_channel_out_int24(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_dst uintptr
	_, _ = i, short_dst
	_ = user_data
	short_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*4)) = int32(Opus_lrintf(tls, float32(float32(libc.Float32FromFloat32(32768)*libc.Float32FromFloat32(256))**(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4)))))
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*4)) = 0
			goto _2
		_2:
			;
			i = i + 1
		}
	}
}

func opus_copy_channel_out_short(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var i OpusT_opus_int32
	var short_dst uintptr
	var v2, v3, v4 float32
	var v5 OpusT_opus_int16
	_, _, _, _, _, _ = i, short_dst, v2, v3, v4, v5
	_ = user_data
	short_dst = dst
	if src != libc.UintptrFromInt32(0) {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			v2 = *(*OpusT_opus_res)(unsafe.Pointer(src + uintptr(i*src_stride)*4))
			v2 = float32(v2 * libc.Float32FromFloat32(32768))
			if v2 > float32(-libc.Int32FromInt32(32768)) {
				v3 = v2
			} else {
				v3 = float32(-libc.Int32FromInt32(32768))
			}
			v2 = v3
			if v2 < float32(libc.Int32FromInt32(32767)) {
				v4 = v2
			} else {
				v4 = float32(libc.Int32FromInt32(32767))
			}
			v2 = v4
			v5 = int16(Opus_lrintf(tls, v2))
			goto _6
		_6:
			*(*OpusT_opus_int16)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*2)) = v5
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < frame_size) {
				break
			}
			*(*OpusT_opus_int16)(unsafe.Pointer(short_dst + uintptr(i*dst_stride+dst_channel)*2)) = 0
			goto _7
		_7:
			;
			i = i + 1
		}
	}
}

func opus_custom_decoder_get_size(tls *libc.TLS, mode uintptr, channels int32) (r int32) {
	var size int32
	_ = size
	size = libc.Int32FromUint64(uint64(120) + libc.Uint64FromInt32(channels*(libc.Int32FromInt32(DEC_PITCH_BUF_SIZE)+(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap)-libc.Int32FromInt32(1))*uint64(4) + libc.Uint64FromInt32(libc.Int32FromInt32(4)*libc.Int32FromInt32(2)*(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands)*uint64(4) + libc.Uint64FromInt32(channels*int32(CELT_LPC_ORDER))*uint64(4))
	return size
}

func opus_custom_decoder_init(tls *libc.TLS, st uintptr, mode uintptr, channels int32) (r int32) {
	var v1 int32
	_ = v1
	if channels < 0 || channels > int32(2) {
		return -int32(1)
	}
	if st == libc.UintptrFromInt32(0) {
		return -int32(7)
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(opus_custom_decoder_get_size(tls, mode, channels))*uint64(1))
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode = mode
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Foverlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	v1 = channels
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdownsample = int32(1)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fstart = 0
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fend = (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fmode)).FeffEBands
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fsignalling = int32(1)
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Fdisable_inv = libc.BoolInt32(channels == int32(1))
	v1 = 0
	goto _3
_3:
	(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st)).Farch = v1
	Opus_opus_custom_decoder_ctl(tls, st, int32(OPUS_RESET_STATE), 0)
	return OPUS_OK
}

// C documentation
//
//	/* Special case for stereo with no downsampling and no accumulation. This is
//	   quite common and we can make it faster by processing both channels in the
//	   same loop, reducing overhead due to the dependency loop in the IIR filter. */

func opus_custom_encoder_get_size(tls *libc.TLS, mode uintptr, channels int32) (r int32) {
	var extra, size int32
	_, _ = extra, size
	extra = 0
	size = libc.Int32FromUint64(uint64(256) + libc.Uint64FromInt32(channels*(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap-libc.Int32FromInt32(1))*uint64(4) + libc.Uint64FromInt32(channels*int32(COMBFILTER_MAXPERIOD))*uint64(4) + libc.Uint64FromInt32(int32(4)*channels*(*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FnbEBands)*uint64(4) + libc.Uint64FromInt32(extra))
	return size
}

func opus_custom_encoder_init_arch(tls *libc.TLS, st uintptr, mode uintptr, channels int32, arch int32) (r int32) {
	var v1 int32
	_ = v1
	if channels < 0 || channels > int32(2) {
		return -int32(1)
	}
	if st == libc.UintptrFromInt32(0) || mode == libc.UintptrFromInt32(0) {
		return -int32(7)
	}
	libc.Xmemset(tls, st, 0, libc.Uint64FromInt32(opus_custom_encoder_get_size(tls, mode, channels))*uint64(1))
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode = mode
	v1 = channels
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fchannels = v1
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fstream_channels = v1
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fupsample = int32(1)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fstart = 0
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fend = (*OpusT_OpusCustomMode)(unsafe.Pointer((*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fmode)).FeffEBands
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fsignalling = int32(1)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Farch = arch
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fconstrained_vbr = int32(1)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fclip = int32(1)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fbitrate = -int32(1)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fvbr = 0
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fforce_intra = 0
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Fcomplexity = int32(5)
	(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st)).Flsb_depth = int32(24)
	Opus_opus_custom_encoder_ctl(tls, st, int32(OPUS_RESET_STATE), 0)
	return OPUS_OK
}

func opus_decode_frame(tls *libc.TLS, st1 uintptr, data uintptr, len1 OpusT_opus_int32, pcm uintptr, frame_size int32, decode_fec int32) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var F10, F20, F2_5, F5, audiosize, bandwidth, c, celt_accum, celt_frame_size, celt_ret, celt_to_silk, decoded_samples, endband, first_frame, i, lost_flag, mode, pcm_silk_size, pcm_too_small, pcm_transition_celt_size, pcm_transition_silk_size, redundancy, redundancy_bytes, redundant_audio_size, ret, silk_ret, start_band, transition, v31, v32 int32
	var _saved_stack, celt_dec, pcm_ptr, pcm_silk, pcm_transition, pcm_transition_celt, pcm_transition_silk, redundant_audio, silk_dec, st, window, v1, v10, v11, v13, v15, v17, v19, v21, v3, v5, v6, v8 uintptr
	var frac, v175, v176 float32
	var gain, x1 OpusT_opus_val32
	var integer OpusT_opus_int32
	var v111 bool
	var _ /* celt_mode at bp+80 */ uintptr
	var _ /* dec at bp+8 */ OpusT_ec_dec
	var _ /* redundant_rng at bp+68 */ OpusT_opus_uint32
	var _ /* res at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* silence at bp+72 */ [2]uint8
	var _ /* silk_frame_size at bp+64 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = F10, F20, F2_5, F5, _saved_stack, audiosize, bandwidth, c, celt_accum, celt_dec, celt_frame_size, celt_ret, celt_to_silk, decoded_samples, endband, first_frame, frac, gain, i, integer, lost_flag, mode, pcm_ptr, pcm_silk, pcm_silk_size, pcm_too_small, pcm_transition, pcm_transition_celt, pcm_transition_celt_size, pcm_transition_silk, pcm_transition_silk_size, redundancy, redundancy_bytes, redundant_audio, redundant_audio_size, ret, silk_dec, silk_ret, st, start_band, transition, window, x1, v1, v10, v11, v111, v13, v15, v17, v175, v176, v19, v21, v3, v31, v32, v5, v6, v8
	silk_ret = 0
	celt_ret = 0
	pcm_transition = libc.UintptrFromInt32(0)
	transition = 0
	redundancy = 0
	redundancy_bytes = 0
	celt_to_silk = 0
	*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 68)) = uint32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _9
_9:
	if (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack == uintptr(0) {
		v13 = libc.Xmalloc(tls, uint64(GLOBAL_STACK_SIZE))
		goto _14
	_14:
		v11 = v13
		goto _12
	_12:
		v10 = v11
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _16
		_16:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _18
	_18:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr = v10
		v5 = v10
	} else {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _20
		_20:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _22
	_22:
		v5 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack
	}
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = v5
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _26
_26:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	silk_dec = st1 + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fsilk_dec_offset)
	celt_dec = st1 + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fcelt_dec_offset)
	F20 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs / int32(50)
	F10 = F20 >> int32(1)
	F5 = F10 >> int32(1)
	F2_5 = F5 >> int32(1)
	if frame_size < F2_5 {
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _28
		_28:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _30
	_30:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(2)
	}
	/* Limit frame_size to avoid excessive stack allocations. */
	if frame_size < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs/int32(25)*int32(3) {
		v31 = frame_size
	} else {
		v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs / int32(25) * int32(3)
	}
	frame_size = v31
	/* Payloads of 1 (2 including ToC) or 0 trigger the PLC/DTX */
	if len1 <= int32(1) {
		data = libc.UintptrFromInt32(0)
		/* In that case, don't conceal more than what the ToC says */
		if frame_size < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size {
			v31 = frame_size
		} else {
			v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size
		}
		frame_size = v31
	}
	if data != libc.UintptrFromInt32(0) {
		audiosize = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fframe_size
		mode = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fmode
		bandwidth = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fbandwidth
		Opus_ec_dec_init(tls, bp+8, data, libc.Uint32FromInt32(len1))
	} else {
		audiosize = frame_size
		/* Run PLC using last used mode (CELT if we ended with CELT redundancy) */
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0 {
			v31 = int32(MODE_CELT_ONLY)
		} else {
			v31 = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode
		}
		mode = v31
		bandwidth = 0
		if mode == 0 {
			/* If we haven't got any packet yet, all we can do is return zeros */
			i = 0
			for {
				if !(i < audiosize*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = libc.Float32FromInt32(0)
				goto _34
			_34:
				;
				i = i + 1
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _36
			_36:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _38
		_38:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return audiosize
		}
		/* Avoids trying to run the PLC on sizes other than 2.5 (CELT), 5 (CELT),
		   10, or 20 (e.g. 12.5 or 30 ms). */
		if audiosize > F20 {
			for cond := true; cond; cond = audiosize > 0 {
				if audiosize < F20 {
					v31 = audiosize
				} else {
					v31 = F20
				}
				ret = opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm, v31, 0)
				if ret < 0 {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _41
					_41:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _43
				_43:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return ret
				}
				pcm = pcm + uintptr(ret*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*4
				audiosize = audiosize - ret
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _45
			_45:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _47
		_47:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return frame_size
		} else {
			if audiosize < F20 {
				if audiosize > F10 {
					audiosize = F10
				} else {
					if mode != int32(MODE_SILK_ONLY) && audiosize > F5 && audiosize < F10 {
						audiosize = F5
					}
				}
			}
		}
	}
	/* In fixed-point, we can tell CELT to do the accumulation on top of the
	   SILK PCM buffer. This saves some stack space. */
	celt_accum = libc.BoolInt32(mode != int32(MODE_CELT_ONLY))
	pcm_transition_silk_size = ALLOC_NONE
	pcm_transition_celt_size = ALLOC_NONE
	if data != libc.UintptrFromInt32(0) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && (mode == int32(MODE_CELT_ONLY) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_CELT_ONLY) && !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) || mode != int32(MODE_CELT_ONLY) && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY)) {
		transition = int32(1)
		/* Decide where to allocate the stack memory for pcm_transition */
		if mode == int32(MODE_CELT_ONLY) {
			pcm_transition_celt_size = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		} else {
			pcm_transition_silk_size = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _49
	_49:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _51
_51:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _53
	_53:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _55
_55:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _57
	_57:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _59
_59:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _61
	_61:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _63
_63:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_transition_celt_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(386))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _65
	_65:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _67
_67:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_transition_celt_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _69
	_69:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _71
_71:
	pcm_transition_celt = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_transition_celt_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if transition != 0 && mode == int32(MODE_CELT_ONLY) {
		pcm_transition = pcm_transition_celt
		if F5 < audiosize {
			v31 = F5
		} else {
			v31 = audiosize
		}
		opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm_transition, v31, 0)
	}
	if audiosize > frame_size {
		/*fprintf(stderr, "PCM buffer too small: %d vs %d (mode = %d)\n", audiosize, frame_size, mode);*/
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _74
		_74:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _76
	_76:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return -int32(1)
	} else {
		frame_size = audiosize
	}
	/* SILK processing */
	if mode != int32(MODE_CELT_ONLY) {
		pcm_silk_size = ALLOC_NONE
		pcm_too_small = libc.BoolInt32(frame_size < F10)
		if pcm_too_small != 0 {
			pcm_silk_size = F10 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _78
		_78:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _80
	_80:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v5 = libc.Xmalloc(tls, uint64(16))
			goto _82
		_82:
			st = v5
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v6 = st
		goto _84
	_84:
		*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v8 = libc.Xmalloc(tls, uint64(16))
			goto _86
		_86:
			st = v8
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v10 = st
		goto _88
	_88:
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v11 = libc.Xmalloc(tls, uint64(16))
			goto _90
		_90:
			st = v11
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v13 = st
		goto _92
	_92:
		if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
			Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(412))
		}
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v15 = libc.Xmalloc(tls, uint64(16))
			goto _94
		_94:
			st = v15
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v17 = st
		goto _96
	_96:
		*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_silk_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v19 = libc.Xmalloc(tls, uint64(16))
			goto _98
		_98:
			st = v19
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v21 = st
		goto _100
	_100:
		pcm_silk = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
		if pcm_too_small != 0 {
			pcm_ptr = pcm_silk
		} else {
			pcm_ptr = pcm
		}
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_CELT_ONLY) {
			Opus_silk_ResetDecoder(tls, silk_dec)
		}
		/* The SILK PLC cannot produce frames of less than 10 ms */
		if int32(10) > int32(1000)*audiosize/(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs {
			v31 = int32(10)
		} else {
			v31 = int32(1000) * audiosize / (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FpayloadSize_ms = v31
		if data != libc.UintptrFromInt32(0) {
			(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FnChannelsInternal = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels
			if mode == int32(MODE_SILK_ONLY) {
				if bandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
					(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(8000)
				} else {
					if bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
						(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(12000)
					} else {
						if bandwidth == int32(OPUS_BANDWIDTH_WIDEBAND) {
							(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
						} else {
							(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
							if !(libc.Int32FromInt32(0) != 0) {
								Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+57, int32(436))
							}
						}
					}
				}
			} else {
				/* Hybrid mode */
				(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.FinternalSampleRate = int32(16000)
			}
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FDecControl.Fenable_deep_plc = libc.BoolInt32((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fcomplexity >= int32(5))
		if data == libc.UintptrFromInt32(0) {
			v31 = int32(1)
		} else {
			v31 = int32(2) * libc.BoolInt32(!!(decode_fec != 0))
		}
		lost_flag = v31
		decoded_samples = 0
		for cond := true; cond; cond = decoded_samples < frame_size {
			/* Call SILK decoder */
			first_frame = libc.BoolInt32(decoded_samples == 0)
			silk_ret = Opus_silk_Decode(tls, silk_dec, st1+16, lost_flag, first_frame, bp+8, pcm_ptr, bp+64, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Farch)
			if silk_ret != 0 {
				if lost_flag != 0 {
					/* PLC failure should not be fatal */
					*(*OpusT_opus_int32)(unsafe.Pointer(bp + 64)) = frame_size
					i = 0
					for {
						if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
							break
						}
						*(*OpusT_opus_res)(unsafe.Pointer(pcm_ptr + uintptr(i)*4)) = libc.Float32FromInt32(0)
						goto _103
					_103:
						;
						i = i + 1
					}
				} else {
					st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
					if !(st != 0) {
						v1 = libc.Xmalloc(tls, uint64(16))
						goto _105
					_105:
						st = v1
						if st != 0 {
							libc.Xmemset(tls, st, 0, uint64(16))
						}
						libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
					}
					v3 = st
					goto _107
				_107:
					(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
					return -int32(3)
				}
			}
			pcm_ptr = pcm_ptr + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 64))*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*4
			decoded_samples = decoded_samples + *(*OpusT_opus_int32)(unsafe.Pointer(bp + 64))
		}
		if pcm_too_small != 0 {
			libc.Xmemcpy(tls, pcm, pcm_silk, libc.Uint64FromInt32(frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4)+libc.Uint64FromInt64(0*((int64(pcm)-int64(pcm_silk))/4)))
		}
	}
	start_band = 0
	if v111 = !(decode_fec != 0) && mode != int32(MODE_CELT_ONLY) && data != libc.UintptrFromInt32(0); v111 {
		v1 = bp + 8
		v31 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _110
	_110:
	}
	if v111 && v31+int32(17)+int32(20)*libc.BoolInt32(mode == int32(MODE_HYBRID)) <= int32(8)*len1 {
		/* Check if we have a redundant 0-8 kHz band */
		if mode == int32(MODE_HYBRID) {
			redundancy = Opus_ec_dec_bit_logp(tls, bp+8, uint32(12))
		} else {
			redundancy = int32(1)
		}
		if redundancy != 0 {
			celt_to_silk = Opus_ec_dec_bit_logp(tls, bp+8, uint32(1))
			/* redundancy_bytes will be at least two, in the non-hybrid
			   case due to the ec_tell() check above */
			if mode == int32(MODE_HYBRID) {
				v31 = libc.Int32FromUint32(Opus_ec_dec_uint(tls, bp+8, uint32(256))) + int32(2)
			} else {
				v1 = bp + 8
				v32 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _115
			_115:
				v31 = len1 - (v32+int32(7))>>int32(3)
			}
			redundancy_bytes = v31
			len1 = len1 - redundancy_bytes
			/* This is a sanity check. It should never happen for a valid
			   packet, so the exact behaviour is not normative. */
			v1 = bp + 8
			v31 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _118
		_118:
			if len1*int32(8) < v31 {
				len1 = 0
				redundancy_bytes = 0
				redundancy = 0
			}
			/* Shrink decoder because of raw bits */
			(*(*OpusT_ec_dec)(unsafe.Pointer(bp + 8))).Fstorage -= libc.Uint32FromInt32(redundancy_bytes)
		}
	}
	if mode != int32(MODE_CELT_ONLY) {
		start_band = int32(17)
	}
	if redundancy != 0 {
		transition = 0
		pcm_transition_silk_size = ALLOC_NONE
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _120
	_120:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _122
_122:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _124
	_124:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _126
_126:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _128
	_128:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _130
_130:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _132
	_132:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _134
_134:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(pcm_transition_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(538))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _136
	_136:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _138
_138:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(pcm_transition_silk_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _140
	_140:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _142
_142:
	pcm_transition_silk = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(pcm_transition_silk_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if transition != 0 && mode != int32(MODE_CELT_ONLY) {
		pcm_transition = pcm_transition_silk
		if F5 < audiosize {
			v31 = F5
		} else {
			v31 = audiosize
		}
		opus_decode_frame(tls, st1, libc.UintptrFromInt32(0), 0, pcm_transition, v31, 0)
	}
	if bandwidth != 0 {
		endband = int32(21)
		switch bandwidth {
		case int32(OPUS_BANDWIDTH_NARROWBAND):
			endband = int32(13)
		case int32(OPUS_BANDWIDTH_MEDIUMBAND):
			fallthrough
		case int32(OPUS_BANDWIDTH_WIDEBAND):
			endband = int32(17)
		case int32(OPUS_BANDWIDTH_SUPERWIDEBAND):
			endband = int32(19)
		case int32(OPUS_BANDWIDTH_FULLBAND):
			endband = int32(21)
		default:
			if !(libc.Int32FromInt32(0) != 0) {
				Opus_celt_fatal(tls, __ccgo_ts+1017, __ccgo_ts+57, int32(567))
			}
			break
		}
		_ = endband == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_END_BAND_REQUEST), libc.VaList(bp+96, endband)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1037, __ccgo_ts+57, int32(570))
		}
	}
	_ = (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels == libc.Int32FromInt32(0)
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_CHANNELS_REQUEST), libc.VaList(bp+96, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fstream_channels)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1172, __ccgo_ts+57, int32(572))
	}
	/* Only allocation memory for redundancy if/when needed */
	if redundancy != 0 {
		v31 = F5 * (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels
	} else {
		v31 = ALLOC_NONE
	}
	redundant_audio_size = v31
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _146
	_146:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _148
_148:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _150
	_150:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v6 = st
	goto _152
_152:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v6)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v8 = libc.Xmalloc(tls, uint64(16))
		goto _154
	_154:
		st = v8
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v10 = st
	goto _156
_156:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _158
	_158:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _160
_160:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(redundant_audio_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v10)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+57, int32(576))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _162
	_162:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _164
_164:
	*(*uintptr)(unsafe.Pointer(v17 + 8)) += uintptr(libc.Uint64FromInt32(redundant_audio_size) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _166
	_166:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _168
_168:
	redundant_audio = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack - uintptr(libc.Uint64FromInt32(redundant_audio_size)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* 5 ms redundant frame for CELT->SILK*/
	if redundancy != 0 && celt_to_silk != 0 {
		/* If the previous frame did not use CELT (the first redundancy frame in
		   a transition from SILK may have been lost) then the CELT decoder is
		   stale at this point and the redundancy audio is not useful, however
		   the final range is still needed (for testing), so the redundancy is
		   always decoded but the decoded audio may not be used */
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(586))
		}
		Opus_celt_decode_with_ec(tls, celt_dec, data+uintptr(len1), redundancy_bytes, redundant_audio, F5, libc.UintptrFromInt32(0), 0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, bp+68+uintptr((OpusT___predefined_ptrdiff_t(bp+68)-int64(bp+68))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1454, __ccgo_ts+57, int32(589))
		}
	}
	/* MUST be after PLC */
	_ = start_band == libc.Int32FromInt32(0)
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, start_band)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1599, __ccgo_ts+57, int32(593))
	}
	if mode != int32(MODE_SILK_ONLY) {
		if F20 < frame_size {
			v31 = F20
		} else {
			v31 = frame_size
		}
		celt_frame_size = v31
		/* Make sure to discard any previous CELT state */
		if mode != (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && !((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
			if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0) == libc.Int32FromInt32(OPUS_OK)) {
				Opus_celt_fatal(tls, __ccgo_ts+1740, __ccgo_ts+57, int32(604))
			}
		}
		/* Decode CELT */
		if decode_fec != 0 {
			v1 = libc.UintptrFromInt32(0)
		} else {
			v1 = data
		}
		celt_ret = Opus_celt_decode_with_ec_dred(tls, celt_dec, v1, len1, pcm, celt_frame_size, bp+8, celt_accum)
		Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, st1+96+uintptr((OpusT___predefined_ptrdiff_t(st1+96)-int64(st1+96))/4)*4))
	} else {
		*(*[2]uint8)(unsafe.Pointer(bp + 72)) = [2]uint8{
			0: uint8(0xFF),
			1: uint8(0xFF),
		}
		if !(celt_accum != 0) {
			i = 0
			for {
				if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = libc.Float32FromInt32(0)
				goto _171
			_171:
				;
				i = i + 1
			}
		}
		/* For hybrid -> SILK transitions, we let the CELT MDCT
		   do a fade-out by decoding a silence frame */
		if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode == int32(MODE_HYBRID) && !(redundancy != 0 && celt_to_silk != 0 && (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
			_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
			if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
				Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(624))
			}
			Opus_celt_decode_with_ec(tls, celt_dec, bp+72, int32(2), pcm, F2_5, libc.UintptrFromInt32(0), celt_accum)
		}
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FrangeFinal = (*(*OpusT_ec_dec)(unsafe.Pointer(bp + 8))).Frng
	}
	if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+96, bp+80+uintptr((OpusT___predefined_ptrdiff_t(bp+80)-int64(bp+80))/8)*8)) == libc.Int32FromInt32(OPUS_OK)) {
		Opus_celt_fatal(tls, __ccgo_ts+1811, __ccgo_ts+57, int32(632))
	}
	window = (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Fwindow
	/* 5 ms redundant frame for SILK->CELT */
	if redundancy != 0 && !(celt_to_silk != 0) {
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_RESET_STATE), 0) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1740, __ccgo_ts+57, int32(639))
		}
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+96, libc.Int32FromInt32(0))) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1331, __ccgo_ts+57, int32(640))
		}
		Opus_celt_decode_with_ec(tls, celt_dec, data+uintptr(len1), redundancy_bytes, redundant_audio, F5, libc.UintptrFromInt32(0), 0)
		if !(Opus_opus_custom_decoder_ctl(tls, celt_dec, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+96, bp+68+uintptr((OpusT___predefined_ptrdiff_t(bp+68)-int64(bp+68))/4)*4)) == libc.Int32FromInt32(OPUS_OK)) {
			Opus_celt_fatal(tls, __ccgo_ts+1454, __ccgo_ts+57, int32(643))
		}
		smooth_fade(tls, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*(frame_size-F2_5))*4, redundant_audio+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*(frame_size-F2_5))*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
	}
	/* 5ms redundant frame for CELT->SILK; ignore if the previous frame did not
	   use CELT (the first redundancy frame in a transition from SILK may have
	   been lost) */
	if redundancy != 0 && celt_to_silk != 0 && ((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode != int32(MODE_SILK_ONLY) || (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy != 0) {
		c = 0
		for {
			if !(c < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
				break
			}
			i = 0
			for {
				if !(i < F2_5) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*i+c)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(redundant_audio + uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*i+c)*4))
				goto _173
			_173:
				;
				i = i + 1
			}
			goto _172
		_172:
			;
			c = c + 1
		}
		smooth_fade(tls, redundant_audio+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
	}
	if transition != 0 {
		if audiosize >= F5 {
			i = 0
			for {
				if !(i < (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5) {
					break
				}
				*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(pcm_transition + uintptr(i)*4))
				goto _174
			_174:
				;
				i = i + 1
			}
			smooth_fade(tls, pcm_transition+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, pcm+uintptr((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels*F2_5)*4, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
		} else {
			/* Not enough time to do a clean transition, but we do it anyway
			   This will not preserve amplitude perfectly and may introduce
			   a bit of temporal aliasing, but it shouldn't be too bad and
			   that's pretty much the best we can do. In any case, generating this
			   transition it pretty silly in the first place */
			smooth_fade(tls, pcm_transition, pcm, pcm, F2_5, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels, window, (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FFs)
		}
	}
	if (*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fdecode_gain != 0 {
		v175 = float32(libc.Float32FromFloat32(0.000648814081) * float32((*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fdecode_gain))
		integer = int32(libc.Xfloor(tls, float64(v175)))
		if integer < -libc.Int32FromInt32(50) {
			v176 = libc.Float32FromInt32(0)
			goto _177
		}
		frac = v175 - float32(integer)
		*(*float32)(unsafe.Pointer(bp)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
		*(*OpusT_opus_uint32)(unsafe.Pointer(bp)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
		v176 = *(*float32)(unsafe.Pointer(bp))
		goto _177
	_177:
		gain = v176
		i = 0
		for {
			if !(i < frame_size*(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fchannels) {
				break
			}
			x1 = OpusT_opus_res(*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) * gain)
			*(*OpusT_opus_res)(unsafe.Pointer(pcm + uintptr(i)*4)) = x1
			goto _178
		_178:
			;
			i = i + 1
		}
	}
	if len1 <= int32(1) {
		(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
	} else {
		*(*OpusT_opus_uint32)(unsafe.Pointer(st1 + 96)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp + 68))
	}
	(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_mode = mode
	(*OpusT_OpusDecoder)(unsafe.Pointer(st1)).Fprev_redundancy = libc.BoolInt32(redundancy != 0 && !(celt_to_silk != 0))
	if celt_ret >= 0 {
		v31 = 0
		goto _180
	_180:
		if v31 != 0 {
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _182
	_182:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _184
_184:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	if celt_ret < 0 {
		v31 = celt_ret
	} else {
		v31 = audiosize
	}
	return v31
}

func opus_encode_frame_native(tls *libc.TLS, st1 uintptr, pcm uintptr, frame_size2 int32, data uintptr, orig_max_data_bytes OpusT_opus_int32, float_api int32, first_frame int32, analysis_info uintptr, is_silence int32, redundancy int32, celt_to_silk int32, prefill int32, equiv_rate OpusT_opus_int32, to_celt int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var HB_gain, g1, g2 OpusT_opus_val16
	var N2, N4, activity, apply_padding, bits_target, c, curr_bandwidth, cutoff_Hz, delay_compensation, end, endband, err, err1, frame_rate, hp_freq_smth1, i, i1, max_data_bytes, max_redundancy, nb_compr_bytes, prefill_offset, redundancy_bytes, ret, start_band, total_buffer, v38, v5, v6 int32
	var _saved_stack, celt_enc, pcm_buf, pcm_silk, silk_enc, st, tmp_prefill, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v29, v3 uintptr
	var celt_pred, mask_sum, noise_energy, noise_energy1, sum, xy, v36, v41, v42 OpusT_opus_val32
	var celt_rate, effective_max_rate, integer, maxBitRate, rate_offset, total_bitRate, v7, v9 OpusT_opus_int32
	var frac, v46, v47 float32
	var mask, masking_depth, v51, v52, v53 OpusT_celt_glog
	var other_bits, srate OpusT_opus_int16
	var v40 bool
	var _ /* celt_mode at bp+8 */ uintptr
	var _ /* dummy at bp+96 */ [2]uint8
	var _ /* dummy at bp+98 */ [2]uint8
	var _ /* enc at bp+24 */ OpusT_ec_enc
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* info at bp+88 */ OpusT_SILKInfo
	var _ /* nBytes at bp+16 */ OpusT_opus_int32
	var _ /* redundant_rng at bp+80 */ OpusT_opus_uint32
	var _ /* res at bp+4 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* zero at bp+84 */ OpusT_opus_int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = HB_gain, N2, N4, _saved_stack, activity, apply_padding, bits_target, c, celt_enc, celt_pred, celt_rate, curr_bandwidth, cutoff_Hz, delay_compensation, effective_max_rate, end, endband, err, err1, frac, frame_rate, g1, g2, hp_freq_smth1, i, i1, integer, mask, mask_sum, masking_depth, maxBitRate, max_data_bytes, max_redundancy, nb_compr_bytes, noise_energy, noise_energy1, other_bits, pcm_buf, pcm_silk, prefill_offset, rate_offset, redundancy_bytes, ret, silk_enc, srate, st, start_band, sum, tmp_prefill, total_bitRate, total_buffer, xy, v1, v11, v13, v15, v17, v19, v21, v23, v25, v27, v29, v3, v36, v38, v40, v41, v42, v46, v47, v5, v51, v52, v53, v6, v7, v9
	silk_enc = libc.UintptrFromInt32(0)
	celt_enc = libc.UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = libc.UintptrFromInt32(0)
	ret = 0
	start_band = 0
	redundancy_bytes = 0
	*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 80)) = uint32(0)
	activity = -int32(1)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if orig_max_data_bytes < int32(1276) {
		v5 = orig_max_data_bytes
	} else {
		v5 = int32(1276)
	}
	max_data_bytes = v5
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		silk_enc = st1 + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_enc_offset)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		celt_enc = st1 + uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fcelt_enc_offset)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_GET_MODE_REQUEST), libc.VaList(bp+112, bp+8+uintptr((OpusT___predefined_ptrdiff_t(bp+8)-int64(bp+8))/8)*8))
	}
	curr_bandwidth = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_LOWDELAY) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_CELT) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		delay_compensation = 0
	} else {
		delay_compensation = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdelay_compensation
	}
	total_buffer = delay_compensation
	frame_rate = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2
	if is_silence != 0 {
		activity = libc.BoolInt32(!(is_silence != 0))
	} else {
		if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis_info)).Fvalid != 0 {
			activity = libc.BoolInt32((*OpusT_AnalysisInfo)(unsafe.Pointer(analysis_info)).Factivity_probability >= libc.Float32FromFloat32(0.1))
			if !(activity != 0) {
				/* Mark as active if this noise frame is sufficiently loud */
				noise_energy = compute_frame_energy(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch)
				activity = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fpeak_signal_energy < float32(libc.Float32FromFloat32(316.23)*noise_energy))
			}
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) {
				noise_energy1 = compute_frame_energy(tls, pcm, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch)
				/* Boosting peak energy a bit because we didn't just average the active frames. */
				activity = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fpeak_signal_energy < float32(libc.Float32FromFloat32(316.23)*float32(libc.Float32FromFloat32(0.5)*noise_energy1)))
			}
		}
	}
	/* For the first frame at a new SILK bandwidth */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_bw_switch != 0 {
		redundancy = int32(1)
		celt_to_silk = int32(1)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_bw_switch = 0
		/* Do a prefill without resetting the sampling rate control. */
		prefill = int32(2)
	}
	/* If we decided to go with CELT, make sure redundancy is off, no matter what
	   we decided earlier. */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) {
		redundancy = 0
	}
	if redundancy != 0 {
		redundancy_bytes = compute_redundancy_bytes(tls, max_data_bytes, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps, frame_rate, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
		if redundancy_bytes == 0 {
			redundancy = 0
		}
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		redundancy = 0
		redundancy_bytes = 0
	}
	/* printf("%d %d %d %d\n", st->bitrate_bps, st->stream_channels, st->mode, curr_bandwidth); */
	v7 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
	goto _8
_8:
	if int32(8)*(max_data_bytes-redundancy_bytes) < v7 {
		v5 = int32(8) * (max_data_bytes - redundancy_bytes)
	} else {
		v9 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
		goto _10
	_10:
		v5 = v9
	}
	bits_target = v5 - int32(8)
	data = data + uintptr(1)
	Opus_ec_enc_init(tls, bp+24, data, libc.Uint32FromInt32(orig_max_data_bytes-int32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _12
	_12:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _14
_14:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _16
	_16:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _18
_18:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _20
	_20:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _22
_22:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _26
_26:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((total_buffer+frame_size2)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(1966))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _30
_30:
	*(*uintptr)(unsafe.Pointer(v25 + 8)) += uintptr(libc.Uint64FromInt32((total_buffer+frame_size2)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v27 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v27
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v29 = st
	goto _34
_34:
	pcm_buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v29)).Fglobal_stack - uintptr(libc.Uint64FromInt32((total_buffer+frame_size2)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	libc.Xmemcpy(tls, pcm_buf, st1+14312+uintptr(((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-total_buffer)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, libc.Uint64FromInt32(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4)+libc.Uint64FromInt64(0*((int64(pcm_buf)-OpusT___predefined_ptrdiff_t(st1+14312+uintptr(((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-total_buffer)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4))/4)))
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_CELT_ONLY) {
		hp_freq_smth1 = libc.Int32FromUint32(libc.Uint32FromInt32(Opus_silk_lin2log(tls, int32(VARIABLE_HP_MIN_CUTOFF_HZ))) << libc.Int32FromInt32(8))
	} else {
		hp_freq_smth1 = (*(*OpusT_silk_encoder_state_FLP)(unsafe.Pointer(silk_enc + 88))).FsCmn.Fvariable_HP_smth1_Q15
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_HP_smth2_Q15 = int32(int64((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_HP_smth2_Q15) + int64(hp_freq_smth1-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_HP_smth2_Q15)*int64(int16(int32(float64(libc.Float32FromFloat32(0.015)*float32(libc.Int64FromInt32(1)<<libc.Int32FromInt32(16)))+libc.Float64FromFloat64(0.5))))>>libc.Int32FromInt32(16))
	/* convert from log scale to Hertz */
	cutoff_Hz = Opus_silk_log2lin(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvariable_HP_smth2_Q15>>libc.Int32FromInt32(8))
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication == int32(OPUS_APPLICATION_VOIP) {
		hp_cutoff(tls, pcm, cutoff_Hz, pcm_buf+uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, st1+14216, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch)
	} else {
		dc_reject(tls, pcm, int32(3), pcm_buf+uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, st1+14216, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
	}
	if float_api != 0 {
		_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Farch
		xy = libc.Float32FromInt32(0)
		i = libc.Int32FromInt32(0)
		for {
			if !(i < frame_size2*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) {
				break
			}
			xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(pcm_buf + uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4 + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(pcm_buf + uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4 + uintptr(i)*4)))
			goto _35
		_35:
			;
			i = i + 1
		}
		v36 = xy
		goto _37
	_37:
		sum = v36
		/* This should filter out both NaNs and ridiculous signals that could
		   cause NaNs further down. */
		if v40 = !(sum < libc.Float32FromFloat32(1e+09)); !v40 {
			*(*float32)(unsafe.Pointer(bp)) = sum
			v5 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
			goto _39
		_39:
		}
		if v40 || v5 != 0 {
			libc.Xmemset(tls, pcm_buf+uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, 0, libc.Uint64FromInt32(frame_size2*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4))
			v42 = libc.Float32FromInt32(0)
			*(*OpusT_opus_val32)(unsafe.Pointer(st1 + 14216 + 3*4)) = v42
			v41 = v42
			*(*OpusT_opus_val32)(unsafe.Pointer(st1 + 14216 + 2*4)) = v41
			v36 = v41
			*(*OpusT_opus_val32)(unsafe.Pointer(st1 + 14216 + 1*4)) = v36
			*(*OpusT_opus_val32)(unsafe.Pointer(st1 + 14216)) = v36
		}
	}
	/* SILK processing */
	HB_gain = libc.Float32FromFloat32(1)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) {
		/* Distribute bits between SILK and CELT */
		v7 = bits_target * (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2) / int32(6)
		goto _45
	_45:
		total_bitRate = v7
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
			/* Base rate for SILK */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate = compute_silk_rate_for_hybrid(tls, total_bitRate, curr_bandwidth, libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs == int32(50)*frame_size2), (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FLBRR_coded, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
			if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking != 0) {
				/* Increasingly attenuate high band when it gets allocated fewer bits */
				celt_rate = total_bitRate - (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate
				v46 = float32(float32(-celt_rate) * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(1024)))
				integer = int32(libc.Xfloor(tls, float64(v46)))
				if integer < -libc.Int32FromInt32(50) {
					v47 = libc.Float32FromInt32(0)
					goto _48
				}
				frac = v46 - float32(integer)
				*(*float32)(unsafe.Pointer(bp + 4)) = libc.Float32FromFloat32(0.9999999403953552) + float32(frac*(libc.Float32FromFloat32(0.6931530833244324)+float32(frac*(libc.Float32FromFloat32(0.24015361070632935)+float32(frac*(libc.Float32FromFloat32(0.05582631751894951)+float32(frac*(libc.Float32FromFloat32(0.00898933969438076)+float32(frac*libc.Float32FromFloat32(0.0018775766948238015))))))))))
				*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4)) = libc.Uint32FromInt32(libc.Int32FromUint32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp + 4)))+libc.Int32FromUint32(libc.Uint32FromInt32(integer)<<libc.Int32FromInt32(23))) & uint32(0x7fffffff)
				v47 = *(*float32)(unsafe.Pointer(bp + 4))
				goto _48
			_48:
				HB_gain = libc.Float32FromFloat32(1) - v47
			}
		} else {
			/* SILK gets all bits */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate = total_bitRate
		}
		/* Surround masking for SILK */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0 && !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Flfe != 0) {
			mask_sum = libc.Float32FromInt32(0)
			end = int32(17)
			srate = int16(16000)
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
				end = int32(13)
				srate = int16(8000)
			} else {
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
					end = int32(15)
					srate = int16(12000)
				}
			}
			c = 0
			for {
				if !(c < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels) {
					break
				}
				i1 = 0
				for {
					if !(i1 < end) {
						break
					}
					if *(*OpusT_celt_glog)(unsafe.Pointer((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking + uintptr(int32(21)*c+i1)*4)) < libc.Float32FromFloat32(0.5) {
						v52 = *(*OpusT_celt_glog)(unsafe.Pointer((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking + uintptr(int32(21)*c+i1)*4))
					} else {
						v52 = libc.Float32FromFloat32(0.5)
					}
					if v52 > -libc.Float32FromFloat32(2) {
						if *(*OpusT_celt_glog)(unsafe.Pointer((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking + uintptr(int32(21)*c+i1)*4)) < libc.Float32FromFloat32(0.5) {
							v53 = *(*OpusT_celt_glog)(unsafe.Pointer((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking + uintptr(int32(21)*c+i1)*4))
						} else {
							v53 = libc.Float32FromFloat32(0.5)
						}
						v51 = v53
					} else {
						v51 = -libc.Float32FromFloat32(2)
					}
					mask = v51
					if mask > libc.Float32FromInt32(0) {
						mask = float32(libc.Float32FromFloat32(0.5) * mask)
					}
					mask_sum = mask_sum + mask
					goto _50
				_50:
					;
					i1 = i1 + 1
				}
				goto _49
			_49:
				;
				c = c + 1
			}
			/* Conservative rate reduction, we cut the masking in half */
			masking_depth = OpusT_celt_glog(mask_sum / float32(end) * float32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels))
			masking_depth = masking_depth + libc.Float32FromFloat32(0.2)
			rate_offset = int32(OpusT_opus_val32(float32(srate) * masking_depth))
			if rate_offset > -int32(2)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate/int32(3) {
				v5 = rate_offset
			} else {
				v5 = -int32(2) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate / int32(3)
			}
			rate_offset = v5
			/* Split the rate change between the SILK and CELT part for hybrid. */
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == int32(OPUS_BANDWIDTH_SUPERWIDEBAND) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbandwidth == int32(OPUS_BANDWIDTH_FULLBAND) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate += int32(3) * rate_offset / int32(5)
			} else {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate += rate_offset
			}
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FpayloadSize_ms = int32(1000) * frame_size2 / (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FnChannelsAPI = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FnChannelsInternal = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels
		if curr_bandwidth == int32(OPUS_BANDWIDTH_NARROWBAND) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate = int32(8000)
		} else {
			if curr_bandwidth == int32(OPUS_BANDWIDTH_MEDIUMBAND) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate = int32(12000)
			} else {
				if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) || curr_bandwidth == int32(OPUS_BANDWIDTH_WIDEBAND)) {
					Opus_celt_fatal(tls, __ccgo_ts+2213, __ccgo_ts+2160, int32(2118))
				}
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate = int32(16000)
			}
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
			/* Don't allow bandwidth reduction at lowest bitrates in hybrid mode */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FminInternalSampleRate = int32(16000)
		} else {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FminInternalSampleRate = int32(8000)
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxInternalSampleRate = int32(16000)
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) {
			v7 = max_data_bytes * int32(8) * (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2) / int32(6)
			goto _56
		_56:
			effective_max_rate = v7
			if frame_rate > int32(50) {
				effective_max_rate = effective_max_rate * int32(2) / int32(3)
			}
			if effective_max_rate < int32(8000) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxInternalSampleRate = int32(12000)
				if int32(12000) < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate {
					v5 = int32(12000)
				} else {
					v5 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate
				}
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate = v5
			}
			if effective_max_rate < int32(7000) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxInternalSampleRate = int32(8000)
				if int32(8000) < (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate {
					v5 = int32(8000)
				} else {
					v5 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate
				}
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FdesiredInternalSampleRate = v5
			}
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseCBR = libc.BoolInt32(!((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0))
		/* Call SILK encoder for the low band */
		/* Max bits for SILK, counting ToC, redundancy bytes, and optionally redundancy. */
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits = (max_data_bytes - int32(1)) * int32(8)
		if redundancy != 0 && redundancy_bytes >= int32(2) {
			/* Counting 1 bit for redundancy position and 20 bits for flag+size (only for hybrid). */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits -= redundancy_bytes*int32(8) + int32(1)
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits -= int32(20)
			}
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseCBR != 0 {
			/* When we're in CBR mode, but we have non-SILK data to encode, switch SILK to VBR with cap to
			   save on complexity. Any variations will be absorbed by CELT and/or DRED and we can still
			   produce a constant bitrate without wasting bits. */
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
				if 0 > (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate*frame_size2/(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs {
					v5 = 0
				} else {
					v5 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits - (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate*frame_size2/(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs
				}
				/* Allow SILK to steal up to 25% of the remaining bits */
				other_bits = int16(v5)
				if 0 > (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits-int32(other_bits)*int32(3)/int32(4) {
					v6 = 0
				} else {
					v6 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits - int32(other_bits)*int32(3)/int32(4)
				}
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits = v6
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseCBR = 0
			}
		} else {
			/* Constrained VBR. */
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
				/* Compute SILK bitrate corresponding to the max total bits available */
				maxBitRate = compute_silk_rate_for_hybrid(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, curr_bandwidth, libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs == int32(50)*frame_size2), (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FLBRR_coded, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
				v7 = maxBitRate * int32(6) / (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / frame_size2)
				goto _62
			_62:
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FmaxBits = v7
			}
		}
		if prefill != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
			*(*OpusT_opus_int32)(unsafe.Pointer(bp + 84)) = 0
			/* Use a smooth onset for the SILK prefill to avoid the encoder trying to encode
			   a discontinuity. The exact location is what we need to avoid leaving any "gap"
			   in the audio when mixing with the redundant CELT frame. Here we can afford to
			   overwrite st->delay_buffer because the only thing that uses it before it gets
			   rewritten is tmp_prefill[] and even then only the part after the ramp really
			   gets used (rather than sent to the encoder and discarded) */
			prefill_offset = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels * ((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer - (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fdelay_compensation - (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(400))
			gain_fade(tls, st1+14312+uintptr(prefill_offset)*4, st1+14312+uintptr(prefill_offset)*4, libc.Float32FromInt32(0), libc.Float32FromFloat32(1), (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Foverlap, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(400), (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fwindow, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
			libc.Xmemset(tls, st1+14312, 0, libc.Uint64FromInt32(prefill_offset)*uint64(4))
			pcm_silk = st1 + 14312
			Opus_silk_Encode(tls, silk_enc, st1+8, pcm_silk, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer, libc.UintptrFromInt32(0), bp+84, prefill, activity)
			/* Prevent a second switch in the real encode call. */
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FopusCanSwitch = 0
		}
		pcm_silk = pcm_buf + uintptr(total_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4
		ret = Opus_silk_Encode(tls, silk_enc, st1+8, pcm_silk, frame_size2, bp+24, bp+16, 0, activity)
		if ret != 0 {
			/*fprintf (stderr, "SILK encode error: %d\n", ret);*/
			/* Handle error */
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _64
			_64:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _66
		_66:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		/* Extract SILK internal bandwidth for signaling in first byte */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FinternalSampleRate == int32(8000) {
				curr_bandwidth = int32(OPUS_BANDWIDTH_NARROWBAND)
			} else {
				if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FinternalSampleRate == int32(12000) {
					curr_bandwidth = int32(OPUS_BANDWIDTH_MEDIUMBAND)
				} else {
					if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FinternalSampleRate == int32(16000) {
						curr_bandwidth = int32(OPUS_BANDWIDTH_WIDEBAND)
					}
				}
			}
		} else {
			if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FinternalSampleRate == libc.Int32FromInt32(16000)) {
				Opus_celt_fatal(tls, __ccgo_ts+2300, __ccgo_ts+2160, int32(2230))
			}
		}
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FopusCanSwitch = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FswitchReady != 0 && !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fnonfinal_frame != 0))
		if activity == -int32(1) {
			activity = libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FsignalType != TYPE_NO_VOICE_ACTIVITY)
		}
		if *(*OpusT_opus_int32)(unsafe.Pointer(bp + 16)) == 0 {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
			*(*uint8)(unsafe.Pointer(data + uintptr(-libc.Int32FromInt32(1)))) = gen_toc(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, curr_bandwidth, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _68
			_68:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _70
		_70:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return int32(1)
		}
		/* FIXME: How do we allocate the redundancy for CBR? */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FopusCanSwitch != 0 {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
				redundancy_bytes = compute_redundancy_bytes(tls, max_data_bytes, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps, frame_rate, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
				redundancy = libc.BoolInt32(redundancy_bytes != 0)
			}
			celt_to_silk = 0
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_bw_switch = int32(1)
		}
	}
	/* CELT processing */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		endband = int32(21)
		switch curr_bandwidth {
		case int32(OPUS_BANDWIDTH_NARROWBAND):
			endband = int32(13)
		case int32(OPUS_BANDWIDTH_MEDIUMBAND):
			fallthrough
		case int32(OPUS_BANDWIDTH_WIDEBAND):
			endband = int32(17)
		case int32(OPUS_BANDWIDTH_SUPERWIDEBAND):
			endband = int32(19)
		case int32(OPUS_BANDWIDTH_FULLBAND):
			endband = int32(21)
			break
		}
		_ = endband == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_END_BAND_REQUEST), libc.VaList(bp+112, endband))
		_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_CHANNELS_REQUEST), libc.VaList(bp+112, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels))
		_ = -libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+112, -libc.Int32FromInt32(1)))
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_SILK_ONLY) {
		celt_pred = libc.Float32FromInt32(2)
		/* We may still decide to disable prediction later */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FreducedDependency != 0 {
			celt_pred = libc.Float32FromInt32(0)
		}
		_ = celt_pred == float32(libc.Int32FromInt32(0))
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_PREDICTION_REQUEST), libc.VaList(bp+112, int32(celt_pred)))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _72
	_72:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _74
_74:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v11 = libc.Xmalloc(tls, uint64(16))
		goto _76
	_76:
		st = v11
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v13 = st
	goto _78
_78:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v13)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v15 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v15
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v17 = st
	goto _82
_82:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v19 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v19
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v21 = st
	goto _86
_86:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/libc.Int32FromInt32(400))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v17)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v21)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+2160, int32(2297))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v23 = libc.Xmalloc(tls, uint64(16))
		goto _88
	_88:
		st = v23
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v25 = st
	goto _90
_90:
	*(*uintptr)(unsafe.Pointer(v25 + 8)) += uintptr(libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/libc.Int32FromInt32(400)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v27 = libc.Xmalloc(tls, uint64(16))
		goto _92
	_92:
		st = v27
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v29 = st
	goto _94
_94:
	tmp_prefill = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v29)).Fglobal_stack - uintptr(libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/libc.Int32FromInt32(400))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_SILK_ONLY) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
		libc.Xmemcpy(tls, tmp_prefill, st1+14312+uintptr(((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-total_buffer-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(400))*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/libc.Int32FromInt32(400))*uint64(4)+libc.Uint64FromInt64(0*((int64(tmp_prefill)-OpusT___predefined_ptrdiff_t(st1+14312+uintptr(((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-total_buffer-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(400))*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4))/4)))
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-(frame_size2+total_buffer)) > 0 {
		libc.Xmemmove(tls, st1+14312, st1+14312+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*frame_size2)*4, libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-frame_size2-total_buffer))*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(st1+14312)-OpusT___predefined_ptrdiff_t(st1+14312+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*frame_size2)*4))/4)))
		libc.Xmemcpy(tls, st1+14312+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-frame_size2-total_buffer))*4, pcm_buf, libc.Uint64FromInt32((frame_size2+total_buffer)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(st1+14312+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer-frame_size2-total_buffer))*4)-OpusT___predefined_ptrdiff_t(pcm_buf))/4)))
	} else {
		libc.Xmemcpy(tls, st1+14312, pcm_buf+uintptr((frame_size2+total_buffer-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4, libc.Uint64FromInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(st1+14312)-OpusT___predefined_ptrdiff_t(pcm_buf+uintptr((frame_size2+total_buffer-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fencoder_buffer)*(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels)*4))/4)))
	}
	/* gain_fade() and stereo_fade() need to be after the buffer copying
	   because we don't want any of this to affect the SILK part */
	if ((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_HB_gain < libc.Float32FromFloat32(1) || HB_gain < libc.Float32FromFloat32(1)) && *(*uintptr)(unsafe.Pointer(bp + 8)) != libc.UintptrFromInt32(0) {
		gain_fade(tls, pcm_buf, pcm_buf, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_HB_gain, HB_gain, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Foverlap, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fwindow, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_HB_gain = HB_gain
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_HYBRID) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels == int32(1) {
		if equiv_rate > int32(32000) {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14 = int32(16384)
		} else {
			if equiv_rate < int32(16000) {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14 = 0
			} else {
				(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14 = int32(16384) - int32(2048)*(libc.Int32FromInt32(32000)-equiv_rate)/(equiv_rate-int32(14000))
			}
		}
	}
	if !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fenergy_masking != 0) && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels == int32(2) {
		/* Apply stereo width reduction (at low bitrates) */
		if int32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fhybrid_stereo_width_Q14) < libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14 < libc.Int32FromInt32(1)<<libc.Int32FromInt32(14) {
			g1 = float32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fhybrid_stereo_width_Q14)
			g2 = float32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14)
			g1 = g1 * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384))
			g2 = g2 * (libc.Float32FromFloat32(1) / libc.Float32FromInt32(16384))
			if *(*uintptr)(unsafe.Pointer(bp + 8)) != libc.UintptrFromInt32(0) {
				stereo_fade(tls, pcm_buf, pcm_buf, g1, g2, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Foverlap, frame_size2, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels, (*OpusT_OpusCustomMode)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fwindow, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs)
			}
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fhybrid_stereo_width_Q14 = int16((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FstereoWidth_Q14)
		}
	}
	if v40 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY); v40 {
		v1 = bp + 24
		v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _97
	_97:
	}
	if v40 && v5+int32(17)+int32(20)*libc.BoolInt32((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID)) <= int32(8)*(max_data_bytes-int32(1)) {
		/* For SILK mode, the redundancy is inferred from the length */
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
			Opus_ec_enc_bit_logp(tls, bp+24, redundancy, uint32(12))
		}
		if redundancy != 0 {
			Opus_ec_enc_bit_logp(tls, bp+24, celt_to_silk, uint32(1))
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
				/* Reserve the 8 bits needed for the redundancy length,
				   and at least a few bits for CELT if possible */
				v1 = bp + 24
				v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _101
			_101:
				max_redundancy = max_data_bytes - int32(1) - (v5+int32(8)+int32(3)+int32(7))>>int32(3)
			} else {
				v1 = bp + 24
				v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
				goto _104
			_104:
				max_redundancy = max_data_bytes - int32(1) - (v5+int32(7))>>int32(3)
			}
			/* Target the same bit-rate for redundancy as for the rest,
			   up to a max of 257 bytes */
			if max_redundancy < redundancy_bytes {
				v5 = max_redundancy
			} else {
				v5 = redundancy_bytes
			}
			redundancy_bytes = v5
			if int32(2) > redundancy_bytes {
				v6 = int32(2)
			} else {
				v6 = redundancy_bytes
			}
			if int32(257) < v6 {
				v5 = int32(257)
			} else {
				if int32(2) > redundancy_bytes {
					v38 = int32(2)
				} else {
					v38 = redundancy_bytes
				}
				v5 = v38
			}
			redundancy_bytes = v5
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
				Opus_ec_enc_uint(tls, bp+24, libc.Uint32FromInt32(redundancy_bytes-int32(2)), uint32(256))
			}
		}
	} else {
		redundancy = 0
	}
	if !(redundancy != 0) {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_bw_switch = 0
		redundancy_bytes = 0
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_CELT_ONLY) {
		start_band = int32(17)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) {
		v1 = bp + 24
		v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _111
	_111:
		ret = (v5 + int32(7)) >> int32(3)
		Opus_ec_enc_done(tls, bp+24)
		nb_compr_bytes = ret
	} else {
		nb_compr_bytes = max_data_bytes - int32(1) - redundancy_bytes
		Opus_ec_enc_shrink(tls, bp+24, libc.Uint32FromInt32(nb_compr_bytes))
	}
	if redundancy != 0 || (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_SILK_ONLY) {
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_ANALYSIS_REQUEST), libc.VaList(bp+112, analysis_info+uintptr((int64(analysis_info)-int64(analysis_info))/64)*64))
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
		(*(*OpusT_SILKInfo)(unsafe.Pointer(bp + 88))).FsignalType = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FsignalType
		(*(*OpusT_SILKInfo)(unsafe.Pointer(bp + 88))).Foffset = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.Foffset
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_SILK_INFO_REQUEST), libc.VaList(bp+112, bp+88+uintptr((OpusT___predefined_ptrdiff_t(bp+88)-int64(bp+88))/8)*8))
	}
	/* 5 ms redundant frame for CELT->SILK */
	if redundancy != 0 && celt_to_silk != 0 {
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		_ = -libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+112, -libc.Int32FromInt32(1)))
		err = Opus_celt_encode_with_ec(tls, celt_enc, pcm_buf, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(200), data+uintptr(nb_compr_bytes), redundancy_bytes, libc.UintptrFromInt32(0))
		if err < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _113
			_113:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _115
		_115:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+112, bp+80+uintptr((OpusT___predefined_ptrdiff_t(bp+80)-int64(bp+80))/4)*4))
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_RESET_STATE), 0)
	}
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_SILK) {
		_ = start_band == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+112, start_band))
	}
	*(*uint8)(unsafe.Pointer(data + uintptr(-libc.Int32FromInt32(1)))) = uint8(0)
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != int32(MODE_SILK_ONLY) {
		_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_REQUEST), libc.VaList(bp+112, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr))
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0 {
				_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate == libc.Int32FromInt32(0)
				Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+112, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps-(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FbitRate))
				_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
				Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_CONSTRAINT_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
			}
		} else {
			if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0 {
				_ = libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
				Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(1)))
				_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvbr_constraint == libc.Int32FromInt32(0)
				Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_CONSTRAINT_REQUEST), libc.VaList(bp+112, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fvbr_constraint))
				_ = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps == libc.Int32FromInt32(0)
				Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+112, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fbitrate_bps))
			}
		}
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode != (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode > 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fapplication != int32(OPUS_APPLICATION_RESTRICTED_CELT) {
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_RESET_STATE), 0)
			/* Prefilling */
			Opus_celt_encode_with_ec(tls, celt_enc, tmp_prefill, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/int32(400), bp+96, int32(2), libc.UintptrFromInt32(0))
			_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
			Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_PREDICTION_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		}
		/* If false, we already busted the budget and we'll end up with a "PLC frame" */
		v1 = bp + 24
		v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
		goto _118
	_118:
		if v5 <= int32(8)*nb_compr_bytes {
			ret = Opus_celt_encode_with_ec(tls, celt_enc, pcm_buf, frame_size2, libc.UintptrFromInt32(0), nb_compr_bytes, bp+24)
			if ret < 0 {
				st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
				if !(st != 0) {
					v1 = libc.Xmalloc(tls, uint64(16))
					goto _120
				_120:
					st = v1
					if st != 0 {
						libc.Xmemset(tls, st, 0, uint64(16))
					}
					libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
				}
				v3 = st
				goto _122
			_122:
				(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
				return -int32(3)
			}
			/* Put CELT->SILK redundancy data in the right place. */
			if redundancy != 0 && celt_to_silk != 0 && (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) && nb_compr_bytes != ret {
				libc.Xmemmove(tls, data+uintptr(ret), data+uintptr(nb_compr_bytes), libc.Uint64FromInt32(redundancy_bytes)*uint64(1)+libc.Uint64FromInt64(0*(int64(data+uintptr(ret))-int64(data+uintptr(nb_compr_bytes)))))
				nb_compr_bytes = ret + redundancy_bytes
			}
		}
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+112, st1+14308+uintptr((OpusT___predefined_ptrdiff_t(st1+14308)-int64(st1+14308))/4)*4))
	} else {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = (*(*OpusT_ec_enc)(unsafe.Pointer(bp + 24))).Frng
	}
	/* 5 ms redundant frame for SILK->CELT */
	if redundancy != 0 && !(celt_to_silk != 0) {
		N2 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(200)
		N4 = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs / int32(400)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_RESET_STATE), 0)
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_START_BAND_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(CELT_SET_PREDICTION_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		_ = libc.Int32FromInt32(0) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_VBR_REQUEST), libc.VaList(bp+112, libc.Int32FromInt32(0)))
		_ = -libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_SET_BITRATE_REQUEST), libc.VaList(bp+112, -libc.Int32FromInt32(1)))
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_HYBRID) {
			/* Shrink packet to what the encoder actually used. */
			nb_compr_bytes = ret
			Opus_ec_enc_shrink(tls, bp+24, libc.Uint32FromInt32(nb_compr_bytes))
		}
		/* NOTE: We could speed this up slightly (at the expense of code size) by just adding a function that prefills the buffer */
		Opus_celt_encode_with_ec(tls, celt_enc, pcm_buf+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(frame_size2-N2-N4))*4, N4, bp+98, int32(2), libc.UintptrFromInt32(0))
		err1 = Opus_celt_encode_with_ec(tls, celt_enc, pcm_buf+uintptr((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fchannels*(frame_size2-N2))*4, N2, data+uintptr(nb_compr_bytes), redundancy_bytes, libc.UintptrFromInt32(0))
		if err1 < 0 {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _124
			_124:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _126
		_126:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		Opus_opus_custom_encoder_ctl(tls, celt_enc, int32(OPUS_GET_FINAL_RANGE_REQUEST), libc.VaList(bp+112, bp+80+uintptr((OpusT___predefined_ptrdiff_t(bp+80)-int64(bp+80))/4)*4))
	}
	/* Signalling the mode in the first byte */
	data = data - 1
	v1 = data
	*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(v1))) | libc.Int32FromUint8(gen_toc(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, curr_bandwidth, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)))
	*(*OpusT_opus_uint32)(unsafe.Pointer(st1 + 14308)) ^= *(*OpusT_opus_uint32)(unsafe.Pointer(bp + 80))
	if to_celt != 0 {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode = int32(MODE_CELT_ONLY)
	} else {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_mode = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode
	}
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_channels = (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fprev_framesize = frame_size2
	(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Ffirst = 0
	/* DTX decision */
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_dtx != 0 && !((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fsilk_mode.FuseDTX != 0) {
		if decide_dtx_mode(tls, activity, st1+14296, libc.Int32FromInt32(2)*libc.Int32FromInt32(1000)*frame_size2/(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs) != 0 {
			(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
			*(*uint8)(unsafe.Pointer(data)) = gen_toc(tls, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FFs/frame_size2, curr_bandwidth, (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fstream_channels)
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _129
			_129:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _131
		_131:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return int32(1)
		}
	} else {
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fnb_no_activity_ms_Q1 = 0
	}
	/* In the unlikely case that the SILK encoder busted its target, tell
	   the decoder to call the PLC */
	v1 = bp + 24
	v5 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _134
_134:
	if v5 > (max_data_bytes-int32(1))*int32(8) {
		if max_data_bytes < int32(2) {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v3 = libc.Xmalloc(tls, uint64(16))
				goto _136
			_136:
				st = v3
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v11 = st
			goto _138
		_138:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack = _saved_stack
			return -int32(2)
		}
		*(*uint8)(unsafe.Pointer(data + 1)) = uint8(0)
		ret = int32(1)
		(*OpusT_OpusEncoder)(unsafe.Pointer(st1)).FrangeFinal = uint32(0)
	} else {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fmode == int32(MODE_SILK_ONLY) && !(redundancy != 0) {
			/*When in LPC only mode it's perfectly
			  reasonable to strip off trailing zero bytes as
			  the required range decoder behavior is to
			  fill these in. This can't be done when the MDCT
			  modes are used because the decoder needs to know
			  the actual length for allocation purposes.*/
			for ret > int32(2) && libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data + uintptr(ret)))) == 0 {
				ret = ret - 1
			}
		}
	}
	/* Count ToC and redundancy */
	ret = ret + (int32(1) + redundancy_bytes)
	apply_padding = libc.BoolInt32(!((*OpusT_OpusEncoder)(unsafe.Pointer(st1)).Fuse_vbr != 0))
	_ = first_frame /* Avoids a warning about first_frame being unused. */
	if apply_padding != 0 {
		if Opus_opus_packet_pad(tls, data, ret, orig_max_data_bytes) != OPUS_OK {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _140
			_140:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _142
		_142:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return -int32(3)
		}
		ret = orig_max_data_bytes
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _144
	_144:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _146
_146:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return ret
}

func opus_extension_iterator_next_repeat(tls *libc.TLS, iter uintptr, ext uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var curr_data0 uintptr
	var repeat_id_byte int32
	var _ /* header_size at bp+0 */ OpusT_opus_int32
	_, _ = curr_data0, repeat_id_byte
	if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame > libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+2537, __ccgo_ts+2422, int32(160))
	}
	for {
		if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame < (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames) {
			break
		}
		for (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len > 0 {
			repeat_id_byte = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data)))
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = skip_extension(tls, iter+32, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len, bp)
			/* We skipped this extension earlier, so it should not fail now. */
			if !((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len >= libc.Int32FromInt32(0)) {
				Opus_celt_fatal(tls, __ccgo_ts+2578, __ccgo_ts+2422, int32(169))
			}
			/* Don't repeat padding or frame separators with a 0 increment. */
			if repeat_id_byte <= int32(3) {
				continue
			}
			/* If the "Repeat These Extensions" extension had L == 0 and this
			   is the last repeated long extension, then force decoding the
			   payload with L = 0. */
			if libc.Int32FromUint8((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l) == 0 && (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame+int32(1) >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames && (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data == (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long {
				repeat_id_byte = repeat_id_byte & ^libc.Int32FromInt32(1)
			}
			curr_data0 = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = skip_extension_payload(tls, iter+8, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len, bp, repeat_id_byte, (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Ftrailing_short_len)
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len < 0 {
				return -int32(4)
			}
			if !(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data)-int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fdata) == int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flen1-(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len)) {
				Opus_celt_fatal(tls, __ccgo_ts+2615, __ccgo_ts+2422, int32(187))
			}
			/* If we were asked to stop at frame_max, skip extensions for later
			   frames. */
			if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fframe_max {
				continue
			}
			if ext != libc.UintptrFromInt32(0) {
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid = repeat_id_byte >> int32(1)
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fframe = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata = curr_data0 + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp)))
				(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 = int32(int64((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data) - int64(curr_data0) - int64(*(*OpusT_opus_int32)(unsafe.Pointer(bp))))
			}
			return int32(1)
		}
		/* We finished repeating the extensions for this frame. */
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fsrc_len = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_len
		goto _1
	_1:
		;
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame + 1
	}
	/* We finished repeating extensions. */
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_data = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_data
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Flast_long = libc.UintptrFromInt32(0)
	/* If L == 0, advance the frame number to handle the case where we did
	   not consume all of the data with an L == 0 long extension. */
	if libc.Int32FromUint8((*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_l) == 0 {
		(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame = (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame + 1
		/* Ignore additional padding if this was already the last frame. */
		if (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_frame >= (*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fnb_frames {
			(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Fcurr_len = 0
		}
	}
	(*OpusT_OpusExtensionIterator)(unsafe.Pointer(iter)).Frepeat_frame = 0
	return 0
}

// C documentation
//
//	/* Return the next extension (excluding real padding, separators, and repeat
//	    indicators, but including the repeated extensions) in bitstream order.
//	   Due to the extension repetition mechanism, extensions are not necessarily
//	    returned in frame order. */

func opus_multistream_encoder_init_impl(tls *libc.TLS, st uintptr, Fs OpusT_opus_int32, channels int32, streams int32, coupled_streams int32, mapping uintptr, application int32, mapping_type OpusT_MappingType) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var alignment uint32
	var coupled_size, i1, mono_size, ret, surround_size, v1, v3, v5 int32
	var ptr uintptr
	_, _, _, _, _, _, _, _, _, _ = alignment, coupled_size, i1, mono_size, ptr, ret, surround_size, v1, v3, v5
	if channels > int32(255) || channels < int32(1) || coupled_streams > streams || streams < int32(1) || coupled_streams < 0 || streams > int32(255)-coupled_streams || streams+coupled_streams > channels {
		return -int32(1)
	}
	coupled_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), Fs, int32(2), application)
	if coupled_size < 0 {
		return coupled_size
	}
	mono_size = Opus_opus_encoder_init(tls, libc.UintptrFromInt32(0), Fs, int32(1), application)
	if mono_size < 0 {
		return mono_size
	}
	if st == libc.UintptrFromInt32(0) {
		surround_size = 0
		if mapping_type == int32(MAPPING_TYPE_SURROUND) {
			surround_size = libc.Int32FromUint64(libc.Uint64FromInt32(channels) * (libc.Uint64FromInt32(MAX_OVERLAP)*libc.Uint64FromInt64(4) + libc.Uint64FromInt64(4)))
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
		goto _2
	_2:
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v3 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
		goto _4
	_4:
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v5 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
		goto _6
	_6:
		return v1 + coupled_streams*v3 + (streams-coupled_streams)*v5 + surround_size
	}
	v1 = 0
	goto _8
_8:
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Farch = v1
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels = channels
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams = streams
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams = coupled_streams
	if mapping_type != int32(MAPPING_TYPE_SURROUND) {
		(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream = -int32(1)
	}
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps = -int32(1000)
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fapplication = application
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).FFs = Fs
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fvariable_duration = int32(OPUS_FRAMESIZE_ARG)
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels) {
			break
		}
		*(*uint8)(unsafe.Pointer(st + 12 + uintptr(i1))) = *(*uint8)(unsafe.Pointer(mapping + uintptr(i1)))
		goto _9
	_9:
		;
		i1 = i1 + 1
	}
	if !(Opus_validate_layout(tls, st) != 0) {
		return -int32(1)
	}
	if !(validate_encoder_layout(tls, st) != 0) {
		return -int32(1)
	}
	if mapping_type == int32(MAPPING_TYPE_AMBISONICS) && !(validate_ambisonics(tls, (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_channels, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0)) != 0) {
		return -int32(1)
	}
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _11
_11:
	ptr = st + uintptr(v1)
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams) {
			break
		}
		ret = Opus_opus_encoder_init(tls, ptr, Fs, int32(2), application)
		if ret != OPUS_OK {
			return ret
		}
		if i1 == (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream {
			_ = libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
			Opus_opus_encoder_ctl(tls, ptr, int32(OPUS_SET_LFE_REQUEST), libc.VaList(bp+8, libc.Int32FromInt32(1)))
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v1 = libc.Int32FromUint32((libc.Uint32FromInt32(coupled_size) + alignment - uint32(1)) / alignment * alignment)
		goto _14
	_14:
		ptr = ptr + uintptr(v1)
		goto _12
	_12:
		;
		i1 = i1 + 1
	}
	for {
		if !(i1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		ret = Opus_opus_encoder_init(tls, ptr, Fs, int32(1), application)
		if ret != OPUS_OK {
			return ret
		}
		if i1 == (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream {
			_ = libc.Int32FromInt32(1) == libc.Int32FromInt32(0)
			Opus_opus_encoder_ctl(tls, ptr, int32(OPUS_SET_LFE_REQUEST), libc.VaList(bp+8, libc.Int32FromInt32(1)))
		}
		alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
		v1 = libc.Int32FromUint32((libc.Uint32FromInt32(mono_size) + alignment - uint32(1)) / alignment * alignment)
		goto _17
	_17:
		ptr = ptr + uintptr(v1)
		goto _15
	_15:
		;
		i1 = i1 + 1
	}
	if mapping_type == int32(MAPPING_TYPE_SURROUND) {
		libc.Xmemset(tls, ms_get_preemph_mem(tls, st), 0, libc.Uint64FromInt32(channels)*uint64(4))
		libc.Xmemset(tls, ms_get_window_mem(tls, st), 0, libc.Uint64FromInt32(channels*libc.Int32FromInt32(MAX_OVERLAP))*uint64(4))
	}
	(*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fmapping_type = mapping_type
	return OPUS_OK
}

func opus_multistream_packet_validate(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, nb_streams int32, Fs OpusT_opus_int32) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var count, s, samples, tmp_samples int32
	var _ /* packet_offset at bp+100 */ OpusT_opus_int32
	var _ /* size at bp+2 */ [48]OpusT_opus_int16
	var _ /* toc at bp+0 */ uint8
	_, _, _, _ = count, s, samples, tmp_samples
	samples = 0
	s = 0
	for {
		if !(s < nb_streams) {
			break
		}
		if len1 <= 0 {
			return -int32(4)
		}
		count = Opus_opus_packet_parse_impl(tls, data, len1, libc.BoolInt32(s != nb_streams-int32(1)), bp, libc.UintptrFromInt32(0), bp+2, libc.UintptrFromInt32(0), bp+100, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0))
		if count < 0 {
			return count
		}
		tmp_samples = Opus_opus_packet_get_nb_samples(tls, data, *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)), Fs)
		if s != 0 && samples != tmp_samples {
			return -int32(4)
		}
		samples = tmp_samples
		data = data + uintptr(*(*OpusT_opus_int32)(unsafe.Pointer(bp + 100)))
		len1 = len1 - *(*OpusT_opus_int32)(unsafe.Pointer(bp + 100))
		goto _1
	_1:
		;
		s = s + 1
	}
	return samples
}

type OpusT___ccgo_fp__Xopus_multistream_decode_native_4 = func(*libc.TLS, uintptr, int32, int32, uintptr, int32, int32, uintptr)

func opus_packet_get_mode(tls *libc.TLS, data uintptr) (r int32) {
	var mode int32
	_ = mode
	if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x80) != 0 {
		mode = int32(MODE_CELT_ONLY)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0x60) == int32(0x60) {
			mode = int32(MODE_HYBRID)
		} else {
			mode = int32(MODE_SILK_ONLY)
		}
	}
	return mode
}

func opus_projection_copy_channel_in_float(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	Opus_mapping_matrix_multiply_channel_in_float(tls, user_data, src, src_stride, dst, src_channel, dst_stride, frame_size)
}

func opus_projection_copy_channel_in_int24(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	Opus_mapping_matrix_multiply_channel_in_int24(tls, user_data, src, src_stride, dst, src_channel, dst_stride, frame_size)
}

func opus_projection_copy_channel_in_short(tls *libc.TLS, dst uintptr, dst_stride int32, src uintptr, src_stride int32, src_channel int32, frame_size int32, user_data uintptr) {
	Opus_mapping_matrix_multiply_channel_in_short(tls, user_data, src, src_stride, dst, src_channel, dst_stride, frame_size)
}

func opus_projection_copy_channel_out_float(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var float_dst, matrix uintptr
	_, _ = float_dst, matrix
	float_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, float_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(4))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_float(tls, matrix, src, dst_channel, src_stride, float_dst, dst_stride, frame_size)
	}
}

func opus_projection_copy_channel_out_int24(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var matrix, short_dst uintptr
	_, _ = matrix, short_dst
	short_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, short_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(4))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_int24(tls, matrix, src, dst_channel, src_stride, short_dst, dst_stride, frame_size)
	}
}

func opus_projection_copy_channel_out_short(tls *libc.TLS, dst uintptr, dst_stride int32, dst_channel int32, src uintptr, src_stride int32, frame_size int32, user_data uintptr) {
	var matrix, short_dst uintptr
	_, _ = matrix, short_dst
	short_dst = dst
	matrix = user_data
	if dst_channel == 0 {
		libc.Xmemset(tls, short_dst, 0, libc.Uint64FromInt32(frame_size*dst_stride)*uint64(2))
	}
	if src != libc.UintptrFromInt32(0) {
		Opus_mapping_matrix_multiply_channel_out_short(tls, matrix, src, dst_channel, src_stride, short_dst, dst_stride, frame_size)
	}
}

func opus_repacketizer_cat_impl(tls *libc.TLS, rp uintptr, data uintptr, len1 OpusT_opus_int32, self_delimited int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var curr_nb_frames, ret int32
	var _ /* tmp_toc at bp+0 */ uint8
	_, _ = curr_nb_frames, ret
	/* Set of check ToC */
	if len1 < int32(1) {
		return -int32(4)
	}
	if (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames == 0 {
		(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc = *(*uint8)(unsafe.Pointer(data))
		(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fframesize = Opus_opus_packet_get_samples_per_frame(tls, data, int32(8000))
	} else {
		if libc.Int32FromUint8((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Ftoc)&int32(0xFC) != libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data)))&int32(0xFC) {
			/*fprintf(stderr, "toc mismatch: 0x%x vs 0x%x\n", rp->toc, data[0]);*/
			return -int32(4)
		}
	}
	curr_nb_frames = Opus_opus_packet_get_nb_frames(tls, data, len1)
	if curr_nb_frames < int32(1) {
		return -int32(4)
	}
	/* Check the 120 ms maximum packet size */
	if (curr_nb_frames+(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fframesize > int32(960) {
		return -int32(4)
	}
	ret = Opus_opus_packet_parse_impl(tls, data, len1, self_delimited, bp, rp+8+uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*8, rp+392+uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*2, libc.UintptrFromInt32(0), libc.UintptrFromInt32(0), rp+496+uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*8, rp+880+uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*4)
	if ret < int32(1) {
		return ret
	}
	*(*uint8)(unsafe.Pointer(rp + 1072 + uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames))) = libc.Uint8FromInt32(ret)
	/* set padding length to zero for all but the first frame */
	for curr_nb_frames > int32(1) {
		(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames = (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames + 1
		*(*OpusT_opus_int32)(unsafe.Pointer(rp + 880 + uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*4)) = 0
		*(*uint8)(unsafe.Pointer(rp + 1072 + uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames))) = uint8(0)
		*(*uintptr)(unsafe.Pointer(rp + 496 + uintptr((*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames)*8)) = libc.UintptrFromInt32(0)
		curr_nb_frames = curr_nb_frames - 1
	}
	(*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames = (*OpusT_OpusRepacketizer)(unsafe.Pointer(rp)).Fnb_frames + 1
	return OPUS_OK
}

func parse_size(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, size uintptr) (r int32) {
	if len1 < int32(1) {
		*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(-int32(1))
		return -int32(1)
	} else {
		if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))) < int32(252) {
			*(*OpusT_opus_int16)(unsafe.Pointer(size)) = libc.Int16FromUint8(*(*uint8)(unsafe.Pointer(data)))
			return int32(1)
		} else {
			if len1 < int32(2) {
				*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(-int32(1))
				return -int32(1)
			} else {
				*(*OpusT_opus_int16)(unsafe.Pointer(size)) = int16(int32(4)*libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data + 1))) + libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(data))))
				return int32(2)
			}
		}
	}
	return r
}

func patch_transient_decision(tls *libc.TLS, newE uintptr, oldE uintptr, nbEBands int32, start int32, end int32, C int32) (r int32) {
	var c, i, v10, v13 int32
	var mean_diff OpusT_opus_val32
	var spread_old [26]OpusT_celt_glog
	var x1, x2, v16 OpusT_opus_val16
	var v2, v3, v5 OpusT_celt_glog
	_, _, _, _, _, _, _, _, _, _, _, _ = c, i, mean_diff, spread_old, x1, x2, v10, v13, v16, v2, v3, v5
	mean_diff = libc.Float32FromInt32(0)
	/* Apply an aggressive (-6 dB/Bark) spreading function to the old frame to
	   avoid false detection caused by irrelevant bands */
	if C == int32(1) {
		spread_old[start] = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(start)*4))
		i = start + int32(1)
		for {
			if !(i < end) {
				break
			}
			if spread_old[i-int32(1)]-libc.Float32FromFloat32(1) > *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4)) {
				v2 = spread_old[i-int32(1)] - libc.Float32FromFloat32(1)
			} else {
				v2 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4))
			}
			spread_old[i] = v2
			goto _1
		_1:
			;
			i = i + 1
		}
	} else {
		if *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(start)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(start+nbEBands)*4)) {
			v2 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(start)*4))
		} else {
			v2 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(start+nbEBands)*4))
		}
		spread_old[start] = v2
		i = start + int32(1)
		for {
			if !(i < end) {
				break
			}
			if *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i+nbEBands)*4)) {
				v3 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4))
			} else {
				v3 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i+nbEBands)*4))
			}
			if spread_old[i-int32(1)]-libc.Float32FromFloat32(1) > v3 {
				v2 = spread_old[i-int32(1)] - libc.Float32FromFloat32(1)
			} else {
				if *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4)) > *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i+nbEBands)*4)) {
					v5 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i)*4))
				} else {
					v5 = *(*OpusT_celt_glog)(unsafe.Pointer(oldE + uintptr(i+nbEBands)*4))
				}
				v2 = v5
			}
			spread_old[i] = v2
			goto _4
		_4:
			;
			i = i + 1
		}
	}
	i = end - int32(2)
	for {
		if !(i >= start) {
			break
		}
		if spread_old[i] > spread_old[i+int32(1)]-libc.Float32FromFloat32(1) {
			v2 = spread_old[i]
		} else {
			v2 = spread_old[i+int32(1)] - libc.Float32FromFloat32(1)
		}
		spread_old[i] = v2
		goto _8
	_8:
		;
		i = i - 1
	}
	/* Compute mean increase */
	c = 0
	for {
		if int32(2) > start {
			v13 = int32(2)
		} else {
			v13 = start
		}
		i = v13
		for {
			if !(i < end-int32(1)) {
				break
			}
			if float32(libc.Int32FromInt32(0)) > *(*OpusT_celt_glog)(unsafe.Pointer(newE + uintptr(i+c*nbEBands)*4)) {
				v2 = float32(libc.Int32FromInt32(0))
			} else {
				v2 = *(*OpusT_celt_glog)(unsafe.Pointer(newE + uintptr(i+c*nbEBands)*4))
			}
			x1 = v2
			if float32(libc.Int32FromInt32(0)) > spread_old[i] {
				v2 = float32(libc.Int32FromInt32(0))
			} else {
				v2 = spread_old[i]
			}
			x2 = v2
			if float32(libc.Int32FromInt32(0)) > x1-x2 {
				v16 = float32(libc.Int32FromInt32(0))
			} else {
				v16 = x1 - x2
			}
			mean_diff = mean_diff + v16
			goto _12
		_12:
			;
			i = i + 1
		}
		goto _11
	_11:
		;
		c = c + 1
		v10 = c
		if !(v10 < C) {
			break
		}
	}
	if int32(2) > start {
		v10 = int32(2)
	} else {
		v10 = start
	}
	mean_diff = mean_diff / float32(C*(end-libc.Int32FromInt32(1)-v10))
	/*printf("%f %f %d\n", mean_diff, max_diff, count);*/
	return libc.BoolInt32(mean_diff > libc.Float32FromFloat32(1))
}

// C documentation
//
//	/** Apply window and compute the MDCT for all sub-frames and
//	    all channels in a frame */

func prefilter_and_fold(tls *libc.TLS, st1 uintptr, N int32) {
	var CC, c, decode_buffer_size, i, overlap, v29 int32
	var _saved_stack, etmp, mode, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var decode_mem [2]uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = CC, _saved_stack, c, decode_buffer_size, decode_mem, etmp, i, mode, overlap, st, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v5, v7, v9
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	decode_buffer_size = int32(DEC_PITCH_BUF_SIZE)
	mode = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fmode
	overlap = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Foverlap
	CC = (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fchannels
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4420, int32(597))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(overlap) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	etmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(overlap)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	c = 0
	for {
		decode_mem[c] = st1 + 112 + uintptr(c*(decode_buffer_size+overlap))*4
		goto _30
	_30:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	c = 0
	for {
		/* Apply the pre-filter to the MDCT overlap for the next frame because
		   the post-filter will be re-applied in the decoder after the MDCT
		   overlap. */
		Opus_comb_filter(tls, etmp, decode_mem[c]+uintptr(decode_buffer_size)*4-uintptr(N)*4, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_period, overlap, -(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain_old, -(*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_gain, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset_old, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Fpostfilter_tapset, libc.UintptrFromInt32(0), 0, (*OpusT_OpusCustomDecoder)(unsafe.Pointer(st1)).Farch)
		/* Simulate TDAC on the concealed audio so that it blends with the
		   MDCT of the next frame. */
		i = 0
		for {
			if !(i < overlap/int32(2)) {
				break
			}
			*(*OpusT_celt_sig)(unsafe.Pointer(decode_mem[c] + uintptr(decode_buffer_size-N+i)*4)) = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow + uintptr(i)*4))**(*OpusT_opus_val32)(unsafe.Pointer(etmp + uintptr(overlap-int32(1)-i)*4))) + OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow + uintptr(overlap-i-int32(1))*4))**(*OpusT_opus_val32)(unsafe.Pointer(etmp + uintptr(i)*4)))
			goto _33
		_33:
			;
			i = i + 1
		}
		goto _32
	_32:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _37
_37:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

func quant_band(tls *libc.TLS, ctx uintptr, X uintptr, N int32, b int32, B int32, lowband uintptr, LM int32, lowband_out uintptr, gain OpusT_opus_val32, lowband_scratch uintptr, fill int32) (r uint32) {
	var B0, N0, N_B, N_B0, encode, j, k, longBlocks, recombine, tf_change, time_divide int32
	var cm uint32
	var n1 OpusT_opus_val16
	var v1, v2 OpusT_opus_uint32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B0, N0, N_B, N_B0, cm, encode, j, k, longBlocks, n1, recombine, tf_change, time_divide, v1, v2
	N0 = N
	N_B = N
	B0 = B
	time_divide = 0
	recombine = 0
	cm = uint32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	tf_change = (*band_ctx)(unsafe.Pointer(ctx)).Ftf_change
	longBlocks = libc.BoolInt32(B0 == int32(1))
	v1 = libc.Uint32FromInt32(B)
	_ = v1 > libc.Uint32FromInt32(0)
	v2 = libc.Uint32FromInt32(N_B) / v1
	goto _3
_3:
	N_B = libc.Int32FromUint32(v2)
	/* Special case for one sample */
	if N == int32(1) {
		return quant_band_n1(tls, ctx, X, libc.UintptrFromInt32(0), lowband_out)
	}
	if tf_change > 0 {
		recombine = tf_change
	}
	/* Band recombining to increase frequency resolution */
	if lowband_scratch != 0 && lowband != 0 && (recombine != 0 || N_B&int32(1) == 0 && tf_change < 0 || B0 > int32(1)) {
		libc.Xmemcpy(tls, lowband_scratch, lowband, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(lowband_scratch)-int64(lowband))/4)))
		lowband = lowband_scratch
	}
	k = 0
	for {
		if !(k < recombine) {
			break
		}
		if encode != 0 {
			Opus_haar1(tls, X, N>>k, int32(1)<<k)
		}
		if lowband != 0 {
			Opus_haar1(tls, lowband, N>>k, int32(1)<<k)
		}
		fill = libc.Int32FromUint8(bit_interleave_table[fill&int32(0xF)]) | libc.Int32FromUint8(bit_interleave_table[fill>>int32(4)])<<int32(2)
		goto _4
	_4:
		;
		k = k + 1
	}
	B = B >> recombine
	N_B = N_B << recombine
	/* Increasing the time resolution */
	for N_B&int32(1) == 0 && tf_change < 0 {
		if encode != 0 {
			Opus_haar1(tls, X, N_B, B)
		}
		if lowband != 0 {
			Opus_haar1(tls, lowband, N_B, B)
		}
		fill = fill | fill<<B
		B = B << int32(1)
		N_B = N_B >> int32(1)
		time_divide = time_divide + 1
		tf_change = tf_change + 1
	}
	B0 = B
	N_B0 = N_B
	/* Reorganize the samples in time order instead of frequency order */
	if B0 > int32(1) {
		if encode != 0 {
			deinterleave_hadamard(tls, X, N_B>>recombine, B0<<recombine, longBlocks)
		}
		if lowband != 0 {
			deinterleave_hadamard(tls, lowband, N_B>>recombine, B0<<recombine, longBlocks)
		}
	}
	cm = quant_partition(tls, ctx, X, N, b, B, lowband, LM, gain, fill)
	/* This code is used by the decoder and by the resynthesis-enabled encoder */
	if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
		/* Undo the sample reorganization going from time order to frequency order */
		if B0 > int32(1) {
			interleave_hadamard(tls, X, N_B>>recombine, B0<<recombine, longBlocks)
		}
		/* Undo time-freq changes that we did earlier */
		N_B = N_B0
		B = B0
		k = 0
		for {
			if !(k < time_divide) {
				break
			}
			B = B >> int32(1)
			N_B = N_B << int32(1)
			cm = cm | cm>>B
			Opus_haar1(tls, X, N_B, B)
			goto _5
		_5:
			;
			k = k + 1
		}
		k = 0
		for {
			if !(k < recombine) {
				break
			}
			cm = uint32(bit_deinterleave_table[cm])
			Opus_haar1(tls, X, N0>>k, int32(1)<<k)
			goto _6
		_6:
			;
			k = k + 1
		}
		B = B << recombine
		/* Scale output for later folding */
		if lowband_out != 0 {
			n1 = float32(libc.Xsqrt(tls, float64(N0)))
			j = 0
			for {
				if !(j < N0) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(lowband_out + uintptr(j)*4)) = OpusT_opus_val16(n1 * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
				goto _7
			_7:
				;
				j = j + 1
			}
		}
		cm = cm & libc.Uint32FromInt32(int32(1)<<B-int32(1))
	}
	return cm
}

var bit_interleave_table = [16]uint8{
	1:  uint8(1),
	2:  uint8(1),
	3:  uint8(1),
	4:  uint8(2),
	5:  uint8(3),
	6:  uint8(3),
	7:  uint8(3),
	8:  uint8(2),
	9:  uint8(3),
	10: uint8(3),
	11: uint8(3),
	12: uint8(2),
	13: uint8(3),
	14: uint8(3),
	15: uint8(3),
}

var bit_deinterleave_table = [16]uint8{
	1:  uint8(0x03),
	2:  uint8(0x0C),
	3:  uint8(0x0F),
	4:  uint8(0x30),
	5:  uint8(0x33),
	6:  uint8(0x3C),
	7:  uint8(0x3F),
	8:  uint8(0xC0),
	9:  uint8(0xC3),
	10: uint8(0xCC),
	11: uint8(0xCF),
	12: uint8(0xF0),
	13: uint8(0xF3),
	14: uint8(0xFC),
	15: uint8(0xFF),
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a band for the stereo case. */

func quant_band_n1(tls *libc.TLS, ctx uintptr, X uintptr, Y uintptr, lowband_out uintptr) (r uint32) {
	var c, encode, sign, stereo, v1 int32
	var ec, x uintptr
	var v3 float32
	_, _, _, _, _, _, _, _ = c, ec, encode, sign, stereo, x, v1, v3
	x = X
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	stereo = libc.BoolInt32(Y != libc.UintptrFromInt32(0))
	c = 0
	for {
		sign = 0
		if (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits >= libc.Int32FromInt32(1)<<libc.Int32FromInt32(BITRES) {
			if encode != 0 {
				sign = libc.BoolInt32(*(*OpusT_celt_norm)(unsafe.Pointer(x)) < libc.Float32FromInt32(0))
				Opus_ec_enc_bits(tls, ec, libc.Uint32FromInt32(sign), uint32(1))
			} else {
				sign = libc.Int32FromUint32(Opus_ec_dec_bits(tls, ec, uint32(1)))
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
		}
		if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
			if sign != 0 {
				v3 = -libc.Float32FromFloat32(1)
			} else {
				v3 = libc.Float32FromFloat32(1)
			}
			*(*OpusT_celt_norm)(unsafe.Pointer(x)) = v3
		}
		x = Y
		goto _2
	_2:
		;
		c = c + 1
		v1 = c
		if !(v1 < int32(1)+stereo) {
			break
		}
	}
	if lowband_out != 0 {
		*(*OpusT_celt_norm)(unsafe.Pointer(lowband_out)) = *(*OpusT_celt_norm)(unsafe.Pointer(X))
	}
	return uint32(1)
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a mono partition.
//	   It can split the band in two and transmit the energy difference with
//	   the two half-bands. It can be called recursively so bands can end up being
//	   split in 8 parts. */

func quant_band_stereo(tls *libc.TLS, ctx uintptr, X uintptr, Y uintptr, N int32, _b int32, B int32, lowband uintptr, LM int32, lowband_out uintptr, lowband_scratch uintptr, _fill int32) (r uint32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*int32)(unsafe.Pointer(bp)) = _b
	*(*int32)(unsafe.Pointer(bp + 4)) = _fill
	var c, delta, encode, imid, inv, iside, itheta, j, mbits, orig_fill, qalloc, sbits, sign, v3, v4, v5 int32
	var cm uint32
	var ec, x2, y2, v1 uintptr
	var mid, side OpusT_opus_val32
	var rebalance OpusT_opus_int32
	var tmp OpusT_celt_norm
	var _ /* sctx at bp+8 */ split_ctx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, cm, delta, ec, encode, imid, inv, iside, itheta, j, mbits, mid, orig_fill, qalloc, rebalance, sbits, side, sign, tmp, x2, y2, v1, v3, v4, v5
	imid = 0
	iside = 0
	inv = 0
	mid = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	cm = uint32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	/* Special case for one sample */
	if N == int32(1) {
		return quant_band_n1(tls, ctx, X, Y, lowband_out)
	}
	orig_fill = *(*int32)(unsafe.Pointer(bp + 4))
	if encode != 0 {
		if *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) < libc.Float32FromFloat32(1e-10) || *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).Fm)).FnbEBands+(*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) < libc.Float32FromFloat32(1e-10) {
			if *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) > *(*OpusT_celt_ener)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).FbandE + uintptr((*OpusT_OpusCustomMode)(unsafe.Pointer((*band_ctx)(unsafe.Pointer(ctx)).Fm)).FnbEBands+(*band_ctx)(unsafe.Pointer(ctx)).Fi)*4)) {
				libc.Xmemcpy(tls, Y, X, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(X))/4)))
			} else {
				libc.Xmemcpy(tls, X, Y, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(X)-int64(Y))/4)))
			}
		}
	}
	compute_theta(tls, ctx, bp+8, X, Y, N, bp, B, B, LM, int32(1), bp+4)
	inv = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Finv
	imid = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fimid
	iside = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fiside
	delta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fdelta
	itheta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fitheta
	qalloc = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fqalloc
	mid = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(imid))
	side = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(iside))
	/* This is a special case for N=2 that only works for stereo and takes
	   advantage of the fact that mid and side are orthogonal to encode
	   the side with just one bit. */
	if N == int32(2) {
		sign = 0
		mbits = *(*int32)(unsafe.Pointer(bp))
		sbits = 0
		/* Only need one bit for the side. */
		if itheta != 0 && itheta != int32(16384) {
			sbits = libc.Int32FromInt32(1) << libc.Int32FromInt32(BITRES)
		}
		mbits = mbits - sbits
		c = libc.BoolInt32(itheta > int32(8192))
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc + sbits
		if c != 0 {
			v1 = Y
		} else {
			v1 = X
		}
		x2 = v1
		if c != 0 {
			v1 = X
		} else {
			v1 = Y
		}
		y2 = v1
		if sbits != 0 {
			if encode != 0 {
				/* Here we only need to encode a sign for the side. */
				/* FIXME: Need to increase fixed-point precision? */
				sign = libc.BoolInt32(OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x2))**(*OpusT_celt_norm)(unsafe.Pointer(y2 + 1*4)))-OpusT_celt_norm(*(*OpusT_celt_norm)(unsafe.Pointer(x2 + 1*4))**(*OpusT_celt_norm)(unsafe.Pointer(y2))) < libc.Float32FromInt32(0))
				Opus_ec_enc_bits(tls, ec, libc.Uint32FromInt32(sign), uint32(1))
			} else {
				sign = libc.Int32FromUint32(Opus_ec_dec_bits(tls, ec, uint32(1)))
			}
		}
		sign = int32(1) - int32(2)*sign
		/* We use orig_fill here because we want to fold the side, but if
		   itheta==16384, we'll have cleared the low bits of fill. */
		cm = quant_band(tls, ctx, x2, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, orig_fill)
		/* We don't split N=2 bands, so cm is either 1 or 0 (for a fold-collapse),
		   and there's no need to worry about mixing with the other channel. */
		*(*OpusT_celt_norm)(unsafe.Pointer(y2)) = OpusT_celt_norm(float32(-sign) * *(*OpusT_celt_norm)(unsafe.Pointer(x2 + 1*4)))
		*(*OpusT_celt_norm)(unsafe.Pointer(y2 + 1*4)) = OpusT_celt_norm(float32(sign) * *(*OpusT_celt_norm)(unsafe.Pointer(x2)))
		if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X)))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)) = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y)) = OpusT_opus_val32(side * *(*OpusT_celt_norm)(unsafe.Pointer(Y)))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)) = OpusT_opus_val32(side * *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)))
			tmp = *(*OpusT_celt_norm)(unsafe.Pointer(X))
			*(*OpusT_celt_norm)(unsafe.Pointer(X)) = tmp - *(*OpusT_celt_norm)(unsafe.Pointer(Y))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y)) = tmp + *(*OpusT_celt_norm)(unsafe.Pointer(Y))
			tmp = *(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4))
			*(*OpusT_celt_norm)(unsafe.Pointer(X + 1*4)) = tmp - *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4))
			*(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4)) = tmp + *(*OpusT_celt_norm)(unsafe.Pointer(Y + 1*4))
		}
	} else {
		if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
			v4 = *(*int32)(unsafe.Pointer(bp))
		} else {
			v4 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
		}
		if 0 > v4 {
			v3 = 0
		} else {
			if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
				v5 = *(*int32)(unsafe.Pointer(bp))
			} else {
				v5 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
			}
			v3 = v5
		}
		mbits = v3
		sbits = *(*int32)(unsafe.Pointer(bp)) - mbits
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc
		rebalance = (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits
		if mbits >= sbits {
			/* In stereo mode, we do not apply a scaling to the mid because we need the normalized
			   mid for folding later. */
			cm = quant_band(tls, ctx, X, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, *(*int32)(unsafe.Pointer(bp + 4)))
			rebalance = mbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != 0 {
				sbits = sbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			/* For a stereo split, the high bits of fill are always zero, so no
			   folding will be done to the side. */
			cm = cm | quant_band(tls, ctx, Y, N, sbits, B, libc.UintptrFromInt32(0), LM, libc.UintptrFromInt32(0), side, libc.UintptrFromInt32(0), *(*int32)(unsafe.Pointer(bp + 4))>>B)
		} else {
			/* For a stereo split, the high bits of fill are always zero, so no
			   folding will be done to the side. */
			cm = quant_band(tls, ctx, Y, N, sbits, B, libc.UintptrFromInt32(0), LM, libc.UintptrFromInt32(0), side, libc.UintptrFromInt32(0), *(*int32)(unsafe.Pointer(bp + 4))>>B)
			rebalance = sbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != int32(16384) {
				mbits = mbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			/* In stereo mode, we do not apply a scaling to the mid because we need the normalized
			   mid for folding later. */
			cm = cm | quant_band(tls, ctx, X, N, mbits, B, lowband, LM, lowband_out, libc.Float32FromFloat32(1), lowband_scratch, *(*int32)(unsafe.Pointer(bp + 4)))
		}
	}
	/* This code is used by the decoder and by the resynthesis-enabled encoder */
	if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
		if N != int32(2) {
			stereo_merge(tls, X, Y, mid, N, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
		}
		if inv != 0 {
			j = 0
			for {
				if !(j < N) {
					break
				}
				*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = -*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
				goto _6
			_6:
				;
				j = j + 1
			}
		}
	}
	return cm
}

func quant_coarse_energy_impl(tls *libc.TLS, m uintptr, start int32, end int32, eBands uintptr, oldEBands uintptr, budget OpusT_opus_int32, tell OpusT_opus_int32, prob_model uintptr, error1 uintptr, enc uintptr, C int32, LM int32, intra int32, max_decay OpusT_celt_glog, lfe int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var badness, bits_left, c, i, pi, qi0, v2, v7, v9 int32
	var beta, coef OpusT_opus_val16
	var decay_bound, oldE, x OpusT_celt_glog
	var f, q, tmp OpusT_opus_val32
	var prev [2]OpusT_opus_val32
	var v4 float32
	var v6 uintptr
	var _ /* qi at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = badness, beta, bits_left, c, coef, decay_bound, f, i, oldE, pi, prev, q, qi0, tmp, x, v2, v4, v6, v7, v9
	badness = 0
	prev = [2]OpusT_opus_val32{}
	if tell+int32(3) <= budget {
		Opus_ec_enc_bit_logp(tls, enc, intra, uint32(3))
	}
	if intra != 0 {
		coef = libc.Float32FromInt32(0)
		beta = beta_intra
	} else {
		beta = beta_coef[LM]
		coef = pred_coef[LM]
	}
	/* Encode at a fixed coarse resolution */
	i = start
	for {
		if !(i < end) {
			break
		}
		c = 0
		for {
			x = *(*OpusT_celt_glog)(unsafe.Pointer(eBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			if -libc.Float32FromFloat32(9) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v4 = -libc.Float32FromFloat32(9)
			} else {
				v4 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			oldE = v4
			f = x - OpusT_celt_glog(coef*oldE) - prev[c]
			/* Rounding to nearest integer here is really important! */
			*(*int32)(unsafe.Pointer(bp)) = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+f)))
			if -libc.Float32FromFloat32(28) > *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) {
				v4 = -libc.Float32FromFloat32(28)
			} else {
				v4 = *(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4))
			}
			decay_bound = v4 - max_decay
			/* Prevent the energy from going down too quickly (e.g. for bands
			   that have just one bin) */
			if *(*int32)(unsafe.Pointer(bp)) < 0 && x < decay_bound {
				*(*int32)(unsafe.Pointer(bp)) = *(*int32)(unsafe.Pointer(bp)) + int32(decay_bound-x)
				if *(*int32)(unsafe.Pointer(bp)) > 0 {
					*(*int32)(unsafe.Pointer(bp)) = 0
				}
			}
			qi0 = *(*int32)(unsafe.Pointer(bp))
			/* If we don't have enough bits to encode all the energy, just assume
			   something safe. */
			v6 = enc
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v6)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v6)).Frng))
			goto _8
		_8:
			tell = v2
			bits_left = budget - tell - int32(3)*C*(end-i)
			if i != start && bits_left < int32(30) {
				if bits_left < int32(24) {
					if int32(1) < *(*int32)(unsafe.Pointer(bp)) {
						v2 = int32(1)
					} else {
						v2 = *(*int32)(unsafe.Pointer(bp))
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
				}
				if bits_left < int32(16) {
					if -int32(1) > *(*int32)(unsafe.Pointer(bp)) {
						v2 = -int32(1)
					} else {
						v2 = *(*int32)(unsafe.Pointer(bp))
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
				}
			}
			if lfe != 0 && i >= int32(2) {
				if *(*int32)(unsafe.Pointer(bp)) < 0 {
					v2 = *(*int32)(unsafe.Pointer(bp))
				} else {
					v2 = 0
				}
				*(*int32)(unsafe.Pointer(bp)) = v2
			}
			if budget-tell >= int32(15) {
				if i < int32(20) {
					v2 = i
				} else {
					v2 = int32(20)
				}
				pi = int32(2) * v2
				Opus_ec_laplace_encode(tls, enc, bp, libc.Uint32FromInt32(libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi))))<<int32(7)), libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(prob_model + uintptr(pi+int32(1)))))<<int32(6))
			} else {
				if budget-tell >= int32(2) {
					if *(*int32)(unsafe.Pointer(bp)) < int32(1) {
						v7 = *(*int32)(unsafe.Pointer(bp))
					} else {
						v7 = int32(1)
					}
					if -int32(1) > v7 {
						v2 = -int32(1)
					} else {
						if *(*int32)(unsafe.Pointer(bp)) < int32(1) {
							v9 = *(*int32)(unsafe.Pointer(bp))
						} else {
							v9 = int32(1)
						}
						v2 = v9
					}
					*(*int32)(unsafe.Pointer(bp)) = v2
					Opus_ec_enc_icdf(tls, enc, int32(2)**(*int32)(unsafe.Pointer(bp))^-libc.BoolInt32(*(*int32)(unsafe.Pointer(bp)) < 0), uintptr(unsafe.Pointer(&small_energy_icdf)), uint32(2))
				} else {
					if budget-tell >= int32(1) {
						if 0 < *(*int32)(unsafe.Pointer(bp)) {
							v2 = 0
						} else {
							v2 = *(*int32)(unsafe.Pointer(bp))
						}
						*(*int32)(unsafe.Pointer(bp)) = v2
						Opus_ec_enc_bit_logp(tls, enc, -*(*int32)(unsafe.Pointer(bp)), uint32(1))
					} else {
						*(*int32)(unsafe.Pointer(bp)) = -int32(1)
					}
				}
			}
			*(*OpusT_celt_glog)(unsafe.Pointer(error1 + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = f - float32(*(*int32)(unsafe.Pointer(bp)))
			badness = badness + libc.Xabs(tls, qi0-*(*int32)(unsafe.Pointer(bp)))
			q = float32(*(*int32)(unsafe.Pointer(bp)))
			tmp = OpusT_opus_val16(coef*oldE) + prev[c] + q
			*(*OpusT_celt_glog)(unsafe.Pointer(oldEBands + uintptr(i+c*(*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FnbEBands)*4)) = tmp
			prev[c] = prev[c] + q - OpusT_opus_val16(beta*q)
			goto _3
		_3:
			;
			c = c + 1
			v2 = c
			if !(v2 < C) {
				break
			}
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	if lfe != 0 {
		v2 = 0
	} else {
		v2 = badness
	}
	return v2
}

func quant_partition(tls *libc.TLS, ctx uintptr, X uintptr, N int32, _b int32, B int32, lowband uintptr, LM2 int32, gain OpusT_opus_val32, _fill int32) (r uint32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*int32)(unsafe.Pointer(bp)) = _b
	*(*int32)(unsafe.Pointer(bp + 4)) = _fill
	var B0, K, curr_bits, delta, encode, hi, i1, i2, imid, iside, itheta, j, lo, mbits, mid, q, qalloc, sbits, spread, v1, v2, v3, v4 int32
	var Y, cache, cache1, cache2, ec, m2, next_lowband2, v5 uintptr
	var cm, cm_mask uint32
	var mid1, side OpusT_opus_val32
	var rebalance OpusT_opus_int32
	var tmp, v30 OpusT_opus_val16
	var _ /* sctx at bp+8 */ split_ctx
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B0, K, Y, cache, cache1, cache2, cm, cm_mask, curr_bits, delta, ec, encode, hi, i1, i2, imid, iside, itheta, j, lo, m2, mbits, mid, mid1, next_lowband2, q, qalloc, rebalance, sbits, side, spread, tmp, v1, v2, v3, v30, v4, v5
	imid = 0
	iside = 0
	B0 = B
	mid1 = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	cm = uint32(0)
	Y = libc.UintptrFromInt32(0)
	encode = (*band_ctx)(unsafe.Pointer(ctx)).Fencode
	m2 = (*band_ctx)(unsafe.Pointer(ctx)).Fm
	i2 = (*band_ctx)(unsafe.Pointer(ctx)).Fi
	spread = (*band_ctx)(unsafe.Pointer(ctx)).Fspread
	ec = (*band_ctx)(unsafe.Pointer(ctx)).Fec
	/* If we need 1.5 more bit than we can produce, split the band in two. */
	cache2 = (*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).Fcache.Findex + uintptr((LM2+int32(1))*(*OpusT_OpusCustomMode)(unsafe.Pointer(m2)).FnbEBands+i2)*2)))
	if LM2 != -int32(1) && *(*int32)(unsafe.Pointer(bp)) > libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache2 + uintptr(*(*uint8)(unsafe.Pointer(cache2))))))+int32(12) && N > int32(2) {
		next_lowband2 = libc.UintptrFromInt32(0)
		N = N >> int32(1)
		Y = X + uintptr(N)*4
		LM2 = LM2 - int32(1)
		if B == int32(1) {
			*(*int32)(unsafe.Pointer(bp + 4)) = *(*int32)(unsafe.Pointer(bp + 4))&int32(1) | *(*int32)(unsafe.Pointer(bp + 4))<<int32(1)
		}
		B = (B + int32(1)) >> int32(1)
		compute_theta(tls, ctx, bp+8, X, Y, N, bp, B, B0, LM2, 0, bp+4)
		imid = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fimid
		iside = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fiside
		delta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fdelta
		itheta = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fitheta
		qalloc = (*(*split_ctx)(unsafe.Pointer(bp + 8))).Fqalloc
		mid1 = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(imid))
		side = OpusT_opus_val32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) * float32(iside))
		/* Give more bits to low-energy MDCTs than they would otherwise deserve */
		if B0 > int32(1) && itheta&int32(0x3fff) != 0 {
			if itheta > int32(8192) {
				/* Rough approximation for pre-echo masking */
				delta = delta - delta>>(int32(4)-LM2)
			} else {
				/* Corresponds to a forward-masking slope of 1.5 dB per 10 ms */
				if 0 < delta+N<<int32(BITRES)>>(int32(5)-LM2) {
					v1 = 0
				} else {
					v1 = delta + N<<int32(BITRES)>>(int32(5)-LM2)
				}
				delta = v1
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
			v2 = *(*int32)(unsafe.Pointer(bp))
		} else {
			v2 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
		}
		if 0 > v2 {
			v1 = 0
		} else {
			if *(*int32)(unsafe.Pointer(bp)) < (*(*int32)(unsafe.Pointer(bp))-delta)/int32(2) {
				v3 = *(*int32)(unsafe.Pointer(bp))
			} else {
				v3 = (*(*int32)(unsafe.Pointer(bp)) - delta) / int32(2)
			}
			v1 = v3
		}
		mbits = v1
		sbits = *(*int32)(unsafe.Pointer(bp)) - mbits
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= qalloc
		if lowband != 0 {
			next_lowband2 = lowband + uintptr(N)*4
		} /* >32-bit split case */
		rebalance = (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits
		if mbits >= sbits {
			cm = quant_partition(tls, ctx, X, N, mbits, B, lowband, LM2, OpusT_opus_val32(gain*mid1), *(*int32)(unsafe.Pointer(bp + 4)))
			rebalance = mbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != 0 {
				sbits = sbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			cm = cm | quant_partition(tls, ctx, Y, N, sbits, B, next_lowband2, LM2, OpusT_opus_val32(gain*side), *(*int32)(unsafe.Pointer(bp + 4))>>B)<<(B0>>int32(1))
		} else {
			cm = quant_partition(tls, ctx, Y, N, sbits, B, next_lowband2, LM2, OpusT_opus_val32(gain*side), *(*int32)(unsafe.Pointer(bp + 4))>>B) << (B0 >> int32(1))
			rebalance = sbits - (rebalance - (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits)
			if rebalance > libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES) && itheta != int32(16384) {
				mbits = mbits + (rebalance - libc.Int32FromInt32(3)<<libc.Int32FromInt32(BITRES))
			}
			cm = cm | quant_partition(tls, ctx, X, N, mbits, B, lowband, LM2, OpusT_opus_val32(gain*mid1), *(*int32)(unsafe.Pointer(bp + 4)))
		}
	} else {
		/* This is the basic no-split case */
		v5 = m2
		v1 = LM2
		v2 = *(*int32)(unsafe.Pointer(bp))
		v1 = v1 + 1
		cache = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
		lo = 0
		hi = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache)))
		v2 = v2 - 1
		i1 = libc.Int32FromInt32(0)
		for {
			if !(i1 < libc.Int32FromInt32(LOG_MAX_PSEUDO)) {
				break
			}
			mid = (lo + hi + int32(1)) >> int32(1)
			if libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(mid)))) >= v2 {
				hi = mid
			} else {
				lo = mid
			}
			goto _8
		_8:
			;
			i1 = i1 + 1
		}
		if lo == 0 {
			v3 = -int32(1)
		} else {
			v3 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(lo))))
		}
		if v2-v3 <= libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache + uintptr(hi))))-v2 {
			v4 = lo
			goto _11
		} else {
			v4 = hi
			goto _11
		}
	_11:
		q = v4
		v5 = m2
		v1 = LM2
		v2 = q
		v1 = v1 + 1
		cache1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
		if v2 == 0 {
			v4 = 0
		} else {
			v4 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache1 + uintptr(v2)))) + int32(1)
		}
		v3 = v4
		goto _16
	_16:
		curr_bits = v3
		*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= curr_bits
		/* Ensures we can never bust the budget */
		for (*band_ctx)(unsafe.Pointer(ctx)).Fremaining_bits < 0 && q > 0 {
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) += curr_bits
			q = q - 1
			v5 = m2
			v1 = LM2
			v2 = q
			v1 = v1 + 1
			cache1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Fbits + uintptr(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).Fcache.Findex + uintptr(v1*(*OpusT_OpusCustomMode)(unsafe.Pointer(v5)).FnbEBands+i2)*2)))
			if v2 == 0 {
				v4 = 0
			} else {
				v4 = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(cache1 + uintptr(v2)))) + int32(1)
			}
			v3 = v4
			goto _22
		_22:
			curr_bits = v3
			*(*OpusT_opus_int32)(unsafe.Pointer(ctx + 40)) -= curr_bits
		}
		if q != 0 {
			v1 = q
			if v1 < int32(8) {
				v3 = v1
			} else {
				v3 = (int32(8) + v1&int32(7)) << (v1>>int32(3) - int32(1))
			}
			v2 = v3
			goto _26
		_26:
			K = v2
			/* Finally do the actual quantization */
			if encode != 0 {
				cm = Opus_alg_quant(tls, X, N, K, spread, B, ec, gain, (*band_ctx)(unsafe.Pointer(ctx)).Fresynth, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
			} else {
				cm = Opus_alg_unquant(tls, X, N, K, spread, B, ec, gain)
			}
		} else {
			if (*band_ctx)(unsafe.Pointer(ctx)).Fresynth != 0 {
				/* B can be as large as 16, so this shift might overflow an int on a
				   16-bit platform; use a long to get defined behavior.*/
				cm_mask = uint32(libc.Uint64FromUint64(1)<<B) - uint32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = libc.Int32FromUint32(uint32(*(*int32)(unsafe.Pointer(bp + 4))) & cm_mask)
				if !(*(*int32)(unsafe.Pointer(bp + 4)) != 0) {
					libc.Xmemset(tls, X, 0, libc.Uint64FromInt32(N)*uint64(4))
				} else {
					if lowband == libc.UintptrFromInt32(0) {
						/* Noise */
						j = 0
						for {
							if !(j < N) {
								break
							}
							(*band_ctx)(unsafe.Pointer(ctx)).Fseed = Opus_celt_lcg_rand(tls, (*band_ctx)(unsafe.Pointer(ctx)).Fseed)
							*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = float32(libc.Int32FromUint32((*band_ctx)(unsafe.Pointer(ctx)).Fseed) >> libc.Int32FromInt32(20))
							goto _28
						_28:
							;
							j = j + 1
						}
						cm = cm_mask
					} else {
						/* Folded spectrum */
						j = 0
						for {
							if !(j < N) {
								break
							}
							(*band_ctx)(unsafe.Pointer(ctx)).Fseed = Opus_celt_lcg_rand(tls, (*band_ctx)(unsafe.Pointer(ctx)).Fseed)
							/* About 48 dB below the "normal" folding level */
							tmp = libc.Float32FromFloat32(1) / libc.Float32FromInt32(256)
							if (*band_ctx)(unsafe.Pointer(ctx)).Fseed&uint32(0x8000) != 0 {
								v30 = tmp
							} else {
								v30 = -tmp
							}
							tmp = v30
							*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = *(*OpusT_celt_norm)(unsafe.Pointer(lowband + uintptr(j)*4)) + tmp
							goto _29
						_29:
							;
							j = j + 1
						}
						cm = libc.Uint32FromInt32(*(*int32)(unsafe.Pointer(bp + 4)))
					}
					Opus_renormalise_vector(tls, X, N, gain, (*band_ctx)(unsafe.Pointer(ctx)).Farch)
				}
			}
		}
	}
	return cm
}

// C documentation
//
//	/* This function is responsible for encoding and decoding a band for the mono case. */

func rate_allocation(tls *libc.TLS, st uintptr, rate uintptr, frame_size int32) (r OpusT_opus_int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var alignment uint32
	var i1, v1 int32
	var ptr uintptr
	var rate_sum OpusT_opus_int32
	var _ /* Fs at bp+0 */ OpusT_opus_int32
	_, _, _, _, _ = alignment, i1, ptr, rate_sum, v1
	rate_sum = 0
	alignment = uint32(uint64(libc.UintptrFromInt32(0) + 8))
	v1 = libc.Int32FromUint32((libc.Uint32FromInt32(int32(296)) + alignment - uint32(1)) / alignment * alignment)
	goto _2
_2:
	ptr = st + uintptr(v1)
	Opus_opus_encoder_ctl(tls, ptr, int32(OPUS_GET_SAMPLE_RATE_REQUEST), libc.VaList(bp+16, bp+uintptr((OpusT___predefined_ptrdiff_t(bp)-int64(bp))/4)*4))
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fmapping_type == int32(MAPPING_TYPE_AMBISONICS) {
		ambisonics_rate_allocation(tls, st, rate, frame_size, *(*OpusT_opus_int32)(unsafe.Pointer(bp)))
	} else {
		surround_rate_allocation(tls, st, rate, frame_size, *(*OpusT_opus_int32)(unsafe.Pointer(bp)))
	}
	i1 = 0
	for {
		if !(i1 < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		if *(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i1)*4)) > int32(500) {
			v1 = *(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i1)*4))
		} else {
			v1 = int32(500)
		}
		*(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i1)*4)) = v1
		rate_sum = rate_sum + *(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i1)*4))
		goto _3
	_3:
		;
		i1 = i1 + 1
	}
	return rate_sum
}

type OpusT___ccgo_fp__Xopus_multistream_encode_native_1 = func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32, uintptr)

type OpusT___ccgo_fp__Xopus_multistream_encode_native_7 = func(*libc.TLS, uintptr, uintptr, int32, int32, int32, int32, int32)

/* Max size in case the encoder decides to return six frames (6 x 20 ms = 120 ms) */

func run_prefilter(tls *libc.TLS, st1 uintptr, in uintptr, prefilter_mem uintptr, CC int32, N int32, prefilter_tapset int32, pitch uintptr, gain uintptr, qgain uintptr, enabled int32, complexity int32, tf_estimate OpusT_opus_val16, nbAvailableBytes int32, analysis uintptr, tone_freq OpusT_opus_val16, toneishness OpusT_opus_val32) (r int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var _pre, _saved_stack, mode, pitch_buf, st, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var c, cancel_pitch, i, max_period, min_period, multiple, offset, offset1, overlap, pf_on, qg, v29, v31, v57 int32
	var gain1, pf_threshold, v56 OpusT_opus_val16
	var thresh [2]OpusT_opus_val16
	var _ /* after at bp+32 */ [2]OpusT_opus_val32
	var _ /* before at bp+24 */ [2]OpusT_opus_val32
	var _ /* pitch_index at bp+16 */ int32
	var _ /* pre at bp+0 */ [2]uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _pre, _saved_stack, c, cancel_pitch, gain1, i, max_period, min_period, mode, multiple, offset, offset1, overlap, pf_on, pf_threshold, pitch_buf, qg, st, thresh, v1, v11, v13, v15, v17, v19, v21, v23, v29, v3, v31, v5, v56, v57, v7, v9
	*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)) = [2]OpusT_opus_val32{}
	*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)) = [2]OpusT_opus_val32{}
	cancel_pitch = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	max_period = int32(COMBFILTER_MAXPERIOD)
	min_period = int32(COMBFILTER_MINPERIOD)
	mode = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fmode
	overlap = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Foverlap
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(CC*(N+max_period))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1427))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(CC*(N+max_period)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	_pre = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(CC*(N+max_period))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	(*(*[2]uintptr)(unsafe.Pointer(bp)))[0] = _pre
	(*(*[2]uintptr)(unsafe.Pointer(bp)))[int32(1)] = _pre + uintptr(N+max_period)*4
	c = 0
	for {
		libc.Xmemcpy(tls, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c], prefilter_mem+uintptr(c*max_period)*4, libc.Uint64FromInt32(max_period)*uint64(4)+libc.Uint64FromInt64(0*((int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c])-int64(prefilter_mem+uintptr(c*max_period)*4))/4)))
		libc.Xmemcpy(tls, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4, in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4)-int64(in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4))/4)))
		goto _30
	_30:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	/* If we detect that the signal is dominated by a single tone, don't rely on the standard pitch
	   estimator, as it can become unreliable. */
	if enabled != 0 && toneishness > libc.Float32FromFloat32(0.99) {
		multiple = int32(1)
		/* Using aliased version of the postfilter above 24 kHz.
		   First value is purposely slightly above pi to avoid triggering for Fs=48kHz. */
		if tone_freq >= libc.Float32FromFloat32(3.1416) {
			tone_freq = libc.Float32FromFloat32(3.141593) - tone_freq
		}
		/* If the pitch is too high for our post-filter, apply pitch doubling until
		   we can get something that fits (not ideal, but better than nothing). */
		for tone_freq >= OpusT_opus_val16(float32(multiple)*libc.Float32FromFloat32(0.39)) {
			multiple = multiple + 1
		}
		if tone_freq > libc.Float32FromFloat32(0.006148) {
			if int32(libc.Xfloor(tls, float64(0.5)+float64(float64(libc.Float64FromFloat32(2)*libc.Float64FromFloat64(M_PI))*float64(multiple))/float64(tone_freq))) < libc.Int32FromInt32(COMBFILTER_MAXPERIOD)-libc.Int32FromInt32(2) {
				v29 = int32(libc.Xfloor(tls, float64(0.5)+float64(float64(libc.Float64FromFloat32(2)*libc.Float64FromFloat64(M_PI))*float64(multiple))/float64(tone_freq)))
			} else {
				v29 = libc.Int32FromInt32(COMBFILTER_MAXPERIOD) - libc.Int32FromInt32(2)
			}
			*(*int32)(unsafe.Pointer(bp + 16)) = v29
		} else {
			/* If the pitch is too low, using a very high pitch will actually give us an improvement
			   due to the DC component of the filter that will be close to our tone. Again, not ideal,
			   but if we only have a single tone, it's better than nothing. */
			*(*int32)(unsafe.Pointer(bp + 16)) = int32(COMBFILTER_MINPERIOD)
		}
		gain1 = libc.Float32FromFloat32(0.75)
	} else {
		if enabled != 0 && complexity >= int32(5) {
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _33
			_33:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _35
		_35:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v5 = libc.Xmalloc(tls, uint64(16))
				goto _37
			_37:
				st = v5
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v7 = st
			goto _39
		_39:
			*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v9 = libc.Xmalloc(tls, uint64(16))
				goto _41
			_41:
				st = v9
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v11 = st
			goto _43
		_43:
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v13 = libc.Xmalloc(tls, uint64(16))
				goto _45
			_45:
				st = v13
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v15 = st
			goto _47
		_47:
			if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((max_period+N)>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
				Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1463))
			}
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v17 = libc.Xmalloc(tls, uint64(16))
				goto _49
			_49:
				st = v17
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v19 = st
			goto _51
		_51:
			*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32((max_period+N)>>libc.Int32FromInt32(1)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v21 = libc.Xmalloc(tls, uint64(16))
				goto _53
			_53:
				st = v21
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v23 = st
			goto _55
		_55:
			pitch_buf = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32((max_period+N)>>libc.Int32FromInt32(1))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
			Opus_pitch_downsample(tls, bp, pitch_buf, (max_period+N)>>int32(1), CC, int32(2), (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
			/* Don't search for the fir last 1.5 octave of the range because
			   there's too many false-positives due to short-term correlation */
			Opus_pitch_search(tls, pitch_buf+uintptr(max_period>>libc.Int32FromInt32(1))*4, pitch_buf, N, max_period-int32(3)*min_period, bp+16, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
			*(*int32)(unsafe.Pointer(bp + 16)) = max_period - *(*int32)(unsafe.Pointer(bp + 16))
			gain1 = Opus_remove_doubling(tls, pitch_buf, max_period, min_period, N, bp+16, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
			if *(*int32)(unsafe.Pointer(bp + 16)) > max_period-int32(2) {
				*(*int32)(unsafe.Pointer(bp + 16)) = max_period - int32(2)
			}
			gain1 = float32(libc.Float32FromFloat32(0.7) * gain1)
			/*printf("%d %d %f %f\n", pitch_change, pitch_index, gain1, st->analysis.tonality);*/
			if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Floss_rate > int32(2) {
				gain1 = float32(libc.Float32FromFloat32(0.5) * gain1)
			}
			if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Floss_rate > int32(4) {
				gain1 = float32(libc.Float32FromFloat32(0.5) * gain1)
			}
			if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Floss_rate > int32(8) {
				gain1 = libc.Float32FromInt32(0)
			}
		} else {
			gain1 = libc.Float32FromInt32(0)
			*(*int32)(unsafe.Pointer(bp + 16)) = int32(COMBFILTER_MINPERIOD)
		}
	}
	if (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fvalid != 0 {
		gain1 = OpusT_opus_val16(gain1 * (*OpusT_AnalysisInfo)(unsafe.Pointer(analysis)).Fmax_pitch_ratio)
	}
	/* Gain threshold for enabling the prefilter/postfilter */
	pf_threshold = libc.Float32FromFloat32(0.2)
	/* Adjusting the threshold based on rate and continuity */
	if libc.Xabs(tls, *(*int32)(unsafe.Pointer(bp + 16))-(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period)*int32(10) > *(*int32)(unsafe.Pointer(bp + 16)) {
		pf_threshold = pf_threshold + libc.Float32FromFloat32(0.2)
		/* Completely disable the prefilter on strong transients without continuity. */
		if tf_estimate > libc.Float32FromFloat32(0.98) {
			gain1 = libc.Float32FromInt32(0)
		}
	}
	if nbAvailableBytes < int32(25) {
		pf_threshold = pf_threshold + libc.Float32FromFloat32(0.1)
	}
	if nbAvailableBytes < int32(35) {
		pf_threshold = pf_threshold + libc.Float32FromFloat32(0.1)
	}
	if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain > libc.Float32FromFloat32(0.4) {
		pf_threshold = pf_threshold - libc.Float32FromFloat32(0.1)
	}
	if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain > libc.Float32FromFloat32(0.55) {
		pf_threshold = pf_threshold - libc.Float32FromFloat32(0.1)
	}
	/* Hard threshold at 0.2 */
	if pf_threshold > libc.Float32FromFloat32(0.2) {
		v56 = pf_threshold
	} else {
		v56 = libc.Float32FromFloat32(0.2)
	}
	pf_threshold = v56
	if gain1 < pf_threshold {
		gain1 = libc.Float32FromInt32(0)
		pf_on = 0
		qg = 0
	} else {
		/*This block is not gated by a total bits check only because
		  of the nbAvailableBytes check above.*/
		if float32(libc.Xfabs(tls, float64(gain1-(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain))) < libc.Float32FromFloat32(0.1) {
			gain1 = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain
		}
		qg = int32(libc.Xfloor(tls, float64(libc.Float32FromFloat32(0.5)+OpusT_opus_val16(gain1*libc.Float32FromInt32(32))/libc.Float32FromInt32(3)))) - int32(1)
		if int32(7) < qg {
			v31 = int32(7)
		} else {
			v31 = qg
		}
		if 0 > v31 {
			v29 = 0
		} else {
			if int32(7) < qg {
				v57 = int32(7)
			} else {
				v57 = qg
			}
			v29 = v57
		}
		qg = v29
		gain1 = OpusT_opus_val16(libc.Float32FromFloat32(0.09375) * float32(qg+libc.Int32FromInt32(1)))
		pf_on = int32(1)
	}
	/*printf("%d %f\n", pitch_index, gain1);*/
	c = 0
	for {
		offset = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize - overlap
		if (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period > int32(COMBFILTER_MINPERIOD) {
			v31 = (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period
		} else {
			v31 = int32(COMBFILTER_MINPERIOD)
		}
		(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period = v31
		libc.Xmemcpy(tls, in+uintptr(c*(N+overlap))*4, st1+252+uintptr(c*overlap)*4, libc.Uint64FromInt32(overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(in+uintptr(c*(N+overlap))*4)-int64(st1+252+uintptr(c*overlap)*4))/4)))
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(bp + 24 + uintptr(c)*4)) += float32(libc.Xfabs(tls, float64(*(*OpusT_celt_sig)(unsafe.Pointer(in + uintptr(c*(N+overlap)+overlap+i)*4)))))
			goto _63
		_63:
			;
			i = i + 1
		}
		if offset != 0 {
			Opus_comb_filter(tls, in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period, offset, -(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain, -(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_tapset, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_tapset, libc.UintptrFromInt32(0), 0, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
		}
		Opus_comb_filter(tls, in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4+uintptr(offset)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4+uintptr(offset)*4, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period, *(*int32)(unsafe.Pointer(bp + 16)), N-offset, -(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain, -gain1, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_tapset, prefilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*OpusT_opus_val32)(unsafe.Pointer(bp + 32 + uintptr(c)*4)) += float32(libc.Xfabs(tls, float64(*(*OpusT_celt_sig)(unsafe.Pointer(in + uintptr(c*(N+overlap)+overlap+i)*4)))))
			goto _64
		_64:
			;
			i = i + 1
		}
		goto _61
	_61:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	if CC == int32(2) {
		thresh[0] = float32(float32(libc.Float32FromFloat32(0.25)*gain1)*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[0]) + float32(libc.Float32FromFloat32(0.01)*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[int32(1)])
		thresh[int32(1)] = float32(float32(libc.Float32FromFloat32(0.25)*gain1)*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[int32(1)]) + float32(libc.Float32FromFloat32(0.01)*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[0])
		/* Don't use the filter if one channel gets significantly worse. */
		if (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[0]-(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[0] > thresh[0] || (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[int32(1)]-(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[int32(1)] > thresh[int32(1)] {
			cancel_pitch = int32(1)
		}
		/* Use the filter only if at least one channel gets significantly better. */
		if (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[0]-(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[0] < thresh[0] && (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[int32(1)]-(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[int32(1)] < thresh[int32(1)] {
			cancel_pitch = int32(1)
		}
	} else {
		/* Check that the mono channel actually got better. */
		if (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 32)))[0] > (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp + 24)))[0] {
			cancel_pitch = int32(1)
		}
	}
	/* If needed, revert to a gain of zero. */
	if cancel_pitch != 0 {
		c = 0
		for {
			offset1 = (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).FshortMdctSize - overlap
			libc.Xmemcpy(tls, in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4)-int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4))/4)))
			Opus_comb_filter(tls, in+uintptr(c*(N+overlap))*4+uintptr(overlap)*4+uintptr(offset1)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4+uintptr(offset1)*4, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_period, *(*int32)(unsafe.Pointer(bp + 16)), overlap, -(*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_gain, float32(-libc.Int32FromInt32(0)), (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Fprefilter_tapset, prefilter_tapset, (*OpusT_OpusCustomMode)(unsafe.Pointer(mode)).Fwindow, overlap, (*OpusT_OpusCustomEncoder)(unsafe.Pointer(st1)).Farch)
			goto _66
		_66:
			;
			c = c + 1
			v29 = c
			if !(v29 < CC) {
				break
			}
		}
		gain1 = libc.Float32FromInt32(0)
		pf_on = 0
		qg = 0
	}
	c = 0
	for {
		libc.Xmemcpy(tls, st1+252+uintptr(c*overlap)*4, in+uintptr(c*(N+overlap))*4+uintptr(N)*4, libc.Uint64FromInt32(overlap)*uint64(4)+libc.Uint64FromInt64(0*((int64(st1+252+uintptr(c*overlap)*4)-int64(in+uintptr(c*(N+overlap))*4+uintptr(N)*4))/4)))
		if N > max_period {
			libc.Xmemcpy(tls, prefilter_mem+uintptr(c*max_period)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(N)*4, libc.Uint64FromInt32(max_period)*uint64(4)+libc.Uint64FromInt64(0*((int64(prefilter_mem+uintptr(c*max_period)*4)-int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(N)*4))/4)))
		} else {
			libc.Xmemmove(tls, prefilter_mem+uintptr(c*max_period)*4, prefilter_mem+uintptr(c*max_period)*4+uintptr(N)*4, libc.Uint64FromInt32(max_period-N)*uint64(4)+libc.Uint64FromInt64(0*((int64(prefilter_mem+uintptr(c*max_period)*4)-int64(prefilter_mem+uintptr(c*max_period)*4+uintptr(N)*4))/4)))
			libc.Xmemcpy(tls, prefilter_mem+uintptr(c*max_period)*4+uintptr(max_period)*4-uintptr(N)*4, (*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(prefilter_mem+uintptr(c*max_period)*4+uintptr(max_period)*4-uintptr(N)*4)-int64((*(*[2]uintptr)(unsafe.Pointer(bp)))[c]+uintptr(max_period)*4))/4)))
		}
		goto _68
	_68:
		;
		c = c + 1
		v29 = c
		if !(v29 < CC) {
			break
		}
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _70
	_70:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _72
_72:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	*(*OpusT_opus_val16)(unsafe.Pointer(gain)) = gain1
	*(*int32)(unsafe.Pointer(pitch)) = *(*int32)(unsafe.Pointer(bp + 16))
	*(*int32)(unsafe.Pointer(qgain)) = qg
	return pf_on
}

func sigmoid_approx(tls *libc.TLS, x float32) (r float32) {
	return libc.Float32FromFloat32(0.5) + float32(libc.Float32FromFloat32(0.5)*tansig_approx(tls, float32(libc.Float32FromFloat32(0.5)*x)))
}

func skip_extension(tls *libc.TLS, pdata uintptr, len1 OpusT_opus_int32, pheader_size uintptr) (r OpusT_opus_int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var id_byte int32
	var v1 uintptr
	var _ /* data at bp+0 */ uintptr
	_, _ = id_byte, v1
	if len1 == 0 {
		*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = 0
		return 0
	}
	if len1 < int32(1) {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(pdata))
	v1 = *(*uintptr)(unsafe.Pointer(bp))
	*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(bp)) + 1
	id_byte = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
	len1 = len1 - 1
	len1 = skip_extension_payload(tls, bp, len1, pheader_size, id_byte, 0)
	if len1 >= 0 {
		*(*uintptr)(unsafe.Pointer(pdata)) = *(*uintptr)(unsafe.Pointer(bp))
		*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = *(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) + 1
	}
	return len1
}

func skip_extension_payload(tls *libc.TLS, pdata uintptr, len1 OpusT_opus_int32, pheader_size uintptr, id_byte int32, trailing_short_len OpusT_opus_int32) (r OpusT_opus_int32) {
	var L, id int32
	var bytes, header_size, lacing OpusT_opus_int32
	var data, v1 uintptr
	_, _, _, _, _, _, _ = L, bytes, data, header_size, id, lacing, v1
	data = *(*uintptr)(unsafe.Pointer(pdata))
	header_size = 0
	id = id_byte >> int32(1)
	L = id_byte & int32(1)
	if id == 0 && L == int32(1) || id == int32(2) {
		/* Nothing to do. */
	} else {
		if id > 0 && id < int32(32) {
			if len1 < L {
				return -int32(1)
			}
			data = data + uintptr(L)
			len1 = len1 - L
		} else {
			if L == 0 {
				if len1 < trailing_short_len {
					return -int32(1)
				}
				data = data + uintptr(len1-trailing_short_len)
				len1 = trailing_short_len
			} else {
				bytes = 0
				for cond := true; cond; cond = lacing == int32(255) {
					if len1 < int32(1) {
						return -int32(1)
					}
					v1 = data
					data = data + 1
					lacing = libc.Int32FromUint8(*(*uint8)(unsafe.Pointer(v1)))
					bytes = bytes + lacing
					header_size = header_size + 1
					len1 = len1 - (lacing + int32(1))
				}
				if len1 < 0 {
					return -int32(1)
				}
				data = data + uintptr(bytes)
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(pdata)) = data
	*(*OpusT_opus_int32)(unsafe.Pointer(pheader_size)) = header_size
	return len1
}

// C documentation
//
//	/* Given an extension, advance data to the next extension and return the
//	   length of the remaining extensions.
//	   N.B., a "Repeat These Extensions" extension (ID==2) only advances past the
//	    extension ID byte.
//	   Higher-level logic is required to skip the extension payloads that come
//	    after it.*/

func smooth_fade(tls *libc.TLS, in1 uintptr, in2 uintptr, out uintptr, overlap int32, channels int32, window uintptr, Fs OpusT_opus_int32) {
	var c, i, inc int32
	var w OpusT_celt_coef
	_, _, _, _ = c, i, inc, w
	inc = int32(48000) / Fs
	c = 0
	for {
		if !(c < channels) {
			break
		}
		i = 0
		for {
			if !(i < overlap) {
				break
			}
			w = OpusT_celt_coef(*(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4)) * *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4)))
			*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+c)*4)) = OpusT_celt_coef(w**(*OpusT_opus_res)(unsafe.Pointer(in2 + uintptr(i*channels+c)*4))) + float32((libc.Float32FromFloat32(1)-w)**(*OpusT_opus_res)(unsafe.Pointer(in1 + uintptr(i*channels+c)*4)))
			goto _2
		_2:
			;
			i = i + 1
		}
		goto _1
	_1:
		;
		c = c + 1
	}
}

func special_hybrid_folding(tls *libc.TLS, m uintptr, norm uintptr, norm2 uintptr, start int32, M int32, dual_stereo int32) {
	var eBands uintptr
	var n1, n2 int32
	_, _, _ = eBands, n1, n2
	eBands = (*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands
	n1 = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start)*2))))
	n2 = M * (int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(2))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer(eBands + uintptr(start+int32(1))*2))))
	/* Duplicate enough of the first band folding data to be able to fold the second band.
	   Copies no data for CELT-only mode. */
	libc.Xmemcpy(tls, norm+uintptr(n1)*4, norm+uintptr(int32(2)*n1-n2)*4, libc.Uint64FromInt32(n2-n1)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(norm+uintptr(n1)*4)-OpusT___predefined_ptrdiff_t(norm+uintptr(int32(2)*n1-n2)*4))/4)))
	if dual_stereo != 0 {
		libc.Xmemcpy(tls, norm2+uintptr(n1)*4, norm2+uintptr(int32(2)*n1-n2)*4, libc.Uint64FromInt32(n2-n1)*uint64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(norm2+uintptr(n1)*4)-OpusT___predefined_ptrdiff_t(norm2+uintptr(int32(2)*n1-n2)*4))/4)))
	}
}

func stereo_analysis(tls *libc.TLS, m uintptr, X uintptr, LM int32, N0 int32) (r int32) {
	var L, M, R, S, sumLR, sumMS OpusT_opus_val32
	var i, j, thetas int32
	_, _, _, _, _, _, _, _, _ = L, M, R, S, i, j, sumLR, sumMS, thetas
	sumLR = libc.Float32FromFloat32(1e-15)
	sumMS = libc.Float32FromFloat32(1e-15)
	/* Use the L1 norm to model the entropy of the L/R signal vs the M/S signal */
	i = 0
	for {
		if !(i < int32(13)) {
			break
		}
		j = int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2))) << LM
		for {
			if !(j < int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2)))<<LM) {
				break
			}
			/* We cast to 32-bit first because of the -32768 case */
			L = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4))
			R = *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(N0+j)*4))
			M = L + R
			S = L - R
			sumLR = sumLR + (float32(libc.Xfabs(tls, float64(L))) + float32(libc.Xfabs(tls, float64(R))))
			sumMS = sumMS + (float32(libc.Xfabs(tls, float64(M))) + float32(libc.Xfabs(tls, float64(S))))
			goto _2
		_2:
			;
			j = j + 1
		}
		goto _1
	_1:
		;
		i = i + 1
	}
	sumMS = float32(libc.Float32FromFloat32(0.707107) * sumMS)
	thetas = int32(13)
	/* We don't need thetas for lower bands with LM<=1 */
	if LM <= int32(1) {
		thetas = thetas - int32(8)
	}
	return libc.BoolInt32(OpusT_opus_val32(float32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + 13*2)))<<(LM+libc.Int32FromInt32(1))+thetas)*sumMS) > OpusT_opus_val32(float32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + 13*2)))<<(LM+libc.Int32FromInt32(1)))*sumLR))
}

func stereo_fade(tls *libc.TLS, in uintptr, out uintptr, g1 OpusT_opus_val16, g2 OpusT_opus_val16, overlap48 int32, frame_size int32, channels int32, window uintptr, Fs OpusT_opus_int32) {
	var diff, diff1 OpusT_opus_val32
	var g, w OpusT_opus_val16
	var i, inc, overlap, v1 int32
	_, _, _, _, _, _, _, _ = diff, diff1, g, i, inc, overlap, w, v1
	if int32(1) > int32(48000)/Fs {
		v1 = int32(1)
	} else {
		v1 = int32(48000) / Fs
	}
	inc = v1
	overlap = overlap48 / inc
	g1 = libc.Float32FromFloat32(1) - g1
	g2 = libc.Float32FromFloat32(1) - g2
	i = 0
	for {
		if !(i < overlap) {
			break
		}
		w = *(*OpusT_celt_coef)(unsafe.Pointer(window + uintptr(i*inc)*4))
		w = OpusT_opus_val16(w * w)
		g = OpusT_opus_val32(w*g2) + OpusT_opus_val32((libc.Float32FromFloat32(1)-w)*g1)
		diff = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*channels)*4)) - *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*channels+int32(1))*4))))
		diff = OpusT_opus_val16(g * diff)
		*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels)*4)) - diff
		*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+int32(1))*4)) = *(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+int32(1))*4)) + diff
		goto _2
	_2:
		;
		i = i + 1
	}
	for {
		if !(i < frame_size) {
			break
		}
		diff1 = float32(libc.Float32FromFloat32(0.5) * (*(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*channels)*4)) - *(*OpusT_opus_res)(unsafe.Pointer(in + uintptr(i*channels+int32(1))*4))))
		diff1 = OpusT_opus_val16(g2 * diff1)
		*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels)*4)) = *(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels)*4)) - diff1
		*(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+int32(1))*4)) = *(*OpusT_opus_res)(unsafe.Pointer(out + uintptr(i*channels+int32(1))*4)) + diff1
		goto _3
	_3:
		;
		i = i + 1
	}
}

func stereo_merge(tls *libc.TLS, X uintptr, Y uintptr, mid OpusT_opus_val32, N1 int32, arch int32) {
	var El, Er, lgain, rgain, side, t, xp, xy, v2 OpusT_opus_val32
	var i, j int32
	var l, r OpusT_celt_norm
	_, _, _, _, _, _, _, _, _, _, _, _, _ = El, Er, i, j, l, lgain, r, rgain, side, t, xp, xy, v2
	xp = libc.Float32FromInt32(0)
	side = libc.Float32FromInt32(0)
	/* Compute the norm of X+Y and X-Y as |X|^2 + |Y|^2 +/- sum(xy) */
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(X + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	v2 = xy
	goto _3
_3:
	xp = v2
	_ = arch
	xy = libc.Float32FromInt32(0)
	i = libc.Int32FromInt32(0)
	for {
		if !(i < N1) {
			break
		}
		xy = xy + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(Y + uintptr(i)*4)))
		goto _4
	_4:
		;
		i = i + 1
	}
	v2 = xy
	goto _6
_6:
	side = v2
	/* Compensating for the mid normalization */
	xp = OpusT_opus_val32(mid * xp)
	/* mid and side are in Q15, not Q14 like X and Y */
	El = OpusT_opus_val32(mid*mid) + side - OpusT_opus_val32(libc.Float32FromInt32(2)*xp)
	Er = OpusT_opus_val32(mid*mid) + side + OpusT_opus_val32(libc.Float32FromInt32(2)*xp)
	if Er < libc.Float32FromFloat32(0.0006) || El < libc.Float32FromFloat32(0.0006) {
		libc.Xmemcpy(tls, Y, X, libc.Uint64FromInt32(N1)*uint64(4)+libc.Uint64FromInt64(0*((int64(Y)-int64(X))/4)))
		return
	}
	t = El
	lgain = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t)))
	t = Er
	rgain = libc.Float32FromFloat32(1) / float32(libc.Xsqrt(tls, float64(t)))
	j = 0
	for {
		if !(j < N1) {
			break
		}
		/* Apply mid scaling (side is already scaled) */
		l = OpusT_opus_val32(mid * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
		r = *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4))
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = OpusT_opus_val32(lgain * (l - r))
		*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = OpusT_opus_val32(rgain * (l + r))
		goto _7
	_7:
		;
		j = j + 1
	}
}

// C documentation
//
//	/* Decide whether we should spread the pulses in the current frame */

func stereo_split(tls *libc.TLS, X uintptr, Y uintptr, N int32) {
	var j int32
	var l, r OpusT_opus_val32
	_, _, _ = j, l, r
	j = 0
	for {
		if !(j < N) {
			break
		}
		l = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)))
		r = float32(libc.Float32FromFloat32(0.70710678) * *(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)))
		*(*OpusT_celt_norm)(unsafe.Pointer(X + uintptr(j)*4)) = l + r
		*(*OpusT_celt_norm)(unsafe.Pointer(Y + uintptr(j)*4)) = r - l
		goto _1
	_1:
		;
		j = j + 1
	}
}

func surround_rate_allocation(tls *libc.TLS, st uintptr, rate uintptr, frame_size int32, Fs OpusT_opus_int32) {
	var bitrate, channel_offset, channel_rate OpusT_opus_int32
	var coupled_ratio, i, lfe_offset, lfe_ratio, nb_coupled, nb_lfe, nb_normal, nb_uncoupled, stream_offset, total, v1, v2, v3 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bitrate, channel_offset, channel_rate, coupled_ratio, i, lfe_offset, lfe_ratio, nb_coupled, nb_lfe, nb_normal, nb_uncoupled, stream_offset, total, v1, v2, v3
	nb_lfe = libc.BoolInt32((*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream != -int32(1))
	nb_coupled = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams
	nb_uncoupled = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams - nb_coupled - nb_lfe
	nb_normal = int32(2)*nb_coupled + nb_uncoupled
	/* Give each non-LFE channel enough bits per channel for coding band energy. */
	if int32(50) > Fs/frame_size {
		v1 = int32(50)
	} else {
		v1 = Fs / frame_size
	}
	channel_offset = int32(40) * v1
	if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps == -int32(1000) {
		bitrate = nb_normal*(channel_offset+Fs+int32(10000)) + int32(8000)*nb_lfe
	} else {
		if (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps == -int32(1) {
			bitrate = nb_normal*int32(750000) + nb_lfe*int32(128000)
		} else {
			bitrate = (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Fbitrate_bps
		}
	}
	/* Give LFE some basic stream_channel allocation but never exceed 1/20 of the
	   total rate for the non-energy part to avoid problems at really low rate. */
	if bitrate/int32(20) < int32(3000) {
		v1 = bitrate / int32(20)
	} else {
		v1 = int32(3000)
	}
	if int32(50) > Fs/frame_size {
		v2 = int32(50)
	} else {
		v2 = Fs / frame_size
	}
	lfe_offset = v1 + int32(15)*v2
	/* We give each stream (coupled or uncoupled) a starting bitrate.
	   This models the main saving of coupled channels over uncoupled. */
	stream_offset = (bitrate - channel_offset*nb_normal - lfe_offset*nb_lfe) / nb_normal / int32(2)
	if int32(20000) < stream_offset {
		v2 = int32(20000)
	} else {
		v2 = stream_offset
	}
	if 0 > v2 {
		v1 = 0
	} else {
		if int32(20000) < stream_offset {
			v3 = int32(20000)
		} else {
			v3 = stream_offset
		}
		v1 = v3
	}
	stream_offset = v1
	/* Coupled streams get twice the mono rate after the offset is allocated. */
	coupled_ratio = int32(512)
	/* Should depend on the bitrate, for now we assume LFE gets 1/8 the bits of mono */
	lfe_ratio = int32(32)
	total = nb_uncoupled<<int32(8) + coupled_ratio*nb_coupled + nb_lfe*lfe_ratio
	channel_rate = int32(int64(256) * int64(bitrate-lfe_offset*nb_lfe-stream_offset*(nb_coupled+nb_uncoupled)-channel_offset*nb_normal) / int64(total))
	i = 0
	for {
		if !(i < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_streams) {
			break
		}
		if i < (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flayout.Fnb_coupled_streams {
			if 0 > stream_offset+channel_rate*coupled_ratio>>int32(8) {
				v1 = 0
			} else {
				v1 = stream_offset + channel_rate*coupled_ratio>>int32(8)
			}
			*(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i)*4)) = int32(2)*channel_offset + v1
		} else {
			if i != (*OpusT_OpusMSEncoder)(unsafe.Pointer(st)).Flfe_stream {
				if 0 > stream_offset+channel_rate {
					v1 = 0
				} else {
					v1 = stream_offset + channel_rate
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i)*4)) = channel_offset + v1
			} else {
				if 0 > lfe_offset+channel_rate*lfe_ratio>>int32(8) {
					v1 = 0
				} else {
					v1 = lfe_offset + channel_rate*lfe_ratio>>int32(8)
				}
				*(*OpusT_opus_int32)(unsafe.Pointer(rate + uintptr(i)*4)) = v1
			}
		}
		goto _7
	_7:
		;
		i = i + 1
	}
}

func tansig_approx(tls *libc.TLS, x float32) (r float32) {
	var D0, D1, D2, N0, N1, N2, X2, den, num, v1, v2, v3 float32
	_, _, _, _, _, _, _, _, _, _, _, _ = D0, D1, D2, N0, N1, N2, X2, den, num, v1, v2, v3
	N0 = libc.Float32FromFloat32(952.52801514)
	N1 = libc.Float32FromFloat32(96.39235687)
	N2 = libc.Float32FromFloat32(0.60863042)
	D0 = libc.Float32FromFloat32(952.72399902)
	D1 = libc.Float32FromFloat32(413.36801147)
	D2 = libc.Float32FromFloat32(11.88600922)
	X2 = float32(x * x)
	num = float32((float32(N2*X2)+N1)*X2) + N0
	den = float32((float32(D2*X2)+D1)*X2) + D0
	num = float32(num*x) / den
	if libc.Float32FromFloat32(1) < num {
		v2 = libc.Float32FromFloat32(1)
	} else {
		v2 = num
	}
	if -libc.Float32FromFloat32(1) > v2 {
		v1 = -libc.Float32FromFloat32(1)
	} else {
		if libc.Float32FromFloat32(1) < num {
			v3 = libc.Float32FromFloat32(1)
		} else {
			v3 = num
		}
		v1 = v3
	}
	return v1
}

func tf_analysis(tls *libc.TLS, m uintptr, len1 int32, isTransient int32, tf_res uintptr, lambda int32, X uintptr, N0 int32, LM int32, tf_estimate OpusT_opus_val16, tf_chan int32, importance uintptr) (r int32) {
	var B, N, best_level, cost0, cost1, curr0, curr01, curr1, curr11, from0, from1, i, k, narrow, sel, tf_select, v127 int32
	var L1, best_L1 OpusT_opus_val32
	var _saved_stack, metric, path0, path1, st, tmp, tmp_1, v1, v10, v12, v14, v16, v18, v20, v22, v24, v3, v6, v8 uintptr
	var bias OpusT_opus_val16
	var selcost [2]int32
	var v5 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = B, L1, N, _saved_stack, best_L1, best_level, bias, cost0, cost1, curr0, curr01, curr1, curr11, from0, from1, i, k, metric, narrow, path0, path1, sel, selcost, st, tf_select, tmp, tmp_1, v1, v10, v12, v127, v14, v16, v18, v20, v22, v24, v3, v5, v6, v8
	tf_select = 0
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if -libc.Float32FromFloat32(0.25) > libc.Float32FromFloat32(0.5)-tf_estimate {
		v5 = -libc.Float32FromFloat32(0.25)
	} else {
		v5 = libc.Float32FromFloat32(0.5) - tf_estimate
	}
	bias = float32(libc.Float32FromFloat32(0.04) * v5)
	/*printf("%f ", bias);*/
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _7
	_7:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _9
_9:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _11
	_11:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _13
_13:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _15
	_15:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _17
_17:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _19
	_19:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _21
_21:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(684))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _23
	_23:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _25
_25:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _27
	_27:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _29
_29:
	metric = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _31
	_31:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _33
_33:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _35
	_35:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _37
_37:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _39
	_39:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _41
_41:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _43
	_43:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _45
_45:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(685))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _49
_49:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _51
	_51:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _53
_53:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _55
	_55:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _57
_57:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _59
	_59:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _61
_61:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _63
	_63:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _65
_65:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _67
	_67:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _69
_69:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(686))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _71
	_71:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _73
_73:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _75
	_75:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _77
_77:
	tmp_1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32((int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1)*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(len1-int32(1))*2))))<<LM)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _79
	_79:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _81
_81:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _83
	_83:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _85
_85:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _87
	_87:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _89
_89:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _91
	_91:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _93
_93:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(687))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _95
	_95:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _97
_97:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _99
	_99:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _101
_101:
	path0 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _103
	_103:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _105
_105:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v6 = libc.Xmalloc(tls, uint64(16))
		goto _107
	_107:
		st = v6
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v8 = st
	goto _109
_109:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v8)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v10 = libc.Xmalloc(tls, uint64(16))
		goto _111
	_111:
		st = v10
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v12 = st
	goto _113
_113:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _115
	_115:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v16 = st
	goto _117
_117:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v12)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v16)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(688))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v18 = libc.Xmalloc(tls, uint64(16))
		goto _119
	_119:
		st = v18
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v20 = st
	goto _121
_121:
	*(*uintptr)(unsafe.Pointer(v20 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v22 = libc.Xmalloc(tls, uint64(16))
		goto _123
	_123:
		st = v22
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v24 = st
	goto _125
_125:
	path1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v24)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < len1) {
			break
		}
		best_level = 0
		N = (int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2))) - int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))) << LM
		/* band is too narrow to be split down to LM=-1 */
		narrow = libc.BoolInt32(int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i+int32(1))*2)))-int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2))) == int32(1))
		libc.Xmemcpy(tls, tmp, X+uintptr(tf_chan*N0+int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))<<LM)*4, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(tmp)-OpusT___predefined_ptrdiff_t(X+uintptr(tf_chan*N0+int32(*(*OpusT_opus_int16)(unsafe.Pointer((*OpusT_OpusCustomMode)(unsafe.Pointer(m)).FeBands + uintptr(i)*2)))<<LM)*4))/4)))
		/* Just add the right channel if we're in stereo */
		/*if (C==2)
		  for (j=0;j<N;j++)
		     tmp[j] = ADD16(SHR16(tmp[j], 1),SHR16(X[N0+j+(m->eBands[i]<<LM)], 1));*/
		if isTransient != 0 {
			v127 = LM
		} else {
			v127 = 0
		}
		L1 = l1_metric(tls, tmp, N, v127, bias)
		best_L1 = L1
		/* Check the -1 case for transients */
		if isTransient != 0 && !(narrow != 0) {
			libc.Xmemcpy(tls, tmp_1, tmp, libc.Uint64FromInt32(N)*uint64(4)+libc.Uint64FromInt64(0*((int64(tmp_1)-int64(tmp))/4)))
			Opus_haar1(tls, tmp_1, N>>LM, int32(1)<<LM)
			L1 = l1_metric(tls, tmp_1, N, LM+int32(1), bias)
			if L1 < best_L1 {
				best_L1 = L1
				best_level = -int32(1)
			}
		}
		/*printf ("%f ", L1);*/
		k = 0
		for {
			if !(k < LM+libc.BoolInt32(!(isTransient != 0 || narrow != 0))) {
				break
			}
			if isTransient != 0 {
				B = LM - k - int32(1)
			} else {
				B = k + int32(1)
			}
			Opus_haar1(tls, tmp, N>>k, int32(1)<<k)
			L1 = l1_metric(tls, tmp, N, B, bias)
			if L1 < best_L1 {
				best_L1 = L1
				best_level = k + int32(1)
			}
			goto _128
		_128:
			;
			k = k + 1
		}
		/*printf ("%d ", isTransient ? LM-best_level : best_level);*/
		/* metric is in Q1 to be able to select the mid-point (-0.5) for narrower bands */
		if isTransient != 0 {
			*(*int32)(unsafe.Pointer(metric + uintptr(i)*4)) = int32(2) * best_level
		} else {
			*(*int32)(unsafe.Pointer(metric + uintptr(i)*4)) = -int32(2) * best_level
		}
		/* For bands that can't be split to -1, set the metric to the half-way point to avoid
		   biasing the decision */
		if narrow != 0 && (*(*int32)(unsafe.Pointer(metric + uintptr(i)*4)) == 0 || *(*int32)(unsafe.Pointer(metric + uintptr(i)*4)) == -int32(2)*LM) {
			*(*int32)(unsafe.Pointer(metric + uintptr(i)*4)) -= int32(1)
		}
		/*printf("%d ", metric[i]/2 + (!isTransient)*LM);*/
		goto _126
	_126:
		;
		i = i + 1
	}
	/*printf("\n");*/
	/* Search for the optimal tf resolution, including tf_select */
	tf_select = 0
	sel = 0
	for {
		if !(sel < int32(2)) {
			break
		}
		cost0 = *(*int32)(unsafe.Pointer(importance)) * libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*sel+0)))))
		if isTransient != 0 {
			v127 = 0
		} else {
			v127 = lambda
		}
		cost1 = *(*int32)(unsafe.Pointer(importance))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*sel+int32(1)))))) + v127
		i = int32(1)
		for {
			if !(i < len1) {
				break
			}
			if cost0 < cost1+lambda {
				v127 = cost0
			} else {
				v127 = cost1 + lambda
			}
			curr0 = v127
			if cost0+lambda < cost1 {
				v127 = cost0 + lambda
			} else {
				v127 = cost1
			}
			curr1 = v127
			cost0 = curr0 + *(*int32)(unsafe.Pointer(importance + uintptr(i)*4))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric + uintptr(i)*4))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*sel+0)))))
			cost1 = curr1 + *(*int32)(unsafe.Pointer(importance + uintptr(i)*4))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric + uintptr(i)*4))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*sel+int32(1))))))
			goto _131
		_131:
			;
			i = i + 1
		}
		if cost0 < cost1 {
			v127 = cost0
		} else {
			v127 = cost1
		}
		cost0 = v127
		selcost[sel] = cost0
		goto _129
	_129:
		;
		sel = sel + 1
	}
	/* For now, we're conservative and only allow tf_select=1 for transients.
	 * If tests confirm it's useful for non-transients, we could allow it. */
	if selcost[int32(1)] < selcost[0] && isTransient != 0 {
		tf_select = int32(1)
	}
	cost0 = *(*int32)(unsafe.Pointer(importance)) * libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+0)))))
	if isTransient != 0 {
		v127 = 0
	} else {
		v127 = lambda
	}
	cost1 = *(*int32)(unsafe.Pointer(importance))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+int32(1)))))) + v127
	/* Viterbi forward pass */
	i = int32(1)
	for {
		if !(i < len1) {
			break
		}
		from0 = cost0
		from1 = cost1 + lambda
		if from0 < from1 {
			curr01 = from0
			*(*int32)(unsafe.Pointer(path0 + uintptr(i)*4)) = 0
		} else {
			curr01 = from1
			*(*int32)(unsafe.Pointer(path0 + uintptr(i)*4)) = int32(1)
		}
		from0 = cost0 + lambda
		from1 = cost1
		if from0 < from1 {
			curr11 = from0
			*(*int32)(unsafe.Pointer(path1 + uintptr(i)*4)) = 0
		} else {
			curr11 = from1
			*(*int32)(unsafe.Pointer(path1 + uintptr(i)*4)) = int32(1)
		}
		cost0 = curr01 + *(*int32)(unsafe.Pointer(importance + uintptr(i)*4))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric + uintptr(i)*4))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+0)))))
		cost1 = curr11 + *(*int32)(unsafe.Pointer(importance + uintptr(i)*4))*libc.Xabs(tls, *(*int32)(unsafe.Pointer(metric + uintptr(i)*4))-int32(2)*int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+int32(1))))))
		goto _136
	_136:
		;
		i = i + 1
	}
	if cost0 < cost1 {
		v127 = 0
	} else {
		v127 = int32(1)
	}
	*(*int32)(unsafe.Pointer(tf_res + uintptr(len1-int32(1))*4)) = v127
	/* Viterbi backward pass to check the decisions */
	i = len1 - int32(2)
	for {
		if !(i >= 0) {
			break
		}
		if *(*int32)(unsafe.Pointer(tf_res + uintptr(i+int32(1))*4)) == int32(1) {
			*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = *(*int32)(unsafe.Pointer(path1 + uintptr(i+int32(1))*4))
		} else {
			*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = *(*int32)(unsafe.Pointer(path0 + uintptr(i+int32(1))*4))
		}
		goto _138
	_138:
		;
		i = i - 1
	}
	/*printf("%d %f\n", *tf_sum, tf_estimate);*/
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _140
	_140:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _142
_142:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return tf_select
}

func tf_decode(tls *libc.TLS, start int32, end int32, isTransient int32, tf_res uintptr, LM int32, dec uintptr) {
	var budget, tell OpusT_opus_uint32
	var curr, i, logp, tf_changed, tf_select, tf_select_rsv, v2 int32
	var v1 uintptr
	_, _, _, _, _, _, _, _, _, _ = budget, curr, i, logp, tell, tf_changed, tf_select, tf_select_rsv, v1, v2
	budget = (*OpusT_ec_dec)(unsafe.Pointer(dec)).Fstorage * uint32(8)
	v1 = dec
	v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _3
_3:
	tell = libc.Uint32FromInt32(v2)
	if isTransient != 0 {
		v2 = int32(2)
	} else {
		v2 = int32(4)
	}
	logp = v2
	tf_select_rsv = libc.BoolInt32(LM > 0 && tell+libc.Uint32FromInt32(logp)+uint32(1) <= budget)
	budget = budget - libc.Uint32FromInt32(tf_select_rsv)
	v2 = libc.Int32FromInt32(0)
	curr = v2
	tf_changed = v2
	i = start
	for {
		if !(i < end) {
			break
		}
		if tell+libc.Uint32FromInt32(logp) <= budget {
			curr = curr ^ Opus_ec_dec_bit_logp(tls, dec, libc.Uint32FromInt32(logp))
			v1 = dec
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _9
		_9:
			tell = libc.Uint32FromInt32(v2)
			tf_changed = tf_changed | curr
		}
		*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = curr
		if isTransient != 0 {
			v2 = int32(4)
		} else {
			v2 = int32(5)
		}
		logp = v2
		goto _6
	_6:
		;
		i = i + 1
	}
	tf_select = 0
	if tf_select_rsv != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+0+tf_changed)))) != int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)+tf_changed)))) {
		tf_select = Opus_ec_dec_bit_logp(tls, dec, uint32(1))
	}
	i = start
	for {
		if !(i < end) {
			break
		}
		*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4))))))
		goto _11
	_11:
		;
		i = i + 1
	}
}

func tf_encode(tls *libc.TLS, start int32, end int32, isTransient int32, tf_res uintptr, LM int32, tf_select int32, enc uintptr) {
	var budget, tell OpusT_opus_uint32
	var curr, i, logp, tf_changed, tf_select_rsv, v2 int32
	var v1 uintptr
	_, _, _, _, _, _, _, _, _ = budget, curr, i, logp, tell, tf_changed, tf_select_rsv, v1, v2
	budget = (*OpusT_ec_enc)(unsafe.Pointer(enc)).Fstorage * uint32(8)
	v1 = enc
	v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
	goto _3
_3:
	tell = libc.Uint32FromInt32(v2)
	if isTransient != 0 {
		v2 = int32(2)
	} else {
		v2 = int32(4)
	}
	logp = v2
	/* Reserve space to code the tf_select decision. */
	tf_select_rsv = libc.BoolInt32(LM > 0 && tell+libc.Uint32FromInt32(logp)+uint32(1) <= budget)
	budget = budget - libc.Uint32FromInt32(tf_select_rsv)
	v2 = libc.Int32FromInt32(0)
	tf_changed = v2
	curr = v2
	i = start
	for {
		if !(i < end) {
			break
		}
		if tell+libc.Uint32FromInt32(logp) <= budget {
			Opus_ec_enc_bit_logp(tls, enc, *(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4))^curr, libc.Uint32FromInt32(logp))
			v1 = enc
			v2 = (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Fnbits_total - (libc.Int32FromInt64(4)*libc.Int32FromInt32(__CHAR_BIT__) - libc.X__builtin_clz(tls, (*OpusT_ec_ctx)(unsafe.Pointer(v1)).Frng))
			goto _9
		_9:
			tell = libc.Uint32FromInt32(v2)
			curr = *(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4))
			tf_changed = tf_changed | curr
		} else {
			*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = curr
		}
		if isTransient != 0 {
			v2 = int32(4)
		} else {
			v2 = int32(5)
		}
		logp = v2
		goto _6
	_6:
		;
		i = i + 1
	}
	/* Only code tf_select if it would actually make a difference. */
	if tf_select_rsv != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+0+tf_changed)))) != int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)+tf_changed)))) {
		Opus_ec_enc_bit_logp(tls, enc, tf_select, uint32(1))
	} else {
		tf_select = 0
	}
	i = start
	for {
		if !(i < end) {
			break
		}
		*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4)) = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(&Opus_tf_select_table)) + uintptr(LM)*8 + uintptr(int32(4)*isTransient+int32(2)*tf_select+*(*int32)(unsafe.Pointer(tf_res + uintptr(i)*4))))))
		goto _11
	_11:
		;
		i = i + 1
	}
	/*for(i=0;i<end;i++)printf("%d ", isTransient ? tf_res[i] : LM+tf_res[i]);printf("\n");*/
}

func tonality_analysis(tls *libc.TLS, tonal uintptr, celt_mode uintptr, x2 uintptr, len1 int32, offset int32, c1 int32, c2 int32, C int32, lsb_depth int32, __ccgo_fp_downmix OpusT_downmix_func) {
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var A, _saved_stack, d2A, dA, in1, info, kfft, noisiness, out, st, tonality, v1, v11, v14, v15, v17, v19, v21, v23, v25, v27, v3, v9 uintptr
	var BFCC, midE [8]float32
	var E, E1, E2, E3, Em, Em1, L1, L2, X1i, X1r, X1r1, X2i, X2r, X2r1, above_max_pitch, alpha, alphaE, alphaE2, angle, angle2, avg_mod, bandwidth_mask, below_max_pitch, binE, binE1, binE2, boost, d2_angle, d2_angle2, d_angle, d_angle2, den, den1, dist, frame_loudness, frame_noisiness, frame_stationarity, frame_tonality, hp_ener, leak_slope, leak_slope1, maxE, max_frame_tonality, mindist, mod1, mod2, nE, noise_floor, noise_ratio, pi4, relativeE, slope, spec_variability, stationarity, sum, sum1, tE, tmp, tt, w, x21, y2, v123, v124, v125, v127, v128, v129 float32
	var N, N2, b, band_end, band_start, bandwidth, i, is_silence, j, k, prev_pos, remaining, v5 int32
	var band_log2, leakage_from, leakage_to [19]float32
	var band_tonality, logE [18]float32
	var is_masked [19]int32
	var tonality2 [240]float32
	var v149 bool
	var _ /* features at bp+4 */ [25]float32
	var _ /* frame_probs at bp+104 */ [2]float32
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	var _ /* layer_out at bp+112 */ [32]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = A, BFCC, E, E1, E2, E3, Em, Em1, L1, L2, N, N2, X1i, X1r, X1r1, X2i, X2r, X2r1, _saved_stack, above_max_pitch, alpha, alphaE, alphaE2, angle, angle2, avg_mod, b, band_end, band_log2, band_start, band_tonality, bandwidth, bandwidth_mask, below_max_pitch, binE, binE1, binE2, boost, d2A, d2_angle, d2_angle2, dA, d_angle, d_angle2, den, den1, dist, frame_loudness, frame_noisiness, frame_stationarity, frame_tonality, hp_ener, i, in1, info, is_masked, is_silence, j, k, kfft, leak_slope, leak_slope1, leakage_from, leakage_to, logE, maxE, max_frame_tonality, midE, mindist, mod1, mod2, nE, noise_floor, noise_ratio, noisiness, out, pi4, prev_pos, relativeE, remaining, slope, spec_variability, st, stationarity, sum, sum1, tE, tmp, tonality, tonality2, tt, w, x21, y2, v1, v11, v123, v124, v125, v127, v128, v129, v14, v149, v15, v17, v19, v21, v23, v25, v27, v3, v5, v9
	N = int32(480)
	N2 = int32(240)
	A = tonal + 12
	dA = tonal + 972
	d2A = tonal + 1932
	pi4 = float32(float64(float64(float64(libc.Float64FromFloat64(M_PI)*libc.Float64FromFloat64(M_PI))*libc.Float64FromFloat64(M_PI)) * libc.Float64FromFloat64(M_PI)))
	slope = libc.Float32FromInt32(0)
	bandwidth = 0
	maxE = libc.Float32FromInt32(0)
	spec_variability = libc.Float32FromInt32(0)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	if !((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Finitialized != 0) {
		(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill = int32(240)
		(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Finitialized = int32(1)
	}
	if int32(10) < int32(1)+(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount {
		v5 = int32(10)
	} else {
		v5 = int32(1) + (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount
	}
	alpha = libc.Float32FromFloat32(1) / float32(v5)
	if int32(25) < int32(1)+(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount {
		v5 = int32(25)
	} else {
		v5 = int32(1) + (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount
	}
	alphaE = libc.Float32FromFloat32(1) / float32(v5)
	/* Noise floor related decay for bandwidth detection: -2.2 dB/second */
	if int32(100) < int32(1)+(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount {
		v5 = int32(100)
	} else {
		v5 = int32(1) + (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount
	}
	alphaE2 = libc.Float32FromFloat32(1) / float32(v5)
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount <= int32(1) {
		alphaE2 = libc.Float32FromInt32(1)
	}
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs == int32(48000) {
		/* len and offset are now at 24 kHz. */
		len1 = len1 / int32(2)
		offset = offset / int32(2)
	} else {
		if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs == int32(16000) {
			len1 = int32(3) * len1 / int32(2)
			offset = int32(3) * offset / int32(2)
		}
	}
	kfft = *(*uintptr)(unsafe.Pointer(celt_mode + 80 + 8))
	if len1 < int32(ANALYSIS_BUF_SIZE)-(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill {
		v5 = len1
	} else {
		v5 = int32(ANALYSIS_BUF_SIZE) - (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill
	}
	*(*float32)(unsafe.Pointer(tonal + 7456)) += downmix_and_resample(tls, __ccgo_fp_downmix, x2, tonal+2892+uintptr((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill)*4, tonal+7592, v5, offset, c1, c2, C, (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs)
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill+len1 < int32(ANALYSIS_BUF_SIZE) {
		*(*int32)(unsafe.Pointer(tonal + 5772)) += len1
		/* Don't have enough to update the analysis */
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _10
		_10:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _12
	_12:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return
	}
	hp_ener = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fhp_ener_accum
	v1 = tonal + 7444
	v5 = *(*int32)(unsafe.Pointer(v1))
	*(*int32)(unsafe.Pointer(v1)) = *(*int32)(unsafe.Pointer(v1)) + 1
	info = tonal + 7604 + uintptr(v5)*64
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos >= int32(DETECT_SIZE) {
		*(*int32)(unsafe.Pointer(tonal + 7444)) -= int32(DETECT_SIZE)
	}
	is_silence = Opus_is_digital_silence(tls, tonal+2892, int32(ANALYSIS_BUF_SIZE), int32(1), lsb_depth)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _16
	_16:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _18
_18:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _20
	_20:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _22
_22:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _24
	_24:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _26
_26:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _28
	_28:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _30
_30:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(480))*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(531))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _34
_34:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(480)) * (libc.Uint64FromInt64(8) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _36
	_36:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _38
_38:
	in1 = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(480))*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _40
	_40:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _42
_42:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _44
	_44:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _46
_46:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _48
	_48:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _50
_50:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _52
	_52:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _54
_54:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(480))*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(532))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _56
	_56:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _58
_58:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(480)) * (libc.Uint64FromInt64(8) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _60
	_60:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _62
_62:
	out = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(480))*(libc.Uint64FromInt64(8)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _64
	_64:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _66
_66:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _68
	_68:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _70
_70:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _72
	_72:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _74
_74:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _76
	_76:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _78
_78:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(240))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(533))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _80
	_80:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _82
_82:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(240)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _84
	_84:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _86
_86:
	tonality = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(240))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _88
	_88:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _90
_90:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _92
	_92:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _94
_94:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v14 = libc.Xmalloc(tls, uint64(16))
		goto _96
	_96:
		st = v14
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _98
_98:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _100
	_100:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _102
_102:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(libc.Int32FromInt32(240))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v19)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+3568, int32(534))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _104
	_104:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _106
_106:
	*(*uintptr)(unsafe.Pointer(v23 + 8)) += uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(240)) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v25 = libc.Xmalloc(tls, uint64(16))
		goto _108
	_108:
		st = v25
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v27 = st
	goto _110
_110:
	noisiness = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v27)).Fglobal_stack - uintptr(libc.Uint64FromInt32(libc.Int32FromInt32(240))*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	i = 0
	for {
		if !(i < N2) {
			break
		}
		w = analysis_window[i]
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(in1 + uintptr(i)*8))).Fr = float32(w * *(*OpusT_opus_val32)(unsafe.Pointer(tonal + 2892 + uintptr(i)*4)))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(in1 + uintptr(i)*8))).Fi = float32(w * *(*OpusT_opus_val32)(unsafe.Pointer(tonal + 2892 + uintptr(N2+i)*4)))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(in1 + uintptr(N-i-int32(1))*8))).Fr = float32(w * *(*OpusT_opus_val32)(unsafe.Pointer(tonal + 2892 + uintptr(N-i-int32(1))*4)))
		(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(in1 + uintptr(N-i-int32(1))*8))).Fi = float32(w * *(*OpusT_opus_val32)(unsafe.Pointer(tonal + 2892 + uintptr(N+N2-i-int32(1))*4)))
		goto _111
	_111:
		;
		i = i + 1
	}
	libc.Xmemmove(tls, tonal+2892, tonal+2892+libc.UintptrFromInt32(ANALYSIS_BUF_SIZE)*4-libc.UintptrFromInt32(240)*4, libc.Uint64FromInt32(libc.Int32FromInt32(240))*libc.Uint64FromInt64(4)+libc.Uint64FromInt64(0*((OpusT___predefined_ptrdiff_t(tonal+2892)-int64(tonal+2892+libc.UintptrFromInt32(ANALYSIS_BUF_SIZE)*4-libc.UintptrFromInt32(240)*4))/4)))
	remaining = len1 - (int32(ANALYSIS_BUF_SIZE) - (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill)
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fhp_ener_accum = downmix_and_resample(tls, __ccgo_fp_downmix, x2, tonal+2892+240*4, tonal+7592, remaining, offset+int32(ANALYSIS_BUF_SIZE)-(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill, c1, c2, C, (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs)
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fmem_fill = int32(240) + remaining
	if is_silence != 0 {
		/* On silence, copy the previous analysis. */
		prev_pos = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fwrite_pos - int32(2)
		if prev_pos < 0 {
			prev_pos = prev_pos + int32(DETECT_SIZE)
		}
		libc.Xmemcpy(tls, info, tonal+7604+uintptr(prev_pos)*64, libc.Uint64FromInt32(libc.Int32FromInt32(1))*libc.Uint64FromInt64(64)+libc.Uint64FromInt64(0*((int64(info)-OpusT___predefined_ptrdiff_t(tonal+7604+uintptr(prev_pos)*64))/64)))
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _113
		_113:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _115
	_115:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return
	}
	_ = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Farch
	Opus_opus_fft_c(tls, kfft, in1, out)
	/* If there's any NaN on the input, the entire output will be NaN, so we only need to check one value. */
	*(*float32)(unsafe.Pointer(bp)) = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out))).Fr
	v5 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
	goto _117
_117:
	if v5 != 0 {
		(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fvalid = 0
		st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
		if !(st != 0) {
			v1 = libc.Xmalloc(tls, uint64(16))
			goto _119
		_119:
			st = v1
			if st != 0 {
				libc.Xmemset(tls, st, 0, uint64(16))
			}
			libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
		}
		v3 = st
		goto _121
	_121:
		(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
		return
	}
	i = int32(1)
	for {
		if !(i < N2) {
			break
		}
		X1r = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr
		X1i = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi
		X2r = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi + (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi
		X2i = (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr - (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr
		v123 = X1i
		v124 = X1r
		x21 = float32(v124 * v124)
		y2 = float32(v123 * v123)
		if x21+y2 < libc.Float32FromFloat32(1e-18) {
			v125 = libc.Float32FromInt32(0)
			goto _126
		}
		if x21 < y2 {
			den = float32((y2 + float32(libc.Float32FromFloat32(0.67848403)*x21)) * (y2 + float32(libc.Float32FromFloat32(0.08595542)*x21)))
			if v123 < libc.Float32FromInt32(0) {
				v127 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v127 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			v125 = float32(float32(-v124*v123)*(y2+float32(libc.Float32FromFloat32(0.43157974)*x21)))/den + v127
			goto _126
		} else {
			den1 = float32((x21 + float32(libc.Float32FromFloat32(0.67848403)*y2)) * (x21 + float32(libc.Float32FromFloat32(0.08595542)*y2)))
			if v123 < libc.Float32FromInt32(0) {
				v128 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v128 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			if float32(v124*v123) < libc.Float32FromInt32(0) {
				v129 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v129 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			v125 = float32(float32(v124*v123)*(x21+float32(libc.Float32FromFloat32(0.43157974)*y2)))/den1 + v128 - v129
			goto _126
		}
	_126:
		angle = float32(float32(libc.Float64FromFloat32(0.5)/libc.Float64FromFloat64(M_PI)) * v125)
		d_angle = angle - *(*float32)(unsafe.Pointer(A + uintptr(i)*4))
		d2_angle = d_angle - *(*float32)(unsafe.Pointer(dA + uintptr(i)*4))
		v123 = X2i
		v124 = X2r
		x21 = float32(v124 * v124)
		y2 = float32(v123 * v123)
		if x21+y2 < libc.Float32FromFloat32(1e-18) {
			v125 = libc.Float32FromInt32(0)
			goto _133
		}
		if x21 < y2 {
			den = float32((y2 + float32(libc.Float32FromFloat32(0.67848403)*x21)) * (y2 + float32(libc.Float32FromFloat32(0.08595542)*x21)))
			if v123 < libc.Float32FromInt32(0) {
				v127 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v127 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			v125 = float32(float32(-v124*v123)*(y2+float32(libc.Float32FromFloat32(0.43157974)*x21)))/den + v127
			goto _133
		} else {
			den1 = float32((x21 + float32(libc.Float32FromFloat32(0.67848403)*y2)) * (x21 + float32(libc.Float32FromFloat32(0.08595542)*y2)))
			if v123 < libc.Float32FromInt32(0) {
				v128 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v128 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			if float32(v124*v123) < libc.Float32FromInt32(0) {
				v129 = -(libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2))
			} else {
				v129 = libc.Float32FromFloat64(3.141592653589793) / libc.Float32FromInt32(2)
			}
			v125 = float32(float32(v124*v123)*(x21+float32(libc.Float32FromFloat32(0.43157974)*y2)))/den1 + v128 - v129
			goto _133
		}
	_133:
		angle2 = float32(float32(libc.Float64FromFloat32(0.5)/libc.Float64FromFloat64(M_PI)) * v125)
		d_angle2 = angle2 - angle
		d2_angle2 = d_angle2 - d_angle
		mod1 = d2_angle - float32(Opus_lrintf(tls, d2_angle))
		*(*float32)(unsafe.Pointer(noisiness + uintptr(i)*4)) = float32(libc.Xfabs(tls, float64(mod1)))
		mod1 = mod1 * mod1
		mod1 = mod1 * mod1
		mod2 = d2_angle2 - float32(Opus_lrintf(tls, d2_angle2))
		*(*float32)(unsafe.Pointer(noisiness + uintptr(i)*4)) += float32(libc.Xfabs(tls, float64(mod2)))
		mod2 = mod2 * mod2
		mod2 = mod2 * mod2
		avg_mod = float32(libc.Float32FromFloat32(0.25) * (*(*float32)(unsafe.Pointer(d2A + uintptr(i)*4)) + mod1 + float32(libc.Float32FromInt32(2)*mod2)))
		/* This introduces an extra delay of 2 frames in the detection. */
		*(*float32)(unsafe.Pointer(tonality + uintptr(i)*4)) = libc.Float32FromFloat32(1)/(libc.Float32FromFloat32(1)+float32(float32(float32(libc.Float32FromFloat32(40)*libc.Float32FromFloat32(16))*pi4)*avg_mod)) - libc.Float32FromFloat32(0.015)
		/* No delay on this detection, but it's less reliable. */
		tonality2[i] = libc.Float32FromFloat32(1)/(libc.Float32FromFloat32(1)+float32(float32(float32(libc.Float32FromFloat32(40)*libc.Float32FromFloat32(16))*pi4)*mod2)) - libc.Float32FromFloat32(0.015)
		*(*float32)(unsafe.Pointer(A + uintptr(i)*4)) = angle2
		*(*float32)(unsafe.Pointer(dA + uintptr(i)*4)) = d_angle2
		*(*float32)(unsafe.Pointer(d2A + uintptr(i)*4)) = mod2
		goto _122
	_122:
		;
		i = i + 1
	}
	i = int32(2)
	for {
		if !(i < N2-int32(1)) {
			break
		}
		if tonality2[i-int32(1)] > tonality2[i+int32(1)] {
			v124 = tonality2[i-int32(1)]
		} else {
			v124 = tonality2[i+int32(1)]
		}
		if tonality2[i] < v124 {
			v123 = tonality2[i]
		} else {
			if tonality2[i-int32(1)] > tonality2[i+int32(1)] {
				v125 = tonality2[i-int32(1)]
			} else {
				v125 = tonality2[i+int32(1)]
			}
			v123 = v125
		}
		tt = v123
		if *(*float32)(unsafe.Pointer(tonality + uintptr(i)*4)) > tt-libc.Float32FromFloat32(0.1) {
			v127 = *(*float32)(unsafe.Pointer(tonality + uintptr(i)*4))
		} else {
			v127 = tt - libc.Float32FromFloat32(0.1)
		}
		*(*float32)(unsafe.Pointer(tonality + uintptr(i)*4)) = float32(libc.Float32FromFloat32(0.9) * v127)
		goto _137
	_137:
		;
		i = i + 1
	}
	frame_tonality = libc.Float32FromInt32(0)
	max_frame_tonality = libc.Float32FromInt32(0)
	/*tw_sum = 0;*/
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Factivity = libc.Float32FromInt32(0)
	frame_noisiness = libc.Float32FromInt32(0)
	frame_stationarity = libc.Float32FromInt32(0)
	if !((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount != 0) {
		b = 0
		for {
			if !(b < int32(NB_TBANDS)) {
				break
			}
			*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) = float32(1e+10)
			*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) = float32(-libc.Float64FromFloat64(1e+10))
			goto _142
		_142:
			;
			b = b + 1
		}
	}
	relativeE = libc.Float32FromInt32(0)
	frame_loudness = libc.Float32FromInt32(0)
	/* The energy of the very first band is special because of DC. */
	E = libc.Float32FromInt32(0)
	X1r1 = float32(libc.Float32FromInt32(2) * (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out))).Fr)
	X2r1 = float32(libc.Float32FromInt32(2) * (*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out))).Fi)
	E = float32(X1r1*X1r1) + float32(X2r1*X2r1)
	i = int32(1)
	for {
		if !(i < int32(4)) {
			break
		}
		binE = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi)
		E = E + binE
		goto _143
	_143:
		;
		i = i + 1
	}
	E = float32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) / libc.Float32FromInt32(32768) * E)
	band_log2[0] = float32(float32(libc.Float32FromFloat32(0.5)*libc.Float32FromFloat32(1.442695)) * float32(libc.Xlog(tls, float64(E+libc.Float32FromFloat32(1e-10)))))
	b = 0
	for {
		if !(b < int32(NB_TBANDS)) {
			break
		}
		E1 = libc.Float32FromInt32(0)
		tE = libc.Float32FromInt32(0)
		nE = libc.Float32FromInt32(0)
		i = tbands[b]
		for {
			if !(i < tbands[b+int32(1)]) {
				break
			}
			binE1 = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi)
			binE1 = float32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) / libc.Float32FromInt32(32768) * binE1)
			E1 = E1 + binE1
			if float32(libc.Int32FromInt32(0)) > *(*float32)(unsafe.Pointer(tonality + uintptr(i)*4)) {
				v123 = float32(libc.Int32FromInt32(0))
			} else {
				v123 = *(*float32)(unsafe.Pointer(tonality + uintptr(i)*4))
			}
			tE = tE + float32(binE1*v123)
			nE = nE + float32(float32(binE1*libc.Float32FromFloat32(2))*(libc.Float32FromFloat32(0.5)-*(*float32)(unsafe.Pointer(noisiness + uintptr(i)*4))))
			goto _145
		_145:
			;
			i = i + 1
		}
		/* Check for extreme band energies that could cause NaNs later. */
		if v149 = !(E1 < libc.Float32FromFloat32(1e+09)); !v149 {
			*(*float32)(unsafe.Pointer(bp)) = E1
			v5 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
			goto _148
		_148:
		}
		if v149 || v5 != 0 {
			(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fvalid = 0
			st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
			if !(st != 0) {
				v1 = libc.Xmalloc(tls, uint64(16))
				goto _151
			_151:
				st = v1
				if st != 0 {
					libc.Xmemset(tls, st, 0, uint64(16))
				}
				libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
			}
			v3 = st
			goto _153
		_153:
			(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
			return
		}
		*(*float32)(unsafe.Pointer(tonal + 5856 + uintptr((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FE_count)*72 + uintptr(b)*4)) = E1
		frame_noisiness = frame_noisiness + nE/(libc.Float32FromFloat32(1e-15)+E1)
		frame_loudness = frame_loudness + float32(libc.Xsqrt(tls, float64(E1+libc.Float32FromFloat32(1e-10))))
		logE[b] = float32(libc.Xlog(tls, float64(E1+libc.Float32FromFloat32(1e-10))))
		band_log2[b+int32(1)] = float32(float32(libc.Float32FromFloat32(0.5)*libc.Float32FromFloat32(1.442695)) * float32(libc.Xlog(tls, float64(E1+libc.Float32FromFloat32(1e-10)))))
		*(*float32)(unsafe.Pointer(tonal + 6432 + uintptr((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FE_count)*72 + uintptr(b)*4)) = logE[b]
		if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount == 0 {
			v123 = logE[b]
			*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) = v123
			*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) = v123
		}
		if float64(*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))) > float64(*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)))+float64(7.5) {
			if *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))-logE[b] > logE[b]-*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) {
				*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) -= libc.Float32FromFloat32(0.01)
			} else {
				*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) += libc.Float32FromFloat32(0.01)
			}
		}
		if logE[b] > *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) {
			*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) = logE[b]
			if *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))-libc.Float32FromInt32(15) > *(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) {
				v123 = *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) - libc.Float32FromInt32(15)
			} else {
				v123 = *(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4))
			}
			*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) = v123
		} else {
			if logE[b] < *(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) {
				*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) = logE[b]
				if *(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4))+libc.Float32FromInt32(15) < *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) {
					v123 = *(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)) + libc.Float32FromInt32(15)
				} else {
					v123 = *(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))
				}
				*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4)) = v123
			}
		}
		relativeE = relativeE + (logE[b]-*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4)))/(libc.Float32FromFloat32(1e-05)+(*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))-*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4))))
		v123 = libc.Float32FromInt32(0)
		L2 = v123
		L1 = v123
		i = 0
		for {
			if !(i < int32(NB_FRAMES)) {
				break
			}
			L1 = L1 + float32(libc.Xsqrt(tls, float64(*(*float32)(unsafe.Pointer(tonal + 5856 + uintptr(i)*72 + uintptr(b)*4)))))
			L2 = L2 + *(*float32)(unsafe.Pointer(tonal + 5856 + uintptr(i)*72 + uintptr(b)*4))
			goto _158
		_158:
			;
			i = i + 1
		}
		if libc.Float32FromFloat32(0.99) < L1/float32(libc.Xsqrt(tls, float64(1e-15)+float64(libc.Float32FromInt32(NB_FRAMES)*L2))) {
			v123 = libc.Float32FromFloat32(0.99)
		} else {
			v123 = L1 / float32(libc.Xsqrt(tls, float64(1e-15)+float64(libc.Float32FromInt32(NB_FRAMES)*L2)))
		}
		stationarity = v123
		stationarity = stationarity * stationarity
		stationarity = stationarity * stationarity
		frame_stationarity = frame_stationarity + stationarity
		/*band_tonality[b] = tE/(1e-15+E)*/
		if tE/(libc.Float32FromFloat32(1e-15)+E1) > float32(stationarity**(*float32)(unsafe.Pointer(tonal + 5776 + uintptr(b)*4))) {
			v123 = tE / (libc.Float32FromFloat32(1e-15) + E1)
		} else {
			v123 = float32(stationarity * *(*float32)(unsafe.Pointer(tonal + 5776 + uintptr(b)*4)))
		}
		band_tonality[b] = v123
		frame_tonality = frame_tonality + band_tonality[b]
		if b >= libc.Int32FromInt32(NB_TBANDS)-libc.Int32FromInt32(NB_TONAL_SKIP_BANDS) {
			frame_tonality = frame_tonality - band_tonality[b-int32(NB_TBANDS)+int32(NB_TONAL_SKIP_BANDS)]
		}
		if max_frame_tonality > float32((libc.Float32FromFloat32(1)+float32(libc.Float32FromFloat32(0.03)*float32(b-libc.Int32FromInt32(NB_TBANDS))))*frame_tonality) {
			v123 = max_frame_tonality
		} else {
			v123 = float32((libc.Float32FromFloat32(1) + float32(libc.Float32FromFloat32(0.03)*float32(b-libc.Int32FromInt32(NB_TBANDS)))) * frame_tonality)
		}
		max_frame_tonality = v123
		slope = slope + float32(band_tonality[b]*float32(b-libc.Int32FromInt32(8)))
		/*printf("%f %f ", band_tonality[b], stationarity);*/
		*(*float32)(unsafe.Pointer(tonal + 5776 + uintptr(b)*4)) = band_tonality[b]
		goto _144
	_144:
		;
		b = b + 1
	}
	leakage_from[0] = band_log2[0]
	leakage_to[0] = band_log2[0] - libc.Float32FromFloat32(2.5)
	b = int32(1)
	for {
		if !(b < libc.Int32FromInt32(NB_TBANDS)+libc.Int32FromInt32(1)) {
			break
		}
		leak_slope = float32(libc.Float32FromFloat32(2)*float32(tbands[b]-tbands[b-int32(1)])) / libc.Float32FromInt32(4)
		if leakage_from[b-int32(1)]+leak_slope < band_log2[b] {
			v123 = leakage_from[b-int32(1)] + leak_slope
		} else {
			v123 = band_log2[b]
		}
		leakage_from[b] = v123
		if leakage_to[b-int32(1)]-leak_slope > band_log2[b]-libc.Float32FromFloat32(2.5) {
			v123 = leakage_to[b-int32(1)] - leak_slope
		} else {
			v123 = band_log2[b] - libc.Float32FromFloat32(2.5)
		}
		leakage_to[b] = v123
		goto _162
	_162:
		;
		b = b + 1
	}
	b = libc.Int32FromInt32(NB_TBANDS) - libc.Int32FromInt32(2)
	for {
		if !(b >= 0) {
			break
		}
		leak_slope1 = float32(libc.Float32FromFloat32(2)*float32(tbands[b+int32(1)]-tbands[b])) / libc.Float32FromInt32(4)
		if leakage_from[b+int32(1)]+leak_slope1 < leakage_from[b] {
			v123 = leakage_from[b+int32(1)] + leak_slope1
		} else {
			v123 = leakage_from[b]
		}
		leakage_from[b] = v123
		if leakage_to[b+int32(1)]-leak_slope1 > leakage_to[b] {
			v123 = leakage_to[b+int32(1)] - leak_slope1
		} else {
			v123 = leakage_to[b]
		}
		leakage_to[b] = v123
		goto _165
	_165:
		;
		b = b - 1
	}
	if !(libc.Int32FromInt32(NB_TBANDS)+libc.Int32FromInt32(1) <= libc.Int32FromInt32(LEAK_BANDS)) {
		Opus_celt_fatal(tls, __ccgo_ts+3586, __ccgo_ts+3568, int32(741))
	}
	b = 0
	for {
		if !(b < libc.Int32FromInt32(NB_TBANDS)+libc.Int32FromInt32(1)) {
			break
		}
		if float32(libc.Int32FromInt32(0)) > leakage_to[b]-band_log2[b] {
			v123 = float32(libc.Int32FromInt32(0))
		} else {
			v123 = leakage_to[b] - band_log2[b]
		}
		if float32(libc.Int32FromInt32(0)) > band_log2[b]-(leakage_from[b]+libc.Float32FromFloat32(2.5)) {
			v124 = float32(libc.Int32FromInt32(0))
		} else {
			v124 = band_log2[b] - (leakage_from[b] + libc.Float32FromFloat32(2.5))
		}
		/* leak_boost[] is made up of two terms. The first, based on leakage_to[],
		   represents the boost needed to overcome the amount of analysis leakage
		   cause in a weaker band b by louder neighbouring bands.
		   The second, based on leakage_from[], applies to a loud band b for
		   which the quantization noise causes synthesis leakage to the weaker
		   neighbouring bands. */
		boost = v123 + v124
		if int32(255) < int32(libc.Xfloor(tls, float64(0.5)+float64(libc.Float32FromFloat32(64)*boost))) {
			v5 = int32(255)
		} else {
			v5 = int32(libc.Xfloor(tls, float64(0.5)+float64(libc.Float32FromFloat32(64)*boost)))
		}
		*(*uint8)(unsafe.Pointer(info + 44 + uintptr(b))) = libc.Uint8FromInt32(v5)
		goto _168
	_168:
		;
		b = b + 1
	}
	for {
		if !(b < int32(LEAK_BANDS)) {
			break
		}
		*(*uint8)(unsafe.Pointer(info + 44 + uintptr(b))) = uint8(0)
		goto _172
	_172:
		;
		b = b + 1
	}
	i = 0
	for {
		if !(i < int32(NB_FRAMES)) {
			break
		}
		mindist = libc.Float32FromFloat32(1e+15)
		j = 0
		for {
			if !(j < int32(NB_FRAMES)) {
				break
			}
			dist = libc.Float32FromInt32(0)
			k = 0
			for {
				if !(k < int32(NB_TBANDS)) {
					break
				}
				tmp = *(*float32)(unsafe.Pointer(tonal + 6432 + uintptr(i)*72 + uintptr(k)*4)) - *(*float32)(unsafe.Pointer(tonal + 6432 + uintptr(j)*72 + uintptr(k)*4))
				dist = dist + float32(tmp*tmp)
				goto _175
			_175:
				;
				k = k + 1
			}
			if j != i {
				if mindist < dist {
					v123 = mindist
				} else {
					v123 = dist
				}
				mindist = v123
			}
			goto _174
		_174:
			;
			j = j + 1
		}
		spec_variability = spec_variability + mindist
		goto _173
	_173:
		;
		i = i + 1
	}
	spec_variability = float32(libc.Xsqrt(tls, float64(spec_variability/libc.Float32FromInt32(NB_FRAMES)/libc.Float32FromInt32(NB_TBANDS))))
	bandwidth_mask = libc.Float32FromInt32(0)
	bandwidth = 0
	maxE = libc.Float32FromInt32(0)
	if 0 > lsb_depth-int32(8) {
		v5 = 0
	} else {
		v5 = lsb_depth - int32(8)
	}
	noise_floor = libc.Float32FromFloat32(0.00057) / float32(libc.Int32FromInt32(1)<<v5)
	noise_floor = noise_floor * noise_floor
	below_max_pitch = libc.Float32FromInt32(0)
	above_max_pitch = libc.Float32FromInt32(0)
	b = 0
	for {
		if !(b < int32(NB_TBANDS)) {
			break
		}
		E2 = libc.Float32FromInt32(0)
		/* Keep a margin of 300 Hz for aliasing */
		band_start = tbands[b]
		band_end = tbands[b+int32(1)]
		i = band_start
		for {
			if !(i < band_end) {
				break
			}
			binE2 = float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fr) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(i)*8))).Fi) + float32((*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi*(*(*OpusT_kiss_fft_cpx)(unsafe.Pointer(out + uintptr(N-i)*8))).Fi)
			E2 = E2 + binE2
			goto _179
		_179:
			;
			i = i + 1
		}
		E2 = float32(libc.Float32FromFloat32(1) / libc.Float32FromInt32(32768) / libc.Float32FromInt32(32768) * E2)
		if maxE > E2 {
			v123 = maxE
		} else {
			v123 = E2
		}
		maxE = v123
		if band_start < int32(64) {
			below_max_pitch = below_max_pitch + E2
		} else {
			above_max_pitch = above_max_pitch + E2
		}
		if float32((libc.Float32FromInt32(1)-alphaE2)**(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4))) > E2 {
			v123 = float32((libc.Float32FromInt32(1) - alphaE2) * *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)))
		} else {
			v123 = E2
		}
		*(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)) = v123
		if E2 > *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)) {
			v123 = E2
		} else {
			v123 = *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4))
		}
		Em = v123
		/* Consider the band "active" only if all these conditions are met:
		   1) less than 90 dB below the peak band (maximal masking possible considering
		      both the ATH and the loudness-dependent slope of the spreading function)
		   2) above the PCM quantization noise floor
		   We use b+1 because the first CELT band isn't included in tbands[]
		*/
		if float32(E2*libc.Float32FromFloat32(1e+09)) > maxE && (Em > float32(float32(libc.Float32FromInt32(3)*noise_floor)*float32(band_end-band_start)) || E2 > float32(noise_floor*float32(band_end-band_start))) {
			bandwidth = b + int32(1)
		}
		/* Check if the band is masked (see below). */
		if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_bandwidth >= b+int32(1) {
			v123 = libc.Float32FromFloat32(0.01)
		} else {
			v123 = libc.Float32FromFloat32(0.05)
		}
		is_masked[b] = libc.BoolInt32(E2 < float32(v123*bandwidth_mask))
		/* Use a simple follower with 13 dB/Bark slope for spreading function. */
		if float32(libc.Float32FromFloat32(0.05)*bandwidth_mask) > E2 {
			v123 = float32(libc.Float32FromFloat32(0.05) * bandwidth_mask)
		} else {
			v123 = E2
		}
		bandwidth_mask = v123
		goto _178
	_178:
		;
		b = b + 1
	}
	/* Special case for the last two bands, for which we don't have spectrum but only
	   the energy above 12 kHz. The difficulty here is that the high-pass we use
	   leaks some LF energy, so we need to increase the threshold without accidentally cutting
	   off the band. */
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FFs == int32(48000) {
		E3 = float32(hp_ener * (libc.Float32FromFloat32(1) / float32(libc.Int32FromInt32(60)*libc.Int32FromInt32(60))))
		if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_bandwidth == int32(20) {
			v123 = libc.Float32FromFloat32(10)
		} else {
			v123 = libc.Float32FromFloat32(30)
		}
		noise_ratio = v123
		above_max_pitch = above_max_pitch + E3
		if float32((libc.Float32FromInt32(1)-alphaE2)**(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4))) > E3 {
			v123 = float32((libc.Float32FromInt32(1) - alphaE2) * *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)))
		} else {
			v123 = E3
		}
		*(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)) = v123
		if E3 > *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4)) {
			v123 = E3
		} else {
			v123 = *(*float32)(unsafe.Pointer(tonal + 7152 + uintptr(b)*4))
		}
		Em1 = v123
		if Em1 > float32(float32(float32(libc.Float32FromInt32(3)*noise_ratio)*noise_floor)*libc.Float32FromInt32(160)) || E3 > float32(float32(noise_ratio*noise_floor)*libc.Float32FromInt32(160)) {
			bandwidth = int32(20)
		}
		/* Check if the band is masked (see below). */
		if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_bandwidth == int32(20) {
			v123 = libc.Float32FromFloat32(0.01)
		} else {
			v123 = libc.Float32FromFloat32(0.05)
		}
		is_masked[b] = libc.BoolInt32(E3 < float32(v123*bandwidth_mask))
	}
	if above_max_pitch > below_max_pitch {
		(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fmax_pitch_ratio = below_max_pitch / above_max_pitch
	} else {
		(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fmax_pitch_ratio = libc.Float32FromInt32(1)
	}
	/* In some cases, resampling aliasing can create a small amount of energy in the first band
	   being cut. So if the last band is masked, we don't include it.  */
	if bandwidth == int32(20) && is_masked[int32(NB_TBANDS)] != 0 {
		bandwidth = bandwidth - int32(2)
	} else {
		if bandwidth > 0 && bandwidth <= int32(NB_TBANDS) && is_masked[bandwidth-int32(1)] != 0 {
			bandwidth = bandwidth - 1
		}
	}
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount <= int32(2) {
		bandwidth = int32(20)
	}
	frame_loudness = float32(libc.Float32FromInt32(20) * float32(libc.Xlog10(tls, float64(frame_loudness))))
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FEtracker-libc.Float32FromFloat32(0.003) > frame_loudness {
		v123 = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FEtracker - libc.Float32FromFloat32(0.003)
	} else {
		v123 = frame_loudness
	}
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FEtracker = v123
	*(*float32)(unsafe.Pointer(tonal + 7428)) *= libc.Float32FromInt32(1) - alphaE
	if frame_loudness < (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FEtracker-libc.Float32FromInt32(30) {
		*(*float32)(unsafe.Pointer(tonal + 7428)) += alphaE
	}
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		sum = libc.Float32FromInt32(0)
		b = 0
		for {
			if !(b < int32(16)) {
				break
			}
			sum = sum + float32(dct_table[i*int32(16)+b]*logE[b])
			goto _191
		_191:
			;
			b = b + 1
		}
		BFCC[i] = sum
		goto _190
	_190:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		sum1 = libc.Float32FromInt32(0)
		b = 0
		for {
			if !(b < int32(16)) {
				break
			}
			sum1 = sum1 + float32(float32(dct_table[i*int32(16)+b]*libc.Float32FromFloat32(0.5))*(*(*float32)(unsafe.Pointer(tonal + 7080 + uintptr(b)*4))+*(*float32)(unsafe.Pointer(tonal + 7008 + uintptr(b)*4))))
			goto _193
		_193:
			;
			b = b + 1
		}
		midE[i] = sum1
		goto _192
	_192:
		;
		i = i + 1
	}
	frame_stationarity = frame_stationarity / libc.Float32FromInt32(NB_TBANDS)
	relativeE = relativeE / libc.Float32FromInt32(NB_TBANDS)
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount < int32(10) {
		relativeE = libc.Float32FromFloat32(0.5)
	}
	frame_noisiness = frame_noisiness / libc.Float32FromInt32(NB_TBANDS)
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Factivity = frame_noisiness + float32((libc.Float32FromInt32(1)-frame_noisiness)*relativeE)
	frame_tonality = max_frame_tonality / float32(libc.Int32FromInt32(NB_TBANDS)-libc.Int32FromInt32(NB_TONAL_SKIP_BANDS))
	if frame_tonality > float32((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_tonality*libc.Float32FromFloat32(0.8)) {
		v123 = frame_tonality
	} else {
		v123 = float32((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_tonality * libc.Float32FromFloat32(0.8))
	}
	frame_tonality = v123
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_tonality = frame_tonality
	slope = slope / float32(libc.Int32FromInt32(8)*libc.Int32FromInt32(8))
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Ftonality_slope = slope
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FE_count = ((*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FE_count + int32(1)) % int32(NB_FRAMES)
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount+int32(1) < int32(ANALYSIS_COUNT_MAX) {
		v5 = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount + int32(1)
	} else {
		v5 = int32(ANALYSIS_COUNT_MAX)
	}
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount = v5
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Ftonality = frame_tonality
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		(*(*[25]float32)(unsafe.Pointer(bp + 4)))[i] = float32(-libc.Float32FromFloat32(0.12299)*(BFCC[i]+*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(24))*4)))) + float32(libc.Float32FromFloat32(0.49195)*(*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i)*4))+*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(16))*4)))) + float32(libc.Float32FromFloat32(0.69693)**(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(8))*4))) - float32(libc.Float32FromFloat32(1.4349)**(*float32)(unsafe.Pointer(tonal + 7356 + uintptr(i)*4)))
		goto _196
	_196:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		*(*float32)(unsafe.Pointer(tonal + 7356 + uintptr(i)*4)) = float32((libc.Float32FromInt32(1)-alpha)**(*float32)(unsafe.Pointer(tonal + 7356 + uintptr(i)*4))) + float32(alpha*BFCC[i])
		goto _197
	_197:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(4)+i] = float32(libc.Float32FromFloat32(0.63246)*(BFCC[i]-*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(24))*4)))) + float32(libc.Float32FromFloat32(0.31623)*(*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i)*4))-*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(16))*4))))
		goto _198
	_198:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(3)) {
			break
		}
		(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(8)+i] = float32(libc.Float32FromFloat32(0.53452)*(BFCC[i]+*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(24))*4)))) - float32(libc.Float32FromFloat32(0.26726)*(*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i)*4))+*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(16))*4)))) - float32(libc.Float32FromFloat32(0.53452)**(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(8))*4)))
		goto _199
	_199:
		;
		i = i + 1
	}
	if (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fcount > int32(5) {
		i = 0
		for {
			if !(i < int32(9)) {
				break
			}
			*(*float32)(unsafe.Pointer(tonal + 7388 + uintptr(i)*4)) = float32((libc.Float32FromInt32(1)-alpha)**(*float32)(unsafe.Pointer(tonal + 7388 + uintptr(i)*4))) + float32(float32(alpha*(*(*[25]float32)(unsafe.Pointer(bp + 4)))[i])*(*(*[25]float32)(unsafe.Pointer(bp + 4)))[i])
			goto _200
		_200:
			;
			i = i + 1
		}
	}
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		(*(*[25]float32)(unsafe.Pointer(bp + 4)))[i] = BFCC[i] - midE[i]
		goto _201
	_201:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(24))*4)) = *(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(16))*4))
		*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(16))*4)) = *(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(8))*4))
		*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i+int32(8))*4)) = *(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i)*4))
		*(*float32)(unsafe.Pointer(tonal + 7228 + uintptr(i)*4)) = BFCC[i]
		goto _202
	_202:
		;
		i = i + 1
	}
	i = 0
	for {
		if !(i < int32(9)) {
			break
		}
		(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(11)+i] = float32(libc.Xsqrt(tls, float64(*(*float32)(unsafe.Pointer(tonal + 7388 + uintptr(i)*4))))) - std_feature_bias[i]
		goto _203
	_203:
		;
		i = i + 1
	}
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(18)] = spec_variability - libc.Float32FromFloat32(0.78)
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(20)] = (*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Ftonality - libc.Float32FromFloat32(0.154723)
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(21)] = (*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Factivity - libc.Float32FromFloat32(0.724643)
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(22)] = frame_stationarity - libc.Float32FromFloat32(0.743717)
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(23)] = (*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Ftonality_slope + libc.Float32FromFloat32(0.069216)
	(*(*[25]float32)(unsafe.Pointer(bp + 4)))[int32(24)] = (*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).FlowECount - libc.Float32FromFloat32(0.06793)
	Opus_analysis_compute_dense(tls, uintptr(unsafe.Pointer(&Opus_layer0)), bp+112, bp+4)
	Opus_analysis_compute_gru(tls, uintptr(unsafe.Pointer(&Opus_layer1)), tonal+7464, bp+112)
	Opus_analysis_compute_dense(tls, uintptr(unsafe.Pointer(&Opus_layer2)), bp+104, tonal+7464)
	/* Probability of speech or music vs noise */
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Factivity_probability = (*(*[2]float32)(unsafe.Pointer(bp + 104)))[int32(1)]
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fmusic_prob = (*(*[2]float32)(unsafe.Pointer(bp + 104)))[0]
	/*printf("%f %f %f\n", frame_probs[0], frame_probs[1], info->music_prob);*/
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fbandwidth = bandwidth
	(*OpusT_TonalityAnalysisState)(unsafe.Pointer(tonal)).Fprev_bandwidth = bandwidth
	/*printf("%d %d\n", info->bandwidth, info->opus_bandwidth);*/
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fnoisiness = frame_noisiness
	(*OpusT_AnalysisInfo)(unsafe.Pointer(info)).Fvalid = int32(1)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _205
	_205:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _207
_207:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
}

type OpusT___ccgo_fp__Xrun_analysis_10 = func(*libc.TLS, uintptr, uintptr, int32, int32, int32, int32, int32)

func tone_detect(tls *libc.TLS, in uintptr, CC int32, N int32, toneishness uintptr, Fs OpusT_opus_int32) (r OpusT_opus_val16) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, st, x, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var delay, fail, i int32
	var freq OpusT_opus_val16
	var _ /* lpc at bp+0 */ [2]OpusT_opus_val32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, delay, fail, freq, i, st, x, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9
	delay = int32(1)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(1370))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(N) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	x = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(N)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	/* Shift by SIG_SHIFT+2 (+3 for stereo) to account for HF gain of the preemphasis filter. */
	if CC == int32(2) {
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4)) = *(*OpusT_celt_sig)(unsafe.Pointer(in + uintptr(i)*4)) + *(*OpusT_celt_sig)(unsafe.Pointer(in + uintptr(i+N)*4))
			goto _29
		_29:
			;
			i = i + 1
		}
	} else {
		i = 0
		for {
			if !(i < N) {
				break
			}
			*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4)) = *(*OpusT_celt_sig)(unsafe.Pointer(in + uintptr(i)*4))
			goto _30
		_30:
			;
			i = i + 1
		}
	}
	fail = tone_lpc(tls, x, N, delay, bp)
	/* If our LPC filter resonates too close to DC, retry the analysis with down-sampling. */
	for delay <= Fs/int32(3000) && (fail != 0 || (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[0] > libc.Float32FromFloat32(1) && (*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)] < libc.Float32FromInt32(0)) {
		delay = delay * int32(2)
		fail = tone_lpc(tls, x, N, delay, bp)
	}
	/* Check that our filter has complex roots. */
	if !(fail != 0) && float64(OpusT_opus_val32((*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[0]))+float64(float64(3.999999)*float64((*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)])) < libc.Float64FromInt32(0) {
		/* Squared radius of the poles. */
		*(*OpusT_opus_val32)(unsafe.Pointer(toneishness)) = -(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[int32(1)]
		freq = float32(libc.Xacos(tls, float64(libc.Float32FromFloat32(0.5)*(*(*[2]OpusT_opus_val32)(unsafe.Pointer(bp)))[0])) / float64(delay))
	} else {
		freq = float32(-libc.Int32FromInt32(1))
		*(*OpusT_opus_val32)(unsafe.Pointer(toneishness)) = libc.Float32FromInt32(0)
	}
	/*printf("%f %f %f %f\n", freq, lpc[0], lpc[1], *toneishness);*/
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _32
	_32:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _34
_34:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	return freq
}

func tone_lpc(tls *libc.TLS, x uintptr, len1 int32, delay int32, lpc uintptr) (r int32) {
	var R00, R01, R02, R11, R12, R22, den, edges, num0, num1, r00, r01, r02, r11, r12, r22 OpusT_opus_val32
	var i int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = R00, R01, R02, R11, R12, R22, den, edges, i, num0, num1, r00, r01, r02, r11, r12, r22
	r00 = libc.Float32FromInt32(0)
	r01 = libc.Float32FromInt32(0)
	r11 = libc.Float32FromInt32(0)
	r02 = libc.Float32FromInt32(0)
	r12 = libc.Float32FromInt32(0)
	r22 = libc.Float32FromInt32(0)
	if !(len1 > libc.Int32FromInt32(2)*delay) {
		Opus_celt_fatal(tls, __ccgo_ts+4181, __ccgo_ts+4084, int32(1310))
	}
	/* Compute correlations as if using the forward prediction covariance method. */
	i = 0
	for {
		if !(i < len1-int32(2)*delay) {
			break
		}
		r00 = r00 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4)))
		r01 = r01 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i+delay)*4)))
		r02 = r02 + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i+int32(2)*delay)*4)))
		goto _1
	_1:
		;
		i = i + 1
	}
	edges = libc.Float32FromInt32(0)
	i = 0
	for {
		if !(i < delay) {
			break
		}
		edges = edges + (OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-int32(2)*delay)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-int32(2)*delay)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))))
		goto _2
	_2:
		;
		i = i + 1
	}
	r11 = r00 + edges
	edges = libc.Float32FromInt32(0)
	i = 0
	for {
		if !(i < delay) {
			break
		}
		edges = edges + (OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-delay)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-delay)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i+delay)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i+delay)*4))))
		goto _3
	_3:
		;
		i = i + 1
	}
	r22 = r11 + edges
	edges = libc.Float32FromInt32(0)
	i = 0
	for {
		if !(i < delay) {
			break
		}
		edges = edges + (OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-int32(2)*delay)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(len1+i-delay)*4))) - OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(x + uintptr(i+delay)*4))))
		goto _4
	_4:
		;
		i = i + 1
	}
	r12 = r01 + edges
	/* Reverse and sum to get the backward contribution. */
	R00 = r00 + r22
	R01 = r01 + r12
	R11 = OpusT_opus_val32(libc.Float32FromInt32(2) * r11)
	R02 = OpusT_opus_val32(libc.Float32FromInt32(2) * r02)
	R12 = r12 + r01
	R22 = r00 + r22
	r00 = R00
	r01 = R01
	r11 = R11
	r02 = R02
	r12 = R12
	r22 = R22
	/* Solve A*x=b, where A=[r00, r01; r01, r11] and b=[r02; r12]. */
	den = OpusT_opus_val32(r00*r11) - OpusT_opus_val32(r01*r01)
	if den < OpusT_opus_val32(libc.Float32FromFloat32(0.001)*OpusT_opus_val32(r00*r11)) {
		return int32(1)
	}
	num1 = OpusT_opus_val32(r02*r11) - OpusT_opus_val32(r01*r12)
	if num1 >= den {
		*(*OpusT_opus_val32)(unsafe.Pointer(lpc + 1*4)) = libc.Float32FromFloat32(1)
	} else {
		if num1 <= -den {
			*(*OpusT_opus_val32)(unsafe.Pointer(lpc + 1*4)) = -libc.Float32FromFloat32(1)
		} else {
			*(*OpusT_opus_val32)(unsafe.Pointer(lpc + 1*4)) = num1 / den
		}
	}
	num0 = OpusT_opus_val32(r00*r12) - OpusT_opus_val32(r02*r01)
	if float32(libc.Float32FromFloat32(0.5)*num0) >= den {
		*(*OpusT_opus_val32)(unsafe.Pointer(lpc)) = libc.Float32FromFloat32(1.999999)
	} else {
		if float32(libc.Float32FromFloat32(0.5)*num0) <= -den {
			*(*OpusT_opus_val32)(unsafe.Pointer(lpc)) = -libc.Float32FromFloat32(1.999999)
		} else {
			*(*OpusT_opus_val32)(unsafe.Pointer(lpc)) = num0 / den
		}
	}
	/*printf("%f %f\n", lpc[0], lpc[1]);*/
	return 0
}

// C documentation
//
//	/* Detects pure of nearly pure tones so we can prevent them from causing problems with the encoder. */

func transient_analysis(tls *libc.TLS, in1 uintptr, len1 int32, C int32, tf_estimate uintptr, tf_chan uintptr, allow_weak_transients int32, weak_transient uintptr, tone_freq OpusT_opus_val16, toneishness OpusT_opus_val32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _saved_stack, st, tmp, v1, v11, v13, v15, v17, v19, v21, v23, v3, v5, v7, v9 uintptr
	var c, i, id, is_transient, len2, v34 int32
	var forward_decay, maxE, tf_max, v33, v44 OpusT_opus_val16
	var mask_metric, unmask OpusT_opus_int32
	var mean, mem0, mem1, norm, x1, x2, y OpusT_opus_val32
	var mem00, v42 float32
	var v39, v40, v41 float64
	var _ /* in at bp+0 */ struct {
		Fi [0]OpusT_opus_uint32
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _saved_stack, c, forward_decay, i, id, is_transient, len2, mask_metric, maxE, mean, mem0, mem00, mem1, norm, st, tf_max, tmp, unmask, x1, x2, y, v1, v11, v13, v15, v17, v19, v21, v23, v3, v33, v34, v39, v40, v41, v42, v44, v5, v7, v9
	is_transient = 0
	mask_metric = 0
	/* Forward masking: 6.7 dB/ms. */
	forward_decay = libc.Float32FromFloat32(0.0625)
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _2
	_2:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _4
_4:
	_saved_stack = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _6
	_6:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _8
_8:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v5 = libc.Xmalloc(tls, uint64(16))
		goto _10
	_10:
		st = v5
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v7 = st
	goto _12
_12:
	*(*uintptr)(unsafe.Pointer(v3 + 8)) += uintptr((libc.Uint64FromInt32(4) - libc.Uint64FromInt64(int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v7)).Fglobal_stack))) & (libc.Uint64FromInt32(4) - libc.Uint64FromInt32(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v9 = libc.Xmalloc(tls, uint64(16))
		goto _14
	_14:
		st = v9
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v11 = st
	goto _16
_16:
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v13 = libc.Xmalloc(tls, uint64(16))
		goto _18
	_18:
		st = v13
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v15 = st
	goto _20
_20:
	if !(int64(libc.Int32FromUint64(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))) <= int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v11)).Fscratch_ptr+uintptr(GLOBAL_STACK_SIZE))-int64((*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v15)).Fglobal_stack)) {
		Opus_celt_fatal(tls, __ccgo_ts+996, __ccgo_ts+4084, int32(300))
	}
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v17 = libc.Xmalloc(tls, uint64(16))
		goto _22
	_22:
		st = v17
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v19 = st
	goto _24
_24:
	*(*uintptr)(unsafe.Pointer(v19 + 8)) += uintptr(libc.Uint64FromInt32(len1) * (libc.Uint64FromInt64(4) / libc.Uint64FromInt64(1)))
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v21 = libc.Xmalloc(tls, uint64(16))
		goto _26
	_26:
		st = v21
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v23 = st
	goto _28
_28:
	tmp = (*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v23)).Fglobal_stack - uintptr(libc.Uint64FromInt32(len1)*(libc.Uint64FromInt64(4)/libc.Uint64FromInt64(1)))
	*(*int32)(unsafe.Pointer(weak_transient)) = 0
	/* For lower bitrates, let's be more conservative and have a forward masking
	   decay of 3.3 dB/ms. This avoids having to code transients at very low
	   bitrate (mostly for hybrid), which can result in unstable energy and/or
	   partial collapse. */
	if allow_weak_transients != 0 {
		forward_decay = libc.Float32FromFloat32(0.03125)
	}
	len2 = len1 / int32(2)
	c = 0
	for {
		if !(c < C) {
			break
		}
		unmask = 0
		mem0 = libc.Float32FromInt32(0)
		mem1 = libc.Float32FromInt32(0)
		/* High-pass filter: (1 - 2*z^-1 + z^-2) / (1 - z^-1 + .5*z^-2) */
		i = 0
		for {
			if !(i < len1) {
				break
			}
			x1 = *(*OpusT_opus_val32)(unsafe.Pointer(in1 + uintptr(i+c*len1)*4))
			y = mem0 + x1
			/* Original code:
			   mem0 = mem1 + y - 2*x;
			   mem1 = x - .5f*y;
			   Modified code to shorten dependency chains: */
			mem00 = mem0
			mem0 = mem0 - x1 + OpusT_opus_val32(libc.Float32FromFloat32(0.5)*mem1)
			mem1 = x1 - mem00
			*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4)) = y
			/*printf("%f ", tmp[i]);*/
			goto _30
		_30:
			;
			i = i + 1
		}
		/*printf("\n");*/
		/* First few samples are bad because we don't propagate the memory */
		libc.Xmemset(tls, tmp, 0, libc.Uint64FromInt32(libc.Int32FromInt32(12))*libc.Uint64FromInt64(4))
		mean = libc.Float32FromInt32(0)
		mem0 = libc.Float32FromInt32(0)
		/* Grouping by two to reduce complexity */
		/* Forward pass to compute the post-echo threshold*/
		i = 0
		for {
			if !(i < len2) {
				break
			}
			x2 = OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(int32(2)*i)*4))**(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(int32(2)*i)*4))) + OpusT_opus_val32(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(int32(2)*i+int32(1))*4))**(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(int32(2)*i+int32(1))*4)))
			mean = mean + x2
			mem0 = x2 + OpusT_opus_val32((libc.Float32FromFloat32(1)-forward_decay)*mem0)
			*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4)) = OpusT_opus_val16(forward_decay * mem0)
			goto _31
		_31:
			;
			i = i + 1
		}
		mem0 = libc.Float32FromInt32(0)
		maxE = libc.Float32FromInt32(0)
		/* Backward pass to compute the pre-echo threshold */
		i = len2 - int32(1)
		for {
			if !(i >= 0) {
				break
			}
			/* Backward masking: 13.9 dB/ms. */
			mem0 = *(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4)) + OpusT_opus_val16(libc.Float32FromFloat32(0.875)*mem0)
			*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4)) = OpusT_opus_val16(libc.Float32FromFloat32(0.125) * mem0)
			if maxE > float32(libc.Float32FromFloat32(0.125)*mem0) {
				v33 = maxE
			} else {
				v33 = float32(libc.Float32FromFloat32(0.125) * mem0)
			}
			maxE = v33
			goto _32
		_32:
			;
			i = i - 1
		}
		/*for (i=0;i<len2;i++)printf("%f ", tmp[i]/mean);printf("\n");*/
		/* Compute the ratio of the "frame energy" over the harmonic mean of the energy.
		   This essentially corresponds to a bitrate-normalized temporal noise-to-mask
		   ratio */
		/* As a compromise with the old transient detector, frame energy is the
		   geometric mean of the energy and half the max */
		mean = float32(libc.Xsqrt(tls, float64(float64(float64(mean*maxE)*float64(0.5))*float64(len2))))
		/* Inverse of the mean energy in Q15+6 */
		norm = float32(len2) / (libc.Float32FromFloat32(1e-15) + mean)
		/* Compute harmonic mean discarding the unreliable boundaries
		   The data is smooth, so we only take 1/4th of the samples */
		unmask = 0
		/* We should never see NaNs here. If we find any, then something really bad happened and we better abort
		   before it does any damage later on. If these asserts are disabled (no hardening), then the table
		   lookup a few lines below (id = ...) is likely to crash dur to an out-of-bounds read. DO NOT FIX
		   that crash on NaN since it could result in a worse issue later on. */
		*(*float32)(unsafe.Pointer(bp)) = *(*OpusT_opus_val16)(unsafe.Pointer(tmp))
		v34 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
		goto _35
	_35:
		if !!(v34 != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+4107, __ccgo_ts+4084, int32(423))
		}
		*(*float32)(unsafe.Pointer(bp)) = norm
		v34 = libc.BoolInt32(*(*OpusT_opus_uint32)(unsafe.Pointer(bp))>>libc.Int32FromInt32(23)&uint32(0xFF) == uint32(0xFF) && *(*OpusT_opus_uint32)(unsafe.Pointer(bp))&uint32(0x007FFFFF) != uint32(0))
		goto _37
	_37:
		if !!(v34 != 0) {
			Opus_celt_fatal(tls, __ccgo_ts+4145, __ccgo_ts+4084, int32(424))
		}
		i = int32(12)
		for {
			if !(i < len2-int32(5)) {
				break
			}
			if float64(libc.Int32FromInt32(127)) < libc.Xfloor(tls, float64(OpusT_opus_val32(libc.Float32FromInt32(64)*norm)*(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4))+libc.Float32FromFloat32(1e-15)))) {
				v40 = float64(libc.Int32FromInt32(127))
			} else {
				v40 = libc.Xfloor(tls, float64(OpusT_opus_val32(libc.Float32FromInt32(64)*norm)*(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4))+libc.Float32FromFloat32(1e-15))))
			}
			if float64(libc.Int32FromInt32(0)) > v40 {
				v39 = float64(libc.Int32FromInt32(0))
			} else {
				if float64(libc.Int32FromInt32(127)) < libc.Xfloor(tls, float64(OpusT_opus_val32(libc.Float32FromInt32(64)*norm)*(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4))+libc.Float32FromFloat32(1e-15)))) {
					v41 = float64(libc.Int32FromInt32(127))
				} else {
					v41 = libc.Xfloor(tls, float64(OpusT_opus_val32(libc.Float32FromInt32(64)*norm)*(*(*OpusT_opus_val16)(unsafe.Pointer(tmp + uintptr(i)*4))+libc.Float32FromFloat32(1e-15))))
				}
				v39 = v41
			}
			id = int32(v39) /* Do not round to nearest */
			unmask = unmask + libc.Int32FromUint8(inv_table[id])
			goto _38
		_38:
			;
			i = i + int32(4)
		}
		/*printf("%d\n", unmask);*/
		/* Normalize, compensate for the 1/4th of the sample and the factor of 6 in the inverse table */
		unmask = int32(64) * unmask * int32(4) / (int32(6) * (len2 - int32(17)))
		if unmask > mask_metric {
			*(*int32)(unsafe.Pointer(tf_chan)) = c
			mask_metric = unmask
		}
		goto _29
	_29:
		;
		c = c + 1
	}
	is_transient = libc.BoolInt32(mask_metric > int32(200))
	/* Prevent the transient detector from confusing the partial cycle of a
	   very low frequency tone with a transient. */
	if toneishness > libc.Float32FromFloat32(0.98) && tone_freq < libc.Float32FromFloat32(0.026) {
		is_transient = 0
		mask_metric = 0
	}
	/* For low bitrates, define "weak transients" that need to be
	   handled differently to avoid partial collapse. */
	if allow_weak_transients != 0 && is_transient != 0 && mask_metric < int32(600) {
		is_transient = 0
		*(*int32)(unsafe.Pointer(weak_transient)) = int32(1)
	}
	/* Arbitrary metric for VBR boost */
	if float32(libc.Int32FromInt32(0)) > float32(libc.Xsqrt(tls, float64(int32(27)*mask_metric)))-libc.Float32FromInt32(42) {
		v42 = float32(libc.Int32FromInt32(0))
	} else {
		v42 = float32(libc.Xsqrt(tls, float64(int32(27)*mask_metric))) - libc.Float32FromInt32(42)
	}
	tf_max = v42
	/* *tf_estimate = 1 + MIN16(1, sqrt(MAX16(0, tf_max-30))/20); */
	if float32(libc.Int32FromInt32(163)) < tf_max {
		v33 = float32(libc.Int32FromInt32(163))
	} else {
		v33 = tf_max
	}
	if float64(libc.Int32FromInt32(0)) > float64(OpusT_opus_val32(float32(libc.Float64FromFloat64(0.0069))*v33))-float64(0.139) {
		v39 = float64(libc.Int32FromInt32(0))
	} else {
		if float32(libc.Int32FromInt32(163)) < tf_max {
			v44 = float32(libc.Int32FromInt32(163))
		} else {
			v44 = tf_max
		}
		v39 = float64(OpusT_opus_val32(float32(libc.Float64FromFloat64(0.0069))*v44)) - float64(0.139)
	}
	*(*OpusT_opus_val16)(unsafe.Pointer(tf_estimate)) = float32(libc.Xsqrt(tls, v39))
	/*printf("%d %f\n", tf_max, mask_metric);*/
	st = libc.Xpthread_getspecific(tls, libc.Uint32FromUint32(0x6f707573))
	if !(st != 0) {
		v1 = libc.Xmalloc(tls, uint64(16))
		goto _47
	_47:
		st = v1
		if st != 0 {
			libc.Xmemset(tls, st, 0, uint64(16))
		}
		libc.Xpthread_setspecific(tls, libc.Uint32FromUint32(0x6f707573), st)
	}
	v3 = st
	goto _49
_49:
	(*OpusT_opus_ccgo_pseudostack_state)(unsafe.Pointer(v3)).Fglobal_stack = _saved_stack
	/*printf("%d %f %d\n", is_transient, (float)*tf_estimate, tf_max);*/
	return is_transient
}

/* Table of 6*64/x, trained on real data to minimize the average error */
var inv_table = [128]uint8{
	0:   uint8(255),
	1:   uint8(255),
	2:   uint8(156),
	3:   uint8(110),
	4:   uint8(86),
	5:   uint8(70),
	6:   uint8(59),
	7:   uint8(51),
	8:   uint8(45),
	9:   uint8(40),
	10:  uint8(37),
	11:  uint8(33),
	12:  uint8(31),
	13:  uint8(28),
	14:  uint8(26),
	15:  uint8(25),
	16:  uint8(23),
	17:  uint8(22),
	18:  uint8(21),
	19:  uint8(20),
	20:  uint8(19),
	21:  uint8(18),
	22:  uint8(17),
	23:  uint8(16),
	24:  uint8(16),
	25:  uint8(15),
	26:  uint8(15),
	27:  uint8(14),
	28:  uint8(13),
	29:  uint8(13),
	30:  uint8(12),
	31:  uint8(12),
	32:  uint8(12),
	33:  uint8(12),
	34:  uint8(11),
	35:  uint8(11),
	36:  uint8(11),
	37:  uint8(10),
	38:  uint8(10),
	39:  uint8(10),
	40:  uint8(9),
	41:  uint8(9),
	42:  uint8(9),
	43:  uint8(9),
	44:  uint8(9),
	45:  uint8(9),
	46:  uint8(8),
	47:  uint8(8),
	48:  uint8(8),
	49:  uint8(8),
	50:  uint8(8),
	51:  uint8(7),
	52:  uint8(7),
	53:  uint8(7),
	54:  uint8(7),
	55:  uint8(7),
	56:  uint8(7),
	57:  uint8(6),
	58:  uint8(6),
	59:  uint8(6),
	60:  uint8(6),
	61:  uint8(6),
	62:  uint8(6),
	63:  uint8(6),
	64:  uint8(6),
	65:  uint8(6),
	66:  uint8(6),
	67:  uint8(6),
	68:  uint8(6),
	69:  uint8(6),
	70:  uint8(6),
	71:  uint8(6),
	72:  uint8(6),
	73:  uint8(5),
	74:  uint8(5),
	75:  uint8(5),
	76:  uint8(5),
	77:  uint8(5),
	78:  uint8(5),
	79:  uint8(5),
	80:  uint8(5),
	81:  uint8(5),
	82:  uint8(5),
	83:  uint8(5),
	84:  uint8(5),
	85:  uint8(4),
	86:  uint8(4),
	87:  uint8(4),
	88:  uint8(4),
	89:  uint8(4),
	90:  uint8(4),
	91:  uint8(4),
	92:  uint8(4),
	93:  uint8(4),
	94:  uint8(4),
	95:  uint8(4),
	96:  uint8(4),
	97:  uint8(4),
	98:  uint8(4),
	99:  uint8(4),
	100: uint8(4),
	101: uint8(4),
	102: uint8(4),
	103: uint8(4),
	104: uint8(4),
	105: uint8(4),
	106: uint8(4),
	107: uint8(4),
	108: uint8(4),
	109: uint8(4),
	110: uint8(3),
	111: uint8(3),
	112: uint8(3),
	113: uint8(3),
	114: uint8(3),
	115: uint8(3),
	116: uint8(3),
	117: uint8(3),
	118: uint8(3),
	119: uint8(3),
	120: uint8(3),
	121: uint8(3),
	122: uint8(3),
	123: uint8(3),
	124: uint8(3),
	125: uint8(3),
	126: uint8(3),
	127: uint8(2),
}

// C documentation
//
//	/* Looks for sudden increases of energy to decide whether we need to patch
//	   the transient decision */

func user_bitrate_to_bitrate(tls *libc.TLS, st uintptr, frame_size1 int32, max_data_bytes int32) (r OpusT_opus_int32) {
	var max_bitrate, user_bitrate, v1 OpusT_opus_int32
	var v3 int32
	_, _, _, _ = max_bitrate, user_bitrate, v1, v3
	if !(frame_size1 != 0) {
		frame_size1 = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs / int32(400)
	}
	v1 = max_data_bytes * int32(8) * (int32(6) * (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs / frame_size1) / int32(6)
	goto _2
_2:
	max_bitrate = v1
	if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bitrate_bps == -int32(1000) {
		user_bitrate = int32(60)*(*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs/frame_size1 + (*OpusT_OpusEncoder)(unsafe.Pointer(st)).FFs*(*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fchannels
	} else {
		if (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bitrate_bps == -int32(1) {
			user_bitrate = int32(1500000)
		} else {
			user_bitrate = (*OpusT_OpusEncoder)(unsafe.Pointer(st)).Fuser_bitrate_bps
		}
	}
	if user_bitrate < max_bitrate {
		v3 = user_bitrate
	} else {
		v3 = max_bitrate
	}
	return v3
}

func validate_ambisonics(tls *libc.TLS, nb_channels int32, nb_streams uintptr, nb_coupled_streams uintptr) (r int32) {
	var acn_channels, nondiegetic_channels, order_plus_one int32
	_, _, _ = acn_channels, nondiegetic_channels, order_plus_one
	if nb_channels < int32(1) || nb_channels > int32(227) {
		return 0
	}
	order_plus_one = libc.Int32FromUint32(Opus_isqrt32(tls, libc.Uint32FromInt32(nb_channels)))
	acn_channels = order_plus_one * order_plus_one
	nondiegetic_channels = nb_channels - acn_channels
	if nondiegetic_channels != 0 && nondiegetic_channels != int32(2) {
		return 0
	}
	if nb_streams != 0 {
		*(*int32)(unsafe.Pointer(nb_streams)) = acn_channels + libc.BoolInt32(nondiegetic_channels != 0)
	}
	if nb_coupled_streams != 0 {
		*(*int32)(unsafe.Pointer(nb_coupled_streams)) = libc.BoolInt32(nondiegetic_channels != 0)
	}
	return int32(1)
}

func validate_encoder_layout(tls *libc.TLS, layout uintptr) (r int32) {
	var s int32
	_ = s
	s = 0
	for {
		if !(s < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_streams) {
			break
		}
		if s < (*OpusT_ChannelLayout)(unsafe.Pointer(layout)).Fnb_coupled_streams {
			if Opus_get_left_channel(tls, layout, s, -int32(1)) == -int32(1) {
				return 0
			}
			if Opus_get_right_channel(tls, layout, s, -int32(1)) == -int32(1) {
				return 0
			}
		} else {
			if Opus_get_mono_channel(tls, layout, s, -int32(1)) == -int32(1) {
				return 0
			}
		}
		goto _1
	_1:
		;
		s = s + 1
	}
	return int32(1)
}

func validate_ms_decoder(tls *libc.TLS, st uintptr) {
	Opus_validate_layout(tls, st)
}

func validate_opus_decoder(tls *libc.TLS, st uintptr) {
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts, __ccgo_ts+57, int32(99))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(48000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(24000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(16000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(12000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs == int32(8000)) {
		Opus_celt_fatal(tls, __ccgo_ts+79, __ccgo_ts+57, int32(103))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FAPI_sampleRate == (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FFs) {
		Opus_celt_fatal(tls, __ccgo_ts+188, __ccgo_ts+57, int32(105))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(16000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(12000) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FinternalSampleRate == int32(8000)) {
		Opus_celt_fatal(tls, __ccgo_ts+246, __ccgo_ts+57, int32(106))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsAPI == (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fchannels) {
		Opus_celt_fatal(tls, __ccgo_ts+440, __ccgo_ts+57, int32(107))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FnChannelsInternal == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+502, __ccgo_ts+57, int32(108))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == 0 || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(10) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(20) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(40) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).FDecControl.FpayloadSize_ms == int32(60)) {
		Opus_celt_fatal(tls, __ccgo_ts+640, __ccgo_ts+57, int32(109))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch >= libc.Int32FromInt32(0)) {
		Opus_celt_fatal(tls, __ccgo_ts+849, __ccgo_ts+57, int32(111))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Farch <= libc.Int32FromInt32(OPUS_ARCHMASK)) {
		Opus_celt_fatal(tls, __ccgo_ts+881, __ccgo_ts+57, int32(112))
	}
	if !((*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(1) || (*OpusT_OpusDecoder)(unsafe.Pointer(st)).Fstream_channels == int32(2)) {
		Opus_celt_fatal(tls, __ccgo_ts+925, __ccgo_ts+57, int32(114))
	}
}

func warped_gain(tls *libc.TLS, coefs uintptr, lambda float32, order int32) (r float32) {
	var gain float32
	var i int32
	_, _ = gain, i
	lambda = -lambda
	gain = *(*float32)(unsafe.Pointer(coefs + uintptr(order-int32(1))*4))
	i = order - int32(2)
	for {
		if !(i >= 0) {
			break
		}
		gain = float32(lambda*gain) + *(*float32)(unsafe.Pointer(coefs + uintptr(i)*4))
		goto _1
	_1:
		;
		i = i - 1
	}
	return libc.Float32FromFloat32(1) / (libc.Float32FromFloat32(1) - float32(lambda*gain))
}

// C documentation
//
//	/* Convert warped filter coefficients to monic pseudo-warped coefficients and limit maximum     */
//	/* amplitude of monic warped coefficients by using bandwidth expansion on the true coefficients */

func warped_true2monic_coefs(tls *libc.TLS, coefs uintptr, lambda float32, limit float32, order int32) {
	var chirp, gain, maxabs, tmp float32
	var i, ind, iter int32
	_, _, _, _, _, _, _ = chirp, gain, i, ind, iter, maxabs, tmp
	ind = 0
	/* Convert to monic coefficients */
	i = order - int32(1)
	for {
		if !(i > 0) {
			break
		}
		*(*float32)(unsafe.Pointer(coefs + uintptr(i-int32(1))*4)) -= float32(lambda * *(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)))
		goto _1
	_1:
		;
		i = i - 1
	}
	gain = (libc.Float32FromFloat32(1) - float32(lambda*lambda)) / (libc.Float32FromFloat32(1) + float32(lambda**(*float32)(unsafe.Pointer(coefs))))
	i = 0
	for {
		if !(i < order) {
			break
		}
		*(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)) *= gain
		goto _2
	_2:
		;
		i = i + 1
	}
	/* Limit */
	iter = 0
	for {
		if !(iter < int32(10)) {
			break
		}
		/* Find maximum absolute value */
		maxabs = -libc.Float32FromFloat32(1)
		i = 0
		for {
			if !(i < order) {
				break
			}
			tmp = float32(libc.Xfabs(tls, float64(*(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)))))
			if tmp > maxabs {
				maxabs = tmp
				ind = i
			}
			goto _4
		_4:
			;
			i = i + 1
		}
		if maxabs <= limit {
			/* Coefficients are within range - done */
			return
		}
		/* Convert back to true warped coefficients */
		i = int32(1)
		for {
			if !(i < order) {
				break
			}
			*(*float32)(unsafe.Pointer(coefs + uintptr(i-int32(1))*4)) += float32(lambda * *(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)))
			goto _5
		_5:
			;
			i = i + 1
		}
		gain = libc.Float32FromFloat32(1) / gain
		i = 0
		for {
			if !(i < order) {
				break
			}
			*(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)) *= gain
			goto _6
		_6:
			;
			i = i + 1
		}
		/* Apply bandwidth expansion */
		chirp = libc.Float32FromFloat32(0.99) - float32((libc.Float32FromFloat32(0.8)+float32(libc.Float32FromFloat32(0.1)*float32(iter)))*(maxabs-limit))/float32(maxabs*float32(ind+libc.Int32FromInt32(1)))
		Opus_silk_bwexpander_FLP(tls, coefs, order, chirp)
		/* Convert to monic warped coefficients */
		i = order - int32(1)
		for {
			if !(i > 0) {
				break
			}
			*(*float32)(unsafe.Pointer(coefs + uintptr(i-int32(1))*4)) -= float32(lambda * *(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)))
			goto _7
		_7:
			;
			i = i - 1
		}
		gain = (libc.Float32FromFloat32(1) - float32(lambda*lambda)) / (libc.Float32FromFloat32(1) + float32(lambda**(*float32)(unsafe.Pointer(coefs))))
		i = 0
		for {
			if !(i < order) {
				break
			}
			*(*float32)(unsafe.Pointer(coefs + uintptr(i)*4)) *= gain
			goto _8
		_8:
			;
			i = i + 1
		}
		goto _3
	_3:
		;
		iter = iter + 1
	}
	_ = libc.Int32FromInt32(0)
}

func write_extension(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, pos OpusT_opus_int32, ext uintptr, last int32) (r int32) {
	var v1 int32
	_ = v1
	if len1-pos < int32(1) {
		return -int32(2)
	}
	if !((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid >= int32(3) && (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid <= int32(127)) {
		Opus_celt_fatal(tls, __ccgo_ts+2879, __ccgo_ts+2422, int32(465))
	}
	if data != 0 {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid < int32(32) {
			v1 = (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1
		} else {
			v1 = libc.BoolInt32(!(last != 0))
		}
		*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid<<int32(1) + v1)
	}
	pos = pos + 1
	return write_extension_payload(tls, data, len1, pos, ext, last)
}

func write_extension_payload(tls *libc.TLS, data uintptr, len1 OpusT_opus_int32, pos OpusT_opus_int32, ext uintptr, last int32) (r int32) {
	var j, length_bytes OpusT_opus_int32
	_, _ = j, length_bytes
	if !((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid >= int32(3) && (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid <= int32(127)) {
		Opus_celt_fatal(tls, __ccgo_ts+2879, __ccgo_ts+2422, int32(425))
	}
	if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fid < int32(32) {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 < 0 || (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 > int32(1) {
			return -int32(1)
		}
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 > 0 {
			if len1-pos < (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 {
				return -int32(2)
			}
			if data != 0 {
				*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = *(*uint8)(unsafe.Pointer((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata))
			}
			pos = pos + 1
		}
	} else {
		if (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 < 0 {
			return -int32(1)
		}
		length_bytes = int32(1) + (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1/int32(255)
		if last != 0 {
			length_bytes = 0
		}
		if len1-pos < length_bytes+(*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 {
			return -int32(2)
		}
		if !(last != 0) {
			j = 0
			for {
				if !(j < (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1/int32(255)) {
					break
				}
				if data != 0 {
					*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = uint8(255)
				}
				pos = pos + 1
				goto _1
			_1:
				;
				j = j + 1
			}
			if data != 0 {
				*(*uint8)(unsafe.Pointer(data + uintptr(pos))) = libc.Uint8FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1 % int32(255))
			}
			pos = pos + 1
		}
		if data != 0 {
			libc.Xmemcpy(tls, data+uintptr(pos), (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata, libc.Uint64FromInt32((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1)*uint64(1)+libc.Uint64FromInt64(0*(OpusT___predefined_ptrdiff_t(data+uintptr(pos))-int64((*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Fdata))))
		}
		pos = pos + (*OpusT_opus_extension_data)(unsafe.Pointer(ext)).Flen1
	}
	return pos
}
